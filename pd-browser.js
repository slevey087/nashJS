(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],3:[function(require,module,exports){
({
	Player,
	_Player,
	gamePopulation,
	Population,
	PlayerList,
	registerStrategy,
	Strategies,
	strategyLoader,
	_expose,
	registry,
	Variable,
	Expression,
	gameHistory,
	excludedPlayers,
	startREPL,
	nhistory,
	Information,
	PerfectInformation
} = require("./index"));
({
	Choice,
	Turn,
	Sequence,
	Loop,
	StochasticLoop,
	HaltIf,
	StochasticHalt,
	Lambda,
	RandomPlayerChoice,
	PopulationDynamics,
	Simultaneous
} = require("./index").Playables);
StockGames = require("./index").StockGames;

rr = StockGames["Round Robin"];
wrap = require("./lib/helperfunctions")("stock-games")

function chooseFirstOption() {
	this.choose = function(options, information) {

		return options[0];
	};
}
registerStrategy(chooseFirstOption, "chooseFirst");

function chooseSecondOption() {
	this.choose = function(options, information) {
		//console.log("second choice");
		return options[1];
	};
}
registerStrategy(chooseSecondOption, "chooseSecond");

function randomize() {
	this.choose = function(options, information) {
		var num = Math.floor(Math.random() * options.length);
		return options[num];
	};
}
registerStrategy(randomize, "randomize");

p1 = Player({ assign: "chooseFirst" });

p2 = Player();
p2.assign("randomize");
p3 = Player();
p3.assign("chooseSecond");
p4 = Player({ assign: "randomize" });

c1 = Choice(p1, ["cooperate", "defect"]);
//c1['left'](5) ;
//c1['right'](2);
c2 = Choice(p2, ["Cooperate", "Defect"]);
//c2['up'](1);
//c2['down'](7);

t2 = Turn([c1, c2]);
t3 = Turn([c1, c2]);
t4 = Turn([c1, c2]);
t5 = Turn([c1, c2]);
s1 = Simultaneous([t2, t3, t4, t5])

c3 = RandomPlayerChoice(["cooperate", "defect"]);
c4 = RandomPlayerChoice(["Cooperate", "Defect"]);

t1 = Turn([c3, c4]);

v1 = new Variable(3);

t1.defect.Defect([2, 2]);
t1.defect.Cooperate([4, 1]);
t1.cooperate.Defect([1, 4]);
t1.cooperate.Cooperate([v1, v1]);

L1 = Lambda(function() {
	v1.set(v1 + 1);
});

pd1 = PopulationDynamics(1.5, 1);

h2 = HaltIf(function() {
	return Population().onlyAlive().length == 0;
});

L1(t1);
pd1(L1);
h2(pd1);

s1 = Sequence(t1, h2);

l1 = Loop(s1, 10, { logContinue: true });

//console.log(_expose(t1).next)
//console.log(_expose(t1).next.cooperate.Cooperate)

h2 = HaltIf(function() {
	return Population().onlyAlive().length == 0;
});

L2 = Lambda(function() {
	p1.kill();
});

t2(L2);

generatePopulation = function() {
	for (i = 0; i < 30; i++) {
		Player({ assign: "chooseFirst" });
	}
	for (i = 0; i < 30; i++) {
		Player({ assign: "chooseSecond" });
	}
};

function gameGenerator() {
	var t = Turn([
		RandomPlayerChoice(["cooperate", "defect"]),
		RandomPlayerChoice(["Cooperate", "Defect"])
	]);

	t.defect.Defect([2, 2]);
	t.defect.Cooperate([4, 1]);
	t.cooperate.Defect([1, 4]);
	t.cooperate.Cooperate([3, 3]);

	return t;
}
//
//
//

//CE = StockGames["Cultural Evolution"](gameGenerator, 1, {generatePopulation});

//n = StockGames["Two-Player Normal"](p1,p2,[["left","right"],["up","down"]]);
pd1 = StockGames["Prisoner's Dilemma"]([p1, p2]);
pd2 = StockGames["Prisoner's Dilemma"]([p3, p4]);

s = Simultaneous([pd1, pd2])

v2 = Variable(1);

//n = StockGames["Simple Zero-Sum"](p1,p2,[["left","right"],["up","down"]], [[v2,2],[3,4]]);

rpc = StockGames["Rock-Paper-Scissors"]([p1, p2]);
t = StockGames["Axelrod Tournament"];
//The code below is to run the repl for testing purposes.
//var toRepl = {_expose, registry,Player,Choice,Turn,Sequence,Loop,StochasticLoop,HaltIf, StochasticHalt, Lambda, p1,c1,c2,t1};
//startREPL(toRepl);

},{"./index":4,"./lib/helperfunctions":16}],4:[function(require,module,exports){
//Main module code
var NashJS = require('./lib/engine');

//Stock-games
NashJS.StockGames = require('./stock-games');



module.exports = NashJS;

},{"./lib/engine":5,"./stock-games":65}],5:[function(require,module,exports){
"use strict";


//Logging
var log = require('./logger');
//log.useWinston();  				Winston doesn't work with browserify, so this is a shim. Uncomment to use Winston.
log.setLevel('debug');

log('info', 'Starting NashJS');


//Game state controllers
var { registry, idCounters } = require('./state');
var { gameHistory, History } = require('./history');


//Players
var { _Player, Player } = require('./player');
registry._addType_("players");
idCounters._addType_("player");


//Population
var { gamePopulation, Population, PlayerList, UserPlayerList } = require('./population');


//Information mechanics
var { Information, PerfectInformation } = require("./information");


//Playables
var { playableClasses, playableInterfaces } = require('./playables/')
for (var _class in playableClasses) {
	registry._addType_(playableClasses[_class].registryName);
	idCounters._addType_(playableClasses[_class].counterName);
}



//Symbolic Logic
var { variablePrototype, Variable, expressionPrototype, Expression } = require('./logic');



//Strategies
registry._addType_("strategies");
idCounters._addType_("strategy");
var { registerStrategy, Strategies } = require('./strategy');
var strategyLoader = require('./strategy-loader');



//THIS FUNCTION IS ONLY FOR DEBUGGING. REMOVE IT FROM MODULE EXPORTS WHEN PUBLISHING
function expose(interfacePlayable) {
	return registry.playables[interfacePlayable.id()];
}



function startREPL(toREPL) {
	var repl = require("repl");

	var replServer = repl.start({
		prompt: "Nash >> ",
	});;

	Object.assign(replServer.context, toREPL);
}


module.exports = {
	Player,
	_Player, //REMOVE THIS LINE WHEN PUBLISHING
	gamePopulation, //REMOVE THIS LINE WHEN PUBLISHING
	'PlayerList': UserPlayerList,
	Population,
	Information, //REMOVE THIS LINE WHEN PUBLISHING
	PerfectInformation, //REMOVE THIS LINE WHEN PUBLISHING
	'Playables': playableInterfaces,
	registerStrategy,
	Strategies,
	strategyLoader,
	gameHistory,
	'nhistory': History, //REMOVE THIS WHEN PUBLISHING
	'_expose': expose, //REMOVE THIS LINE WHEN PUBLISHING
	registry, //REMOVE THIS LINE WHEN PUBLISHING
	startREPL, //Should this line be removed when publishing?
	Variable,
	Expression
};

},{"./history":24,"./information":25,"./logger":26,"./logic":27,"./playables/":30,"./player":41,"./population":42,"./state":43,"./strategy":45,"./strategy-loader":44,"repl":1}],6:[function(require,module,exports){
var general = {
  //Check if variable is an Object
  isObject: function(a) {
    return !!a && a.constructor === Object;
  },

  //What do you think?
  isFunction: function(a) {
    return typeof a === "function";
  },

  //Provide a function, a context ('this'), and an argument array.
  //Returns a function that can be called.
  applyBind: function(func, that, argArray) {
    return func.bind.apply(func, [that].concat(argArray));
  },

  //Wraps a function to ensure it only gets called one time.
  once: function(fn, context) {
    var result;

    return function() {
      if (fn) {
        result = fn.apply(context || this, arguments);
        fn = null;
      }

      return result;
    };
  },

  // Randomly re-order array
  shuffle: function(array) {
    var currentIndex = array.length,
      temporaryValue,
      randomIndex;

    // While there remain elements to shuffle...
    while (0 !== currentIndex) {
      // Pick a remaining element...
      randomIndex = Math.floor(Math.random() * currentIndex);
      currentIndex -= 1;

      // And swap it with the current element.
      temporaryValue = array[currentIndex];
      array[currentIndex] = array[randomIndex];
      array[randomIndex] = temporaryValue;
    }

    return array;
  }
};

module.exports = general;

},{}],7:[function(require,module,exports){
"use strict";

var log = require("../logger");

log("debug", "helperFunctions-index: Loading helper functions loader.");

/*
var general  = require('./general');
var player   = require('./player');
var playable = require('./playable');
var turn 	 = require('./turn');
var state 	 = require('./state'); 
*/

function loader(file) {
	return require("./" + file + ".js");
}

module.exports = loader;
//module.exports = {general, player, playable, turn, state};

// Hack to compile Glob files (in browserify). DonÂ´t call this function!
(function() {
	require('./general.js');require('./index.js');require('./logic.js');require('./playable.js');require('./player.js');require('./state.js');require('./stock-games.js');require('./tournament.js');require('./turn.js');
});

},{"../logger":26,"./general.js":6,"./index.js":7,"./logic.js":8,"./playable.js":9,"./player.js":10,"./state.js":11,"./stock-games.js":12,"./tournament.js":13,"./turn.js":14}],8:[function(require,module,exports){
"use strict";

var logic = {
	
	// Check to see if object is Variable/Expression or not. Returns true/false
	isLogic: function(logic){
		
		if (logic instanceof Function && logic == logic*1) return true
		else return false;
	}
};

module.exports = logic;
},{}],9:[function(require,module,exports){
"use strict";

var {SynchronousPromise} = require('synchronous-promise');

//Game state controllers
var {registry} = require('../state');

var playable = {
	// Generates the function that gets returned when a Playable is called, which can then be called to chain playables together.
	chainerGenerator:function(externalObj, internalObj){
		externalObj = this;
		return function(source){
			var previousPlayable, path;
		
			//TODO: verify that source is the right type
		
			return SynchronousPromise.all([function(){
				if (source instanceof Promise || source instanceof SynchronousPromise) {
					source.then(function(result){
						previousPlayable = registry.playables[result.playable.id()];
						path = result.path
						return SynchronousPromise.resolve();
					});				
				}
				return SynchronousPromise.resolve()
			}(), function(){
				if (!(source instanceof Promise || source instanceof SynchronousPromise)) {
					previousPlayable = registry.playables[source.id()];	
					path = source.path;
				}
				return SynchronousPromise.resolve();
			}()]).then(function(result){
				
				if (path == "all") previousPlayable.addNext(internalObj);
				else {
					
					outcomeTreeGetValue(previousPlayable.next, path).push(internalObj); 
				}
				
					//previousPlayable.next[selected].push(_choice);
			
				return SynchronousPromise.resolve({
					'playable':externalObj,
					path:"all"
				});
			});
		};
	},


	//Use to set every value of an outcome tree
	outcomeTreeAddAll:function(tree, value){
		
		//If it's an array, then we're already done.
		if (Array.isArray(tree)) {
			tree.push(value);			//Use push here because this will be a unique array
		}
		else {
			var recurse = function(obj, val){
	
				for (var keys in obj) {
					
					//If no keys left to traverse, then assign value. If not, recurse.
					if (Array.isArray(obj[keys])) {
						obj[keys] = obj[keys].slice().concat(val);			//Use slice-concat here because this might not be a unique array (the creation process duplicates them)
					}
					else recurse(obj[keys],val);
					
				}
			};
		recurse(tree, value);
		}
	},

	
	//Traverse an outcome tree to obtain the value for a desired key-set
	//Argument one is a nested object, while argument 2 is an array of keys for the object, 1 layer at a time.
	outcomeTreeGetValue:function(tree, selector){
	
		//Find the next item in the chain associated with the resultant outcome	
		for (var i = 0, len = selector.length; i < len; i++) {
			tree = tree[selector[i]];
		}
			
		return tree;
	},


	//Traverse an outcome tree to set the value for a desired key-set
	//Argument one is a nested object, while argument 2 is an array of keys for the object, 1 layer at a time.
	outcomeTreeSetValue:function(tree, selector, value){
	
		//Find the next item in the chain associated with the resultant outcome	
		for (var i = 0, len = selector.length -1; i < len; i++) {
			tree = tree[selector[i]];
		}
			
		return tree[selector[i]] = value;
	}
}



module.exports = playable;
},{"../state":43,"synchronous-promise":62}],10:[function(require,module,exports){
"use strict";

//  Game state
var { registry } = require("../state");

// helper function
var { isFunction } = require("./general");

// Player claass
var { _Player } = require("../player");

// Population
var { gamePopulation } = require("../population")

var player = {

	//reset all players. Recreate from class, re-assign strategy, loop through objects that reference player to set new reference. result argument is only for pass-through.
	reinitializePlayers: function(population = "all", result = null) {
		return Promise.resolve().then(function() {
			var oldPlayer, strategy, parameters;

			// if no population is supplied, fetch everybody
			if (population === "all") population = Object.keys(registry.players)
			else(population = population.ids())

			//Redefine each player
			for (var i = 0; i < population.length; i++) {
				var player = population[i];

				oldPlayer = registry.players[player];
				strategy = oldPlayer.strategy._id;
				parameters = {}; //TODO: when adding player parameters, be sure they're included here

				registry.players[player] = new _Player(oldPlayer.id, parameters);
				registry.players[player].interface = oldPlayer.interface;
				registry.players[player].assign(strategy);
			}

			//For each choice, recreate player references
			for (var choice in registry.choices) {
				if (registry.choices[choice].player)
					registry.choices[choice].player = registry.players[registry.choices[choice].player.id];
			}

			return Promise.resolve(result);
		});
	}
};

module.exports = player;

},{"../player":41,"../population":42,"../state":43,"./general":6}],11:[function(require,module,exports){
"use strict";

var log = require('../logger');

// State variables
var {idCounters, registry} = require('../state');

var state = {
	
	//Handle ID setting for all objects that get stored in the registry
	idHandler: function idHandler(id, type, recursing=false){
		//Assign id
		
		idCounters[type]++;
		var counter = idCounters[type];
		
		if (!id) {
			return type + counter.toString();
		}
		else {
			
			// Check that id isn't taken. If it is, construct a new one.
			
			//Construct list of all objects by extracting all registry entries
			var items = []
			Object.keys(registry).forEach(function(reg){items.push.apply(items, Object.keys(registry[reg]))})
			
			// if id is already taken, generate a new one by adding a number at the end.
			if (items.indexOf(id) > -1) {
				
				var match, oldNum, exp, newId;
				var oldId = id;
				
				do {
					// This finds a number at the end, and increments it, or starts with 1 if there wasn't one.
					match = /\d+$/.exec(id);
					oldNum = match ? match[0] : "";
					exp = new RegExp(oldNum + "$");
					id = id.replace(exp, Number(oldNum) + 1)
				
				}	
				while (items.indexOf(id) >-1)
				
				// Log warning
				log("warn", "ID " + oldId + " is taken. Using instead " + id);
			}
			
			return id
		}
	}
};

module.exports = state;
},{"../logger":26,"../state":43}],12:[function(require,module,exports){
"use strict";

//External dependency
var esprima = require("esprima");

var stockGames = {
	// utility function to create two ways to call a game, either with all the arguments, or curried, where the returned function takes players and parameters
	// The combineParameters setting will
	gameWrapper: function(game, argumentValidator = function() { return true; }, {
		combineParameters =
		true
	} = {}) {

		// run the game. Optionally, validate the arguments first.
		var generate = function(...args) {
			var result = argumentValidator(...args)
			if (result === true) return game(...args);
			else throw new Error(result);
		}

		// creates a wrapper around the game, which accepts the first argument (players) and last argument (parameters), and passes it forward.
		// If combineParameters is set to true, then the second argument of the returned function will get merged with the last argument
		// given when generator is called.
		generate.createGenerator = function(...args) {

			console.log(game, game.toString())
			var gameCode = esprima.parseScript("(" + game.toString() + ")")
			console.log(gameCode)

			var gameArgs = gameCode.body[0].expression.params
			var lastArg = gameArgs[gameArgs.length - 1]

			var originalParameters
			if ((lastArg.name && lastArg.name.toLowerCase() === "parameters") || lastArg.type === "ObjectPattern" ||
				(lastArg.type == "AssignmentPattern" && lastArg.left.type == "ObjectPattern")) {
				// Check that the game arguments and createGenerator arguments are the correct lengths. createGenerator should be
				// 1 less than game, because players is omitted.
				// TODO: use esprima to allow players to be anywhere in the game definition (or even omitted) rather than first
				if (args.length == gameArgs.length - 1) originalParameters = args.pop();
			}


			return function(players, parameters = {}) {

				// If combining parameters, merge and remove from arguments
				if (combineParameters && originalParameters) parameters = Object.assign({}, originalParameters,
					parameters)

				return generate(players, ...args, parameters)
			}
		}

		return generate;
	}


}

module.exports = stockGames;

},{"esprima":51}],13:[function(require,module,exports){
"use strict";

// Strategies
var { Strategies } = require("../strategy");

// Players
var { Player } = require("../player");

module.exports = {
  // Create a player for each available strategy
  generatePopulation: function() {
    var players = [];

    Strategies().forEach(function(strategy) {
      players.push(Player({ assign: strategy }));
    });

    return players;
  }
};

},{"../player":41,"../strategy":45}],14:[function(require,module,exports){
"use strict";

var {SynchronousPromise} = require('synchronous-promise');

var turn = {
	
	//Recurse through the options in input, and write val to output. 
	recurse : function recurse(input, output, val, valGenerator=function(){}, path=[]){
		return SynchronousPromise.resolve(path).then(function(path){
			
			//Since we slice the array each time, if there are no more entries left then we're done with this branch.
			if (input.length == 0) return SynchronousPromise.resolve(path)
			
			
			//Among all values from the array
			return SynchronousPromise.all(input[0].map(function(item){
				var value;
				var splitPath = path.slice(0).concat(item);
				
				//If there are more items to iterate over, include them in the output then recurse.
				//If not, put in the new value.
				if (input.length == 1) {
					
					//If val is a function, wrap it in a function that will get supplied an argument with where we are				
					if (typeof val == "function") {
						value = function(){	
							var args = [splitPath].concat(Array.prototype.slice.call(arguments));
							return val.apply(null, args);
						};
					}
					else value = val || valGenerator(splitPath);
					
					output[item] = value;
				}
				else output[item] = {};
				
				
				return recurse(input.slice(1),output[item], val, valGenerator, splitPath);
			}));		
		});
	}
};


module.exports = turn;
},{"synchronous-promise":62}],15:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],16:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"../logger":26,"./general.js":15,"./index.js":16,"./logic.js":17,"./playable.js":18,"./player.js":19,"./state.js":20,"./stock-games.js":21,"./tournament.js":22,"./turn.js":23,"dup":7}],17:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],18:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"../state":43,"dup":9,"synchronous-promise":62}],19:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"../player":41,"../population":42,"../state":43,"./general":15,"dup":10}],20:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"../logger":26,"../state":43,"dup":11}],21:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"dup":12,"esprima":51}],22:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"../player":41,"../strategy":45,"dup":13}],23:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"dup":14,"synchronous-promise":62}],24:[function(require,module,exports){
"use strict";

//External dependency
var jsonata = require("jsonata");


var { isObject, isFunction } = require("./helperfunctions")("general");

//Extension of array to handle history lists.
function History(...args) {
	if (Array.isArray(args[0])) args = args[0];

	Object.setPrototypeOf(args, History.prototype);

	args.log = args.slice();
	args.log.tree = args;
	Object.setPrototypeOf(args.log, History.prototype);

	args.scores = [];
	args.scores.tree = args;
	Object.setPrototypeOf(args.scores, History.prototype);

	return args;
}

History.prototype = Object.create(Array.prototype);
History.prototype.constructor = History;

//To add entry
History.prototype.add = function(entry) {
	//Add to history and to log
	this.push(entry);
	if (this.log) this.log.push(entry);

	//Cycle up the parent tree, add to each log
	var check = this;
	if (check.tree instanceof History && check.tree.parent instanceof History) {
		check.tree.parent.log.add(entry);
	}
	if (check.parent instanceof History) {
		check.parent.log.add(entry);
	}

	//If we're being called fr

	return this;
};

//To add entry without logging (for playables that would like the tree history
//to be structured differently than the log history.
History.prototype.addNoLog = function(entry) {
	this.push(entry);
	return this;
};


History.prototype.addScores = function(entry) {
	//Add to history
	this.scores.push(entry);

	//Cycle up the parent tree, add to each log
	var check = this;
	if (check.parent instanceof History) {
		check.parent.addScores(entry);
	}



	return this;
};


//A temporary History that can be merged back in later. The child and parent are linked until .orphan() is called.
History.prototype.child = function(parent = this) {
	var h = new History();
	h.parent = parent;
	return h;
};

//Same as .child except includes prior parent history when .print() is called.
History.prototype.childWithContent = function(parent = this) {
	var storedLog = parent.slice();
	var storedScores = parent.slice();

	var h = new History();


	h.log.print = function() {
		History.prototype.print.call(storedLog.concat(h.log))
	}
	h.scores.print = function() {
		History.prototype.print.call(storedScores.concat(h.scores))
	}

	h.parent = parent;
	return h;
};

//This severs the link between the temporary history and its parent. Use this when merging composite entries.
History.prototype.orphan = function() {
	delete this.parent;
	delete this.log;
	delete this.scores;
	return this;
};

//Clear history
History.prototype.clearHistory = function() {
	this.splice(0, this.length);
	if (this.log) this.log.splice(0, this.log.length);
	if (this.scores) this.scores.splice(0, this.scores.length);
	delete this.parent;
};

//End the game.
History.prototype.end = function() {
	this.stop = true;
	if (this.parent) this.parent.end();
};

//Get a particular sort of entry, eg. Turn.
History.prototype.getType = function(type) {
	return new History(
		this.filter(function(entry) {
			//If it's not an object, don't even bother.
			if (!isObject(entry)) return false;

			for (var key in entry) {
				if (key == type) return true;
			}

			return false;
		})
	);
};

//Help read the history in Chrome with less clutter.
History.prototype.print = function() {
	var history = JSON.parse(JSON.stringify(this));
	history.query = History.prototype.query
	return history;
};

History.prototype.query = function(queryString, ...args) {
	return jsonata(queryString).evaluate(this, ...args);
}

//Supply an entry, it will check for a property that is a History
History.prototype.recurse = function(type) {
	var list = this;

	return new History(
		list.map(function(entry) {
			for (var key in entry) {
				console.log(key, entry);
				if (entry[key] instanceof History) return entry[key].recurse(type);
				else if (key == type) return entry;
			}
			return null;
		})
	);
};

//Accept a History and return one suitable for the user
function UserHistory(history) {
	var userHistory = history.map(function(entry) {
		return JSON.parse(JSON.stringify(entry));
	});

	Object.setPrototypeOf(userHistory, UserHistory.prototype);

	//Attach methods from History, wrapped in a function. If those methods return a history,
	//then the function will convert that to a userHistory.
	for (var method in History.prototype) {
		if (isFunction(history[method])) {
			if (method != "constructor")
				userHistory[method] = (function(method) {
					return function() {
						var result = history[method].apply(history, arguments);
						if (result instanceof History) return new UserHistory(result);
						else if (isObject(result))
							return JSON.parse(JSON.stringify(result));
						else return result;
					};
				})(method);
		}
	}

	return userHistory;
}

UserHistory.prototype = Object.create(History.prototype);
UserHistory.prototype.constructor = UserHistory;

var gameHistory = new History(); //TODO: add choice-only history

module.exports = { History, UserHistory, gameHistory };

},{"./helperfunctions":16,"jsonata":55}],25:[function(require,module,exports){
"use strict";

//When a strategy's .choose() function is called, it is given an information set. That data is a limited map of the internal objects of the game engine, including information on the game history and the players. This is threaded through playables, much like History, so that a parent playable can specify an information set for the playables it calls, or else the default construction will be used. Additionally, the user can provide a filter function, to selectively delete (or add) information elements before they are passed to .choose().

//History functions
var { gameHistory, History } = require('./history');

//Population functions
var { gamePopulation, PlayerList } = require('./population');


function Information(history = gameHistory, population = gamePopulation) {
	this.history = history;
	this.population = population;

	this.additional = [];

	this.update();
};

//Check the source then cache a hard-copy.
Information.prototype.update = function(player, local) {
	this.infoPopulation = this.population().info();

	this.infoHistory = { log: this.history.log.print(), scores: this.history.scores.print() };

	this.additional = [];

	//Return value. Mimics .deliver()
	var information = {
		history: { log: this.infoHistory.log, scores: this.infoHistory.scores },
		population: this
			.infoPopulation
	}
	if (player) information.me = information.population.get(player.id);
	if (local) Object.assign(information, local);

	return information;
};

//Clone the cached copies and provide them. Will deliver the same thing every time until update is called.
Information.prototype.deliver = function(player, local) {
	var information = {
		history: { log: this.infoHistory.log, scores: this.infoHistory.scores },
		population: this
			.infoPopulation
	}


	if (player) information.me = information.population.get(player.id);
	if (local) Object.assign(information, local);
	if (this.additional) this.additional.forEach(function(entry) { Object.assign(information, entry) });

	return JSON.parse(JSON.stringify(information));
};

//This probably doesn't need to be a separate function, but adding it in case it expands later.
Information.prototype.addAdditional = function(entry = null) {
	if (entry) this.additional.push(entry);
};

//Make copy of this information function, which allows for updating and freezing.
Information.prototype.child = function() {
	var information = new Information(this.history, this.population);

	return information;
};



//Game state, analogous to gameHistory
var PerfectInformation = new Information(gameHistory, gamePopulation);

//Overwrite .deliver(). PerfectInformation is always up-to-date! Thus no need to do a 2nd JSON.stringify.
PerfectInformation.deliver = function(player, local) {

	var information = this.update(player, local);

	if (player) information.me = information.population.get(player.id);
	if (local) Object.assign(information, local);

	return information;
};


module.exports = { Information, PerfectInformation };

},{"./history":24,"./population":42}],26:[function(require,module,exports){
"use strict";



var logger = function() {
	var args = [...arguments];
	var level = (args[0] == "silly" || !args[0]) ? "trace" : args[0];
	args.shift();

	logger.logger[level].apply(logger.logger, args);
};

//logger.logger = console;					//TODO clean this all up a lot.

var getLogger = require("loglevel-colored-level-prefix");
var options = { prefix: 'nashJS', level: 'trace' }
logger.logger = getLogger(options)

logger.setLevel = function(level) {
	logger.logger.level = level;
	logger.logger.setLevel(level)
};

/*
logger.useWinston = function(){

	var winston = require('winston');
	var util = require('util');

	winston.level = "warn";

	winston.clear()
	winston.add(winston.transports.Console, {
		level: 'trace',
		prettyPrint:  function ( object ){
			return util.inspect(object);
		},
		colorize: true,
		silent: false,
		timestamp: false
	});

	this.logger = winston;
};
*/

module.exports = logger;

},{"loglevel-colored-level-prefix":56}],27:[function(require,module,exports){
"use strict";

var log = require('./logger');

//Helper functions
var {isFunction} = require('./helperFunctions')('general');


// Extend function, the sneaky way.
var variablePrototype = Object.create(Function.prototype);


variablePrototype.constructor = function (value) {
	
	var variable = this;
	variable.value = value;								//TODO: add a way to have a function that automatically generates a value.

	this.id = function(){return _playable.id;};			//TODO: work on ids and registration
};


variablePrototype.call = function () {
	return this.value;
};
	
variablePrototype.toJSON 	= function(){
	return this.call();
}		
variablePrototype.toString 	= function(){
	return this.call();
}
variablePrototype.valueOf 	= function(){
	return this.call();
};


variablePrototype.set = function(newValue){
	this.value = newValue;
	return this.value;
};



//Repurpose the very-similar code for Variable, but re-write certain keys
var expressionPrototype = Object.create(Function.prototype);

expressionPrototype.constructor = function(expression){
	if (!isFunction(expression)) log("error", "Expression must be a function.");
	
	var value = expression();
	if (isNaN(value)) log("error", "Expression must return a number");			//TODO: should Expressions/Variables allow strings?
		
	this.value = expression;	
	
	return value;
};

expressionPrototype.call = function(){
	return this.value() * 1;
};

expressionPrototype.toJSON	 	= function(){
	return this.call();
}
expressionPrototype.toString 	= function(){
	return this.call();
}
expressionPrototype.valueOf 	= function(){
	return this.call();
};

expressionPrototype.set = function(newExpression){
	if (!isFunction(newExpression)) log("error", "Expression must be a function.");
	
	var value = newExpression();
	this.value = newExpression;
	
	return value;
};



//Produces the function that will produce the end result. This part is reusable if you need to do this again.
var classFactory = function (proto) {
	return function () {
		
		var f = function () {
			return f.call.apply(f, arguments);      
		};
		
		Object.defineProperty(f, "constructor", {configurable:true, writable:true});
		Object.defineProperty(f, "call", {writable:true});
		Object.defineProperty(f, "toString", {writable:true});
		Object.defineProperty(f, "valueOf", {writable:true});
		
		Object.keys(proto).forEach(function (key) {
			f[key] = proto[key];
		});
		
		f.constructor.apply(f, arguments);		
		
		return f;
	}
};


var Variable = classFactory(variablePrototype);
var Expression = classFactory(expressionPrototype);
// called as: var instance = Variable();

module.exports = {variablePrototype, Variable, expressionPrototype, Expression};
},{"./helperFunctions":7,"./logger":26}],28:[function(require,module,exports){
"use strict";

var log = require("../logger");
log("debug", "Loading Class: Choice");

// External dependency
var { SynchronousPromise } = require("synchronous-promise");

//Game state controllers
var { registry } = require("../state");
var { gameHistory } = require("../history");
var { PerfectInformation } = require("../information");

//Helper functions
var { idHandler } = require("../helperFunctions")("state");
var { isFunction } = require("../helperFunctions")("general");
var { chainerGenerator } = require("../helperFunctions")("playable");

//Parent class
var { _Playable, Playable } = require("./playable");

//Backend function class for Choice
function _Choice(id, player, options, parameters = {}) {
	_Playable.call(this, id);

	this.next = {};

	this.player = registry.players[player];
	this.options = options;
	this.defaultOption = parameters.defaultOption || options[0]; //TODO: make defaultOption functional
	this.informationFilter = parameters.informationFilter || null;

	registry.choices[id] = this;

	var choice = this;
	this.options.forEach(function(item) {
		choice.next[item] = [];
	});
}

_Choice.prototype = Object.create(_Playable.prototype);
_Choice.prototype.constructor = _Choice;

_Choice.registryName = "choices";
_Choice.counterName = "choice";

_Choice.prototype.play = function({
	usePayoffs = false,
	history = gameHistory,
	information: rawInformation = PerfectInformation,
	releasePlayer = true,
	informationFilter = this.informationFilter,
	_compileInformation = null
} = {}) {
	var choice = this;

	if (!choice.player.alive)
		return Promise.reject({
			result: choice.id + ": Player " + choice.player.id + " is dead."
		});

	//While this choice is happening, don't allow other choices to use this player.
	choice.player.available = false;

	//Information mechanics. If we're dealing with PerfectInformation, this won't get delivered, so we'll include it in the call to .deliver(). If we're using an information supplied from some other playable, then they can do what they like with it.
	var choiceInfo = {
		choice: {
			id: choice.id,
			player: choice.player.id,
			options: choice.options
		}
	};
	rawInformation.addAdditional(choiceInfo);
	//Perform some data processing if other playables need it.
	if (_compileInformation) _compileInformation(rawInformation);

	return Promise.resolve()
		.then(function() {
			//Prep information
			var information = rawInformation.deliver(choice.player, choiceInfo);
			if (informationFilter) information = informationFilter(information);

			return choice.player.choose(choice.options.slice(0), information);
		})
		.then(function(result) {
			var player = choice.player;
			var id = choice.id;

			//Add to player's individual history;
			player.history.push({
				choice: id,
				options: choice.options,
				result
			});

			result = result || choice.defaultOption;

			var resultObject = {
				result,
				historyEntry: {
					choice: id,
					player: player.id,
					move: result
				}
			};

			//This will probably only happen if it's a single-player game, otherwise we'll use playoffs defined in a Turn
			if (usePayoffs) {
				var payout = choice.payoffs[result];

				player.score += payout;

				//track the payoff
				var scoreEntry = {
					choice: id,
					payouts: {
						[player.id]: Number(payout)
					}
				};

				history.addScores(scoreEntry);
				resultObject.historyEntry.payouts = {
					[player.id]: payout };
			}

			log(
				"silly",
				"_Choice.play: removing from occupiedPlayers: ",
				choice.player.id
			);
			if (releasePlayer) choice.releasePlayer();

			return Promise.resolve(resultObject); //TODO: add information mechanisms
		});
};

//Release player from excluded players list, so that other objects can use it.
_Choice.prototype.releasePlayer = function() {
	this.player.available = true;
};

_Choice.prototype.findNext = function({ result } = {}) {
	return this.next[result.result];
};

_Choice.prototype.generateChainingFunctions = function(choice) {
	var _choice = this;

	_choice.options.forEach(function(option) {
		_choice.payoffs[option] = 0; //Start payoffs at zero

		choice[option] = function(payoff) {
			//Create functions for user to assign payoffs
			if (!isNaN(payoff)) _choice.payoffs[option] = payoff;
			return SynchronousPromise.resolve({
				playable: choice,
				path: [option]
			});
		};
	});
};

_Choice.prototype.summaryThis = function(summary) {
	summary.player = this.player.id;
	summary.options = this.options.slice();

	return summary;
};

//TODO: un-fuck this.
_Choice.prototype.summaryNext = function(
	summary,
	entries = {},
	shortCircuit = false,
	maxEntries = 10
) {
	// Copy over the choice options
	summary.next = Object.assign({}, this.next);

	// Loop through them and summarize at each step.
	var count = 0;
	for (var key in summary.next) {
		summary.next[key] = summary.next[key].map(function(playable) {
			count++;
			return playable.summarize({}, entries);
		});
	}

	// If there weren't any next steps, delete the next key, to reduce clutter.
	if (count == 0) delete summary.next;

	return summary;
};

//Set all payoffs to zero.
_Choice.prototype.zeroPayoffs = function() {
	var choice = this;

	choice.payoffs = {};

	choice.options.forEach(function(option) {
		choice.payoffs[option] = 0;
	});
};

function Choice(player, options, parameters = {}) {
	var id = idHandler(parameters.id, "choice");

	//If informationFilter was supplied, it must be a function
	if (parameters.informationFilter && !isFunction(parameters.informationFilter))
		throw new Error("informationFilter must be a function");

	//Create backend choice object
	var _choice = new _Choice(id, player.id(), options, parameters);

	//Return this reference object to the user. Run the function to select a source
	var choice = Playable(_choice);

	//Interface to specify single-player payoffs in single-player/single-choice games
	_choice.zeroPayoffs();

	_choice.generateChainingFunctions(choice);

	/*
	options.forEach(function(option){
		_choice.payoffs[option] = 0;			//Start payoffs at zero

		choice[option] = function(payoff){					//Create functions for user to assign payoffs
			if (!isNaN(payoff))_choice.payoffs[option] = payoff;
			return Promise.resolve({
				playable:choice,
				path:[option]
			})
		};
	});
	*/

	//Function to set all payoffs at once
	choice.setAllPayoffs = function(payoffs) {
		//TODO: make this work. Include error handling if array given isn't expected dimensions.
	};

	//Way for user to interact with payoffs
	choice.payoffs = function() {
		return registry.choices[id].payoffs;
	};

	return choice;
}

module.exports = { _Choice, Choice };

},{"../helperFunctions":7,"../history":24,"../information":25,"../logger":26,"../state":43,"./playable":33,"synchronous-promise":62}],29:[function(require,module,exports){
"use strict";

var log = require('../logger');
log("debug", "Loading Class: HaltIf")

//Game state controllers
var {registry} = require('../state');
var {gameHistory} = require('../history');

//Helper functions
var {isFunction}	= require('../helperFunctions')("general");
var {idHandler} 	= require('../helperFunctions')("state");

//Parent class
var {_Playable, Playable} = require('./playable');



//Backend function class for Game
function _Halt(id,testCondition, {logContinue = false}){
	_Playable.call(this,id);
	
	this.testCondition = testCondition;
	this.logContinue = logContinue;
	
	registry.halts[id] = this;
}

_Halt.prototype = Object.create(_Playable.prototype);
_Halt.prototype.constructor = _Halt;

_Halt.registryName = "halts";
_Halt.counterName = "haltIf";

_Halt.prototype.play = function({initializePlayers=false, shortCircuit=false, history=gameHistory}={}){
	
	var halt = this;
	
	var resultObject = {
		'playable':halt,
		'historyEntry':{
			'halt':halt.id
		}
	};
	
	
	var test = halt.testCondition();
	
	
	if (test) {
		log("info", "Halting at " + halt.id)
		
		resultObject.historyEntry.action = "halt";
		resultObject.result = "Halt";
	
		return Promise.reject(resultObject);
	}
	
	//Halt probably gets used for loops, and we might not want to see lots of continue messages, so "logContinue" will omit them.
	if (halt.logContinue) {
		resultObject.historyEntry.action = "continue";
	}
	else delete resultObject.historyEntry
	
	
	return Promise.resolve(resultObject)
};


_Halt.prototype.summaryThis = function(summary){
	summary.condition = this.testCondition.toString();
}



function HaltIf(testCondition=function(){}, {id=null, logContinue=false}={}){
	var id = idHandler(id,"haltIf")
	
	if (!isFunction(testCondition)) log("warn",id + ": testCondition should be a function, or else game will not halt.")

	//Create backend loop object
	var _halt = new _Halt(id, testCondition, {logContinue});
	
	
	//Return this reference object to the user. Run the function to select a source
	var halt = Playable(_halt);	
	return halt;	
}


module.exports = {_Halt, HaltIf};
},{"../helperFunctions":7,"../history":24,"../logger":26,"../state":43,"./playable":33}],30:[function(require,module,exports){
"use strict";

//Loads the playables that will be used by Nash. This is basically the controller list: if it's not in these lists,
// then it won't be available for us.

//External dependency
var present = require("present");

var log = require("../logger");

var { applyBind } = require("../helperFunctions")("general");

log("debug", "Loading Playable Classes: ");

//Playables
var { _Playable } = require("./playable");
var { _Choice, Choice } = require("./choice");
var { _Turn, Turn } = require("./turn");
var { _Sequence, Sequence } = require("./sequence");
var { _Loop, Loop } = require("./loop");
var { _SLoop, StochasticLoop } = require("./stochasticLoop");
var { _Halt, HaltIf } = require("./halt-if");
var { _SHalt, StochasticHalt } = require("./stochastic-halt");
var { _Lambda, Lambda } = require("./lambda");
var { _RPChoice, RandomPlayerChoice } = require("./random-player-choice");
var { _PopulationDynamics, PopulationDynamics } = require("./population-dynamics");
var { _Simultaneous, Simultaneous } = require("./simultaneous");

//Runs when loading Playable classes.
function initializePlayableClass(playableClass) {
	//Replace the .play() method with a wrapper which calls it and a few other functions
	if (playableClass.prototype.hasOwnProperty("play")) {
		playableClass.prototype.play = (function(play) {
			return function({ history = gameHistory } = {}) {
				var playable = this;
				var args = [].slice.call(arguments);

				// Set our history
				args[0].history ? null : args[0].history = this.history || gameHistory

				// how to halt the game without errors. TODO this is probably fucked
				if (history.stop) return { playable };


				return _Playable.prototype._startTimer
					.apply(playable, args)
					.then(applyBind(playable.checkInit, playable, args))
					.then(applyBind(playable.prePlay, playable, args))
					.then(applyBind(play, playable, args))
					.then(applyBind(playable.postPlay, playable, args))
					.then(applyBind(_Playable.prototype._stopTimer, playable, args))
					.then(applyBind(playable.handleHistory, playable, args))
					.then(applyBind(_Playable.prototype.proceed, playable, args));
			};
		})(playableClass.prototype.play);
	}
}

exports.playableClasses = {
	_Playable,
	_Choice,
	_Turn,
	_Sequence,
	_Loop,
	_SLoop,
	_Halt,
	_SHalt,
	_Lambda,
	_RPChoice,
	_PopulationDynamics,
	_Simultaneous
};
exports.playableInterfaces = {
	Choice,
	Turn,
	Sequence,
	Loop,
	StochasticLoop,
	HaltIf,
	StochasticHalt,
	Lambda,
	RandomPlayerChoice,
	PopulationDynamics,
	Simultaneous
};

for (var playableClass in exports.playableClasses) {
	if (playableClass != "_Playable")
		initializePlayableClass(exports.playableClasses[playableClass]);
}

},{"../helperFunctions":7,"../logger":26,"./choice":28,"./halt-if":29,"./lambda":31,"./loop":32,"./playable":33,"./population-dynamics":34,"./random-player-choice":35,"./sequence":36,"./simultaneous":37,"./stochastic-halt":38,"./stochasticLoop":39,"./turn":40,"present":58}],31:[function(require,module,exports){
"use strict";

var log = require('../logger');
log("debug", "Loading Class: Lambda")

//Game state controllers
var {registry, gameHistory} = require('../state');

//Helper functions
var {isFunction}	= require('../helperFunctions')("general");
var {idHandler} 	= require('../helperFunctions')("state");

//Parent class
var {_Playable, Playable} = require('./playable');



//Backend function class for Game
function _Lambda(id, action, parameters={}){
	_Playable.call(this,id);
	
	this.action = action;
	
	registry.lambdas[id] = this;
}
_Lambda.prototype = Object.create(_Playable.prototype);
_Lambda.prototype.constructor = _Lambda

_Lambda.registryName = "lambdas";
_Lambda.counterName = "lambda";


_Lambda.prototype.play = function({initializePlayers=false, shortCircuit=false, history=gameHistory}={}){
	
	var lambda = this;
		
	var result = lambda.action()
		
	var resultObject = {
		result,
		'playable':lambda,
		historyEntry:{
			lambda:lambda.id,
			result
		}
	};
	
	return Promise.resolve(resultObject)
};

_Lambda.prototype.summaryThis = function(summary){
	summary.action = this.action.toString();
}


function Lambda(action=function(){}, parameters={}){
	var id = idHandler(parameters.id,"lambda")
	
	if (!isFunction(action)) log("warn",id + ": action should be a function.")

	//Create backend lambda object
	var _lambda = new _Lambda(id, action, parameters);
	
	
	//Return this reference object to the user. Run the function to select a source
	var lambda = Playable(_lambda);	
	return lambda;	
}


module.exports = {_Lambda, Lambda};
},{"../helperFunctions":7,"../logger":26,"../state":43,"./playable":33}],32:[function(require,module,exports){
"use strict";

var log = require("../logger");
log("debug", "Loading Class: Loop");

//Game state controllers
var { registry } = require("../state");
var { gameHistory, History } = require("../history");

//Helper functions
var { idHandler } = require("../helperFunctions")("state");
var { chainerGenerator } = require("../helperFunctions")("playable");

// Information mechanics
var { Information, PerfectInformation } = require("../information");
var { gamePopulation } = require("../population");

//Parent class
var { _Playable, Playable } = require("./playable");

//Backend function class for Loop

function _Loop(id, playable, count, parameters) {
	_Playable.call(this, id, parameters);

	var { logContinue = true, playableParameters = {} } = parameters;

	this.playable = registry.playables[playable.id()];
	this.logContinue = logContinue;
	this.playableParameters = playableParameters;

	this.count = count;

	registry.loops[id] = this;
}
_Loop.prototype = Object.create(_Playable.prototype);
_Loop.prototype.constructor = _Loop;

_Loop.registryName = "loops";
_Loop.counterName = "loop";

_Loop.prototype.play = function({
	history = this.history || gameHistory,
	information = this.information || PerfectInformation,
	playableParameters = this.playableParameters
} = {}) {

	var loop = this;
	loop.counter = 0;

	// Split the history entry
	var loopHistory = history.child();

	// information mechanics.
	//compartmentalize If set
	if (loop.compartmentalize) {
		information = new Information(loop.compartmentalize.history || loopHistory,
			loop.compartmentalize.population || gamePopulation);
	}
	// Pass along
	playableParameters.information = information


	var promise = Promise.resolve();

	var action = function(result) {
		//If the game has been ended early, don't continue.
		if (history.stop) return { playable: loop };

		loop.counter++;
		if (!result) result = {};

		//Deal with history
		history.log.add({
			loop: loop.id,
			loopTo: loop.playable.id,
			count: loop.counter
		});

		playableParameters.shortCircuit = true;
		playableParameters.history = loopHistory;

		return loop.playable.play(playableParameters).then(function(result) {
			//Re-format result, replace playable with Loop playable
			result.playable = loop;

			//TODO: add information mechanisms

			return Promise.resolve(result);
		});
	};

	//Repeat the playable loop.count times, by chaining promises.
	for (var i = 0; i < loop.count; i++) {
		promise = promise.then(action);
	}

	return promise.then(function(result) {
		result.historyEntry = {
			loop: loop.id,
			count: loop.counter,
			action: loopHistory.orphan()
		};
		return Promise.resolve(result);
	});
};

//Overwrite history handler to prevent "loop finished" entry from hitting the tree.
_Loop.prototype.handleHistory = function({
		history = this.history || gameHistory,
		information = this.information || PerfectInformation,
		logContinue = this.logContinue
	} = {},
	result
) {
	var loop = this;

	return Promise.resolve(result).then(function(result) {
		//Write final entry if logContinue is set to true
		if (logContinue) {
			history.log.add({
				loop: loop.id,
				loopTo: "Loop finished.",
				count: loop.counter
			});
		}

		history.addNoLog(result.historyEntry);

		return result;
	});
};

// Add detail/nesting to summary.
_Loop.prototype.summaryThis = function(summary, entries) {
	summary.count = this.count;

	summary.action = {};
	this.playable.summarize(summary.action, entries, true);
};

function Loop(playable, count = 1, parameters = {}) {
	var id = idHandler(parameters.id, "loop");

	//Create backend loop object
	var _loop = new _Loop(id, playable, count, parameters);

	//Return this reference object to the user. Run the function to select a source
	var loop = Playable(_loop);
	return loop;
}

module.exports = { _Loop, Loop };

},{"../helperFunctions":7,"../history":24,"../information":25,"../logger":26,"../population":42,"../state":43,"./playable":33}],33:[function(require,module,exports){
"use strict";

var log = require("../logger");
log("debug", "Loading Class: Playable");

var { SynchronousPromise } = require("synchronous-promise");
var present = require("present");

//Game state controllers
var { registry, idCounters } = require("../state");
var { gameHistory, History } = require("../history");

//Helper functions
var { isFunction } = require("../helperFunctions")("general");
var { outcomeTreeAddAll, outcomeTreeGetValue } = require("../helperFunctions")("playable");
var { reinitializePlayers } = require("../helperFunctions")("player");

//To return to user
var { Population, PlayerList } = require("../population");

//_playable class, superclass for objects which can execute game steps (choice, turn, game)
function _Playable(id, parameters = {}) {
	this.id = id;
	this.next = [];
	registry.playables[id] = this;
	idCounters.playable++;

	parameters.compartmentalize ? this.compartmentalize = parameters.compartmentalize : null;
	parameters.history ? (this.history = parameters.history) : null;
	parameters.information ? (this.information = parameters.information) : null;
	parameters.initializePlayers ? (this.initializePlayers = parameters.initializePlayers) : null;
}

_Playable.registryName = "playables";
_Playable.counterName = "playable";

//Add reference to next playable branch, to chain playables together.
_Playable.prototype.addNext = function(nextPlayable) {
	outcomeTreeAddAll(this.next, nextPlayable);
};

//Called before .play() to start timing.
_Playable.prototype._startTimer = function() {
	this._timer = present();
	return Promise.resolve();
};

//Called before prePlay, initialize players if true.
_Playable.prototype.checkInit = function({ initializePlayers = this.initializePlayers } = {}, result) {
	// if we get something
	if (initializePlayers) {
		// if it's just true, then reinitialize everybody
		if (initializePlayers === true) return reinitializePlayers("all", result)

		// if it's a playerList, use that
		else if (initializePlayers instanceof PlayerList) return reinitializePlayers(initializePlayers)

		// if we get a function, then run the function and check that it's returning a playerList
		else if (isFunction(initializePlayers)) {
			var list = initializePlayers()
			if (list instanceof PlayerList) return reinitializePlayers(list, result);
		}

		// otherwise, convert it to a playerList and let PlayerList deal with it.
		else return reinitializePlayers(new PlayerList(initializePlayers), result);
	}

	// if we didn't get anything or got false, we're done here.
	else return Promise.resolve(result);
};


//Called before .play() but after _startTimer
_Playable.prototype.prePlay = function({} = {}, result) {
	return Promise.resolve(result);
};

//Called after .play(), overwritable.
_Playable.prototype.postPlay = function({} = {}, result) {
	return Promise.resolve(result);
};

//Called after .postPlay() to stop timer and log.
_Playable.prototype._stopTimer = function({} = {}, result) {
	if (result.historyEntry)
		result.historyEntry.duration = present() - this._timer;
	delete this._timer;

	return Promise.resolve(result);
};

//Called after timer stops, to write log. Overwiteable if playable has specific logging behavior.
_Playable.prototype.handleHistory = function({ history = gameHistory } = {},
	result
) {
	return Promise.resolve(result).then(function(result) {
		if (result.historyEntry) history.add(result.historyEntry);
		return Promise.resolve(result);
	});
};

//Determine whether to play next, and if so, do.
_Playable.prototype.proceed = function({ shortCircuit } = {}, result) {
	var playable = this;

	return Promise.resolve(result).then(function(result) {
		//Replace reported playable with latest running playable (this is necessary for short-circuit logic)
		result.playable = playable;

		//Short-circuit logic allows higher-order playable to figure out what to do next.
		if (shortCircuit) return Promise.resolve(result);

		return playable.playNext(result);
	});
};

//Play next.
_Playable.prototype.playNext = function(result, parameters = {}) {
	var playable = this;

	return Promise.resolve(result).then(function(result) {
		//Find out where to go next
		var next = playable.findNext({ result });

		//If there's somewhere to go, then go.
		if (next[0] instanceof _Playable)
			return Promise.all(
				next.map(function(playable) {
					return playable.play(parameters);
				})
			);

		//Otherwise, we're done here
		return Promise.resolve(result);
	});
};

// Return the next playable in the sequence. Overwriteable for playables with more complicated branching.
_Playable.prototype.findNext = function() {
	return this.next;
};

_Playable.prototype._summarize = function() {};

// Summarize the game structure. Calls summaryThis and summaryNext, which are overwritable.
_Playable.prototype.summarize = function(
	summary = {},
	entries = {},
	shortCircuit = false,
	maxEntries = 10
) {
	// Start summary for this playable
	summary[this.constructor.counterName] = this.id;

	// Track how many times we've been here before, to avoid circular recursion
	entries[this.id] ? ++entries[this.id] : (entries[this.id] = 1);
	if (entries[this.id] > maxEntries) shortCircuit = true;

	// Add summary
	this.summaryThis(summary, entries);

	// Proceed to next steps
	if (!shortCircuit || shortCircuit !== this)
		this.summaryNext(summary, entries);

	return summary;
};

// Adds the summary information on this playable. Overwrite this in order to add specific information.
_Playable.prototype.summaryThis = function(summary = {}, entries = {}) {
	return summary;
};

// Adds summary information down the next-path. Overwite this for playables with more complex branching.
_Playable.prototype.summaryNext = function(summary = {}, entries = {}) {
	// If there's a next-entry
	if (this.next.length > 0) {
		// Loop over each next-item, and summarize it.
		summary.next = this.next.map(function(playable) {
			return playable.summarize({}, entries);
		});

		// If there's only one item, no need for an array.
		if (summary.next.length == 1) summary.next = summary.next[0];
	}
};


//Convoluted code here to produce the object that user interacts with (ie c1 in 'c1 = Choice()')
//This mimics creating a class that inherits from Function. First define the "prototype", which includes
//a "constructor", a "call" method that will get called, and any other properties and methods.
//Then 'classFactory' produces the class/constructing object (see below), which you can use to
//produce the actual objects.

var playablePrototype = Object.create(Function.prototype);

playablePrototype.constructor = function(_playable) {
	var playable = this;

	//Tag-back. Store the front-end object in the back-end object, for retrieval
	_playable.interface = playable;

	this.call = function(source) {
		var previousPlayable, path;

		//TODO: verify that source is the right type

		return SynchronousPromise.all([
			(function() {
				if (source instanceof Promise || source instanceof SynchronousPromise) {
					source.then(function(result) {
						previousPlayable = registry.playables[result.playable.id()];
						path = result.path;
						console.log(path);
						return SynchronousPromise.resolve();
					});
				}
				return SynchronousPromise.resolve();
			})(),
			(function() {
				if (!(source instanceof Promise || source instanceof SynchronousPromise)) {
					previousPlayable = registry.playables[source.id()];
					path = source.path;
				}

				return SynchronousPromise.resolve();
			})()
		]).then(function(result) {
			console.log(path);
			log(
				"debug",
				"Adding next playable to " +
				previousPlayable.id +
				", node " +
				_playable.id
			);

			if (path == "all") previousPlayable.addNext(_playable);
			else {
				outcomeTreeGetValue(previousPlayable.next, path).push(_playable);
			}

			log("silly", previousPlayable.next);
			//previousPlayable.next[selected].push(_choice);

			return SynchronousPromise.resolve({
				playable: playable,
				path: "all"
			});
		});
	};

	this.id = function() {
		return _playable.id;
	};

	this.play = function({
		initializePlayers = false,
		usePayoffs = true,
		shortCircuit = false,
		writeHistory =
		true,
		clearHistory = true,
		releasePlayers = true
	} = {}) {

		if (clearHistory) gameHistory.clearHistory();

		var history = writeHistory ?
			_playable.history || gameHistory :
			new History();

		return Promise.resolve()
			.then(function(result) {
				return _playable.play({ initializePlayers, usePayoffs, shortCircuit, history, releasePlayers });
			})
			.catch(function(reason) {
				console.log(reason);

				//If the game was stopped by a Halt playable or everybody's dead, we'll end up here, and things are fine. Just log it.
				if (reason.result == "Halt") {
					gameHistory.add(reason.historyEntry);
					return Promise.resolve(reason.result);
				} else if (reason.result == "Population Collapse")
					return Promise.resolve(reason.result);
				else {
					history.log.add({ error: reason });
					return Promise.reject(reason);
				}
			})
			.then(function(result) {
				//Replace result, so that user can't get access to _playables

				return Promise.resolve({
					Population: Population(),
					gameHistory
				});
			});
	};

	this.summarize = function() {
		return _playable.summarize({});
	};
};

playablePrototype.call = function() {
	//This will get overwritten when the "constructor" is called, but leaving it here so you can figure out how the hell this works.
};

playablePrototype.path = "all";

//Produces the function that will produce the end result. This part is reusable if you need to do this again.
var classFactory = function(proto) {
	return function() {
		var f = function() {
			return f.call.apply(f, arguments);
		};

		Object.defineProperty(f, "constructor", {
			configurable: true,
			writable: true
		});
		Object.defineProperty(f, "call", { writable: true });

		Object.keys(proto).forEach(function(key) {
			f[key] = proto[key];
		});

		f.constructor.apply(f, arguments);

		delete f.constructor; //Added this bit here, to prevent the user from trying to create new objects.

		return f;
	};
};

var Playable = classFactory(playablePrototype);
// called as: var instance = Playable(/* some internal object like _choice */);

module.exports = { _Playable, Playable };

},{"../helperFunctions":7,"../history":24,"../logger":26,"../population":42,"../state":43,"present":58,"synchronous-promise":62}],34:[function(require,module,exports){
"use strict";

var log = require('../logger');

//External dependency
var poisson = require('randgen').rpoisson;

//Game state controllers
var {registry, gameHistory} = require('../state');

//Helper functions
var {isFunction}	= require('../helperFunctions')("general");
var {idHandler} 	= require('../helperFunctions')("state");

//Parent class
var {_Playable, Playable} = require('./playable');

//Player controllers
var {_Player, Player} = require('../player');
var {PlayerList, UserPlayerList, gamePopulation, Population} = require('../population');

//Update this each time .play is called, but leave it available to the whole scope so that 
//growth and decay can access it
var population;

//Default growth function
var growthDefault = function growth(player, population, birthRate, selectiveMultiplier) {
	var score = player.score;
	var mean = population.scoresMean();
	var std = population.scoresStd();
	
	var Z = !(isNaN(std) || std==0) ? (score-mean)/std : 0
	
	console.log(score, mean, std,Z);
	
	var rate = birthRate + selectiveMultiplier*Z;

	var generated = poisson(rate);
	log("silly","growthDefault: generated random number " + generated.toString()+ " using rate "+ rate.toString());
	
	return generated;
}

//Default decay function
var decayDefault = function decay(player, population, deathRate, selectiveMultiplier) {
	var score = player.score;
	var mean = population.scoresMean();
	var std = population.scoresStd();
	
	console.log(score, mean, std);
	
	var Z =  !(isNaN(std)||std==0) ? (score-mean)/std : 0;
	
	console.log(Z)
	var rate = deathRate - selectiveMultiplier*Z;
	
	var generated = poisson(rate);
	log("silly","decayDefault: generated random number " + generated.toString()+ " using rate "+ rate.toString());
	return generated;
}



//Backend function class for PopulationDynamics
function _PopulationDynamics(id, birthRate,deathRate, {growthFunction=growthDefault, decayFunction=decayDefault, selectiveMultiplier= .5, playerParameters={}}={}){
	_Playable.call(this,id);
	
	var pd = this;
	
	this.birthRate = birthRate;
	this.deathRate = deathRate;
	this.selectiveMultiplier = selectiveMultiplier;
	
	//Wrap the growth and decay functions, so that the user doesn't have to worry about calling this.birthRate or this.deathRate
	this.growth = function(player){
		log("silly","_pd.growth: Checking grow condition");
		return growthFunction(player, population, pd.birthRate, pd.selectiveMultiplier)
	};
	this.decay = function(player){
		log("silly","_pd.decay: Checking decay condition");
		return decayFunction(player, population, pd.deathRate, pd.selectiveMultiplier);
	};
	
	this.playerParameters = playerParameters;
	
	registry.controllers[id] = this;
}
_PopulationDynamics.prototype = Object.create(_Playable.prototype);
_PopulationDynamics.prototype.constructor = _PopulationDynamics;

_PopulationDynamics.registryName = "controllers";
_PopulationDynamics.counterName = "populationDynamics";


_PopulationDynamics.prototype.play = function({initializePlayers=false, shortCircuit=false, history=gameHistory}={}){
	
	var pd = this;
	
	var births = 0;
	var deaths = 0;
	
	//Update population using whoever's alive currently
	population = gamePopulation().onlyAlive();
		
	
	//Kill cycle
	var killed = new PlayerList([]);
	population.forEach(function(player){
		// If the decay function is returns truthy, kill.
		
		if (pd.decay(player)) {
			log("silly","must kill...")
			player.kill();
			deaths++;
			killed.push(player);
			log("silly","dead");
		}
		
		
	});
	
	//Update update again to prevent the recently deceased from reproducing
	population = gamePopulation().onlyAlive();
	
	if (population.length == 0) {
		//Everybody's dead. Let's wrap it up.
		var reason = {result:"Population Collapse", playable:pd};
		history.end();
		return Promise.resolve(reason);
	}
	
	//Birth cycle
	var born = new UserPlayerList([]);
	population.forEach(function(player){
		//Birth whatever number is returned
		var numBirth = pd.growth(player)
		console.log(numBirth);
		for (var i=1; i<=numBirth; i++){
			log("silly", "Player " + player.id +" giving birth!");
			
			var playerParameters = Object.assign({},{
					assign:player.strategy ? player.strategy._id : "",
					parent:player.id}
				,pd.playerParameters);
			
			born.push(Player(playerParameters));
		}	
	});
	
	
	var result = {births, deaths};
	
	var resultObject = {
		result,
		'playable':pd,
		historyEntry:{
			populationDynamics:pd.id,
			result
		}
	};
	
	return Promise.resolve(resultObject);
};



function PopulationDynamics(birthRate=.05, deathRate = .05, parameters={}){
	var id = idHandler(parameters.id,"populationDynamics")
	
	if (parameters.growth && !isFunction(growth)) log("error",id + ": growth should be a function.");
	if (parameters.decay && !isFunction(decay))   log("error",id + ": decay should be a function.");
		
	//Create backend lambda object
	var _pd = new _PopulationDynamics(id, birthRate, deathRate, parameters);
	
	
	//Return this reference object to the user. Run the function to select a source
	var pd = Playable(_pd);	
	return pd;	
}


module.exports = {_PopulationDynamics, PopulationDynamics};
},{"../helperFunctions":7,"../logger":26,"../player":41,"../population":42,"../state":43,"./playable":33,"randgen":59}],35:[function(require,module,exports){
"use strict";

var log = require('../logger');
log("debug", "Loading Class: RandomPlayerChoice")

//Game state controllers
var {registry, gameHistory, occupiedPlayers} = require('../state');

//Helper functions
var {idHandler} = require('../helperFunctions')("state");
var {chainerGenerator} = require('../helperFunctions')("playable");

//Parent class
var {_Playable, Playable} = require('./playable');
var {_Choice, Choice} = require('./choice');

//Population helpers
var {PlayerList} = require('../population');


//Backend function class for RPChoice
function _RPChoice(id, options, {includePlayers, excludePlayers=new PlayerList()}){
	
	//If they specify players to draw from, use only that list. Otherwise, use whoever's around.
	this.includePlayers = includePlayers || "all";
	
	this.excludePlayers = new PlayerList(excludePlayers);
	
	this.generator = Math.random;
	
	var player = null;
	
	
	_Choice.call(this,id, player, options, {});
}

_RPChoice.prototype = Object.create(_Choice.prototype);
_RPChoice.prototype.constructor = _RPChoice;

_RPChoice.registryName = "choices";
_RPChoice.counterName = "randomPlayerChoice";



//Select the player to make the choice
_RPChoice.prototype.choosePlayer = function choosePlayer(){
	
	var rpChoice = this;
	
	return Promise.resolve().then(function(){
		
		//Find players to choose from
		var pool = new PlayerList(rpChoice.includePlayers).onlyAlive().onlyAvailable().exclude(rpChoice.excludePlayers)
		if (pool.length == 0) return Promise.reject("No available players.");
	
		log("silly", "rpChoice.choosePlayer: choosing froom pool: " + pool.ids());
	
		var randomNumber = Math.floor(rpChoice.generator()*pool.length);
		var candidate = pool[randomNumber];
	
	
		log("silly", "rpChoice.choosePlayer: selecting player ", candidate.id)
	
		rpChoice.player = candidate;
		candidate.available = false;
	
		return Promise.resolve(candidate.id);
	});
};

_RPChoice.prototype.prePlay = function(){
	return this.choosePlayer();
};


_RPChoice.prototype.summaryThis = function(summary){
	summary.options = this.options;
};



function RandomPlayerChoice(options, {id=null, excludePlayers=[], playerList=null}={}){
	var id = idHandler(id,"randomPlayerChoice")
	
	//Create backend choice object
	var _rpChoice = new _RPChoice(id, options, {playerList, excludePlayers});
	
	//Return this reference object to the user. Run the function to select a source
	var rpChoice = Playable(_rpChoice)
	
	rpChoice.playerList = function(playerList){
		if (Array.isArray(playerList)) _rpChoice.playerList = playerList;
		return 	_rpChoice.playerList 
	};
	
	rpChoice.excludePlayers = function(excludePlayers){
		if (Array.isArray(excludePlayers)) {
			_rpChoice.excludePlayers = [];
			
			excludePlayers.forEach(function(player){
				_rpChoice.excludePlayers.push(player.id());
			});
			
		}
		return 	_rpChoice.excludePlayers 
	};
	
	//Interface to specify single-player payoffs in single-player/single-choice games
	_rpChoice.zeroPayoffs();       
	
	_rpChoice.generateChainingFunctions(rpChoice);
	
	//Function to set all payoffs at once
	rpChoice.setAllPayoffs = function(payoffs){
		//TODO: make this work. Include error handling if array given isn't expected dimensions.
	};
	
	
	//Way for user to interact with payoffs
	rpChoice.payoffs = function(){return registry.choices[id].payoffs;};
	
	return rpChoice;	
}



module.exports = {_RPChoice, RandomPlayerChoice};
},{"../helperFunctions":7,"../logger":26,"../population":42,"../state":43,"./choice":28,"./playable":33}],36:[function(require,module,exports){
"use strict";

var log = require("../logger");
log("debug", "Loading Class: Sequence");

//Game state controllers
var { registry } = require("../state");
var { gameHistory } = require("../history");

//Helper functions
var { idHandler } = require("../helperFunctions")("state");

//Information
var { Information, PerfectInformation } = require("../information");

//Parent class
var { _Playable, Playable } = require("./playable");

//Backend function class for Sequence
function _Sequence(id, playableStart, playableFinish, parameters = {}) {
	_Playable.call(this, id, parameters);

	this.playableStart = registry.playables[playableStart.id()];
	this.playableFinish = registry.playables[playableFinish.id()];

	registry.sequences[id] = this;
}
_Sequence.prototype = Object.create(_Playable.prototype);
_Sequence.prototype.constructor = _Sequence;

_Sequence.registryName = "sequences";
_Sequence.counterName = "sequence";

_Sequence.prototype.play = function({
	history = gameHistory,
	information = this.information ||
	PerfectInformation
} = {}) {

	var sequence = this;

	//Log the history appropriately
	var startEntry = {
		sequence: sequence.id,
		action: "start"
	};
	history.log.add(startEntry);

	//History object to give to sequenced playables.
	var sequenceHistory = history.child();

	//compartmentalize if set. "compartmentalize" means pass on information as if this playable is the entire game.
	if (sequence.compartmentalize) {
		information = new Information(sequence.compartmentalize.history || sequenceHistory,
			sequence.compartmentalize.population || gamePopulation);
	}

	// Recursion down the chain of playables
	var action = function action(result) {
		//Stop if the game is over.
		if (history.stop) return { playable: sequence };

		//Otherwise, recurse to figure out what to do next.
		if (Array.isArray(result)) {
			log("silly", "sequence.play: Next-item is an array, splitting into pieces.");

			return Promise.all(
				result.map(function(item) {
					log("silly", "sequence.play: recursing on", item);
					return action(item);
				})
			);
		}

		if (result.playable !== sequence.playableFinish) {
			log("silly", result);

			if (result.playable.findNext({ result }).length > 0) {
				log("silly", "Playable has next-item, continuing down chain.");

				return result.playable.playNext(result, { shortCircuit: true, history: sequenceHistory, information })
					.then(action); //Repeat for next playable in chain
			}
			return Promise.resolve(result);
		}
		return Promise.resolve(result);
	};

	return sequence.playableStart
		.play({ shortCircuit: true, history: sequenceHistory, information })
		.then(action)
		.then(function(result) {
			result.historyEntry = {
				sequence: sequence.id,
				action: sequenceHistory.orphan()
			};

			//TODO: add information mechanisms

			return Promise.resolve(result);
		});
};

//Overwrite history handler so that tree doesn't have "start" and "finish" entries.
_Sequence.prototype.handleHistory = function({ history = gameHistory } = {},
	result
) {
	var sequence = this;

	return Promise.resolve(result).then(function(result) {
		history.log.add({
			sequence: sequence.id,
			action: "finish",
			duration: result.historyEntry.duration
		});

		history.addNoLog(result.historyEntry);
		return Promise.resolve(result);
	});
};

//TODO: finish this!
_Sequence.prototype.summaryThis = function(summary, entries, shortCircuit) {
	summary.action = {};

	this.playableStart.summarize(
		summary.action,
		entries,
		(shortCircuit = this.playableFinish)
	);
};

function Sequence(playableStart, playableFinish, parameters = {}) {
	var id = idHandler(parameters.id, "sequence");

	//Create backend loop object
	var _sequence = new _Sequence(id, playableStart, playableFinish, parameters);

	//Return this reference object to the user. Run the function to select a source
	var sequence = Playable(_sequence);
	return sequence;
}

module.exports = { _Sequence, Sequence };

},{"../helperFunctions":7,"../history":24,"../information":25,"../logger":26,"../state":43,"./playable":33}],37:[function(require,module,exports){
"use strict";

var log = require('../logger');

//Helper functions
var { isObject } = require('../helperFunctions')("general");
var { idHandler } = require('../helperFunctions')("state");

//Parent class
var { _Playable, Playable } = require('./playable');

// Information mechanics
var { Information, PerfectInformation } = require('../information');


//Backend class
function _Simultaneous(id, playableArray, { playableParameters = {} } = {}) {
	_Playable.call(this, id);

	this.playableArray = playableArray;
	this.playableParameters = playableParameters;

	registry.controllers[id] = this;
}

_Simultaneous.prototype = Object.create(_Playable.prototype);
_Simultaneous.prototype.constructor = _Simultaneous;

_Simultaneous.registryName = "controllers";
_Simultaneous.counterName = "simultaneous";


//Simultaneous Promise.all's the playables, which causes them to run meshed.
_Simultaneous.prototype.play = function({ history = gameHistory, information = PerfectInformation } = {}) {

	var simultaneous = this;

	// Deal with history. Log start, then split history for children playables to fill in.
	history.log.add({
		simultaneous: simultaneous.id,
		action: "Simultaneous start."
	});
	var simultaneousHistory = []



	//TODO: is information mechanics correct?

	return Promise.all(simultaneous.playableArray.map(function(playable) {
		var branchHistory = history.childWithContent();
		simultaneousHistory.push(branchHistory)

		// Information mechanics
		//compartmentalize if set. "compartmentalize" means pass on information as if this playable is the entire game.
		if (simultaneous.compartmentalize) {
			information = new Information(simultaneous.compartmentalize.history || branchHistory,
				simultaneous.compartmentalize.population || gamePopulation);
		}

		var simultaneousInformation = information.child();

		return playable.play({ history: simultaneousHistory, information: simultaneousInformation });
	})).then(function(resultArray) {

		var resultObject = {
			resultArray,
			playable: simultaneous,
			historyEntry: {
				simultaneous: simultaneous.id,
				action: simultaneousHistory.map(function(history) {
					return history.orphan();
				})
			}
		};
		return resultObject;
	});
};


_Simultaneous.prototype.handleHistory = function({ history = gameHistory } = {}, result) {

	history.log.add({
		simultaneous: this.id,
		action: "Simultaneous complete."
	});

	history.addNoLog(result.historyEntry);

	return Promise.resolve(result);
};

_Simultaneous.prototype.summaryThis = function(summary, entries) {
	summary.action = [];

	this.playableArray.forEach(function(playable, index) {
		summary.action[index] = {}
		playable.summarize(summary.action[index], entries);
	});
}


//Frontend class
function Simultaneous(playableArray, parameters = {}) {
	var id = idHandler(parameters.id, "simultaneous")

	playableArray = playableArray.map(function(playable) {
		return registry.playables[playable.id()];
	});


	//Create backend instance.
	var _simultaneous = new _Simultaneous(id, playableArray, parameters);

	//Return this reference object to the user. Run the function to select a source
	var simultaneous = Playable(_simultaneous);
	return simultaneous;
}


module.exports = { _Simultaneous, Simultaneous };

},{"../helperFunctions":7,"../information":25,"../logger":26,"./playable":33}],38:[function(require,module,exports){
"use strict";

var log = require('../logger');
log("debug", "Loading Class: Stochastic-Halt")

//Game state controllers
var {registry, gameHistory} = require('../state');

//Helper functions
var {isFunction}	= require('../helperFunctions')("general");
var {idHandler} 	= require('../helperFunctions')("state");

//Parent class
var {_Playable, Playable} 	= require('./playable');
var {_Halt, Halt}			= require('./halt-if');


//Backend function class for SHalt
function _SHalt(id, probability, parameters){
	_Halt.call(this,id,null,parameters);
	
	var sHalt = this;
	
	this.probability = probability;
	this.generator = Math.random;				//TODO: allow user to specify random number generator
	
	this.testCondition = function(){
		if (sHalt.generator() < sHalt.probability) return true;
	};
	
	
	registry.sHalts[id] = this;
}
_SHalt.prototype = Object.create(_Halt.prototype);
_SHalt.prototype.constructor = _SHalt;

_SHalt.registryName = "sHalts";
_SHalt.counterName = "stochasticHalt";

/*
_SHalt.prototype.play = function({initializePlayers=false, shortCircuit=false}={}){
	
	var sHalt = this;
	var test = sHalt.testCondition();
	
	if (test) {
		log("info", "Halting at " + sHalt.id)
		
		return Promise.reject({
			result:"Halt",
			playable:sHalt
		});
	}
	
	var resultObject = {
		'result':"Continued",
		'playable':sHalt
	};
	
	return Promise.resolve(resultObject)
	.then(function(result){	
		
		//TODO: add information mechanisms
		
		return Promise.resolve(result)		
	}).then(function(result){
		
		return sHalt.proceed(result, shortCircuit);
	});
};
*/

_SHalt.prototype.summaryThis = function(summary, entries){
	summary.probability = this.probability;
}


function StochasticHalt(probability, {id=null, logContinue=false}={}){
	var id = idHandler(id,"stochasticHalt")
	
	if (isNaN(probability) || probability < 0 || probability > 1) throw new Error('Invalid probability');

	//Create backend sHalt objects
	var _sHalt = new _SHalt(id, probability, {logContinue});
	
	
	//Return this reference object to the user. Run the function to select a source
	var sHalt = Playable(_sHalt);	
	return sHalt;	
}


module.exports = {_SHalt, StochasticHalt};
},{"../helperFunctions":7,"../logger":26,"../state":43,"./halt-if":29,"./playable":33}],39:[function(require,module,exports){
"use strict";

var log = require('../logger');
log("debug", "Loading Class: StochasticLoop")

//Game state controllers
var {registry, gameHistory} = require('../state');

//Helper functions
var {idHandler} 		= require('../helperFunctions')("state");
var {chainerGenerator} 	= require('../helperFunctions')("playable");

//Parent classes
var {_Playable,Playable} = require('./playable');
var {_Loop, Loop} 		 = require('./loop');


//Backend function class for StochasticLoop
function _SLoop(id, playable, probability, parameters){
	_Loop.call(this,id, playable, null, parameters);
	
	this.playable = registry.playables[playable.id()];
	
	//This inherits from Loop which uses a count. Delete that and replace with probability.
	delete this.count;			
	this.probability = probability;						
	
	this.generator = Math.random;				//TODO: allow user to specify random number generator
	
	registry.sLoops[id] = this;
}
_SLoop.prototype = Object.create(_Loop.prototype);
_SLoop.prototype.constructor = _SLoop;

_SLoop.registryName = "sLoops";
_SLoop.counterName = "stochasticLoop";


_SLoop.prototype.play = function({initializePlayers=false, shortCircuit=false, history=gameHistory}={}){
	
	var sLoop = this;
	sLoop.counter = 0;
	var loopHistory = history.child();
	
	var promise = Promise.resolve({});
	
	//Section that will be looped
	var action = function(result){
		
		sLoop.counter++;
		if (!result) result = {};
		
		
		//Deal with history
		history.log.add({
			loop:sLoop.id,
			loopTo:sLoop.playable.id,
			count:sLoop.counter
		});
		
		return sLoop.playable.play({shortCircuit:true, history:loopHistory})
		.then(function(result){
		
			result.playable = sLoop;
			//TODO: add information mechanisms
		
			return Promise.resolve(result)		
		});
	};
	
	
	//Generate random numbers, repeat while number is above halting probability
	while (sLoop.generator() > sLoop.probability) {
		promise = promise.then(action);
	}
	
	
	return promise.then(function(result){
		
		result.historyEntry = {
			loop:sLoop.id,
			count:sLoop.counter,
			action:loopHistory.orphan()
		};
	
		return Promise.resolve(result);
	});
};

_SLoop.prototype.summaryThis = function(summary, entries){
	summary.probability = this.probability;
	
	summary.action = {}
	this.playable.summarize(summary.action, entries, true)
}


//User interface
function StochasticLoop(playable, probability=.5, parameters={}){
	var id = idHandler(parameters.id,"stochasticLoop")
	
	if (isNaN(probability) || probability < 0 || probability > 1) throw new Error('Invalid probability');
	
	//Create backend sLoop object
	var _sLoop = new _SLoop(id, playable, probability, parameters);
	
	
	//Return this reference object to the user. Run the function to select a source
	var sLoop = Playable(_sLoop);
	return sLoop;	
}



module.exports = {_SLoop, StochasticLoop};
},{"../helperFunctions":7,"../logger":26,"../state":43,"./loop":32,"./playable":33}],40:[function(require,module,exports){
"use strict";

var log = require("../logger");
log("debug", "Loading Class: Turn");

//External dependency
var { SynchronousPromise } = require("synchronous-promise");

//Helper functions
var { isObject, once } = require("../helperFunctions")("general");
var { chainerGenerator, outcomeTreeGetValue, outcomeTreeSetValue } = require("../helperFunctions")("playable");
var { recurse } = require("../helperFunctions")("turn");
var { idHandler } = require("../helperFunctions")("state");

//Game state controllers
var { registry } = require("../state");
var { gameHistory } = require("../history");
var { Information, PerfectInformation } = require("../information");

//Parent class
var { _Playable, Playable } = require("./playable");

//Backend function class for Turn
function _Turn(id, choices, parameters = {}) {
	_Playable.call(this, id);

	this.payoffsImplicit = {};
	this.payoffsExplicit = {};

	this.next = {};

	this.choices = choices.map(function(choice) {
		return registry.choices[choice.id()];
	});

	registry.turns[id] = this;

	var turn = this;

	this.choiceMap = this.choices.map(function(item) {
		return item.options;
	});

	recurse(turn.choiceMap, turn.payoffsImplicit, null, function() {
			return Array(turn.choiceMap.length).fill(0);
		})
		.then(function(result) {
			log("silly", "Added implicit payoffs map to turn.");
			return recurse(turn.choiceMap, turn.payoffsExplicit, {});
		})
		.then(function(result) {
			log("silly", "Added explicit payoffs map to turn.");
			return recurse(turn.choiceMap, turn.next, null, function() {
				return [];
			});
		})
		.then(function(result) {
			log("silly", "Added blank next map to turn.");
			return Promise.resolve(result);
		})
		.catch(function(reason) {
			log("error", reason);
		}); //TODO: error handling here
}
_Turn.prototype = Object.create(_Playable.prototype);
_Turn.prototype.constructor = _Turn;

_Turn.registryName = "turns";
_Turn.counterName = "turn";


_Turn.prototype.play = function({
	usePayoffs = true,
	history = gameHistory,
	information = PerfectInformation,
	releasePlayers = true
} = {}) {

	var turn = this;
	var choiceHistory = history.child();
	var choiceInformation = information.child();

	history.log.add({
		turn: turn.id,
		choices: turn.choices.map(function(choice) {
			return choice.id;
		})
	});

	var compileInformation = function(ri) {
		//If there's no turn entry, create one.
		if (!choiceInformation.additional[0].turn) {
			var turnInfo = {
				turn: {
					id: turn.id,
					choices: [],
					exclude: function(player) {
						return this.choices.filter(function(choice) {
							return choice.player == player;
						});
					}
				}
			};
			choiceInformation.additional.unshift(turnInfo);
		}
		choiceInformation.additional[0].turn.choices.push(
			choiceInformation.additional.pop()
		);

		information.additional.forEach(
			choiceInformation.addAdditional.bind(choiceInformation)
		);
	};

	return Promise.all(
			turn.choices.map(function(choice) {
				return choice.play({
					shortCircuit: true,
					history: choiceHistory,
					information: choiceInformation,
					_compileInformation: compileInformation,
					releasePlayers: false
				});
			})
		)
		.then(function(result) {
			//Re-format output from array of Choice results to single Turn result
			//And release players
			var resultPath = result.map(function(choice, index) {
				if (releasePlayers) turn.choices[index].releasePlayer();
				return choice.result;
			});

			//Pass along results and record history
			var resultObject = {
				result: resultPath,
				playable: turn,
				historyEntry: {
					turn: turn.id,
					results: choiceHistory.orphan(),
					payouts: {}
				}
			};

			return Promise.resolve(resultObject);
		})
		.then(function(result) {
			//Implement payoffs
			if (usePayoffs) {
				var implicitPayoffs = outcomeTreeGetValue(
					turn.payoffsImplicit,
					result.result
				);
				var explicitPayoffs = outcomeTreeGetValue(
					turn.payoffsExplicit,
					result.result
				);

				// For the log
				var payouts = {};

				implicitPayoffs.forEach(function(payoff, index) {
					// Do nothing if payoff is zero.
					if (payoff == 0) return;

					// fetch player and increment score
					var player = turn.choices[index].player;
					player.score += payoff;

					//And include it in the log entry
					payouts[player.id] = Number(payoff);
				});

				for (var player in explicitPayoffs) {
					registry.players[player].score += explicitPayoffs[player];

					//And include it in the log entry
					payouts[player] = Number(explicitPayoffs[player]);
				}

				//Log for the scores log
				var scoreEntry = {
					turn: turn.id,
					result: result.result,
					payouts: payouts
				};
				history.addScores(scoreEntry);


				// Log for the game history
				result.historyEntry.payouts = payouts;
			}

			return Promise.resolve(result); //TODO: add information mechanisms
		});
};

//Overwrite default history handler, because we don't want a second entry in the tree
_Turn.prototype.handleHistory = function({ history = gameHistory } = {},
	result
) {
	history.addNoLog(result.historyEntry);

	return Promise.resolve(result);
};

_Turn.prototype.findNext = function({ result } = {}) {
	return outcomeTreeGetValue(this.next, result.result);
};

_Turn.prototype.generateChainingFunctions = function() {
	var _turn = this;
	var turn = _turn.interface;

	//Create payoff setter/branch router functions.
	//recurse adds a wrapper around this function which supplies the path.
	recurse(_turn.choiceMap, turn, function(path, payoffs) {
		//If user supplied payoffs in array form, then translate to object based on which players are involved in the choices
		if (Array.isArray(payoffs)) {
			if (payoffs.length !== _turn.choices.length) {
				//If array isn't right length, then this is unintelligible.
				log(
					"error",
					"Payoff array does not match Turn dimensions, cannot assign payoffs."
				);
				return Promise.reject(new Error("Payoff array is not correct length"));
			}

			var originalPayoffs = payoffs.slice();
			payoffs = {};

			outcomeTreeSetValue(_turn.payoffsImplicit, path, originalPayoffs);
		} else if (isObject(payoffs)) {
			payoffs = JSON.parse(JSON.stringify(payoffs));
			outcomeTreeSetValue(_turn.payoffsExplicit, path, payoffs);
		}

		return SynchronousPromise.resolve({
			playable: turn,
			path: path
		});
	});
};

_Turn.prototype.setAllPayoffs = function(payoffArray) {
	var turn = this;

	//Recurse through the options in input, to come up with a path to every combination of options in the array of arrays.
	function recurse(input, numPlayers, payoffs, path = [], coordinates = []) {
		return SynchronousPromise.resolve(path).then(function(path) {
			//Since we slice the array each time, if there are no more entries left then we're done with this branch.
			if (input.length == 0) return SynchronousPromise.resolve(path);

			//Among all values from the array
			return SynchronousPromise.all(
				input[0].map(function(item, index) {
					var splitPath = path.slice(0).concat(item);
					var splitCoordinates = coordinates.slice(0).concat(index);
					var splitPayoffs = payoffs[index];

					//If we're at the last position in the array of options, then we have a complete path.
					if (input.length == 1) {
						/* you might need these later
					console.log("path ", splitPath);
					console.log("coordinates ", splitCoordinates)
					console.log("payoff ",splitPayoffs)
					*/

						splitPayoffs = JSON.parse(JSON.stringify(splitPayoffs));

						//Allow the first few array elements to be implicit payoffs. Check that they are actually there and are numbers
						var implicit = splitPayoffs.slice(0, numPlayers);
						if (
							implicit.length == numPlayers &&
							implicit.every(function(payoff) {
								return !isNaN(payoff);
							})
						) {
							outcomeTreeSetValue(turn.payoffsImplicit, splitPath, implicit);
						}

						//Any remaining should be assigned as explicit payoffs, if they're objects.
						splitPayoffs.slice(numPlayers).forEach(function(explicit) {
							if (isObject(explicit))
								outcomeTreeSetValue(turn.payoffsExplicit, splitPath, explicit);
						});
					}

					//If there are more items to iterate over, include them in the output then recurse.
					return recurse(
						input.slice(1),
						numPlayers,
						splitPayoffs,
						splitPath,
						splitCoordinates
					);
				})
			);
		});
	}

	return recurse(turn.choiceMap, turn.choices.length, payoffArray).catch(
		function(reason) {
			log("error", reason);
		}
	);
};

// Adding more complicated summary entry
_Turn.prototype.summaryThis = function(summary, entries, shortCircuit = false) {
	// Fetch summaries for each choice.
	summary.choices = [];
	this.choices.forEach(function(choice, index) {
		summary.choices[index] = choice.summarize(
			summary.choices[index],
			entries,
			true
		);
	});

	// Include payoffs
	summary.payoffs = JSON.parse(
		JSON.stringify({
			implicit: this.payoffsImplicit,
			explicit: this.payoffsExplicit
		})
	);

	return summary;
};

//
_Turn.prototype.summaryNext = function(summary, entries) {
	var turn = this;

	// Create map
	summary.next = {};
	var count = 0;
	recurse(this.choiceMap, summary.next, null, function(path) {
		return outcomeTreeGetValue(turn.next, path).map(function(playable) {
			++count;
			return playable.summarize();
		});
	});

	// If there is no next, delete the key.
	if (count == 0) delete summary.next;
};

function Turn(choices, parameters = {}) {
	var id = idHandler(parameters.id, "turn");

	//Create backend choice object
	var _turn = new _Turn(id, choices, parameters);

	//Return this reference object to the user. Run the function to select a source
	var turn = Playable(_turn);

	_turn.generateChainingFunctions();

	//Function to set all payoffs at once
	turn.setAllPayoffs = function(payoffs) {
		//TODO: Include error handling if array given isn't expected dimensions.
		_turn.setAllPayoffs(payoffs);
	};

	//Way for user to interact with payoffs
	turn.payoffs = function() {
		return JSON.parse(
			JSON.stringify({
				implicit: _turn.payoffsImplicit,
				explicit: _turn.payoffsExplicit
			})
		);
	};

	// Returns the payoffs in nested array form, to make cloning easier, ie. t2.setAllPayoffs(t1.payoffsMatrix())
	turn.payoffsMatrix = function() {

		// recursion to construct payoff matrix
		var mapper = function(obj, path = []) {
			//If it's an array, then we've reached the payoffs
			if (Array.isArray(obj)) {
				var payoff = obj.slice(0)
				// Add explicit payoffs too
				var explicit = outcomeTreeGetValue(_turn.payoffsExplicit, path);

				// Only add an entry if the explicit payoffs object is not empty
				return Object.keys(explicit).length > 0 ? payoff.concat([outcomeTreeGetValue(_turn.payoffsExplicit,
					path)]) : payoff
			}

			// Otherwise, dig in deeper
			else return Object.keys(obj).map(function(key) { return mapper(obj[key], path.slice(0).concat([key])) })
		}
		return mapper(_turn.payoffsImplicit)
	}

	return turn;
}

module.exports = { _Turn, Turn };

},{"../helperFunctions":7,"../history":24,"../information":25,"../logger":26,"../state":43,"./playable":33,"synchronous-promise":62}],41:[function(require,module,exports){
"use strict";

var log = require('./logger');

//Game state controllers
var { registry } = require('./state');

//Helper functions
var { idHandler } = require('./helperFunctions')("state");
var { chainerGenerator } = require('./helperFunctions')("playable");

var { UserHistory } = require('./history');

//Backend for Player
function _Player(id, { name = "", assign = null } = {}) {
	log('silly', 'Creating interal player object.');

	this.id = id
	this.score = 0
	this.name = name;

	this.history = [];

	if (assign) this.assign(assign);

	this.alive = true;
	this.available = true;

	registry.players[id] = this;
}


//Make a copy of the player, in order to take a snapshot. ////TODO try this again sometime.
/*
_Player.prototype.clone = function(){
	//Make new copy. Don't keep more than one.
	delete this.copy

	var clone = new _Player(this.id);

	//Loop through properties and assign them.
	for (var key in this){
		clone[key] = this[key];
	}
	//Do not add to registry. This will keep duplicates out of population.

	//Do add reference so we can find it again.
	this.copy = clone;

	return clone;
};
*/


//Assign strategy to player
_Player.prototype.assign = function(strategy) {

	//TODO: verify strategy type
	if (registry.strategies[strategy]) {
		this.strategy = new registry.strategies[strategy];
		this.strategy._id = strategy
	} else throw new Error("Strategy '" + strategy + "' is not defined");
};


//Call strategy to make a choice
_Player.prototype.choose = function(options, information = {}) { //TODO: check that there's a strategy assigned before trying to play
	var player = this;
	if (player.strategy)
		return Promise.resolve(player.strategy.choose(options, information).toString());
	else
		log("warning", "No strategy assigned to player " + player.id + ". Using default option.");
	return Promise.resolve(null);
};


//Takes a JSON.parse(JSON.stringify()) copy of _player. Returns a cleaned up version
_Player.prototype.infoClean = function(infoObject) {
	delete infoObject.interface;
	infoObject.strategy = infoObject.strategy._id;

	return infoObject;
};


//Kill player. TODO: add player to some sort of "dead" list to avoid being picked to do things.
_Player.prototype.kill = function() {
	this.alive = false;
};



//Class that is the reference for the user to hold onto
function player() {}


//Frontend for Player
function Player(parameters = {}) {
	var id = idHandler(parameters.id, "player");

	//Create backend player object
	var _player = new _Player(id, parameters);


	//Return this reference object to the user
	var playerInterface = new player(); //Probably add functionality here

	//Tag-back. Store the front-end object in the back-end object, for retrieval
	_player.interface = playerInterface;

	playerInterface.alive = function() {
		return _player.alive;
	}

	playerInterface.assign = function(strategy) {
		_player.assign(strategy);
	};

	playerInterface.available = function() {
		return _player.available
	};

	playerInterface.busy = function() {
		_player.available = false;
	};

	playerInterface.history = function() {
		return new UserHistory(_player.history);
	};

	playerInterface.id = function() { return id; };

	playerInterface.kill = function() {
		_player.kill();
	}

	playerInterface.release = function() {
		_player.available = true;
	};

	playerInterface.resetScore = function() {
		_player.score = 0;
	}

	playerInterface.score = function() {
		return registry.players[id].score;
	};

	playerInterface.strategy = function() {
		return _player.strategy._id;
	};


	return playerInterface
}




module.exports = { _Player, Player };

},{"./helperFunctions":7,"./history":24,"./logger":26,"./state":43}],42:[function(require,module,exports){
"use strict";

var log = require("./logger");

//Helper functions
var { isFunction, isObject } = require("./helperFunctions")("general");

//Game state controllers
var { registry } = require("./state");

var { _Player } = require("./player");

//Class PlayerList is a list of players which includes some extra functionality. UserPlayerList takes a playerList and
//sanitizes it for the user (ie returns .interface for each player).

function PlayerList(...args) {
	if (Array.isArray(args[0])) args = args[0].slice(0);
	if (args == "all") return gamePopulation();

	// We'll need to retain the original arguments in order to create the generator
	var originalArgs = []

	// Loop over the arguments, save the originals, parse them to _players
	for (var i = 0, len = args.length; i < len; i++) {
		originalArgs.push(args[i]);
		if (isFunction(args[i].id)) args[i] = registry.players[args[i].id()];
		else if (typeof args[i] === 'string') args[i] = registry.players[args[i]]
	}

	Object.setPrototypeOf(args, PlayerList.prototype);

	// returns the same playerlist, but updated, using the original args.
	args.generator = function() {
		return new PlayerList(originalArgs);
	};

	return args;
}

PlayerList.prototype = Object.create(Array.prototype);
PlayerList.prototype.constructor = PlayerList;

//Return a playerList with only the players who are available
PlayerList.prototype.onlyAlive = function() {
	return new PlayerList(
		this.filter(function(player) {
			return player.alive;
		})
	);
};

//Return a playerList with only the players who are available
PlayerList.prototype.onlyAvailable = function() {
	return new PlayerList(
		this.filter(function(player) {
			return player.available;
		})
	);
};

//Kill all players in the playerList
PlayerList.prototype.kill = function() {
	this.forEach(function(player) {
		player.kill();
	});
};

PlayerList.prototype.release = function() {
	this.forEach(function(player) {
		player.available = true;
	});
};

//Return array of ids of each player in the list
PlayerList.prototype.ids = function() {
	return this.map(function(player) {
		return player.id;
	});
};

//Return a PlayerList minus the specified players.
//Argument can be _player, interface, or a player's id.
PlayerList.prototype.exclude = function(playerArg) {
	if (Array.isArray(playerArg))
		return playerArg.reduce(function(running, item) {
			return running.exclude(item);
		}, this);

	return new PlayerList(
		this.filter(function(player) {
			if (
				playerArg === player ||
				playerArg == player.interface ||
				playerArg == player.id ||
				(isObject(playerArg) && playerArg.id == player.id)
			)
				return false;
			else return true;
		})
	);
};

//Create an InfoPlayerList out of this PlayerList. Useful for getting summary view.
PlayerList.prototype.info = function() {
	return new InfoPlayerList(this);
};

// Placeholder for generator method.
PlayerList.prototype.generator = function() {
	// This will get shadowed when the constructor is called, but it needs to be here so that the
	// UserPlayerList and InfoPlayerList constructors can see it.
}

//Return an array of the strategy of each player in the list
PlayerList.prototype.strategies = function() {
	return this.map(function(player) {
		return player.strategy ? player.strategy._id : "";
	});
};

//Return a PlayerList with only players using a given strategy
PlayerList.prototype.usingStrategy = function(strategy) {
	return new PlayerList(
		this.filter(function(player) {
			if (
				player.strategy == strategy ||
				player.strategy._id == strategy ||
				(isFunction(strategy) && player.strategy instanceof strategy)
			)
				return true;
			else return false;
		})
	);
};

/*

TODO figure out how to make this work

//Returns an object where the keys are strategy names and the values are arrays of players.
//This needs to be overridden on the UserPlayerList prototype, because the normal wrapper logic
//for UserPlayerList cannot sanitize this.
PlayerList.prototype.byStrategy = function(){
	var list = this;
	var data = {};

	Object.keys(registry.strategies).forEach(function(strategy){
		data[strategy] = list.usingStrategy(strategy);
	});

	return data;
};
*/

//Returns an object where the keys are each strategy and the values
//are the number of players in the list who are using it.
PlayerList.prototype.strategyDistribution = function() {
	var counts = {};

	this.forEach(function(player) {
		var s = player.strategy._id;
		counts[s] = (counts[s] || 0) + 1;
	});

	return counts;
};

//Returns an array of scores of each player in the list
PlayerList.prototype.scores = function() {
	var scores = [];

	this.forEach(function(player) {
		scores.push(player.score); //Use the interface function to avoid users re-assigning the reference
	});
	return scores;
};

// Returns an object where each key is a strategy and each value is an array of the scores of players with that strategy.
// TODO: finish .total() method, which will sum the arrays (duplicating .scoresByStrategyTotals)
PlayerList.prototype.scoresByStrategy = function() {
	var scores = {};
	var list = this;

	list.strategies().map(function(strategy) {
		scores[strategy] = list.usingStrategy(strategy).scores();
	});

	scores.total = function() {
		var score = {};
		var scores = this;
		Object.keys(scores).forEach(function(strategy) {
			if (Array.isArray(scores[strategy])) score[strategy] = scores[strategy].reduce(function(a, b) {
				return a + b;
			}, 0);
		});
		return score;
	};

	return scores;
};

// Returns an object where each key is a strategy and each value is the sum of scores of all players with that value
PlayerList.prototype.scoresByStrategyTotals = function() {
	var scores = {};
	var list = this;

	list.strategies().map(function(strategy) {
		scores[strategy] = list
			.usingStrategy(strategy)
			.scores()
			.reduce(function(a, b) {
				return a + b;
			}, 0);
	});

	return scores;
};

//Returns an object where the keys are the player ids and the values
//are the players' score
PlayerList.prototype.scoresObject = function() {
	var scores = {};

	this.forEach(function(player) {
		scores[player.id] = player.score;
	});

	return scores;
};

//Mean of the scores
PlayerList.prototype.scoresMean = function() {
	var scores = this.scores();

	var mean =
		scores.reduce(function(sum, value) {
			return sum + value;
		}, 0) / scores.length;

	return mean;
};

//Array with 2 entries, the lowest and highest score
PlayerList.prototype.scoresRange = function() {
	var scores = this.scores();

	scores.sort(function(a, b) {
		return a - b;
	});

	return [scores[0], scores[scores.length - 1]];
};

//The standard deviation of the scores
PlayerList.prototype.scoresStd = function() {
	var scores = this.scores();
	var mean = this.scoresMean();

	var variance =
		scores.reduce(function(sum, value) {
			return sum + Math.pow(value - mean, 2);
		}, 0) / scores.length;

	var std = Math.sqrt(variance);

	return std;
};

//Returns the single player with the highest score
PlayerList.prototype.leader = function() {
	var players = this.slice();

	players.sort(function(a, b) {
		return b.score - a.score;
	});

	return players[0];
};

PlayerList.prototype.resetScores = function() {
	this.forEach(function(player) {
		player.score = 0;
	});
};

//Accept a PlayerList and return one suitable for the user, or create a playerlist and return one suitable for the user
function UserPlayerList(...playerList) {
	if (Array.isArray(playerList[0])) playerList = playerList[0];

	// If we've got a playerList, return the interface of each player
	if (playerList instanceof PlayerList) {
		var userPlayerList = playerList.map(function(player) {
			return player.interface;
		});
	}
	// If not, first create a playerList, then call this function again to wrap it.
	else return new UserPlayerList(new PlayerList(playerList));

	Object.setPrototypeOf(userPlayerList, UserPlayerList.prototype);

	//Attach methods from PlayerList, wrapped in a function. If those methods return a playerList,
	//then the function will convert that to a UserPlayerList.
	for (var method in PlayerList.prototype) {
		if (isFunction(playerList[method])) {
			if (method != "constructor")
				userPlayerList[method] = (function(method) {
					return function() {
						var result = playerList[method].apply(playerList, arguments);
						if (result instanceof PlayerList) return new UserPlayerList(result);
						else if (result instanceof _Player) return result.interface;
						else return result;
					};
				})(method);
		}
	}

	return userPlayerList;
}

UserPlayerList.prototype = Object.create(PlayerList.prototype);
UserPlayerList.prototype.constructor = UserPlayerList;

//Accept a PlayerList and return one suitable for a strategy information set.
function InfoPlayerList(playerList) {
	var infoPlayerList = playerList.map(function(player) {
		return player.infoClean(JSON.parse(JSON.stringify(player)));
	});

	Object.setPrototypeOf(infoPlayerList, InfoPlayerList.prototype);

	//Attach selected methods from PlayerList, wrapped in a function. If those methods return a playerList,
	//then the function will convert that to an InfoPlayerList.
	var methodsToInclude = [
		"onlyAlive",
		"onlyAvailable",
		"ids",
		"exclude",
		"generator",
		"strategies",
		"usingStrategy",
		"strategyDistribution",
		"scores",
		"scoresObject",
		"scoresMean",
		"scoresRange",
		"scoresStd",
		"leader"
	];

	for (var method in PlayerList.prototype) {
		if (isFunction(playerList[method])) {
			if (methodsToInclude.indexOf(method) > -1)
				infoPlayerList[method] = (function(method) {
					return function() {
						var result = playerList[method].apply(playerList, arguments);
						if (result instanceof PlayerList) return new InfoPlayerList(result);
						else if (result instanceof _Player)
							return result.infoClean(JSON.parse(JSON.stringify(result)));
						else return result;
					};
				})(method);
		}
	}

	return infoPlayerList;
}

InfoPlayerList.prototype = Object.create(Array.prototype);
InfoPlayerList.prototype.constructor = InfoPlayerList;

//Extra method to return a single player from an infoPlayerList
InfoPlayerList.prototype.get = function(playerID) {
	return this.find(function(player) {
		return player.id == playerID;
	});
};

//Generates a PlayerList containing all players.
var gamePopulation = function() {
	var population = [];

	for (var player in registry.players) {
		population.push(registry.players[player]);
	}

	return new PlayerList(population);
};

//Does the same, but a UserPlayerList
var Population = function() {
	return new UserPlayerList(gamePopulation());
};

//Does the same, but an InfoPlayerList
var InfoPopulation = function() {
	return new InfoPlayerList(gamePopulation());
};

//A short-hand to return total population size without creating a PlayerList
Population.size = function() {
	return Object.keys(registry.players).length;
};

module.exports = {
	PlayerList,
	UserPlayerList,
	InfoPlayerList,
	gamePopulation,
	Population,
	InfoPopulation
};

},{"./helperFunctions":7,"./logger":26,"./player":41,"./state":43}],43:[function(require,module,exports){
"use strict";

var log = require('./logger');

log("debug", "state: Creating game state variables.")


var registry = {}
registry._addType_ = function(type){	
	registry[type] = {};
	log("silly", "state: adding registry entry: ", type)
};


var idCounters = {}
idCounters._addType_ = function(type){
	idCounters[type] = 0
	log("silly", "state: adding counter entry: ", type)
};





module.exports = {registry, idCounters};
},{"./logger":26}],44:[function(require,module,exports){
"use strict";

const nashName = "./core";						//Change this when published, probably to 'nash-js'

var fs = require("fs");
var compiler = require('expression-sandbox');

var {registerStrategy} = require('./strategy');

//Check to see if parsed expression is call to require or eval
function isBannedCall(node) {
	return (node.type === 'CallExpression') &&
		(node.callee.type === 'MemberExpression') &&
		(node.callee.object.type === 'Identifier') &&
		((node.callee.object.name === 'require') || (node.callee.object.name === 'eval'));
}


function removeCalls(source) {
		const entries = [];
		esprima.parseScript(source, {}, function (node, meta) {
			if (isBannedCall(node)) {
				entries.push({
					start: meta.start.offset,
					end: meta.end.offset
				});
			}
		});
		entries.sort((a, b) => { return b.end - a.end }).forEach(n => {
			source = source.slice(0, n.start) +" null; " + source.slice(n.end);
		});
		return source;
	}


	
var loadStrategy = function(filepath, trusted=false){
	var source = fs.readFileSync(filepath);
	
	if (!trusted) {
		var originalSource = source;
		var parsedSource = removeCalls(source);
	
		if (originalSource != parsedSource) throw new Error("Strategy " + filepath + " uses require or eval.");
	}
	
	source = "\"use strict\"; \n " + source;
	compiler(source)(registerStrategy);
};					//TODO: change this so that strategies can't require any modules.



function loadStrategyFolder(path="./strategies"){
	var files = fs.readdirSync(path);
	var strategies = {}
	files.forEach(function(file){
		var filePath = path + '/' + file;
		requireFunction(filepath);
	});
};


module.exports = {loadStrategy, loadStrategyFolder};
},{"./strategy":45,"expression-sandbox":52,"fs":1}],45:[function(require,module,exports){
"use strict";

var log = require('./logger');

//Javascript code parser
var esprima = require('esprima');

//Game state controllers
var {registry} = require('./state');

//Helper functions
var {idHandler} = require('./helperFunctions')("state");



//User interface to declare strategy type.
function registerStrategy(strategy, name, playername = ""){
	var id = idHandler(name,"strategy");
	
	log("debug", "Loading strategy '" + id + "'")
	registry.strategies[id] = strategy;
}

//Strip out requires and such
function sanitizeStrategy(strategy){
	// console.log(x) or console['error'](y)
	function isRequireCall(node) {
		return (node.type === 'CallExpression') &&
			(node.callee.type === 'MemberExpression') &&
			(node.callee.object.type === 'Identifier') &&
			(node.callee.object.name === 'require');
	}
	
	function removeCalls(source) {
		const entries = [];
		esprima.parseScript(source, {}, function (node, meta) {
			if (isRequireCall(node)) {
				entries.push({
					start: meta.start.offset,
					end: meta.end.offset
				});
			}
		});
		entries.sort((a, b) => { return b.end - a.end }).forEach(n => {
			source = source.slice(0, n.start) + source.slice(n.end);
		});
		return source;
	}
	
	removeCalls(strategy.toString());

}

//Returns to the user an array of all registered strategies. TODO: have this mirror PlayerList, to provide functionality like onlyAlive and scoresObject.
function Strategies(){
	var strategies = [];
	for (var strategy in registry.strategies) strategies.push(strategy);
	return strategies;
};

module.exports = {registerStrategy, Strategies};
},{"./helperFunctions":7,"./logger":26,"./state":43,"esprima":51}],46:[function(require,module,exports){
'use strict';
module.exports = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};

},{}],47:[function(require,module,exports){
'use strict';

function assembleStyles () {
	var styles = {
		modifiers: {
			reset: [0, 0],
			bold: [1, 22], // 21 isn't widely supported and 22 does the same thing
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		colors: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],
			gray: [90, 39]
		},
		bgColors: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49]
		}
	};

	// fix humans
	styles.colors.grey = styles.colors.gray;

	Object.keys(styles).forEach(function (groupName) {
		var group = styles[groupName];

		Object.keys(group).forEach(function (styleName) {
			var style = group[styleName];

			styles[styleName] = group[styleName] = {
				open: '\u001b[' + style[0] + 'm',
				close: '\u001b[' + style[1] + 'm'
			};
		});

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});
	});

	return styles;
}

Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});

},{}],48:[function(require,module,exports){
(function (process){
'use strict';
var escapeStringRegexp = require('escape-string-regexp');
var ansiStyles = require('ansi-styles');
var stripAnsi = require('strip-ansi');
var hasAnsi = require('has-ansi');
var supportsColor = require('supports-color');
var defineProps = Object.defineProperties;
var isSimpleWindowsTerm = process.platform === 'win32' && !/^xterm/i.test(process.env.TERM);

function Chalk(options) {
	// detect mode if not set manually
	this.enabled = !options || options.enabled === undefined ? supportsColor : options.enabled;
}

// use bright blue on Windows as the normal blue color is illegible
if (isSimpleWindowsTerm) {
	ansiStyles.blue.open = '\u001b[94m';
}

var styles = (function () {
	var ret = {};

	Object.keys(ansiStyles).forEach(function (key) {
		ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');

		ret[key] = {
			get: function () {
				return build.call(this, this._styles.concat(key));
			}
		};
	});

	return ret;
})();

var proto = defineProps(function chalk() {}, styles);

function build(_styles) {
	var builder = function () {
		return applyStyle.apply(builder, arguments);
	};

	builder._styles = _styles;
	builder.enabled = this.enabled;
	// __proto__ is used because we must return a function, but there is
	// no way to create a function with a different prototype.
	/* eslint-disable no-proto */
	builder.__proto__ = proto;

	return builder;
}

function applyStyle() {
	// support varags, but simply cast to string in case there's only one arg
	var args = arguments;
	var argsLen = args.length;
	var str = argsLen !== 0 && String(arguments[0]);

	if (argsLen > 1) {
		// don't slice `arguments`, it prevents v8 optimizations
		for (var a = 1; a < argsLen; a++) {
			str += ' ' + args[a];
		}
	}

	if (!this.enabled || !str) {
		return str;
	}

	var nestedStyles = this._styles;
	var i = nestedStyles.length;

	// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
	// see https://github.com/chalk/chalk/issues/58
	// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
	var originalDim = ansiStyles.dim.open;
	if (isSimpleWindowsTerm && (nestedStyles.indexOf('gray') !== -1 || nestedStyles.indexOf('grey') !== -1)) {
		ansiStyles.dim.open = '';
	}

	while (i--) {
		var code = ansiStyles[nestedStyles[i]];

		// Replace any instances already present with a re-opening code
		// otherwise only the part of the string until said closing code
		// will be colored, and the rest will simply be 'plain'.
		str = code.open + str.replace(code.closeRe, code.open) + code.close;
	}

	// Reset the original 'dim' if we changed it to work around the Windows dimmed gray issue.
	ansiStyles.dim.open = originalDim;

	return str;
}

function init() {
	var ret = {};

	Object.keys(styles).forEach(function (name) {
		ret[name] = {
			get: function () {
				return build.call(this, [name]);
			}
		};
	});

	return ret;
}

defineProps(Chalk.prototype, init());

module.exports = new Chalk();
module.exports.styles = ansiStyles;
module.exports.hasColor = hasAnsi;
module.exports.stripColor = stripAnsi;
module.exports.supportsColor = supportsColor;

}).call(this,require('_process'))

},{"_process":2,"ansi-styles":47,"escape-string-regexp":50,"has-ansi":54,"strip-ansi":61,"supports-color":49}],49:[function(require,module,exports){
(function (process){
'use strict';
var argv = process.argv;

var terminator = argv.indexOf('--');
var hasFlag = function (flag) {
	flag = '--' + flag;
	var pos = argv.indexOf(flag);
	return pos !== -1 && (terminator !== -1 ? pos < terminator : true);
};

module.exports = (function () {
	if ('FORCE_COLOR' in process.env) {
		return true;
	}

	if (hasFlag('no-color') ||
		hasFlag('no-colors') ||
		hasFlag('color=false')) {
		return false;
	}

	if (hasFlag('color') ||
		hasFlag('colors') ||
		hasFlag('color=true') ||
		hasFlag('color=always')) {
		return true;
	}

	if (process.stdout && !process.stdout.isTTY) {
		return false;
	}

	if (process.platform === 'win32') {
		return true;
	}

	if ('COLORTERM' in process.env) {
		return true;
	}

	if (process.env.TERM === 'dumb') {
		return false;
	}

	if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
		return true;
	}

	return false;
})();

}).call(this,require('_process'))

},{"_process":2}],50:[function(require,module,exports){
'use strict';

var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

module.exports = function (str) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	return str.replace(matchOperatorsRe, '\\$&');
};

},{}],51:[function(require,module,exports){
(function webpackUniversalModuleDefinition(root, factory) {
/* istanbul ignore next */
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
/* istanbul ignore next */
	else if(typeof exports === 'object')
		exports["esprima"] = factory();
	else
		root["esprima"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/* istanbul ignore if */
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/*
	  Copyright JS Foundation and other contributors, https://js.foundation/

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	Object.defineProperty(exports, "__esModule", { value: true });
	var comment_handler_1 = __webpack_require__(1);
	var jsx_parser_1 = __webpack_require__(3);
	var parser_1 = __webpack_require__(8);
	var tokenizer_1 = __webpack_require__(15);
	function parse(code, options, delegate) {
	    var commentHandler = null;
	    var proxyDelegate = function (node, metadata) {
	        if (delegate) {
	            delegate(node, metadata);
	        }
	        if (commentHandler) {
	            commentHandler.visit(node, metadata);
	        }
	    };
	    var parserDelegate = (typeof delegate === 'function') ? proxyDelegate : null;
	    var collectComment = false;
	    if (options) {
	        collectComment = (typeof options.comment === 'boolean' && options.comment);
	        var attachComment = (typeof options.attachComment === 'boolean' && options.attachComment);
	        if (collectComment || attachComment) {
	            commentHandler = new comment_handler_1.CommentHandler();
	            commentHandler.attach = attachComment;
	            options.comment = true;
	            parserDelegate = proxyDelegate;
	        }
	    }
	    var isModule = false;
	    if (options && typeof options.sourceType === 'string') {
	        isModule = (options.sourceType === 'module');
	    }
	    var parser;
	    if (options && typeof options.jsx === 'boolean' && options.jsx) {
	        parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
	    }
	    else {
	        parser = new parser_1.Parser(code, options, parserDelegate);
	    }
	    var program = isModule ? parser.parseModule() : parser.parseScript();
	    var ast = program;
	    if (collectComment && commentHandler) {
	        ast.comments = commentHandler.comments;
	    }
	    if (parser.config.tokens) {
	        ast.tokens = parser.tokens;
	    }
	    if (parser.config.tolerant) {
	        ast.errors = parser.errorHandler.errors;
	    }
	    return ast;
	}
	exports.parse = parse;
	function parseModule(code, options, delegate) {
	    var parsingOptions = options || {};
	    parsingOptions.sourceType = 'module';
	    return parse(code, parsingOptions, delegate);
	}
	exports.parseModule = parseModule;
	function parseScript(code, options, delegate) {
	    var parsingOptions = options || {};
	    parsingOptions.sourceType = 'script';
	    return parse(code, parsingOptions, delegate);
	}
	exports.parseScript = parseScript;
	function tokenize(code, options, delegate) {
	    var tokenizer = new tokenizer_1.Tokenizer(code, options);
	    var tokens;
	    tokens = [];
	    try {
	        while (true) {
	            var token = tokenizer.getNextToken();
	            if (!token) {
	                break;
	            }
	            if (delegate) {
	                token = delegate(token);
	            }
	            tokens.push(token);
	        }
	    }
	    catch (e) {
	        tokenizer.errorHandler.tolerate(e);
	    }
	    if (tokenizer.errorHandler.tolerant) {
	        tokens.errors = tokenizer.errors();
	    }
	    return tokens;
	}
	exports.tokenize = tokenize;
	var syntax_1 = __webpack_require__(2);
	exports.Syntax = syntax_1.Syntax;
	// Sync with *.json manifests.
	exports.version = '4.0.0';


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var syntax_1 = __webpack_require__(2);
	var CommentHandler = (function () {
	    function CommentHandler() {
	        this.attach = false;
	        this.comments = [];
	        this.stack = [];
	        this.leading = [];
	        this.trailing = [];
	    }
	    CommentHandler.prototype.insertInnerComments = function (node, metadata) {
	        //  innnerComments for properties empty block
	        //  `function a() {/** comments **\/}`
	        if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
	            var innerComments = [];
	            for (var i = this.leading.length - 1; i >= 0; --i) {
	                var entry = this.leading[i];
	                if (metadata.end.offset >= entry.start) {
	                    innerComments.unshift(entry.comment);
	                    this.leading.splice(i, 1);
	                    this.trailing.splice(i, 1);
	                }
	            }
	            if (innerComments.length) {
	                node.innerComments = innerComments;
	            }
	        }
	    };
	    CommentHandler.prototype.findTrailingComments = function (metadata) {
	        var trailingComments = [];
	        if (this.trailing.length > 0) {
	            for (var i = this.trailing.length - 1; i >= 0; --i) {
	                var entry_1 = this.trailing[i];
	                if (entry_1.start >= metadata.end.offset) {
	                    trailingComments.unshift(entry_1.comment);
	                }
	            }
	            this.trailing.length = 0;
	            return trailingComments;
	        }
	        var entry = this.stack[this.stack.length - 1];
	        if (entry && entry.node.trailingComments) {
	            var firstComment = entry.node.trailingComments[0];
	            if (firstComment && firstComment.range[0] >= metadata.end.offset) {
	                trailingComments = entry.node.trailingComments;
	                delete entry.node.trailingComments;
	            }
	        }
	        return trailingComments;
	    };
	    CommentHandler.prototype.findLeadingComments = function (metadata) {
	        var leadingComments = [];
	        var target;
	        while (this.stack.length > 0) {
	            var entry = this.stack[this.stack.length - 1];
	            if (entry && entry.start >= metadata.start.offset) {
	                target = entry.node;
	                this.stack.pop();
	            }
	            else {
	                break;
	            }
	        }
	        if (target) {
	            var count = target.leadingComments ? target.leadingComments.length : 0;
	            for (var i = count - 1; i >= 0; --i) {
	                var comment = target.leadingComments[i];
	                if (comment.range[1] <= metadata.start.offset) {
	                    leadingComments.unshift(comment);
	                    target.leadingComments.splice(i, 1);
	                }
	            }
	            if (target.leadingComments && target.leadingComments.length === 0) {
	                delete target.leadingComments;
	            }
	            return leadingComments;
	        }
	        for (var i = this.leading.length - 1; i >= 0; --i) {
	            var entry = this.leading[i];
	            if (entry.start <= metadata.start.offset) {
	                leadingComments.unshift(entry.comment);
	                this.leading.splice(i, 1);
	            }
	        }
	        return leadingComments;
	    };
	    CommentHandler.prototype.visitNode = function (node, metadata) {
	        if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
	            return;
	        }
	        this.insertInnerComments(node, metadata);
	        var trailingComments = this.findTrailingComments(metadata);
	        var leadingComments = this.findLeadingComments(metadata);
	        if (leadingComments.length > 0) {
	            node.leadingComments = leadingComments;
	        }
	        if (trailingComments.length > 0) {
	            node.trailingComments = trailingComments;
	        }
	        this.stack.push({
	            node: node,
	            start: metadata.start.offset
	        });
	    };
	    CommentHandler.prototype.visitComment = function (node, metadata) {
	        var type = (node.type[0] === 'L') ? 'Line' : 'Block';
	        var comment = {
	            type: type,
	            value: node.value
	        };
	        if (node.range) {
	            comment.range = node.range;
	        }
	        if (node.loc) {
	            comment.loc = node.loc;
	        }
	        this.comments.push(comment);
	        if (this.attach) {
	            var entry = {
	                comment: {
	                    type: type,
	                    value: node.value,
	                    range: [metadata.start.offset, metadata.end.offset]
	                },
	                start: metadata.start.offset
	            };
	            if (node.loc) {
	                entry.comment.loc = node.loc;
	            }
	            node.type = type;
	            this.leading.push(entry);
	            this.trailing.push(entry);
	        }
	    };
	    CommentHandler.prototype.visit = function (node, metadata) {
	        if (node.type === 'LineComment') {
	            this.visitComment(node, metadata);
	        }
	        else if (node.type === 'BlockComment') {
	            this.visitComment(node, metadata);
	        }
	        else if (this.attach) {
	            this.visitNode(node, metadata);
	        }
	    };
	    return CommentHandler;
	}());
	exports.CommentHandler = CommentHandler;


/***/ },
/* 2 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Syntax = {
	    AssignmentExpression: 'AssignmentExpression',
	    AssignmentPattern: 'AssignmentPattern',
	    ArrayExpression: 'ArrayExpression',
	    ArrayPattern: 'ArrayPattern',
	    ArrowFunctionExpression: 'ArrowFunctionExpression',
	    AwaitExpression: 'AwaitExpression',
	    BlockStatement: 'BlockStatement',
	    BinaryExpression: 'BinaryExpression',
	    BreakStatement: 'BreakStatement',
	    CallExpression: 'CallExpression',
	    CatchClause: 'CatchClause',
	    ClassBody: 'ClassBody',
	    ClassDeclaration: 'ClassDeclaration',
	    ClassExpression: 'ClassExpression',
	    ConditionalExpression: 'ConditionalExpression',
	    ContinueStatement: 'ContinueStatement',
	    DoWhileStatement: 'DoWhileStatement',
	    DebuggerStatement: 'DebuggerStatement',
	    EmptyStatement: 'EmptyStatement',
	    ExportAllDeclaration: 'ExportAllDeclaration',
	    ExportDefaultDeclaration: 'ExportDefaultDeclaration',
	    ExportNamedDeclaration: 'ExportNamedDeclaration',
	    ExportSpecifier: 'ExportSpecifier',
	    ExpressionStatement: 'ExpressionStatement',
	    ForStatement: 'ForStatement',
	    ForOfStatement: 'ForOfStatement',
	    ForInStatement: 'ForInStatement',
	    FunctionDeclaration: 'FunctionDeclaration',
	    FunctionExpression: 'FunctionExpression',
	    Identifier: 'Identifier',
	    IfStatement: 'IfStatement',
	    ImportDeclaration: 'ImportDeclaration',
	    ImportDefaultSpecifier: 'ImportDefaultSpecifier',
	    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
	    ImportSpecifier: 'ImportSpecifier',
	    Literal: 'Literal',
	    LabeledStatement: 'LabeledStatement',
	    LogicalExpression: 'LogicalExpression',
	    MemberExpression: 'MemberExpression',
	    MetaProperty: 'MetaProperty',
	    MethodDefinition: 'MethodDefinition',
	    NewExpression: 'NewExpression',
	    ObjectExpression: 'ObjectExpression',
	    ObjectPattern: 'ObjectPattern',
	    Program: 'Program',
	    Property: 'Property',
	    RestElement: 'RestElement',
	    ReturnStatement: 'ReturnStatement',
	    SequenceExpression: 'SequenceExpression',
	    SpreadElement: 'SpreadElement',
	    Super: 'Super',
	    SwitchCase: 'SwitchCase',
	    SwitchStatement: 'SwitchStatement',
	    TaggedTemplateExpression: 'TaggedTemplateExpression',
	    TemplateElement: 'TemplateElement',
	    TemplateLiteral: 'TemplateLiteral',
	    ThisExpression: 'ThisExpression',
	    ThrowStatement: 'ThrowStatement',
	    TryStatement: 'TryStatement',
	    UnaryExpression: 'UnaryExpression',
	    UpdateExpression: 'UpdateExpression',
	    VariableDeclaration: 'VariableDeclaration',
	    VariableDeclarator: 'VariableDeclarator',
	    WhileStatement: 'WhileStatement',
	    WithStatement: 'WithStatement',
	    YieldExpression: 'YieldExpression'
	};


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
/* istanbul ignore next */
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var character_1 = __webpack_require__(4);
	var JSXNode = __webpack_require__(5);
	var jsx_syntax_1 = __webpack_require__(6);
	var Node = __webpack_require__(7);
	var parser_1 = __webpack_require__(8);
	var token_1 = __webpack_require__(13);
	var xhtml_entities_1 = __webpack_require__(14);
	token_1.TokenName[100 /* Identifier */] = 'JSXIdentifier';
	token_1.TokenName[101 /* Text */] = 'JSXText';
	// Fully qualified element name, e.g. <svg:path> returns "svg:path"
	function getQualifiedElementName(elementName) {
	    var qualifiedName;
	    switch (elementName.type) {
	        case jsx_syntax_1.JSXSyntax.JSXIdentifier:
	            var id = elementName;
	            qualifiedName = id.name;
	            break;
	        case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
	            var ns = elementName;
	            qualifiedName = getQualifiedElementName(ns.namespace) + ':' +
	                getQualifiedElementName(ns.name);
	            break;
	        case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
	            var expr = elementName;
	            qualifiedName = getQualifiedElementName(expr.object) + '.' +
	                getQualifiedElementName(expr.property);
	            break;
	        /* istanbul ignore next */
	        default:
	            break;
	    }
	    return qualifiedName;
	}
	var JSXParser = (function (_super) {
	    __extends(JSXParser, _super);
	    function JSXParser(code, options, delegate) {
	        return _super.call(this, code, options, delegate) || this;
	    }
	    JSXParser.prototype.parsePrimaryExpression = function () {
	        return this.match('<') ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
	    };
	    JSXParser.prototype.startJSX = function () {
	        // Unwind the scanner before the lookahead token.
	        this.scanner.index = this.startMarker.index;
	        this.scanner.lineNumber = this.startMarker.line;
	        this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
	    };
	    JSXParser.prototype.finishJSX = function () {
	        // Prime the next lookahead.
	        this.nextToken();
	    };
	    JSXParser.prototype.reenterJSX = function () {
	        this.startJSX();
	        this.expectJSX('}');
	        // Pop the closing '}' added from the lookahead.
	        if (this.config.tokens) {
	            this.tokens.pop();
	        }
	    };
	    JSXParser.prototype.createJSXNode = function () {
	        this.collectComments();
	        return {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    };
	    JSXParser.prototype.createJSXChildNode = function () {
	        return {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    };
	    JSXParser.prototype.scanXHTMLEntity = function (quote) {
	        var result = '&';
	        var valid = true;
	        var terminated = false;
	        var numeric = false;
	        var hex = false;
	        while (!this.scanner.eof() && valid && !terminated) {
	            var ch = this.scanner.source[this.scanner.index];
	            if (ch === quote) {
	                break;
	            }
	            terminated = (ch === ';');
	            result += ch;
	            ++this.scanner.index;
	            if (!terminated) {
	                switch (result.length) {
	                    case 2:
	                        // e.g. '&#123;'
	                        numeric = (ch === '#');
	                        break;
	                    case 3:
	                        if (numeric) {
	                            // e.g. '&#x41;'
	                            hex = (ch === 'x');
	                            valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
	                            numeric = numeric && !hex;
	                        }
	                        break;
	                    default:
	                        valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
	                        valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
	                        break;
	                }
	            }
	        }
	        if (valid && terminated && result.length > 2) {
	            // e.g. '&#x41;' becomes just '#x41'
	            var str = result.substr(1, result.length - 2);
	            if (numeric && str.length > 1) {
	                result = String.fromCharCode(parseInt(str.substr(1), 10));
	            }
	            else if (hex && str.length > 2) {
	                result = String.fromCharCode(parseInt('0' + str.substr(1), 16));
	            }
	            else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
	                result = xhtml_entities_1.XHTMLEntities[str];
	            }
	        }
	        return result;
	    };
	    // Scan the next JSX token. This replaces Scanner#lex when in JSX mode.
	    JSXParser.prototype.lexJSX = function () {
	        var cp = this.scanner.source.charCodeAt(this.scanner.index);
	        // < > / : = { }
	        if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
	            var value = this.scanner.source[this.scanner.index++];
	            return {
	                type: 7 /* Punctuator */,
	                value: value,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: this.scanner.index - 1,
	                end: this.scanner.index
	            };
	        }
	        // " '
	        if (cp === 34 || cp === 39) {
	            var start = this.scanner.index;
	            var quote = this.scanner.source[this.scanner.index++];
	            var str = '';
	            while (!this.scanner.eof()) {
	                var ch = this.scanner.source[this.scanner.index++];
	                if (ch === quote) {
	                    break;
	                }
	                else if (ch === '&') {
	                    str += this.scanXHTMLEntity(quote);
	                }
	                else {
	                    str += ch;
	                }
	            }
	            return {
	                type: 8 /* StringLiteral */,
	                value: str,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        // ... or .
	        if (cp === 46) {
	            var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
	            var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
	            var value = (n1 === 46 && n2 === 46) ? '...' : '.';
	            var start = this.scanner.index;
	            this.scanner.index += value.length;
	            return {
	                type: 7 /* Punctuator */,
	                value: value,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        // `
	        if (cp === 96) {
	            // Only placeholder, since it will be rescanned as a real assignment expression.
	            return {
	                type: 10 /* Template */,
	                value: '',
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: this.scanner.index,
	                end: this.scanner.index
	            };
	        }
	        // Identifer can not contain backslash (char code 92).
	        if (character_1.Character.isIdentifierStart(cp) && (cp !== 92)) {
	            var start = this.scanner.index;
	            ++this.scanner.index;
	            while (!this.scanner.eof()) {
	                var ch = this.scanner.source.charCodeAt(this.scanner.index);
	                if (character_1.Character.isIdentifierPart(ch) && (ch !== 92)) {
	                    ++this.scanner.index;
	                }
	                else if (ch === 45) {
	                    // Hyphen (char code 45) can be part of an identifier.
	                    ++this.scanner.index;
	                }
	                else {
	                    break;
	                }
	            }
	            var id = this.scanner.source.slice(start, this.scanner.index);
	            return {
	                type: 100 /* Identifier */,
	                value: id,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        return this.scanner.lex();
	    };
	    JSXParser.prototype.nextJSXToken = function () {
	        this.collectComments();
	        this.startMarker.index = this.scanner.index;
	        this.startMarker.line = this.scanner.lineNumber;
	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        var token = this.lexJSX();
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        if (this.config.tokens) {
	            this.tokens.push(this.convertToken(token));
	        }
	        return token;
	    };
	    JSXParser.prototype.nextJSXText = function () {
	        this.startMarker.index = this.scanner.index;
	        this.startMarker.line = this.scanner.lineNumber;
	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        var start = this.scanner.index;
	        var text = '';
	        while (!this.scanner.eof()) {
	            var ch = this.scanner.source[this.scanner.index];
	            if (ch === '{' || ch === '<') {
	                break;
	            }
	            ++this.scanner.index;
	            text += ch;
	            if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                ++this.scanner.lineNumber;
	                if (ch === '\r' && this.scanner.source[this.scanner.index] === '\n') {
	                    ++this.scanner.index;
	                }
	                this.scanner.lineStart = this.scanner.index;
	            }
	        }
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        var token = {
	            type: 101 /* Text */,
	            value: text,
	            lineNumber: this.scanner.lineNumber,
	            lineStart: this.scanner.lineStart,
	            start: start,
	            end: this.scanner.index
	        };
	        if ((text.length > 0) && this.config.tokens) {
	            this.tokens.push(this.convertToken(token));
	        }
	        return token;
	    };
	    JSXParser.prototype.peekJSXToken = function () {
	        var state = this.scanner.saveState();
	        this.scanner.scanComments();
	        var next = this.lexJSX();
	        this.scanner.restoreState(state);
	        return next;
	    };
	    // Expect the next JSX token to match the specified punctuator.
	    // If not, an exception will be thrown.
	    JSXParser.prototype.expectJSX = function (value) {
	        var token = this.nextJSXToken();
	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Return true if the next JSX token matches the specified punctuator.
	    JSXParser.prototype.matchJSX = function (value) {
	        var next = this.peekJSXToken();
	        return next.type === 7 /* Punctuator */ && next.value === value;
	    };
	    JSXParser.prototype.parseJSXIdentifier = function () {
	        var node = this.createJSXNode();
	        var token = this.nextJSXToken();
	        if (token.type !== 100 /* Identifier */) {
	            this.throwUnexpectedToken(token);
	        }
	        return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
	    };
	    JSXParser.prototype.parseJSXElementName = function () {
	        var node = this.createJSXNode();
	        var elementName = this.parseJSXIdentifier();
	        if (this.matchJSX(':')) {
	            var namespace = elementName;
	            this.expectJSX(':');
	            var name_1 = this.parseJSXIdentifier();
	            elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
	        }
	        else if (this.matchJSX('.')) {
	            while (this.matchJSX('.')) {
	                var object = elementName;
	                this.expectJSX('.');
	                var property = this.parseJSXIdentifier();
	                elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
	            }
	        }
	        return elementName;
	    };
	    JSXParser.prototype.parseJSXAttributeName = function () {
	        var node = this.createJSXNode();
	        var attributeName;
	        var identifier = this.parseJSXIdentifier();
	        if (this.matchJSX(':')) {
	            var namespace = identifier;
	            this.expectJSX(':');
	            var name_2 = this.parseJSXIdentifier();
	            attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
	        }
	        else {
	            attributeName = identifier;
	        }
	        return attributeName;
	    };
	    JSXParser.prototype.parseJSXStringLiteralAttribute = function () {
	        var node = this.createJSXNode();
	        var token = this.nextJSXToken();
	        if (token.type !== 8 /* StringLiteral */) {
	            this.throwUnexpectedToken(token);
	        }
	        var raw = this.getTokenRaw(token);
	        return this.finalize(node, new Node.Literal(token.value, raw));
	    };
	    JSXParser.prototype.parseJSXExpressionAttribute = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        this.finishJSX();
	        if (this.match('}')) {
	            this.tolerateError('JSX attributes must only be assigned a non-empty expression');
	        }
	        var expression = this.parseAssignmentExpression();
	        this.reenterJSX();
	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
	    };
	    JSXParser.prototype.parseJSXAttributeValue = function () {
	        return this.matchJSX('{') ? this.parseJSXExpressionAttribute() :
	            this.matchJSX('<') ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
	    };
	    JSXParser.prototype.parseJSXNameValueAttribute = function () {
	        var node = this.createJSXNode();
	        var name = this.parseJSXAttributeName();
	        var value = null;
	        if (this.matchJSX('=')) {
	            this.expectJSX('=');
	            value = this.parseJSXAttributeValue();
	        }
	        return this.finalize(node, new JSXNode.JSXAttribute(name, value));
	    };
	    JSXParser.prototype.parseJSXSpreadAttribute = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        this.expectJSX('...');
	        this.finishJSX();
	        var argument = this.parseAssignmentExpression();
	        this.reenterJSX();
	        return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
	    };
	    JSXParser.prototype.parseJSXAttributes = function () {
	        var attributes = [];
	        while (!this.matchJSX('/') && !this.matchJSX('>')) {
	            var attribute = this.matchJSX('{') ? this.parseJSXSpreadAttribute() :
	                this.parseJSXNameValueAttribute();
	            attributes.push(attribute);
	        }
	        return attributes;
	    };
	    JSXParser.prototype.parseJSXOpeningElement = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('<');
	        var name = this.parseJSXElementName();
	        var attributes = this.parseJSXAttributes();
	        var selfClosing = this.matchJSX('/');
	        if (selfClosing) {
	            this.expectJSX('/');
	        }
	        this.expectJSX('>');
	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
	    };
	    JSXParser.prototype.parseJSXBoundaryElement = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('<');
	        if (this.matchJSX('/')) {
	            this.expectJSX('/');
	            var name_3 = this.parseJSXElementName();
	            this.expectJSX('>');
	            return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
	        }
	        var name = this.parseJSXElementName();
	        var attributes = this.parseJSXAttributes();
	        var selfClosing = this.matchJSX('/');
	        if (selfClosing) {
	            this.expectJSX('/');
	        }
	        this.expectJSX('>');
	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
	    };
	    JSXParser.prototype.parseJSXEmptyExpression = function () {
	        var node = this.createJSXChildNode();
	        this.collectComments();
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        return this.finalize(node, new JSXNode.JSXEmptyExpression());
	    };
	    JSXParser.prototype.parseJSXExpressionContainer = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        var expression;
	        if (this.matchJSX('}')) {
	            expression = this.parseJSXEmptyExpression();
	            this.expectJSX('}');
	        }
	        else {
	            this.finishJSX();
	            expression = this.parseAssignmentExpression();
	            this.reenterJSX();
	        }
	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
	    };
	    JSXParser.prototype.parseJSXChildren = function () {
	        var children = [];
	        while (!this.scanner.eof()) {
	            var node = this.createJSXChildNode();
	            var token = this.nextJSXText();
	            if (token.start < token.end) {
	                var raw = this.getTokenRaw(token);
	                var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
	                children.push(child);
	            }
	            if (this.scanner.source[this.scanner.index] === '{') {
	                var container = this.parseJSXExpressionContainer();
	                children.push(container);
	            }
	            else {
	                break;
	            }
	        }
	        return children;
	    };
	    JSXParser.prototype.parseComplexJSXElement = function (el) {
	        var stack = [];
	        while (!this.scanner.eof()) {
	            el.children = el.children.concat(this.parseJSXChildren());
	            var node = this.createJSXChildNode();
	            var element = this.parseJSXBoundaryElement();
	            if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
	                var opening = element;
	                if (opening.selfClosing) {
	                    var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
	                    el.children.push(child);
	                }
	                else {
	                    stack.push(el);
	                    el = { node: node, opening: opening, closing: null, children: [] };
	                }
	            }
	            if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
	                el.closing = element;
	                var open_1 = getQualifiedElementName(el.opening.name);
	                var close_1 = getQualifiedElementName(el.closing.name);
	                if (open_1 !== close_1) {
	                    this.tolerateError('Expected corresponding JSX closing tag for %0', open_1);
	                }
	                if (stack.length > 0) {
	                    var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
	                    el = stack[stack.length - 1];
	                    el.children.push(child);
	                    stack.pop();
	                }
	                else {
	                    break;
	                }
	            }
	        }
	        return el;
	    };
	    JSXParser.prototype.parseJSXElement = function () {
	        var node = this.createJSXNode();
	        var opening = this.parseJSXOpeningElement();
	        var children = [];
	        var closing = null;
	        if (!opening.selfClosing) {
	            var el = this.parseComplexJSXElement({ node: node, opening: opening, closing: closing, children: children });
	            children = el.children;
	            closing = el.closing;
	        }
	        return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
	    };
	    JSXParser.prototype.parseJSXRoot = function () {
	        // Pop the opening '<' added from the lookahead.
	        if (this.config.tokens) {
	            this.tokens.pop();
	        }
	        this.startJSX();
	        var element = this.parseJSXElement();
	        this.finishJSX();
	        return element;
	    };
	    JSXParser.prototype.isStartOfExpression = function () {
	        return _super.prototype.isStartOfExpression.call(this) || this.match('<');
	    };
	    return JSXParser;
	}(parser_1.Parser));
	exports.JSXParser = JSXParser;


/***/ },
/* 4 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// See also tools/generate-unicode-regex.js.
	var Regex = {
	    // Unicode v8.0.0 NonAsciiIdentifierStart:
	    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
	    // Unicode v8.0.0 NonAsciiIdentifierPart:
	    NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
	};
	exports.Character = {
	    /* tslint:disable:no-bitwise */
	    fromCodePoint: function (cp) {
	        return (cp < 0x10000) ? String.fromCharCode(cp) :
	            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +
	                String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));
	    },
	    // https://tc39.github.io/ecma262/#sec-white-space
	    isWhiteSpace: function (cp) {
	        return (cp === 0x20) || (cp === 0x09) || (cp === 0x0B) || (cp === 0x0C) || (cp === 0xA0) ||
	            (cp >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) >= 0);
	    },
	    // https://tc39.github.io/ecma262/#sec-line-terminators
	    isLineTerminator: function (cp) {
	        return (cp === 0x0A) || (cp === 0x0D) || (cp === 0x2028) || (cp === 0x2029);
	    },
	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
	    isIdentifierStart: function (cp) {
	        return (cp === 0x24) || (cp === 0x5F) ||
	            (cp >= 0x41 && cp <= 0x5A) ||
	            (cp >= 0x61 && cp <= 0x7A) ||
	            (cp === 0x5C) ||
	            ((cp >= 0x80) && Regex.NonAsciiIdentifierStart.test(exports.Character.fromCodePoint(cp)));
	    },
	    isIdentifierPart: function (cp) {
	        return (cp === 0x24) || (cp === 0x5F) ||
	            (cp >= 0x41 && cp <= 0x5A) ||
	            (cp >= 0x61 && cp <= 0x7A) ||
	            (cp >= 0x30 && cp <= 0x39) ||
	            (cp === 0x5C) ||
	            ((cp >= 0x80) && Regex.NonAsciiIdentifierPart.test(exports.Character.fromCodePoint(cp)));
	    },
	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
	    isDecimalDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x39); // 0..9
	    },
	    isHexDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x39) ||
	            (cp >= 0x41 && cp <= 0x46) ||
	            (cp >= 0x61 && cp <= 0x66); // a..f
	    },
	    isOctalDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x37); // 0..7
	    }
	};


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var jsx_syntax_1 = __webpack_require__(6);
	/* tslint:disable:max-classes-per-file */
	var JSXClosingElement = (function () {
	    function JSXClosingElement(name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
	        this.name = name;
	    }
	    return JSXClosingElement;
	}());
	exports.JSXClosingElement = JSXClosingElement;
	var JSXElement = (function () {
	    function JSXElement(openingElement, children, closingElement) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXElement;
	        this.openingElement = openingElement;
	        this.children = children;
	        this.closingElement = closingElement;
	    }
	    return JSXElement;
	}());
	exports.JSXElement = JSXElement;
	var JSXEmptyExpression = (function () {
	    function JSXEmptyExpression() {
	        this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
	    }
	    return JSXEmptyExpression;
	}());
	exports.JSXEmptyExpression = JSXEmptyExpression;
	var JSXExpressionContainer = (function () {
	    function JSXExpressionContainer(expression) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
	        this.expression = expression;
	    }
	    return JSXExpressionContainer;
	}());
	exports.JSXExpressionContainer = JSXExpressionContainer;
	var JSXIdentifier = (function () {
	    function JSXIdentifier(name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
	        this.name = name;
	    }
	    return JSXIdentifier;
	}());
	exports.JSXIdentifier = JSXIdentifier;
	var JSXMemberExpression = (function () {
	    function JSXMemberExpression(object, property) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
	        this.object = object;
	        this.property = property;
	    }
	    return JSXMemberExpression;
	}());
	exports.JSXMemberExpression = JSXMemberExpression;
	var JSXAttribute = (function () {
	    function JSXAttribute(name, value) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
	        this.name = name;
	        this.value = value;
	    }
	    return JSXAttribute;
	}());
	exports.JSXAttribute = JSXAttribute;
	var JSXNamespacedName = (function () {
	    function JSXNamespacedName(namespace, name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
	        this.namespace = namespace;
	        this.name = name;
	    }
	    return JSXNamespacedName;
	}());
	exports.JSXNamespacedName = JSXNamespacedName;
	var JSXOpeningElement = (function () {
	    function JSXOpeningElement(name, selfClosing, attributes) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
	        this.name = name;
	        this.selfClosing = selfClosing;
	        this.attributes = attributes;
	    }
	    return JSXOpeningElement;
	}());
	exports.JSXOpeningElement = JSXOpeningElement;
	var JSXSpreadAttribute = (function () {
	    function JSXSpreadAttribute(argument) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
	        this.argument = argument;
	    }
	    return JSXSpreadAttribute;
	}());
	exports.JSXSpreadAttribute = JSXSpreadAttribute;
	var JSXText = (function () {
	    function JSXText(value, raw) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXText;
	        this.value = value;
	        this.raw = raw;
	    }
	    return JSXText;
	}());
	exports.JSXText = JSXText;


/***/ },
/* 6 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.JSXSyntax = {
	    JSXAttribute: 'JSXAttribute',
	    JSXClosingElement: 'JSXClosingElement',
	    JSXElement: 'JSXElement',
	    JSXEmptyExpression: 'JSXEmptyExpression',
	    JSXExpressionContainer: 'JSXExpressionContainer',
	    JSXIdentifier: 'JSXIdentifier',
	    JSXMemberExpression: 'JSXMemberExpression',
	    JSXNamespacedName: 'JSXNamespacedName',
	    JSXOpeningElement: 'JSXOpeningElement',
	    JSXSpreadAttribute: 'JSXSpreadAttribute',
	    JSXText: 'JSXText'
	};


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var syntax_1 = __webpack_require__(2);
	/* tslint:disable:max-classes-per-file */
	var ArrayExpression = (function () {
	    function ArrayExpression(elements) {
	        this.type = syntax_1.Syntax.ArrayExpression;
	        this.elements = elements;
	    }
	    return ArrayExpression;
	}());
	exports.ArrayExpression = ArrayExpression;
	var ArrayPattern = (function () {
	    function ArrayPattern(elements) {
	        this.type = syntax_1.Syntax.ArrayPattern;
	        this.elements = elements;
	    }
	    return ArrayPattern;
	}());
	exports.ArrayPattern = ArrayPattern;
	var ArrowFunctionExpression = (function () {
	    function ArrowFunctionExpression(params, body, expression) {
	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
	        this.id = null;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = expression;
	        this.async = false;
	    }
	    return ArrowFunctionExpression;
	}());
	exports.ArrowFunctionExpression = ArrowFunctionExpression;
	var AssignmentExpression = (function () {
	    function AssignmentExpression(operator, left, right) {
	        this.type = syntax_1.Syntax.AssignmentExpression;
	        this.operator = operator;
	        this.left = left;
	        this.right = right;
	    }
	    return AssignmentExpression;
	}());
	exports.AssignmentExpression = AssignmentExpression;
	var AssignmentPattern = (function () {
	    function AssignmentPattern(left, right) {
	        this.type = syntax_1.Syntax.AssignmentPattern;
	        this.left = left;
	        this.right = right;
	    }
	    return AssignmentPattern;
	}());
	exports.AssignmentPattern = AssignmentPattern;
	var AsyncArrowFunctionExpression = (function () {
	    function AsyncArrowFunctionExpression(params, body, expression) {
	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
	        this.id = null;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = expression;
	        this.async = true;
	    }
	    return AsyncArrowFunctionExpression;
	}());
	exports.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
	var AsyncFunctionDeclaration = (function () {
	    function AsyncFunctionDeclaration(id, params, body) {
	        this.type = syntax_1.Syntax.FunctionDeclaration;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = false;
	        this.async = true;
	    }
	    return AsyncFunctionDeclaration;
	}());
	exports.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
	var AsyncFunctionExpression = (function () {
	    function AsyncFunctionExpression(id, params, body) {
	        this.type = syntax_1.Syntax.FunctionExpression;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = false;
	        this.async = true;
	    }
	    return AsyncFunctionExpression;
	}());
	exports.AsyncFunctionExpression = AsyncFunctionExpression;
	var AwaitExpression = (function () {
	    function AwaitExpression(argument) {
	        this.type = syntax_1.Syntax.AwaitExpression;
	        this.argument = argument;
	    }
	    return AwaitExpression;
	}());
	exports.AwaitExpression = AwaitExpression;
	var BinaryExpression = (function () {
	    function BinaryExpression(operator, left, right) {
	        var logical = (operator === '||' || operator === '&&');
	        this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
	        this.operator = operator;
	        this.left = left;
	        this.right = right;
	    }
	    return BinaryExpression;
	}());
	exports.BinaryExpression = BinaryExpression;
	var BlockStatement = (function () {
	    function BlockStatement(body) {
	        this.type = syntax_1.Syntax.BlockStatement;
	        this.body = body;
	    }
	    return BlockStatement;
	}());
	exports.BlockStatement = BlockStatement;
	var BreakStatement = (function () {
	    function BreakStatement(label) {
	        this.type = syntax_1.Syntax.BreakStatement;
	        this.label = label;
	    }
	    return BreakStatement;
	}());
	exports.BreakStatement = BreakStatement;
	var CallExpression = (function () {
	    function CallExpression(callee, args) {
	        this.type = syntax_1.Syntax.CallExpression;
	        this.callee = callee;
	        this.arguments = args;
	    }
	    return CallExpression;
	}());
	exports.CallExpression = CallExpression;
	var CatchClause = (function () {
	    function CatchClause(param, body) {
	        this.type = syntax_1.Syntax.CatchClause;
	        this.param = param;
	        this.body = body;
	    }
	    return CatchClause;
	}());
	exports.CatchClause = CatchClause;
	var ClassBody = (function () {
	    function ClassBody(body) {
	        this.type = syntax_1.Syntax.ClassBody;
	        this.body = body;
	    }
	    return ClassBody;
	}());
	exports.ClassBody = ClassBody;
	var ClassDeclaration = (function () {
	    function ClassDeclaration(id, superClass, body) {
	        this.type = syntax_1.Syntax.ClassDeclaration;
	        this.id = id;
	        this.superClass = superClass;
	        this.body = body;
	    }
	    return ClassDeclaration;
	}());
	exports.ClassDeclaration = ClassDeclaration;
	var ClassExpression = (function () {
	    function ClassExpression(id, superClass, body) {
	        this.type = syntax_1.Syntax.ClassExpression;
	        this.id = id;
	        this.superClass = superClass;
	        this.body = body;
	    }
	    return ClassExpression;
	}());
	exports.ClassExpression = ClassExpression;
	var ComputedMemberExpression = (function () {
	    function ComputedMemberExpression(object, property) {
	        this.type = syntax_1.Syntax.MemberExpression;
	        this.computed = true;
	        this.object = object;
	        this.property = property;
	    }
	    return ComputedMemberExpression;
	}());
	exports.ComputedMemberExpression = ComputedMemberExpression;
	var ConditionalExpression = (function () {
	    function ConditionalExpression(test, consequent, alternate) {
	        this.type = syntax_1.Syntax.ConditionalExpression;
	        this.test = test;
	        this.consequent = consequent;
	        this.alternate = alternate;
	    }
	    return ConditionalExpression;
	}());
	exports.ConditionalExpression = ConditionalExpression;
	var ContinueStatement = (function () {
	    function ContinueStatement(label) {
	        this.type = syntax_1.Syntax.ContinueStatement;
	        this.label = label;
	    }
	    return ContinueStatement;
	}());
	exports.ContinueStatement = ContinueStatement;
	var DebuggerStatement = (function () {
	    function DebuggerStatement() {
	        this.type = syntax_1.Syntax.DebuggerStatement;
	    }
	    return DebuggerStatement;
	}());
	exports.DebuggerStatement = DebuggerStatement;
	var Directive = (function () {
	    function Directive(expression, directive) {
	        this.type = syntax_1.Syntax.ExpressionStatement;
	        this.expression = expression;
	        this.directive = directive;
	    }
	    return Directive;
	}());
	exports.Directive = Directive;
	var DoWhileStatement = (function () {
	    function DoWhileStatement(body, test) {
	        this.type = syntax_1.Syntax.DoWhileStatement;
	        this.body = body;
	        this.test = test;
	    }
	    return DoWhileStatement;
	}());
	exports.DoWhileStatement = DoWhileStatement;
	var EmptyStatement = (function () {
	    function EmptyStatement() {
	        this.type = syntax_1.Syntax.EmptyStatement;
	    }
	    return EmptyStatement;
	}());
	exports.EmptyStatement = EmptyStatement;
	var ExportAllDeclaration = (function () {
	    function ExportAllDeclaration(source) {
	        this.type = syntax_1.Syntax.ExportAllDeclaration;
	        this.source = source;
	    }
	    return ExportAllDeclaration;
	}());
	exports.ExportAllDeclaration = ExportAllDeclaration;
	var ExportDefaultDeclaration = (function () {
	    function ExportDefaultDeclaration(declaration) {
	        this.type = syntax_1.Syntax.ExportDefaultDeclaration;
	        this.declaration = declaration;
	    }
	    return ExportDefaultDeclaration;
	}());
	exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
	var ExportNamedDeclaration = (function () {
	    function ExportNamedDeclaration(declaration, specifiers, source) {
	        this.type = syntax_1.Syntax.ExportNamedDeclaration;
	        this.declaration = declaration;
	        this.specifiers = specifiers;
	        this.source = source;
	    }
	    return ExportNamedDeclaration;
	}());
	exports.ExportNamedDeclaration = ExportNamedDeclaration;
	var ExportSpecifier = (function () {
	    function ExportSpecifier(local, exported) {
	        this.type = syntax_1.Syntax.ExportSpecifier;
	        this.exported = exported;
	        this.local = local;
	    }
	    return ExportSpecifier;
	}());
	exports.ExportSpecifier = ExportSpecifier;
	var ExpressionStatement = (function () {
	    function ExpressionStatement(expression) {
	        this.type = syntax_1.Syntax.ExpressionStatement;
	        this.expression = expression;
	    }
	    return ExpressionStatement;
	}());
	exports.ExpressionStatement = ExpressionStatement;
	var ForInStatement = (function () {
	    function ForInStatement(left, right, body) {
	        this.type = syntax_1.Syntax.ForInStatement;
	        this.left = left;
	        this.right = right;
	        this.body = body;
	        this.each = false;
	    }
	    return ForInStatement;
	}());
	exports.ForInStatement = ForInStatement;
	var ForOfStatement = (function () {
	    function ForOfStatement(left, right, body) {
	        this.type = syntax_1.Syntax.ForOfStatement;
	        this.left = left;
	        this.right = right;
	        this.body = body;
	    }
	    return ForOfStatement;
	}());
	exports.ForOfStatement = ForOfStatement;
	var ForStatement = (function () {
	    function ForStatement(init, test, update, body) {
	        this.type = syntax_1.Syntax.ForStatement;
	        this.init = init;
	        this.test = test;
	        this.update = update;
	        this.body = body;
	    }
	    return ForStatement;
	}());
	exports.ForStatement = ForStatement;
	var FunctionDeclaration = (function () {
	    function FunctionDeclaration(id, params, body, generator) {
	        this.type = syntax_1.Syntax.FunctionDeclaration;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = generator;
	        this.expression = false;
	        this.async = false;
	    }
	    return FunctionDeclaration;
	}());
	exports.FunctionDeclaration = FunctionDeclaration;
	var FunctionExpression = (function () {
	    function FunctionExpression(id, params, body, generator) {
	        this.type = syntax_1.Syntax.FunctionExpression;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = generator;
	        this.expression = false;
	        this.async = false;
	    }
	    return FunctionExpression;
	}());
	exports.FunctionExpression = FunctionExpression;
	var Identifier = (function () {
	    function Identifier(name) {
	        this.type = syntax_1.Syntax.Identifier;
	        this.name = name;
	    }
	    return Identifier;
	}());
	exports.Identifier = Identifier;
	var IfStatement = (function () {
	    function IfStatement(test, consequent, alternate) {
	        this.type = syntax_1.Syntax.IfStatement;
	        this.test = test;
	        this.consequent = consequent;
	        this.alternate = alternate;
	    }
	    return IfStatement;
	}());
	exports.IfStatement = IfStatement;
	var ImportDeclaration = (function () {
	    function ImportDeclaration(specifiers, source) {
	        this.type = syntax_1.Syntax.ImportDeclaration;
	        this.specifiers = specifiers;
	        this.source = source;
	    }
	    return ImportDeclaration;
	}());
	exports.ImportDeclaration = ImportDeclaration;
	var ImportDefaultSpecifier = (function () {
	    function ImportDefaultSpecifier(local) {
	        this.type = syntax_1.Syntax.ImportDefaultSpecifier;
	        this.local = local;
	    }
	    return ImportDefaultSpecifier;
	}());
	exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
	var ImportNamespaceSpecifier = (function () {
	    function ImportNamespaceSpecifier(local) {
	        this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
	        this.local = local;
	    }
	    return ImportNamespaceSpecifier;
	}());
	exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
	var ImportSpecifier = (function () {
	    function ImportSpecifier(local, imported) {
	        this.type = syntax_1.Syntax.ImportSpecifier;
	        this.local = local;
	        this.imported = imported;
	    }
	    return ImportSpecifier;
	}());
	exports.ImportSpecifier = ImportSpecifier;
	var LabeledStatement = (function () {
	    function LabeledStatement(label, body) {
	        this.type = syntax_1.Syntax.LabeledStatement;
	        this.label = label;
	        this.body = body;
	    }
	    return LabeledStatement;
	}());
	exports.LabeledStatement = LabeledStatement;
	var Literal = (function () {
	    function Literal(value, raw) {
	        this.type = syntax_1.Syntax.Literal;
	        this.value = value;
	        this.raw = raw;
	    }
	    return Literal;
	}());
	exports.Literal = Literal;
	var MetaProperty = (function () {
	    function MetaProperty(meta, property) {
	        this.type = syntax_1.Syntax.MetaProperty;
	        this.meta = meta;
	        this.property = property;
	    }
	    return MetaProperty;
	}());
	exports.MetaProperty = MetaProperty;
	var MethodDefinition = (function () {
	    function MethodDefinition(key, computed, value, kind, isStatic) {
	        this.type = syntax_1.Syntax.MethodDefinition;
	        this.key = key;
	        this.computed = computed;
	        this.value = value;
	        this.kind = kind;
	        this.static = isStatic;
	    }
	    return MethodDefinition;
	}());
	exports.MethodDefinition = MethodDefinition;
	var Module = (function () {
	    function Module(body) {
	        this.type = syntax_1.Syntax.Program;
	        this.body = body;
	        this.sourceType = 'module';
	    }
	    return Module;
	}());
	exports.Module = Module;
	var NewExpression = (function () {
	    function NewExpression(callee, args) {
	        this.type = syntax_1.Syntax.NewExpression;
	        this.callee = callee;
	        this.arguments = args;
	    }
	    return NewExpression;
	}());
	exports.NewExpression = NewExpression;
	var ObjectExpression = (function () {
	    function ObjectExpression(properties) {
	        this.type = syntax_1.Syntax.ObjectExpression;
	        this.properties = properties;
	    }
	    return ObjectExpression;
	}());
	exports.ObjectExpression = ObjectExpression;
	var ObjectPattern = (function () {
	    function ObjectPattern(properties) {
	        this.type = syntax_1.Syntax.ObjectPattern;
	        this.properties = properties;
	    }
	    return ObjectPattern;
	}());
	exports.ObjectPattern = ObjectPattern;
	var Property = (function () {
	    function Property(kind, key, computed, value, method, shorthand) {
	        this.type = syntax_1.Syntax.Property;
	        this.key = key;
	        this.computed = computed;
	        this.value = value;
	        this.kind = kind;
	        this.method = method;
	        this.shorthand = shorthand;
	    }
	    return Property;
	}());
	exports.Property = Property;
	var RegexLiteral = (function () {
	    function RegexLiteral(value, raw, pattern, flags) {
	        this.type = syntax_1.Syntax.Literal;
	        this.value = value;
	        this.raw = raw;
	        this.regex = { pattern: pattern, flags: flags };
	    }
	    return RegexLiteral;
	}());
	exports.RegexLiteral = RegexLiteral;
	var RestElement = (function () {
	    function RestElement(argument) {
	        this.type = syntax_1.Syntax.RestElement;
	        this.argument = argument;
	    }
	    return RestElement;
	}());
	exports.RestElement = RestElement;
	var ReturnStatement = (function () {
	    function ReturnStatement(argument) {
	        this.type = syntax_1.Syntax.ReturnStatement;
	        this.argument = argument;
	    }
	    return ReturnStatement;
	}());
	exports.ReturnStatement = ReturnStatement;
	var Script = (function () {
	    function Script(body) {
	        this.type = syntax_1.Syntax.Program;
	        this.body = body;
	        this.sourceType = 'script';
	    }
	    return Script;
	}());
	exports.Script = Script;
	var SequenceExpression = (function () {
	    function SequenceExpression(expressions) {
	        this.type = syntax_1.Syntax.SequenceExpression;
	        this.expressions = expressions;
	    }
	    return SequenceExpression;
	}());
	exports.SequenceExpression = SequenceExpression;
	var SpreadElement = (function () {
	    function SpreadElement(argument) {
	        this.type = syntax_1.Syntax.SpreadElement;
	        this.argument = argument;
	    }
	    return SpreadElement;
	}());
	exports.SpreadElement = SpreadElement;
	var StaticMemberExpression = (function () {
	    function StaticMemberExpression(object, property) {
	        this.type = syntax_1.Syntax.MemberExpression;
	        this.computed = false;
	        this.object = object;
	        this.property = property;
	    }
	    return StaticMemberExpression;
	}());
	exports.StaticMemberExpression = StaticMemberExpression;
	var Super = (function () {
	    function Super() {
	        this.type = syntax_1.Syntax.Super;
	    }
	    return Super;
	}());
	exports.Super = Super;
	var SwitchCase = (function () {
	    function SwitchCase(test, consequent) {
	        this.type = syntax_1.Syntax.SwitchCase;
	        this.test = test;
	        this.consequent = consequent;
	    }
	    return SwitchCase;
	}());
	exports.SwitchCase = SwitchCase;
	var SwitchStatement = (function () {
	    function SwitchStatement(discriminant, cases) {
	        this.type = syntax_1.Syntax.SwitchStatement;
	        this.discriminant = discriminant;
	        this.cases = cases;
	    }
	    return SwitchStatement;
	}());
	exports.SwitchStatement = SwitchStatement;
	var TaggedTemplateExpression = (function () {
	    function TaggedTemplateExpression(tag, quasi) {
	        this.type = syntax_1.Syntax.TaggedTemplateExpression;
	        this.tag = tag;
	        this.quasi = quasi;
	    }
	    return TaggedTemplateExpression;
	}());
	exports.TaggedTemplateExpression = TaggedTemplateExpression;
	var TemplateElement = (function () {
	    function TemplateElement(value, tail) {
	        this.type = syntax_1.Syntax.TemplateElement;
	        this.value = value;
	        this.tail = tail;
	    }
	    return TemplateElement;
	}());
	exports.TemplateElement = TemplateElement;
	var TemplateLiteral = (function () {
	    function TemplateLiteral(quasis, expressions) {
	        this.type = syntax_1.Syntax.TemplateLiteral;
	        this.quasis = quasis;
	        this.expressions = expressions;
	    }
	    return TemplateLiteral;
	}());
	exports.TemplateLiteral = TemplateLiteral;
	var ThisExpression = (function () {
	    function ThisExpression() {
	        this.type = syntax_1.Syntax.ThisExpression;
	    }
	    return ThisExpression;
	}());
	exports.ThisExpression = ThisExpression;
	var ThrowStatement = (function () {
	    function ThrowStatement(argument) {
	        this.type = syntax_1.Syntax.ThrowStatement;
	        this.argument = argument;
	    }
	    return ThrowStatement;
	}());
	exports.ThrowStatement = ThrowStatement;
	var TryStatement = (function () {
	    function TryStatement(block, handler, finalizer) {
	        this.type = syntax_1.Syntax.TryStatement;
	        this.block = block;
	        this.handler = handler;
	        this.finalizer = finalizer;
	    }
	    return TryStatement;
	}());
	exports.TryStatement = TryStatement;
	var UnaryExpression = (function () {
	    function UnaryExpression(operator, argument) {
	        this.type = syntax_1.Syntax.UnaryExpression;
	        this.operator = operator;
	        this.argument = argument;
	        this.prefix = true;
	    }
	    return UnaryExpression;
	}());
	exports.UnaryExpression = UnaryExpression;
	var UpdateExpression = (function () {
	    function UpdateExpression(operator, argument, prefix) {
	        this.type = syntax_1.Syntax.UpdateExpression;
	        this.operator = operator;
	        this.argument = argument;
	        this.prefix = prefix;
	    }
	    return UpdateExpression;
	}());
	exports.UpdateExpression = UpdateExpression;
	var VariableDeclaration = (function () {
	    function VariableDeclaration(declarations, kind) {
	        this.type = syntax_1.Syntax.VariableDeclaration;
	        this.declarations = declarations;
	        this.kind = kind;
	    }
	    return VariableDeclaration;
	}());
	exports.VariableDeclaration = VariableDeclaration;
	var VariableDeclarator = (function () {
	    function VariableDeclarator(id, init) {
	        this.type = syntax_1.Syntax.VariableDeclarator;
	        this.id = id;
	        this.init = init;
	    }
	    return VariableDeclarator;
	}());
	exports.VariableDeclarator = VariableDeclarator;
	var WhileStatement = (function () {
	    function WhileStatement(test, body) {
	        this.type = syntax_1.Syntax.WhileStatement;
	        this.test = test;
	        this.body = body;
	    }
	    return WhileStatement;
	}());
	exports.WhileStatement = WhileStatement;
	var WithStatement = (function () {
	    function WithStatement(object, body) {
	        this.type = syntax_1.Syntax.WithStatement;
	        this.object = object;
	        this.body = body;
	    }
	    return WithStatement;
	}());
	exports.WithStatement = WithStatement;
	var YieldExpression = (function () {
	    function YieldExpression(argument, delegate) {
	        this.type = syntax_1.Syntax.YieldExpression;
	        this.argument = argument;
	        this.delegate = delegate;
	    }
	    return YieldExpression;
	}());
	exports.YieldExpression = YieldExpression;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = __webpack_require__(9);
	var error_handler_1 = __webpack_require__(10);
	var messages_1 = __webpack_require__(11);
	var Node = __webpack_require__(7);
	var scanner_1 = __webpack_require__(12);
	var syntax_1 = __webpack_require__(2);
	var token_1 = __webpack_require__(13);
	var ArrowParameterPlaceHolder = 'ArrowParameterPlaceHolder';
	var Parser = (function () {
	    function Parser(code, options, delegate) {
	        if (options === void 0) { options = {}; }
	        this.config = {
	            range: (typeof options.range === 'boolean') && options.range,
	            loc: (typeof options.loc === 'boolean') && options.loc,
	            source: null,
	            tokens: (typeof options.tokens === 'boolean') && options.tokens,
	            comment: (typeof options.comment === 'boolean') && options.comment,
	            tolerant: (typeof options.tolerant === 'boolean') && options.tolerant
	        };
	        if (this.config.loc && options.source && options.source !== null) {
	            this.config.source = String(options.source);
	        }
	        this.delegate = delegate;
	        this.errorHandler = new error_handler_1.ErrorHandler();
	        this.errorHandler.tolerant = this.config.tolerant;
	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
	        this.scanner.trackComment = this.config.comment;
	        this.operatorPrecedence = {
	            ')': 0,
	            ';': 0,
	            ',': 0,
	            '=': 0,
	            ']': 0,
	            '||': 1,
	            '&&': 2,
	            '|': 3,
	            '^': 4,
	            '&': 5,
	            '==': 6,
	            '!=': 6,
	            '===': 6,
	            '!==': 6,
	            '<': 7,
	            '>': 7,
	            '<=': 7,
	            '>=': 7,
	            '<<': 8,
	            '>>': 8,
	            '>>>': 8,
	            '+': 9,
	            '-': 9,
	            '*': 11,
	            '/': 11,
	            '%': 11
	        };
	        this.lookahead = {
	            type: 2 /* EOF */,
	            value: '',
	            lineNumber: this.scanner.lineNumber,
	            lineStart: 0,
	            start: 0,
	            end: 0
	        };
	        this.hasLineTerminator = false;
	        this.context = {
	            isModule: false,
	            await: false,
	            allowIn: true,
	            allowStrictDirective: true,
	            allowYield: true,
	            firstCoverInitializedNameError: null,
	            isAssignmentTarget: false,
	            isBindingElement: false,
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            labelSet: {},
	            strict: false
	        };
	        this.tokens = [];
	        this.startMarker = {
	            index: 0,
	            line: this.scanner.lineNumber,
	            column: 0
	        };
	        this.lastMarker = {
	            index: 0,
	            line: this.scanner.lineNumber,
	            column: 0
	        };
	        this.nextToken();
	        this.lastMarker = {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    }
	    Parser.prototype.throwError = function (messageFormat) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var args = Array.prototype.slice.call(arguments, 1);
	        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
	            assert_1.assert(idx < args.length, 'Message reference must be in range');
	            return args[idx];
	        });
	        var index = this.lastMarker.index;
	        var line = this.lastMarker.line;
	        var column = this.lastMarker.column + 1;
	        throw this.errorHandler.createError(index, line, column, msg);
	    };
	    Parser.prototype.tolerateError = function (messageFormat) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var args = Array.prototype.slice.call(arguments, 1);
	        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
	            assert_1.assert(idx < args.length, 'Message reference must be in range');
	            return args[idx];
	        });
	        var index = this.lastMarker.index;
	        var line = this.scanner.lineNumber;
	        var column = this.lastMarker.column + 1;
	        this.errorHandler.tolerateError(index, line, column, msg);
	    };
	    // Throw an exception because of the token.
	    Parser.prototype.unexpectedTokenError = function (token, message) {
	        var msg = message || messages_1.Messages.UnexpectedToken;
	        var value;
	        if (token) {
	            if (!message) {
	                msg = (token.type === 2 /* EOF */) ? messages_1.Messages.UnexpectedEOS :
	                    (token.type === 3 /* Identifier */) ? messages_1.Messages.UnexpectedIdentifier :
	                        (token.type === 6 /* NumericLiteral */) ? messages_1.Messages.UnexpectedNumber :
	                            (token.type === 8 /* StringLiteral */) ? messages_1.Messages.UnexpectedString :
	                                (token.type === 10 /* Template */) ? messages_1.Messages.UnexpectedTemplate :
	                                    messages_1.Messages.UnexpectedToken;
	                if (token.type === 4 /* Keyword */) {
	                    if (this.scanner.isFutureReservedWord(token.value)) {
	                        msg = messages_1.Messages.UnexpectedReserved;
	                    }
	                    else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
	                        msg = messages_1.Messages.StrictReservedWord;
	                    }
	                }
	            }
	            value = token.value;
	        }
	        else {
	            value = 'ILLEGAL';
	        }
	        msg = msg.replace('%0', value);
	        if (token && typeof token.lineNumber === 'number') {
	            var index = token.start;
	            var line = token.lineNumber;
	            var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
	            var column = token.start - lastMarkerLineStart + 1;
	            return this.errorHandler.createError(index, line, column, msg);
	        }
	        else {
	            var index = this.lastMarker.index;
	            var line = this.lastMarker.line;
	            var column = this.lastMarker.column + 1;
	            return this.errorHandler.createError(index, line, column, msg);
	        }
	    };
	    Parser.prototype.throwUnexpectedToken = function (token, message) {
	        throw this.unexpectedTokenError(token, message);
	    };
	    Parser.prototype.tolerateUnexpectedToken = function (token, message) {
	        this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
	    };
	    Parser.prototype.collectComments = function () {
	        if (!this.config.comment) {
	            this.scanner.scanComments();
	        }
	        else {
	            var comments = this.scanner.scanComments();
	            if (comments.length > 0 && this.delegate) {
	                for (var i = 0; i < comments.length; ++i) {
	                    var e = comments[i];
	                    var node = void 0;
	                    node = {
	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
	                        value: this.scanner.source.slice(e.slice[0], e.slice[1])
	                    };
	                    if (this.config.range) {
	                        node.range = e.range;
	                    }
	                    if (this.config.loc) {
	                        node.loc = e.loc;
	                    }
	                    var metadata = {
	                        start: {
	                            line: e.loc.start.line,
	                            column: e.loc.start.column,
	                            offset: e.range[0]
	                        },
	                        end: {
	                            line: e.loc.end.line,
	                            column: e.loc.end.column,
	                            offset: e.range[1]
	                        }
	                    };
	                    this.delegate(node, metadata);
	                }
	            }
	        }
	    };
	    // From internal representation to an external structure
	    Parser.prototype.getTokenRaw = function (token) {
	        return this.scanner.source.slice(token.start, token.end);
	    };
	    Parser.prototype.convertToken = function (token) {
	        var t = {
	            type: token_1.TokenName[token.type],
	            value: this.getTokenRaw(token)
	        };
	        if (this.config.range) {
	            t.range = [token.start, token.end];
	        }
	        if (this.config.loc) {
	            t.loc = {
	                start: {
	                    line: this.startMarker.line,
	                    column: this.startMarker.column
	                },
	                end: {
	                    line: this.scanner.lineNumber,
	                    column: this.scanner.index - this.scanner.lineStart
	                }
	            };
	        }
	        if (token.type === 9 /* RegularExpression */) {
	            var pattern = token.pattern;
	            var flags = token.flags;
	            t.regex = { pattern: pattern, flags: flags };
	        }
	        return t;
	    };
	    Parser.prototype.nextToken = function () {
	        var token = this.lookahead;
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        this.collectComments();
	        if (this.scanner.index !== this.startMarker.index) {
	            this.startMarker.index = this.scanner.index;
	            this.startMarker.line = this.scanner.lineNumber;
	            this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        }
	        var next = this.scanner.lex();
	        this.hasLineTerminator = (token.lineNumber !== next.lineNumber);
	        if (next && this.context.strict && next.type === 3 /* Identifier */) {
	            if (this.scanner.isStrictModeReservedWord(next.value)) {
	                next.type = 4 /* Keyword */;
	            }
	        }
	        this.lookahead = next;
	        if (this.config.tokens && next.type !== 2 /* EOF */) {
	            this.tokens.push(this.convertToken(next));
	        }
	        return token;
	    };
	    Parser.prototype.nextRegexToken = function () {
	        this.collectComments();
	        var token = this.scanner.scanRegExp();
	        if (this.config.tokens) {
	            // Pop the previous token, '/' or '/='
	            // This is added from the lookahead token.
	            this.tokens.pop();
	            this.tokens.push(this.convertToken(token));
	        }
	        // Prime the next lookahead.
	        this.lookahead = token;
	        this.nextToken();
	        return token;
	    };
	    Parser.prototype.createNode = function () {
	        return {
	            index: this.startMarker.index,
	            line: this.startMarker.line,
	            column: this.startMarker.column
	        };
	    };
	    Parser.prototype.startNode = function (token) {
	        return {
	            index: token.start,
	            line: token.lineNumber,
	            column: token.start - token.lineStart
	        };
	    };
	    Parser.prototype.finalize = function (marker, node) {
	        if (this.config.range) {
	            node.range = [marker.index, this.lastMarker.index];
	        }
	        if (this.config.loc) {
	            node.loc = {
	                start: {
	                    line: marker.line,
	                    column: marker.column,
	                },
	                end: {
	                    line: this.lastMarker.line,
	                    column: this.lastMarker.column
	                }
	            };
	            if (this.config.source) {
	                node.loc.source = this.config.source;
	            }
	        }
	        if (this.delegate) {
	            var metadata = {
	                start: {
	                    line: marker.line,
	                    column: marker.column,
	                    offset: marker.index
	                },
	                end: {
	                    line: this.lastMarker.line,
	                    column: this.lastMarker.column,
	                    offset: this.lastMarker.index
	                }
	            };
	            this.delegate(node, metadata);
	        }
	        return node;
	    };
	    // Expect the next token to match the specified punctuator.
	    // If not, an exception will be thrown.
	    Parser.prototype.expect = function (value) {
	        var token = this.nextToken();
	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Quietly expect a comma when in tolerant mode, otherwise delegates to expect().
	    Parser.prototype.expectCommaSeparator = function () {
	        if (this.config.tolerant) {
	            var token = this.lookahead;
	            if (token.type === 7 /* Punctuator */ && token.value === ',') {
	                this.nextToken();
	            }
	            else if (token.type === 7 /* Punctuator */ && token.value === ';') {
	                this.nextToken();
	                this.tolerateUnexpectedToken(token);
	            }
	            else {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
	            }
	        }
	        else {
	            this.expect(',');
	        }
	    };
	    // Expect the next token to match the specified keyword.
	    // If not, an exception will be thrown.
	    Parser.prototype.expectKeyword = function (keyword) {
	        var token = this.nextToken();
	        if (token.type !== 4 /* Keyword */ || token.value !== keyword) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Return true if the next token matches the specified punctuator.
	    Parser.prototype.match = function (value) {
	        return this.lookahead.type === 7 /* Punctuator */ && this.lookahead.value === value;
	    };
	    // Return true if the next token matches the specified keyword
	    Parser.prototype.matchKeyword = function (keyword) {
	        return this.lookahead.type === 4 /* Keyword */ && this.lookahead.value === keyword;
	    };
	    // Return true if the next token matches the specified contextual keyword
	    // (where an identifier is sometimes a keyword depending on the context)
	    Parser.prototype.matchContextualKeyword = function (keyword) {
	        return this.lookahead.type === 3 /* Identifier */ && this.lookahead.value === keyword;
	    };
	    // Return true if the next token is an assignment operator
	    Parser.prototype.matchAssign = function () {
	        if (this.lookahead.type !== 7 /* Punctuator */) {
	            return false;
	        }
	        var op = this.lookahead.value;
	        return op === '=' ||
	            op === '*=' ||
	            op === '**=' ||
	            op === '/=' ||
	            op === '%=' ||
	            op === '+=' ||
	            op === '-=' ||
	            op === '<<=' ||
	            op === '>>=' ||
	            op === '>>>=' ||
	            op === '&=' ||
	            op === '^=' ||
	            op === '|=';
	    };
	    // Cover grammar support.
	    //
	    // When an assignment expression position starts with an left parenthesis, the determination of the type
	    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
	    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
	    //
	    // There are three productions that can be parsed in a parentheses pair that needs to be determined
	    // after the outermost pair is closed. They are:
	    //
	    //   1. AssignmentExpression
	    //   2. BindingElements
	    //   3. AssignmentTargets
	    //
	    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
	    // binding element or assignment target.
	    //
	    // The three productions have the relationship:
	    //
	    //   BindingElements â AssignmentTargets â AssignmentExpression
	    //
	    // with a single exception that CoverInitializedName when used directly in an Expression, generates
	    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
	    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
	    //
	    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
	    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
	    // the CoverInitializedName check is conducted.
	    //
	    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
	    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
	    // pattern. The CoverInitializedName check is deferred.
	    Parser.prototype.isolateCoverGrammar = function (parseFunction) {
	        var previousIsBindingElement = this.context.isBindingElement;
	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
	        this.context.isBindingElement = true;
	        this.context.isAssignmentTarget = true;
	        this.context.firstCoverInitializedNameError = null;
	        var result = parseFunction.call(this);
	        if (this.context.firstCoverInitializedNameError !== null) {
	            this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
	        }
	        this.context.isBindingElement = previousIsBindingElement;
	        this.context.isAssignmentTarget = previousIsAssignmentTarget;
	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
	        return result;
	    };
	    Parser.prototype.inheritCoverGrammar = function (parseFunction) {
	        var previousIsBindingElement = this.context.isBindingElement;
	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
	        this.context.isBindingElement = true;
	        this.context.isAssignmentTarget = true;
	        this.context.firstCoverInitializedNameError = null;
	        var result = parseFunction.call(this);
	        this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
	        this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
	        return result;
	    };
	    Parser.prototype.consumeSemicolon = function () {
	        if (this.match(';')) {
	            this.nextToken();
	        }
	        else if (!this.hasLineTerminator) {
	            if (this.lookahead.type !== 2 /* EOF */ && !this.match('}')) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            this.lastMarker.index = this.startMarker.index;
	            this.lastMarker.line = this.startMarker.line;
	            this.lastMarker.column = this.startMarker.column;
	        }
	    };
	    // https://tc39.github.io/ecma262/#sec-primary-expression
	    Parser.prototype.parsePrimaryExpression = function () {
	        var node = this.createNode();
	        var expr;
	        var token, raw;
	        switch (this.lookahead.type) {
	            case 3 /* Identifier */:
	                if ((this.context.isModule || this.context.await) && this.lookahead.value === 'await') {
	                    this.tolerateUnexpectedToken(this.lookahead);
	                }
	                expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
	                break;
	            case 6 /* NumericLiteral */:
	            case 8 /* StringLiteral */:
	                if (this.context.strict && this.lookahead.octal) {
	                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
	                }
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(token.value, raw));
	                break;
	            case 1 /* BooleanLiteral */:
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(token.value === 'true', raw));
	                break;
	            case 5 /* NullLiteral */:
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(null, raw));
	                break;
	            case 10 /* Template */:
	                expr = this.parseTemplateLiteral();
	                break;
	            case 7 /* Punctuator */:
	                switch (this.lookahead.value) {
	                    case '(':
	                        this.context.isBindingElement = false;
	                        expr = this.inheritCoverGrammar(this.parseGroupExpression);
	                        break;
	                    case '[':
	                        expr = this.inheritCoverGrammar(this.parseArrayInitializer);
	                        break;
	                    case '{':
	                        expr = this.inheritCoverGrammar(this.parseObjectInitializer);
	                        break;
	                    case '/':
	                    case '/=':
	                        this.context.isAssignmentTarget = false;
	                        this.context.isBindingElement = false;
	                        this.scanner.index = this.startMarker.index;
	                        token = this.nextRegexToken();
	                        raw = this.getTokenRaw(token);
	                        expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
	                        break;
	                    default:
	                        expr = this.throwUnexpectedToken(this.nextToken());
	                }
	                break;
	            case 4 /* Keyword */:
	                if (!this.context.strict && this.context.allowYield && this.matchKeyword('yield')) {
	                    expr = this.parseIdentifierName();
	                }
	                else if (!this.context.strict && this.matchKeyword('let')) {
	                    expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
	                }
	                else {
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    if (this.matchKeyword('function')) {
	                        expr = this.parseFunctionExpression();
	                    }
	                    else if (this.matchKeyword('this')) {
	                        this.nextToken();
	                        expr = this.finalize(node, new Node.ThisExpression());
	                    }
	                    else if (this.matchKeyword('class')) {
	                        expr = this.parseClassExpression();
	                    }
	                    else {
	                        expr = this.throwUnexpectedToken(this.nextToken());
	                    }
	                }
	                break;
	            default:
	                expr = this.throwUnexpectedToken(this.nextToken());
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-array-initializer
	    Parser.prototype.parseSpreadElement = function () {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
	        return this.finalize(node, new Node.SpreadElement(arg));
	    };
	    Parser.prototype.parseArrayInitializer = function () {
	        var node = this.createNode();
	        var elements = [];
	        this.expect('[');
	        while (!this.match(']')) {
	            if (this.match(',')) {
	                this.nextToken();
	                elements.push(null);
	            }
	            else if (this.match('...')) {
	                var element = this.parseSpreadElement();
	                if (!this.match(']')) {
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    this.expect(',');
	                }
	                elements.push(element);
	            }
	            else {
	                elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
	                if (!this.match(']')) {
	                    this.expect(',');
	                }
	            }
	        }
	        this.expect(']');
	        return this.finalize(node, new Node.ArrayExpression(elements));
	    };
	    // https://tc39.github.io/ecma262/#sec-object-initializer
	    Parser.prototype.parsePropertyMethod = function (params) {
	        this.context.isAssignmentTarget = false;
	        this.context.isBindingElement = false;
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = params.simple;
	        var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
	        if (this.context.strict && params.firstRestricted) {
	            this.tolerateUnexpectedToken(params.firstRestricted, params.message);
	        }
	        if (this.context.strict && params.stricted) {
	            this.tolerateUnexpectedToken(params.stricted, params.message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        return body;
	    };
	    Parser.prototype.parsePropertyMethodFunction = function () {
	        var isGenerator = false;
	        var node = this.createNode();
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = false;
	        var params = this.parseFormalParameters();
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
	    };
	    Parser.prototype.parsePropertyMethodAsyncFunction = function () {
	        var node = this.createNode();
	        var previousAllowYield = this.context.allowYield;
	        var previousAwait = this.context.await;
	        this.context.allowYield = false;
	        this.context.await = true;
	        var params = this.parseFormalParameters();
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        this.context.await = previousAwait;
	        return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
	    };
	    Parser.prototype.parseObjectPropertyKey = function () {
	        var node = this.createNode();
	        var token = this.nextToken();
	        var key;
	        switch (token.type) {
	            case 8 /* StringLiteral */:
	            case 6 /* NumericLiteral */:
	                if (this.context.strict && token.octal) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
	                }
	                var raw = this.getTokenRaw(token);
	                key = this.finalize(node, new Node.Literal(token.value, raw));
	                break;
	            case 3 /* Identifier */:
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 4 /* Keyword */:
	                key = this.finalize(node, new Node.Identifier(token.value));
	                break;
	            case 7 /* Punctuator */:
	                if (token.value === '[') {
	                    key = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    this.expect(']');
	                }
	                else {
	                    key = this.throwUnexpectedToken(token);
	                }
	                break;
	            default:
	                key = this.throwUnexpectedToken(token);
	        }
	        return key;
	    };
	    Parser.prototype.isPropertyKey = function (key, value) {
	        return (key.type === syntax_1.Syntax.Identifier && key.name === value) ||
	            (key.type === syntax_1.Syntax.Literal && key.value === value);
	    };
	    Parser.prototype.parseObjectProperty = function (hasProto) {
	        var node = this.createNode();
	        var token = this.lookahead;
	        var kind;
	        var key = null;
	        var value = null;
	        var computed = false;
	        var method = false;
	        var shorthand = false;
	        var isAsync = false;
	        if (token.type === 3 /* Identifier */) {
	            var id = token.value;
	            this.nextToken();
	            computed = this.match('[');
	            isAsync = !this.hasLineTerminator && (id === 'async') &&
	                !this.match(':') && !this.match('(') && !this.match('*');
	            key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
	        }
	        else if (this.match('*')) {
	            this.nextToken();
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	        }
	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
	        if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'get' && lookaheadPropertyKey) {
	            kind = 'get';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            this.context.allowYield = false;
	            value = this.parseGetterMethod();
	        }
	        else if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'set' && lookaheadPropertyKey) {
	            kind = 'set';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseSetterMethod();
	        }
	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
	            kind = 'init';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseGeneratorMethod();
	            method = true;
	        }
	        else {
	            if (!key) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            kind = 'init';
	            if (this.match(':') && !isAsync) {
	                if (!computed && this.isPropertyKey(key, '__proto__')) {
	                    if (hasProto.value) {
	                        this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
	                    }
	                    hasProto.value = true;
	                }
	                this.nextToken();
	                value = this.inheritCoverGrammar(this.parseAssignmentExpression);
	            }
	            else if (this.match('(')) {
	                value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
	                method = true;
	            }
	            else if (token.type === 3 /* Identifier */) {
	                var id = this.finalize(node, new Node.Identifier(token.value));
	                if (this.match('=')) {
	                    this.context.firstCoverInitializedNameError = this.lookahead;
	                    this.nextToken();
	                    shorthand = true;
	                    var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    value = this.finalize(node, new Node.AssignmentPattern(id, init));
	                }
	                else {
	                    shorthand = true;
	                    value = id;
	                }
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	        }
	        return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
	    };
	    Parser.prototype.parseObjectInitializer = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var properties = [];
	        var hasProto = { value: false };
	        while (!this.match('}')) {
	            properties.push(this.parseObjectProperty(hasProto));
	            if (!this.match('}')) {
	                this.expectCommaSeparator();
	            }
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.ObjectExpression(properties));
	    };
	    // https://tc39.github.io/ecma262/#sec-template-literals
	    Parser.prototype.parseTemplateHead = function () {
	        assert_1.assert(this.lookahead.head, 'Template literal must start with a template head');
	        var node = this.createNode();
	        var token = this.nextToken();
	        var raw = token.value;
	        var cooked = token.cooked;
	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
	    };
	    Parser.prototype.parseTemplateElement = function () {
	        if (this.lookahead.type !== 10 /* Template */) {
	            this.throwUnexpectedToken();
	        }
	        var node = this.createNode();
	        var token = this.nextToken();
	        var raw = token.value;
	        var cooked = token.cooked;
	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
	    };
	    Parser.prototype.parseTemplateLiteral = function () {
	        var node = this.createNode();
	        var expressions = [];
	        var quasis = [];
	        var quasi = this.parseTemplateHead();
	        quasis.push(quasi);
	        while (!quasi.tail) {
	            expressions.push(this.parseExpression());
	            quasi = this.parseTemplateElement();
	            quasis.push(quasi);
	        }
	        return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
	    };
	    // https://tc39.github.io/ecma262/#sec-grouping-operator
	    Parser.prototype.reinterpretExpressionAsPattern = function (expr) {
	        switch (expr.type) {
	            case syntax_1.Syntax.Identifier:
	            case syntax_1.Syntax.MemberExpression:
	            case syntax_1.Syntax.RestElement:
	            case syntax_1.Syntax.AssignmentPattern:
	                break;
	            case syntax_1.Syntax.SpreadElement:
	                expr.type = syntax_1.Syntax.RestElement;
	                this.reinterpretExpressionAsPattern(expr.argument);
	                break;
	            case syntax_1.Syntax.ArrayExpression:
	                expr.type = syntax_1.Syntax.ArrayPattern;
	                for (var i = 0; i < expr.elements.length; i++) {
	                    if (expr.elements[i] !== null) {
	                        this.reinterpretExpressionAsPattern(expr.elements[i]);
	                    }
	                }
	                break;
	            case syntax_1.Syntax.ObjectExpression:
	                expr.type = syntax_1.Syntax.ObjectPattern;
	                for (var i = 0; i < expr.properties.length; i++) {
	                    this.reinterpretExpressionAsPattern(expr.properties[i].value);
	                }
	                break;
	            case syntax_1.Syntax.AssignmentExpression:
	                expr.type = syntax_1.Syntax.AssignmentPattern;
	                delete expr.operator;
	                this.reinterpretExpressionAsPattern(expr.left);
	                break;
	            default:
	                // Allow other node type for tolerant parsing.
	                break;
	        }
	    };
	    Parser.prototype.parseGroupExpression = function () {
	        var expr;
	        this.expect('(');
	        if (this.match(')')) {
	            this.nextToken();
	            if (!this.match('=>')) {
	                this.expect('=>');
	            }
	            expr = {
	                type: ArrowParameterPlaceHolder,
	                params: [],
	                async: false
	            };
	        }
	        else {
	            var startToken = this.lookahead;
	            var params = [];
	            if (this.match('...')) {
	                expr = this.parseRestElement(params);
	                this.expect(')');
	                if (!this.match('=>')) {
	                    this.expect('=>');
	                }
	                expr = {
	                    type: ArrowParameterPlaceHolder,
	                    params: [expr],
	                    async: false
	                };
	            }
	            else {
	                var arrow = false;
	                this.context.isBindingElement = true;
	                expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
	                if (this.match(',')) {
	                    var expressions = [];
	                    this.context.isAssignmentTarget = false;
	                    expressions.push(expr);
	                    while (this.lookahead.type !== 2 /* EOF */) {
	                        if (!this.match(',')) {
	                            break;
	                        }
	                        this.nextToken();
	                        if (this.match(')')) {
	                            this.nextToken();
	                            for (var i = 0; i < expressions.length; i++) {
	                                this.reinterpretExpressionAsPattern(expressions[i]);
	                            }
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: expressions,
	                                async: false
	                            };
	                        }
	                        else if (this.match('...')) {
	                            if (!this.context.isBindingElement) {
	                                this.throwUnexpectedToken(this.lookahead);
	                            }
	                            expressions.push(this.parseRestElement(params));
	                            this.expect(')');
	                            if (!this.match('=>')) {
	                                this.expect('=>');
	                            }
	                            this.context.isBindingElement = false;
	                            for (var i = 0; i < expressions.length; i++) {
	                                this.reinterpretExpressionAsPattern(expressions[i]);
	                            }
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: expressions,
	                                async: false
	                            };
	                        }
	                        else {
	                            expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
	                        }
	                        if (arrow) {
	                            break;
	                        }
	                    }
	                    if (!arrow) {
	                        expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
	                    }
	                }
	                if (!arrow) {
	                    this.expect(')');
	                    if (this.match('=>')) {
	                        if (expr.type === syntax_1.Syntax.Identifier && expr.name === 'yield') {
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: [expr],
	                                async: false
	                            };
	                        }
	                        if (!arrow) {
	                            if (!this.context.isBindingElement) {
	                                this.throwUnexpectedToken(this.lookahead);
	                            }
	                            if (expr.type === syntax_1.Syntax.SequenceExpression) {
	                                for (var i = 0; i < expr.expressions.length; i++) {
	                                    this.reinterpretExpressionAsPattern(expr.expressions[i]);
	                                }
	                            }
	                            else {
	                                this.reinterpretExpressionAsPattern(expr);
	                            }
	                            var parameters = (expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr]);
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: parameters,
	                                async: false
	                            };
	                        }
	                    }
	                    this.context.isBindingElement = false;
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-left-hand-side-expressions
	    Parser.prototype.parseArguments = function () {
	        this.expect('(');
	        var args = [];
	        if (!this.match(')')) {
	            while (true) {
	                var expr = this.match('...') ? this.parseSpreadElement() :
	                    this.isolateCoverGrammar(this.parseAssignmentExpression);
	                args.push(expr);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expectCommaSeparator();
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return args;
	    };
	    Parser.prototype.isIdentifierName = function (token) {
	        return token.type === 3 /* Identifier */ ||
	            token.type === 4 /* Keyword */ ||
	            token.type === 1 /* BooleanLiteral */ ||
	            token.type === 5 /* NullLiteral */;
	    };
	    Parser.prototype.parseIdentifierName = function () {
	        var node = this.createNode();
	        var token = this.nextToken();
	        if (!this.isIdentifierName(token)) {
	            this.throwUnexpectedToken(token);
	        }
	        return this.finalize(node, new Node.Identifier(token.value));
	    };
	    Parser.prototype.parseNewExpression = function () {
	        var node = this.createNode();
	        var id = this.parseIdentifierName();
	        assert_1.assert(id.name === 'new', 'New expression must start with `new`');
	        var expr;
	        if (this.match('.')) {
	            this.nextToken();
	            if (this.lookahead.type === 3 /* Identifier */ && this.context.inFunctionBody && this.lookahead.value === 'target') {
	                var property = this.parseIdentifierName();
	                expr = new Node.MetaProperty(id, property);
	            }
	            else {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	        }
	        else {
	            var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
	            var args = this.match('(') ? this.parseArguments() : [];
	            expr = new Node.NewExpression(callee, args);
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        return this.finalize(node, expr);
	    };
	    Parser.prototype.parseAsyncArgument = function () {
	        var arg = this.parseAssignmentExpression();
	        this.context.firstCoverInitializedNameError = null;
	        return arg;
	    };
	    Parser.prototype.parseAsyncArguments = function () {
	        this.expect('(');
	        var args = [];
	        if (!this.match(')')) {
	            while (true) {
	                var expr = this.match('...') ? this.parseSpreadElement() :
	                    this.isolateCoverGrammar(this.parseAsyncArgument);
	                args.push(expr);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expectCommaSeparator();
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return args;
	    };
	    Parser.prototype.parseLeftHandSideExpressionAllowCall = function () {
	        var startToken = this.lookahead;
	        var maybeAsync = this.matchContextualKeyword('async');
	        var previousAllowIn = this.context.allowIn;
	        this.context.allowIn = true;
	        var expr;
	        if (this.matchKeyword('super') && this.context.inFunctionBody) {
	            expr = this.createNode();
	            this.nextToken();
	            expr = this.finalize(expr, new Node.Super());
	            if (!this.match('(') && !this.match('.') && !this.match('[')) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	        }
	        else {
	            expr = this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
	        }
	        while (true) {
	            if (this.match('.')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('.');
	                var property = this.parseIdentifierName();
	                expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
	            }
	            else if (this.match('(')) {
	                var asyncArrow = maybeAsync && (startToken.lineNumber === this.lookahead.lineNumber);
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = false;
	                var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
	                expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
	                if (asyncArrow && this.match('=>')) {
	                    for (var i = 0; i < args.length; ++i) {
	                        this.reinterpretExpressionAsPattern(args[i]);
	                    }
	                    expr = {
	                        type: ArrowParameterPlaceHolder,
	                        params: args,
	                        async: true
	                    };
	                }
	            }
	            else if (this.match('[')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('[');
	                var property = this.isolateCoverGrammar(this.parseExpression);
	                this.expect(']');
	                expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
	            }
	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
	                var quasi = this.parseTemplateLiteral();
	                expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
	            }
	            else {
	                break;
	            }
	        }
	        this.context.allowIn = previousAllowIn;
	        return expr;
	    };
	    Parser.prototype.parseSuper = function () {
	        var node = this.createNode();
	        this.expectKeyword('super');
	        if (!this.match('[') && !this.match('.')) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        return this.finalize(node, new Node.Super());
	    };
	    Parser.prototype.parseLeftHandSideExpression = function () {
	        assert_1.assert(this.context.allowIn, 'callee of new expression always allow in keyword.');
	        var node = this.startNode(this.lookahead);
	        var expr = (this.matchKeyword('super') && this.context.inFunctionBody) ? this.parseSuper() :
	            this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
	        while (true) {
	            if (this.match('[')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('[');
	                var property = this.isolateCoverGrammar(this.parseExpression);
	                this.expect(']');
	                expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
	            }
	            else if (this.match('.')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('.');
	                var property = this.parseIdentifierName();
	                expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
	            }
	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
	                var quasi = this.parseTemplateLiteral();
	                expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
	            }
	            else {
	                break;
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-update-expressions
	    Parser.prototype.parseUpdateExpression = function () {
	        var expr;
	        var startToken = this.lookahead;
	        if (this.match('++') || this.match('--')) {
	            var node = this.startNode(startToken);
	            var token = this.nextToken();
	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	            if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
	                this.tolerateError(messages_1.Messages.StrictLHSPrefix);
	            }
	            if (!this.context.isAssignmentTarget) {
	                this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	            }
	            var prefix = true;
	            expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        else {
	            expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	            if (!this.hasLineTerminator && this.lookahead.type === 7 /* Punctuator */) {
	                if (this.match('++') || this.match('--')) {
	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
	                        this.tolerateError(messages_1.Messages.StrictLHSPostfix);
	                    }
	                    if (!this.context.isAssignmentTarget) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	                    }
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    var operator = this.nextToken().value;
	                    var prefix = false;
	                    expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-unary-operators
	    Parser.prototype.parseAwaitExpression = function () {
	        var node = this.createNode();
	        this.nextToken();
	        var argument = this.parseUnaryExpression();
	        return this.finalize(node, new Node.AwaitExpression(argument));
	    };
	    Parser.prototype.parseUnaryExpression = function () {
	        var expr;
	        if (this.match('+') || this.match('-') || this.match('~') || this.match('!') ||
	            this.matchKeyword('delete') || this.matchKeyword('void') || this.matchKeyword('typeof')) {
	            var node = this.startNode(this.lookahead);
	            var token = this.nextToken();
	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	            expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
	            if (this.context.strict && expr.operator === 'delete' && expr.argument.type === syntax_1.Syntax.Identifier) {
	                this.tolerateError(messages_1.Messages.StrictDelete);
	            }
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        else if (this.context.await && this.matchContextualKeyword('await')) {
	            expr = this.parseAwaitExpression();
	        }
	        else {
	            expr = this.parseUpdateExpression();
	        }
	        return expr;
	    };
	    Parser.prototype.parseExponentiationExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	        if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match('**')) {
	            this.nextToken();
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	            var left = expr;
	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
	            expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression('**', left, right));
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-exp-operator
	    // https://tc39.github.io/ecma262/#sec-multiplicative-operators
	    // https://tc39.github.io/ecma262/#sec-additive-operators
	    // https://tc39.github.io/ecma262/#sec-bitwise-shift-operators
	    // https://tc39.github.io/ecma262/#sec-relational-operators
	    // https://tc39.github.io/ecma262/#sec-equality-operators
	    // https://tc39.github.io/ecma262/#sec-binary-bitwise-operators
	    // https://tc39.github.io/ecma262/#sec-binary-logical-operators
	    Parser.prototype.binaryPrecedence = function (token) {
	        var op = token.value;
	        var precedence;
	        if (token.type === 7 /* Punctuator */) {
	            precedence = this.operatorPrecedence[op] || 0;
	        }
	        else if (token.type === 4 /* Keyword */) {
	            precedence = (op === 'instanceof' || (this.context.allowIn && op === 'in')) ? 7 : 0;
	        }
	        else {
	            precedence = 0;
	        }
	        return precedence;
	    };
	    Parser.prototype.parseBinaryExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
	        var token = this.lookahead;
	        var prec = this.binaryPrecedence(token);
	        if (prec > 0) {
	            this.nextToken();
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	            var markers = [startToken, this.lookahead];
	            var left = expr;
	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
	            var stack = [left, token.value, right];
	            var precedences = [prec];
	            while (true) {
	                prec = this.binaryPrecedence(this.lookahead);
	                if (prec <= 0) {
	                    break;
	                }
	                // Reduce: make a binary expression from the three topmost entries.
	                while ((stack.length > 2) && (prec <= precedences[precedences.length - 1])) {
	                    right = stack.pop();
	                    var operator = stack.pop();
	                    precedences.pop();
	                    left = stack.pop();
	                    markers.pop();
	                    var node = this.startNode(markers[markers.length - 1]);
	                    stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
	                }
	                // Shift.
	                stack.push(this.nextToken().value);
	                precedences.push(prec);
	                markers.push(this.lookahead);
	                stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
	            }
	            // Final reduce to clean-up the stack.
	            var i = stack.length - 1;
	            expr = stack[i];
	            markers.pop();
	            while (i > 1) {
	                var node = this.startNode(markers.pop());
	                var operator = stack[i - 1];
	                expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
	                i -= 2;
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-conditional-operator
	    Parser.prototype.parseConditionalExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
	        if (this.match('?')) {
	            this.nextToken();
	            var previousAllowIn = this.context.allowIn;
	            this.context.allowIn = true;
	            var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            this.context.allowIn = previousAllowIn;
	            this.expect(':');
	            var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-assignment-operators
	    Parser.prototype.checkPatternParam = function (options, param) {
	        switch (param.type) {
	            case syntax_1.Syntax.Identifier:
	                this.validateParam(options, param, param.name);
	                break;
	            case syntax_1.Syntax.RestElement:
	                this.checkPatternParam(options, param.argument);
	                break;
	            case syntax_1.Syntax.AssignmentPattern:
	                this.checkPatternParam(options, param.left);
	                break;
	            case syntax_1.Syntax.ArrayPattern:
	                for (var i = 0; i < param.elements.length; i++) {
	                    if (param.elements[i] !== null) {
	                        this.checkPatternParam(options, param.elements[i]);
	                    }
	                }
	                break;
	            case syntax_1.Syntax.ObjectPattern:
	                for (var i = 0; i < param.properties.length; i++) {
	                    this.checkPatternParam(options, param.properties[i].value);
	                }
	                break;
	            default:
	                break;
	        }
	        options.simple = options.simple && (param instanceof Node.Identifier);
	    };
	    Parser.prototype.reinterpretAsCoverFormalsList = function (expr) {
	        var params = [expr];
	        var options;
	        var asyncArrow = false;
	        switch (expr.type) {
	            case syntax_1.Syntax.Identifier:
	                break;
	            case ArrowParameterPlaceHolder:
	                params = expr.params;
	                asyncArrow = expr.async;
	                break;
	            default:
	                return null;
	        }
	        options = {
	            simple: true,
	            paramSet: {}
	        };
	        for (var i = 0; i < params.length; ++i) {
	            var param = params[i];
	            if (param.type === syntax_1.Syntax.AssignmentPattern) {
	                if (param.right.type === syntax_1.Syntax.YieldExpression) {
	                    if (param.right.argument) {
	                        this.throwUnexpectedToken(this.lookahead);
	                    }
	                    param.right.type = syntax_1.Syntax.Identifier;
	                    param.right.name = 'yield';
	                    delete param.right.argument;
	                    delete param.right.delegate;
	                }
	            }
	            else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === 'await') {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            this.checkPatternParam(options, param);
	            params[i] = param;
	        }
	        if (this.context.strict || !this.context.allowYield) {
	            for (var i = 0; i < params.length; ++i) {
	                var param = params[i];
	                if (param.type === syntax_1.Syntax.YieldExpression) {
	                    this.throwUnexpectedToken(this.lookahead);
	                }
	            }
	        }
	        if (options.message === messages_1.Messages.StrictParamDupe) {
	            var token = this.context.strict ? options.stricted : options.firstRestricted;
	            this.throwUnexpectedToken(token, options.message);
	        }
	        return {
	            simple: options.simple,
	            params: params,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    };
	    Parser.prototype.parseAssignmentExpression = function () {
	        var expr;
	        if (!this.context.allowYield && this.matchKeyword('yield')) {
	            expr = this.parseYieldExpression();
	        }
	        else {
	            var startToken = this.lookahead;
	            var token = startToken;
	            expr = this.parseConditionalExpression();
	            if (token.type === 3 /* Identifier */ && (token.lineNumber === this.lookahead.lineNumber) && token.value === 'async') {
	                if (this.lookahead.type === 3 /* Identifier */ || this.matchKeyword('yield')) {
	                    var arg = this.parsePrimaryExpression();
	                    this.reinterpretExpressionAsPattern(arg);
	                    expr = {
	                        type: ArrowParameterPlaceHolder,
	                        params: [arg],
	                        async: true
	                    };
	                }
	            }
	            if (expr.type === ArrowParameterPlaceHolder || this.match('=>')) {
	                // https://tc39.github.io/ecma262/#sec-arrow-function-definitions
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                var isAsync = expr.async;
	                var list = this.reinterpretAsCoverFormalsList(expr);
	                if (list) {
	                    if (this.hasLineTerminator) {
	                        this.tolerateUnexpectedToken(this.lookahead);
	                    }
	                    this.context.firstCoverInitializedNameError = null;
	                    var previousStrict = this.context.strict;
	                    var previousAllowStrictDirective = this.context.allowStrictDirective;
	                    this.context.allowStrictDirective = list.simple;
	                    var previousAllowYield = this.context.allowYield;
	                    var previousAwait = this.context.await;
	                    this.context.allowYield = true;
	                    this.context.await = isAsync;
	                    var node = this.startNode(startToken);
	                    this.expect('=>');
	                    var body = void 0;
	                    if (this.match('{')) {
	                        var previousAllowIn = this.context.allowIn;
	                        this.context.allowIn = true;
	                        body = this.parseFunctionSourceElements();
	                        this.context.allowIn = previousAllowIn;
	                    }
	                    else {
	                        body = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    }
	                    var expression = body.type !== syntax_1.Syntax.BlockStatement;
	                    if (this.context.strict && list.firstRestricted) {
	                        this.throwUnexpectedToken(list.firstRestricted, list.message);
	                    }
	                    if (this.context.strict && list.stricted) {
	                        this.tolerateUnexpectedToken(list.stricted, list.message);
	                    }
	                    expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) :
	                        this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
	                    this.context.strict = previousStrict;
	                    this.context.allowStrictDirective = previousAllowStrictDirective;
	                    this.context.allowYield = previousAllowYield;
	                    this.context.await = previousAwait;
	                }
	            }
	            else {
	                if (this.matchAssign()) {
	                    if (!this.context.isAssignmentTarget) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	                    }
	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
	                        var id = expr;
	                        if (this.scanner.isRestrictedWord(id.name)) {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
	                        }
	                        if (this.scanner.isStrictModeReservedWord(id.name)) {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	                        }
	                    }
	                    if (!this.match('=')) {
	                        this.context.isAssignmentTarget = false;
	                        this.context.isBindingElement = false;
	                    }
	                    else {
	                        this.reinterpretExpressionAsPattern(expr);
	                    }
	                    token = this.nextToken();
	                    var operator = token.value;
	                    var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
	                    this.context.firstCoverInitializedNameError = null;
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-comma-operator
	    Parser.prototype.parseExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        if (this.match(',')) {
	            var expressions = [];
	            expressions.push(expr);
	            while (this.lookahead.type !== 2 /* EOF */) {
	                if (!this.match(',')) {
	                    break;
	                }
	                this.nextToken();
	                expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
	            }
	            expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-block
	    Parser.prototype.parseStatementListItem = function () {
	        var statement;
	        this.context.isAssignmentTarget = true;
	        this.context.isBindingElement = true;
	        if (this.lookahead.type === 4 /* Keyword */) {
	            switch (this.lookahead.value) {
	                case 'export':
	                    if (!this.context.isModule) {
	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
	                    }
	                    statement = this.parseExportDeclaration();
	                    break;
	                case 'import':
	                    if (!this.context.isModule) {
	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
	                    }
	                    statement = this.parseImportDeclaration();
	                    break;
	                case 'const':
	                    statement = this.parseLexicalDeclaration({ inFor: false });
	                    break;
	                case 'function':
	                    statement = this.parseFunctionDeclaration();
	                    break;
	                case 'class':
	                    statement = this.parseClassDeclaration();
	                    break;
	                case 'let':
	                    statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
	                    break;
	                default:
	                    statement = this.parseStatement();
	                    break;
	            }
	        }
	        else {
	            statement = this.parseStatement();
	        }
	        return statement;
	    };
	    Parser.prototype.parseBlock = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var block = [];
	        while (true) {
	            if (this.match('}')) {
	                break;
	            }
	            block.push(this.parseStatementListItem());
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.BlockStatement(block));
	    };
	    // https://tc39.github.io/ecma262/#sec-let-and-const-declarations
	    Parser.prototype.parseLexicalBinding = function (kind, options) {
	        var node = this.createNode();
	        var params = [];
	        var id = this.parsePattern(params, kind);
	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(id.name)) {
	                this.tolerateError(messages_1.Messages.StrictVarName);
	            }
	        }
	        var init = null;
	        if (kind === 'const') {
	            if (!this.matchKeyword('in') && !this.matchContextualKeyword('of')) {
	                if (this.match('=')) {
	                    this.nextToken();
	                    init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                }
	                else {
	                    this.throwError(messages_1.Messages.DeclarationMissingInitializer, 'const');
	                }
	            }
	        }
	        else if ((!options.inFor && id.type !== syntax_1.Syntax.Identifier) || this.match('=')) {
	            this.expect('=');
	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        }
	        return this.finalize(node, new Node.VariableDeclarator(id, init));
	    };
	    Parser.prototype.parseBindingList = function (kind, options) {
	        var list = [this.parseLexicalBinding(kind, options)];
	        while (this.match(',')) {
	            this.nextToken();
	            list.push(this.parseLexicalBinding(kind, options));
	        }
	        return list;
	    };
	    Parser.prototype.isLexicalDeclaration = function () {
	        var state = this.scanner.saveState();
	        this.scanner.scanComments();
	        var next = this.scanner.lex();
	        this.scanner.restoreState(state);
	        return (next.type === 3 /* Identifier */) ||
	            (next.type === 7 /* Punctuator */ && next.value === '[') ||
	            (next.type === 7 /* Punctuator */ && next.value === '{') ||
	            (next.type === 4 /* Keyword */ && next.value === 'let') ||
	            (next.type === 4 /* Keyword */ && next.value === 'yield');
	    };
	    Parser.prototype.parseLexicalDeclaration = function (options) {
	        var node = this.createNode();
	        var kind = this.nextToken().value;
	        assert_1.assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');
	        var declarations = this.parseBindingList(kind, options);
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
	    };
	    // https://tc39.github.io/ecma262/#sec-destructuring-binding-patterns
	    Parser.prototype.parseBindingRestElement = function (params, kind) {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.parsePattern(params, kind);
	        return this.finalize(node, new Node.RestElement(arg));
	    };
	    Parser.prototype.parseArrayPattern = function (params, kind) {
	        var node = this.createNode();
	        this.expect('[');
	        var elements = [];
	        while (!this.match(']')) {
	            if (this.match(',')) {
	                this.nextToken();
	                elements.push(null);
	            }
	            else {
	                if (this.match('...')) {
	                    elements.push(this.parseBindingRestElement(params, kind));
	                    break;
	                }
	                else {
	                    elements.push(this.parsePatternWithDefault(params, kind));
	                }
	                if (!this.match(']')) {
	                    this.expect(',');
	                }
	            }
	        }
	        this.expect(']');
	        return this.finalize(node, new Node.ArrayPattern(elements));
	    };
	    Parser.prototype.parsePropertyPattern = function (params, kind) {
	        var node = this.createNode();
	        var computed = false;
	        var shorthand = false;
	        var method = false;
	        var key;
	        var value;
	        if (this.lookahead.type === 3 /* Identifier */) {
	            var keyToken = this.lookahead;
	            key = this.parseVariableIdentifier();
	            var init = this.finalize(node, new Node.Identifier(keyToken.value));
	            if (this.match('=')) {
	                params.push(keyToken);
	                shorthand = true;
	                this.nextToken();
	                var expr = this.parseAssignmentExpression();
	                value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
	            }
	            else if (!this.match(':')) {
	                params.push(keyToken);
	                shorthand = true;
	                value = init;
	            }
	            else {
	                this.expect(':');
	                value = this.parsePatternWithDefault(params, kind);
	            }
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            this.expect(':');
	            value = this.parsePatternWithDefault(params, kind);
	        }
	        return this.finalize(node, new Node.Property('init', key, computed, value, method, shorthand));
	    };
	    Parser.prototype.parseObjectPattern = function (params, kind) {
	        var node = this.createNode();
	        var properties = [];
	        this.expect('{');
	        while (!this.match('}')) {
	            properties.push(this.parsePropertyPattern(params, kind));
	            if (!this.match('}')) {
	                this.expect(',');
	            }
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.ObjectPattern(properties));
	    };
	    Parser.prototype.parsePattern = function (params, kind) {
	        var pattern;
	        if (this.match('[')) {
	            pattern = this.parseArrayPattern(params, kind);
	        }
	        else if (this.match('{')) {
	            pattern = this.parseObjectPattern(params, kind);
	        }
	        else {
	            if (this.matchKeyword('let') && (kind === 'const' || kind === 'let')) {
	                this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
	            }
	            params.push(this.lookahead);
	            pattern = this.parseVariableIdentifier(kind);
	        }
	        return pattern;
	    };
	    Parser.prototype.parsePatternWithDefault = function (params, kind) {
	        var startToken = this.lookahead;
	        var pattern = this.parsePattern(params, kind);
	        if (this.match('=')) {
	            this.nextToken();
	            var previousAllowYield = this.context.allowYield;
	            this.context.allowYield = true;
	            var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            this.context.allowYield = previousAllowYield;
	            pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
	        }
	        return pattern;
	    };
	    // https://tc39.github.io/ecma262/#sec-variable-statement
	    Parser.prototype.parseVariableIdentifier = function (kind) {
	        var node = this.createNode();
	        var token = this.nextToken();
	        if (token.type === 4 /* Keyword */ && token.value === 'yield') {
	            if (this.context.strict) {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	            }
	            else if (!this.context.allowYield) {
	                this.throwUnexpectedToken(token);
	            }
	        }
	        else if (token.type !== 3 /* Identifier */) {
	            if (this.context.strict && token.type === 4 /* Keyword */ && this.scanner.isStrictModeReservedWord(token.value)) {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	            }
	            else {
	                if (this.context.strict || token.value !== 'let' || kind !== 'var') {
	                    this.throwUnexpectedToken(token);
	                }
	            }
	        }
	        else if ((this.context.isModule || this.context.await) && token.type === 3 /* Identifier */ && token.value === 'await') {
	            this.tolerateUnexpectedToken(token);
	        }
	        return this.finalize(node, new Node.Identifier(token.value));
	    };
	    Parser.prototype.parseVariableDeclaration = function (options) {
	        var node = this.createNode();
	        var params = [];
	        var id = this.parsePattern(params, 'var');
	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(id.name)) {
	                this.tolerateError(messages_1.Messages.StrictVarName);
	            }
	        }
	        var init = null;
	        if (this.match('=')) {
	            this.nextToken();
	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        }
	        else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
	            this.expect('=');
	        }
	        return this.finalize(node, new Node.VariableDeclarator(id, init));
	    };
	    Parser.prototype.parseVariableDeclarationList = function (options) {
	        var opt = { inFor: options.inFor };
	        var list = [];
	        list.push(this.parseVariableDeclaration(opt));
	        while (this.match(',')) {
	            this.nextToken();
	            list.push(this.parseVariableDeclaration(opt));
	        }
	        return list;
	    };
	    Parser.prototype.parseVariableStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('var');
	        var declarations = this.parseVariableDeclarationList({ inFor: false });
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.VariableDeclaration(declarations, 'var'));
	    };
	    // https://tc39.github.io/ecma262/#sec-empty-statement
	    Parser.prototype.parseEmptyStatement = function () {
	        var node = this.createNode();
	        this.expect(';');
	        return this.finalize(node, new Node.EmptyStatement());
	    };
	    // https://tc39.github.io/ecma262/#sec-expression-statement
	    Parser.prototype.parseExpressionStatement = function () {
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ExpressionStatement(expr));
	    };
	    // https://tc39.github.io/ecma262/#sec-if-statement
	    Parser.prototype.parseIfClause = function () {
	        if (this.context.strict && this.matchKeyword('function')) {
	            this.tolerateError(messages_1.Messages.StrictFunction);
	        }
	        return this.parseStatement();
	    };
	    Parser.prototype.parseIfStatement = function () {
	        var node = this.createNode();
	        var consequent;
	        var alternate = null;
	        this.expectKeyword('if');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            consequent = this.parseIfClause();
	            if (this.matchKeyword('else')) {
	                this.nextToken();
	                alternate = this.parseIfClause();
	            }
	        }
	        return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
	    };
	    // https://tc39.github.io/ecma262/#sec-do-while-statement
	    Parser.prototype.parseDoWhileStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('do');
	        var previousInIteration = this.context.inIteration;
	        this.context.inIteration = true;
	        var body = this.parseStatement();
	        this.context.inIteration = previousInIteration;
	        this.expectKeyword('while');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	        }
	        else {
	            this.expect(')');
	            if (this.match(';')) {
	                this.nextToken();
	            }
	        }
	        return this.finalize(node, new Node.DoWhileStatement(body, test));
	    };
	    // https://tc39.github.io/ecma262/#sec-while-statement
	    Parser.prototype.parseWhileStatement = function () {
	        var node = this.createNode();
	        var body;
	        this.expectKeyword('while');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            var previousInIteration = this.context.inIteration;
	            this.context.inIteration = true;
	            body = this.parseStatement();
	            this.context.inIteration = previousInIteration;
	        }
	        return this.finalize(node, new Node.WhileStatement(test, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-for-statement
	    // https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements
	    Parser.prototype.parseForStatement = function () {
	        var init = null;
	        var test = null;
	        var update = null;
	        var forIn = true;
	        var left, right;
	        var node = this.createNode();
	        this.expectKeyword('for');
	        this.expect('(');
	        if (this.match(';')) {
	            this.nextToken();
	        }
	        else {
	            if (this.matchKeyword('var')) {
	                init = this.createNode();
	                this.nextToken();
	                var previousAllowIn = this.context.allowIn;
	                this.context.allowIn = false;
	                var declarations = this.parseVariableDeclarationList({ inFor: true });
	                this.context.allowIn = previousAllowIn;
	                if (declarations.length === 1 && this.matchKeyword('in')) {
	                    var decl = declarations[0];
	                    if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
	                        this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, 'for-in');
	                    }
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                }
	                else {
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.expect(';');
	                }
	            }
	            else if (this.matchKeyword('const') || this.matchKeyword('let')) {
	                init = this.createNode();
	                var kind = this.nextToken().value;
	                if (!this.context.strict && this.lookahead.value === 'in') {
	                    init = this.finalize(init, new Node.Identifier(kind));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else {
	                    var previousAllowIn = this.context.allowIn;
	                    this.context.allowIn = false;
	                    var declarations = this.parseBindingList(kind, { inFor: true });
	                    this.context.allowIn = previousAllowIn;
	                    if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword('in')) {
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                        this.nextToken();
	                        left = init;
	                        right = this.parseExpression();
	                        init = null;
	                    }
	                    else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                        this.nextToken();
	                        left = init;
	                        right = this.parseAssignmentExpression();
	                        init = null;
	                        forIn = false;
	                    }
	                    else {
	                        this.consumeSemicolon();
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                    }
	                }
	            }
	            else {
	                var initStartToken = this.lookahead;
	                var previousAllowIn = this.context.allowIn;
	                this.context.allowIn = false;
	                init = this.inheritCoverGrammar(this.parseAssignmentExpression);
	                this.context.allowIn = previousAllowIn;
	                if (this.matchKeyword('in')) {
	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
	                    }
	                    this.nextToken();
	                    this.reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else if (this.matchContextualKeyword('of')) {
	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
	                    }
	                    this.nextToken();
	                    this.reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = this.parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                }
	                else {
	                    if (this.match(',')) {
	                        var initSeq = [init];
	                        while (this.match(',')) {
	                            this.nextToken();
	                            initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
	                        }
	                        init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
	                    }
	                    this.expect(';');
	                }
	            }
	        }
	        if (typeof left === 'undefined') {
	            if (!this.match(';')) {
	                test = this.parseExpression();
	            }
	            this.expect(';');
	            if (!this.match(')')) {
	                update = this.parseExpression();
	            }
	        }
	        var body;
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            var previousInIteration = this.context.inIteration;
	            this.context.inIteration = true;
	            body = this.isolateCoverGrammar(this.parseStatement);
	            this.context.inIteration = previousInIteration;
	        }
	        return (typeof left === 'undefined') ?
	            this.finalize(node, new Node.ForStatement(init, test, update, body)) :
	            forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) :
	                this.finalize(node, new Node.ForOfStatement(left, right, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-continue-statement
	    Parser.prototype.parseContinueStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('continue');
	        var label = null;
	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
	            var id = this.parseVariableIdentifier();
	            label = id;
	            var key = '$' + id.name;
	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
	            }
	        }
	        this.consumeSemicolon();
	        if (label === null && !this.context.inIteration) {
	            this.throwError(messages_1.Messages.IllegalContinue);
	        }
	        return this.finalize(node, new Node.ContinueStatement(label));
	    };
	    // https://tc39.github.io/ecma262/#sec-break-statement
	    Parser.prototype.parseBreakStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('break');
	        var label = null;
	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
	            var id = this.parseVariableIdentifier();
	            var key = '$' + id.name;
	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
	            }
	            label = id;
	        }
	        this.consumeSemicolon();
	        if (label === null && !this.context.inIteration && !this.context.inSwitch) {
	            this.throwError(messages_1.Messages.IllegalBreak);
	        }
	        return this.finalize(node, new Node.BreakStatement(label));
	    };
	    // https://tc39.github.io/ecma262/#sec-return-statement
	    Parser.prototype.parseReturnStatement = function () {
	        if (!this.context.inFunctionBody) {
	            this.tolerateError(messages_1.Messages.IllegalReturn);
	        }
	        var node = this.createNode();
	        this.expectKeyword('return');
	        var hasArgument = !this.match(';') && !this.match('}') &&
	            !this.hasLineTerminator && this.lookahead.type !== 2 /* EOF */;
	        var argument = hasArgument ? this.parseExpression() : null;
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ReturnStatement(argument));
	    };
	    // https://tc39.github.io/ecma262/#sec-with-statement
	    Parser.prototype.parseWithStatement = function () {
	        if (this.context.strict) {
	            this.tolerateError(messages_1.Messages.StrictModeWith);
	        }
	        var node = this.createNode();
	        var body;
	        this.expectKeyword('with');
	        this.expect('(');
	        var object = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            body = this.parseStatement();
	        }
	        return this.finalize(node, new Node.WithStatement(object, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-switch-statement
	    Parser.prototype.parseSwitchCase = function () {
	        var node = this.createNode();
	        var test;
	        if (this.matchKeyword('default')) {
	            this.nextToken();
	            test = null;
	        }
	        else {
	            this.expectKeyword('case');
	            test = this.parseExpression();
	        }
	        this.expect(':');
	        var consequent = [];
	        while (true) {
	            if (this.match('}') || this.matchKeyword('default') || this.matchKeyword('case')) {
	                break;
	            }
	            consequent.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.SwitchCase(test, consequent));
	    };
	    Parser.prototype.parseSwitchStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('switch');
	        this.expect('(');
	        var discriminant = this.parseExpression();
	        this.expect(')');
	        var previousInSwitch = this.context.inSwitch;
	        this.context.inSwitch = true;
	        var cases = [];
	        var defaultFound = false;
	        this.expect('{');
	        while (true) {
	            if (this.match('}')) {
	                break;
	            }
	            var clause = this.parseSwitchCase();
	            if (clause.test === null) {
	                if (defaultFound) {
	                    this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
	                }
	                defaultFound = true;
	            }
	            cases.push(clause);
	        }
	        this.expect('}');
	        this.context.inSwitch = previousInSwitch;
	        return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
	    };
	    // https://tc39.github.io/ecma262/#sec-labelled-statements
	    Parser.prototype.parseLabelledStatement = function () {
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        var statement;
	        if ((expr.type === syntax_1.Syntax.Identifier) && this.match(':')) {
	            this.nextToken();
	            var id = expr;
	            var key = '$' + id.name;
	            if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.Redeclaration, 'Label', id.name);
	            }
	            this.context.labelSet[key] = true;
	            var body = void 0;
	            if (this.matchKeyword('class')) {
	                this.tolerateUnexpectedToken(this.lookahead);
	                body = this.parseClassDeclaration();
	            }
	            else if (this.matchKeyword('function')) {
	                var token = this.lookahead;
	                var declaration = this.parseFunctionDeclaration();
	                if (this.context.strict) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
	                }
	                else if (declaration.generator) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
	                }
	                body = declaration;
	            }
	            else {
	                body = this.parseStatement();
	            }
	            delete this.context.labelSet[key];
	            statement = new Node.LabeledStatement(id, body);
	        }
	        else {
	            this.consumeSemicolon();
	            statement = new Node.ExpressionStatement(expr);
	        }
	        return this.finalize(node, statement);
	    };
	    // https://tc39.github.io/ecma262/#sec-throw-statement
	    Parser.prototype.parseThrowStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('throw');
	        if (this.hasLineTerminator) {
	            this.throwError(messages_1.Messages.NewlineAfterThrow);
	        }
	        var argument = this.parseExpression();
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ThrowStatement(argument));
	    };
	    // https://tc39.github.io/ecma262/#sec-try-statement
	    Parser.prototype.parseCatchClause = function () {
	        var node = this.createNode();
	        this.expectKeyword('catch');
	        this.expect('(');
	        if (this.match(')')) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        var params = [];
	        var param = this.parsePattern(params);
	        var paramMap = {};
	        for (var i = 0; i < params.length; i++) {
	            var key = '$' + params[i].value;
	            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
	                this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
	            }
	            paramMap[key] = true;
	        }
	        if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(param.name)) {
	                this.tolerateError(messages_1.Messages.StrictCatchVariable);
	            }
	        }
	        this.expect(')');
	        var body = this.parseBlock();
	        return this.finalize(node, new Node.CatchClause(param, body));
	    };
	    Parser.prototype.parseFinallyClause = function () {
	        this.expectKeyword('finally');
	        return this.parseBlock();
	    };
	    Parser.prototype.parseTryStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('try');
	        var block = this.parseBlock();
	        var handler = this.matchKeyword('catch') ? this.parseCatchClause() : null;
	        var finalizer = this.matchKeyword('finally') ? this.parseFinallyClause() : null;
	        if (!handler && !finalizer) {
	            this.throwError(messages_1.Messages.NoCatchOrFinally);
	        }
	        return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
	    };
	    // https://tc39.github.io/ecma262/#sec-debugger-statement
	    Parser.prototype.parseDebuggerStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('debugger');
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.DebuggerStatement());
	    };
	    // https://tc39.github.io/ecma262/#sec-ecmascript-language-statements-and-declarations
	    Parser.prototype.parseStatement = function () {
	        var statement;
	        switch (this.lookahead.type) {
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 6 /* NumericLiteral */:
	            case 8 /* StringLiteral */:
	            case 10 /* Template */:
	            case 9 /* RegularExpression */:
	                statement = this.parseExpressionStatement();
	                break;
	            case 7 /* Punctuator */:
	                var value = this.lookahead.value;
	                if (value === '{') {
	                    statement = this.parseBlock();
	                }
	                else if (value === '(') {
	                    statement = this.parseExpressionStatement();
	                }
	                else if (value === ';') {
	                    statement = this.parseEmptyStatement();
	                }
	                else {
	                    statement = this.parseExpressionStatement();
	                }
	                break;
	            case 3 /* Identifier */:
	                statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
	                break;
	            case 4 /* Keyword */:
	                switch (this.lookahead.value) {
	                    case 'break':
	                        statement = this.parseBreakStatement();
	                        break;
	                    case 'continue':
	                        statement = this.parseContinueStatement();
	                        break;
	                    case 'debugger':
	                        statement = this.parseDebuggerStatement();
	                        break;
	                    case 'do':
	                        statement = this.parseDoWhileStatement();
	                        break;
	                    case 'for':
	                        statement = this.parseForStatement();
	                        break;
	                    case 'function':
	                        statement = this.parseFunctionDeclaration();
	                        break;
	                    case 'if':
	                        statement = this.parseIfStatement();
	                        break;
	                    case 'return':
	                        statement = this.parseReturnStatement();
	                        break;
	                    case 'switch':
	                        statement = this.parseSwitchStatement();
	                        break;
	                    case 'throw':
	                        statement = this.parseThrowStatement();
	                        break;
	                    case 'try':
	                        statement = this.parseTryStatement();
	                        break;
	                    case 'var':
	                        statement = this.parseVariableStatement();
	                        break;
	                    case 'while':
	                        statement = this.parseWhileStatement();
	                        break;
	                    case 'with':
	                        statement = this.parseWithStatement();
	                        break;
	                    default:
	                        statement = this.parseExpressionStatement();
	                        break;
	                }
	                break;
	            default:
	                statement = this.throwUnexpectedToken(this.lookahead);
	        }
	        return statement;
	    };
	    // https://tc39.github.io/ecma262/#sec-function-definitions
	    Parser.prototype.parseFunctionSourceElements = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var body = this.parseDirectivePrologues();
	        var previousLabelSet = this.context.labelSet;
	        var previousInIteration = this.context.inIteration;
	        var previousInSwitch = this.context.inSwitch;
	        var previousInFunctionBody = this.context.inFunctionBody;
	        this.context.labelSet = {};
	        this.context.inIteration = false;
	        this.context.inSwitch = false;
	        this.context.inFunctionBody = true;
	        while (this.lookahead.type !== 2 /* EOF */) {
	            if (this.match('}')) {
	                break;
	            }
	            body.push(this.parseStatementListItem());
	        }
	        this.expect('}');
	        this.context.labelSet = previousLabelSet;
	        this.context.inIteration = previousInIteration;
	        this.context.inSwitch = previousInSwitch;
	        this.context.inFunctionBody = previousInFunctionBody;
	        return this.finalize(node, new Node.BlockStatement(body));
	    };
	    Parser.prototype.validateParam = function (options, param, name) {
	        var key = '$' + name;
	        if (this.context.strict) {
	            if (this.scanner.isRestrictedWord(name)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamName;
	            }
	            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamDupe;
	            }
	        }
	        else if (!options.firstRestricted) {
	            if (this.scanner.isRestrictedWord(name)) {
	                options.firstRestricted = param;
	                options.message = messages_1.Messages.StrictParamName;
	            }
	            else if (this.scanner.isStrictModeReservedWord(name)) {
	                options.firstRestricted = param;
	                options.message = messages_1.Messages.StrictReservedWord;
	            }
	            else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamDupe;
	            }
	        }
	        /* istanbul ignore next */
	        if (typeof Object.defineProperty === 'function') {
	            Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
	        }
	        else {
	            options.paramSet[key] = true;
	        }
	    };
	    Parser.prototype.parseRestElement = function (params) {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.parsePattern(params);
	        if (this.match('=')) {
	            this.throwError(messages_1.Messages.DefaultRestParameter);
	        }
	        if (!this.match(')')) {
	            this.throwError(messages_1.Messages.ParameterAfterRestParameter);
	        }
	        return this.finalize(node, new Node.RestElement(arg));
	    };
	    Parser.prototype.parseFormalParameter = function (options) {
	        var params = [];
	        var param = this.match('...') ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
	        for (var i = 0; i < params.length; i++) {
	            this.validateParam(options, params[i], params[i].value);
	        }
	        options.simple = options.simple && (param instanceof Node.Identifier);
	        options.params.push(param);
	    };
	    Parser.prototype.parseFormalParameters = function (firstRestricted) {
	        var options;
	        options = {
	            simple: true,
	            params: [],
	            firstRestricted: firstRestricted
	        };
	        this.expect('(');
	        if (!this.match(')')) {
	            options.paramSet = {};
	            while (this.lookahead.type !== 2 /* EOF */) {
	                this.parseFormalParameter(options);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expect(',');
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return {
	            simple: options.simple,
	            params: options.params,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    };
	    Parser.prototype.matchAsyncFunction = function () {
	        var match = this.matchContextualKeyword('async');
	        if (match) {
	            var state = this.scanner.saveState();
	            this.scanner.scanComments();
	            var next = this.scanner.lex();
	            this.scanner.restoreState(state);
	            match = (state.lineNumber === next.lineNumber) && (next.type === 4 /* Keyword */) && (next.value === 'function');
	        }
	        return match;
	    };
	    Parser.prototype.parseFunctionDeclaration = function (identifierIsOptional) {
	        var node = this.createNode();
	        var isAsync = this.matchContextualKeyword('async');
	        if (isAsync) {
	            this.nextToken();
	        }
	        this.expectKeyword('function');
	        var isGenerator = isAsync ? false : this.match('*');
	        if (isGenerator) {
	            this.nextToken();
	        }
	        var message;
	        var id = null;
	        var firstRestricted = null;
	        if (!identifierIsOptional || !this.match('(')) {
	            var token = this.lookahead;
	            id = this.parseVariableIdentifier();
	            if (this.context.strict) {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
	                }
	            }
	            else {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictFunctionName;
	                }
	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictReservedWord;
	                }
	            }
	        }
	        var previousAllowAwait = this.context.await;
	        var previousAllowYield = this.context.allowYield;
	        this.context.await = isAsync;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters(firstRestricted);
	        var params = formalParameters.params;
	        var stricted = formalParameters.stricted;
	        firstRestricted = formalParameters.firstRestricted;
	        if (formalParameters.message) {
	            message = formalParameters.message;
	        }
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = formalParameters.simple;
	        var body = this.parseFunctionSourceElements();
	        if (this.context.strict && firstRestricted) {
	            this.throwUnexpectedToken(firstRestricted, message);
	        }
	        if (this.context.strict && stricted) {
	            this.tolerateUnexpectedToken(stricted, message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        this.context.await = previousAllowAwait;
	        this.context.allowYield = previousAllowYield;
	        return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) :
	            this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
	    };
	    Parser.prototype.parseFunctionExpression = function () {
	        var node = this.createNode();
	        var isAsync = this.matchContextualKeyword('async');
	        if (isAsync) {
	            this.nextToken();
	        }
	        this.expectKeyword('function');
	        var isGenerator = isAsync ? false : this.match('*');
	        if (isGenerator) {
	            this.nextToken();
	        }
	        var message;
	        var id = null;
	        var firstRestricted;
	        var previousAllowAwait = this.context.await;
	        var previousAllowYield = this.context.allowYield;
	        this.context.await = isAsync;
	        this.context.allowYield = !isGenerator;
	        if (!this.match('(')) {
	            var token = this.lookahead;
	            id = (!this.context.strict && !isGenerator && this.matchKeyword('yield')) ? this.parseIdentifierName() : this.parseVariableIdentifier();
	            if (this.context.strict) {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
	                }
	            }
	            else {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictFunctionName;
	                }
	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictReservedWord;
	                }
	            }
	        }
	        var formalParameters = this.parseFormalParameters(firstRestricted);
	        var params = formalParameters.params;
	        var stricted = formalParameters.stricted;
	        firstRestricted = formalParameters.firstRestricted;
	        if (formalParameters.message) {
	            message = formalParameters.message;
	        }
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = formalParameters.simple;
	        var body = this.parseFunctionSourceElements();
	        if (this.context.strict && firstRestricted) {
	            this.throwUnexpectedToken(firstRestricted, message);
	        }
	        if (this.context.strict && stricted) {
	            this.tolerateUnexpectedToken(stricted, message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        this.context.await = previousAllowAwait;
	        this.context.allowYield = previousAllowYield;
	        return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) :
	            this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
	    };
	    // https://tc39.github.io/ecma262/#sec-directive-prologues-and-the-use-strict-directive
	    Parser.prototype.parseDirective = function () {
	        var token = this.lookahead;
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        var directive = (expr.type === syntax_1.Syntax.Literal) ? this.getTokenRaw(token).slice(1, -1) : null;
	        this.consumeSemicolon();
	        return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
	    };
	    Parser.prototype.parseDirectivePrologues = function () {
	        var firstRestricted = null;
	        var body = [];
	        while (true) {
	            var token = this.lookahead;
	            if (token.type !== 8 /* StringLiteral */) {
	                break;
	            }
	            var statement = this.parseDirective();
	            body.push(statement);
	            var directive = statement.directive;
	            if (typeof directive !== 'string') {
	                break;
	            }
	            if (directive === 'use strict') {
	                this.context.strict = true;
	                if (firstRestricted) {
	                    this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
	                }
	                if (!this.context.allowStrictDirective) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
	                }
	            }
	            else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }
	        return body;
	    };
	    // https://tc39.github.io/ecma262/#sec-method-definitions
	    Parser.prototype.qualifiedPropertyName = function (token) {
	        switch (token.type) {
	            case 3 /* Identifier */:
	            case 8 /* StringLiteral */:
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 6 /* NumericLiteral */:
	            case 4 /* Keyword */:
	                return true;
	            case 7 /* Punctuator */:
	                return token.value === '[';
	            default:
	                break;
	        }
	        return false;
	    };
	    Parser.prototype.parseGetterMethod = function () {
	        var node = this.createNode();
	        var isGenerator = false;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = false;
	        var formalParameters = this.parseFormalParameters();
	        if (formalParameters.params.length > 0) {
	            this.tolerateError(messages_1.Messages.BadGetterArity);
	        }
	        var method = this.parsePropertyMethod(formalParameters);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
	    };
	    Parser.prototype.parseSetterMethod = function () {
	        var node = this.createNode();
	        var isGenerator = false;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = false;
	        var formalParameters = this.parseFormalParameters();
	        if (formalParameters.params.length !== 1) {
	            this.tolerateError(messages_1.Messages.BadSetterArity);
	        }
	        else if (formalParameters.params[0] instanceof Node.RestElement) {
	            this.tolerateError(messages_1.Messages.BadSetterRestParameter);
	        }
	        var method = this.parsePropertyMethod(formalParameters);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
	    };
	    Parser.prototype.parseGeneratorMethod = function () {
	        var node = this.createNode();
	        var isGenerator = true;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = true;
	        var params = this.parseFormalParameters();
	        this.context.allowYield = false;
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
	    };
	    // https://tc39.github.io/ecma262/#sec-generator-function-definitions
	    Parser.prototype.isStartOfExpression = function () {
	        var start = true;
	        var value = this.lookahead.value;
	        switch (this.lookahead.type) {
	            case 7 /* Punctuator */:
	                start = (value === '[') || (value === '(') || (value === '{') ||
	                    (value === '+') || (value === '-') ||
	                    (value === '!') || (value === '~') ||
	                    (value === '++') || (value === '--') ||
	                    (value === '/') || (value === '/='); // regular expression literal
	                break;
	            case 4 /* Keyword */:
	                start = (value === 'class') || (value === 'delete') ||
	                    (value === 'function') || (value === 'let') || (value === 'new') ||
	                    (value === 'super') || (value === 'this') || (value === 'typeof') ||
	                    (value === 'void') || (value === 'yield');
	                break;
	            default:
	                break;
	        }
	        return start;
	    };
	    Parser.prototype.parseYieldExpression = function () {
	        var node = this.createNode();
	        this.expectKeyword('yield');
	        var argument = null;
	        var delegate = false;
	        if (!this.hasLineTerminator) {
	            var previousAllowYield = this.context.allowYield;
	            this.context.allowYield = false;
	            delegate = this.match('*');
	            if (delegate) {
	                this.nextToken();
	                argument = this.parseAssignmentExpression();
	            }
	            else if (this.isStartOfExpression()) {
	                argument = this.parseAssignmentExpression();
	            }
	            this.context.allowYield = previousAllowYield;
	        }
	        return this.finalize(node, new Node.YieldExpression(argument, delegate));
	    };
	    // https://tc39.github.io/ecma262/#sec-class-definitions
	    Parser.prototype.parseClassElement = function (hasConstructor) {
	        var token = this.lookahead;
	        var node = this.createNode();
	        var kind = '';
	        var key = null;
	        var value = null;
	        var computed = false;
	        var method = false;
	        var isStatic = false;
	        var isAsync = false;
	        if (this.match('*')) {
	            this.nextToken();
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            var id = key;
	            if (id.name === 'static' && (this.qualifiedPropertyName(this.lookahead) || this.match('*'))) {
	                token = this.lookahead;
	                isStatic = true;
	                computed = this.match('[');
	                if (this.match('*')) {
	                    this.nextToken();
	                }
	                else {
	                    key = this.parseObjectPropertyKey();
	                }
	            }
	            if ((token.type === 3 /* Identifier */) && !this.hasLineTerminator && (token.value === 'async')) {
	                var punctuator = this.lookahead.value;
	                if (punctuator !== ':' && punctuator !== '(' && punctuator !== '*') {
	                    isAsync = true;
	                    token = this.lookahead;
	                    key = this.parseObjectPropertyKey();
	                    if (token.type === 3 /* Identifier */) {
	                        if (token.value === 'get' || token.value === 'set') {
	                            this.tolerateUnexpectedToken(token);
	                        }
	                        else if (token.value === 'constructor') {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
	                        }
	                    }
	                }
	            }
	        }
	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
	        if (token.type === 3 /* Identifier */) {
	            if (token.value === 'get' && lookaheadPropertyKey) {
	                kind = 'get';
	                computed = this.match('[');
	                key = this.parseObjectPropertyKey();
	                this.context.allowYield = false;
	                value = this.parseGetterMethod();
	            }
	            else if (token.value === 'set' && lookaheadPropertyKey) {
	                kind = 'set';
	                computed = this.match('[');
	                key = this.parseObjectPropertyKey();
	                value = this.parseSetterMethod();
	            }
	        }
	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
	            kind = 'init';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseGeneratorMethod();
	            method = true;
	        }
	        if (!kind && key && this.match('(')) {
	            kind = 'init';
	            value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
	            method = true;
	        }
	        if (!kind) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        if (kind === 'init') {
	            kind = 'method';
	        }
	        if (!computed) {
	            if (isStatic && this.isPropertyKey(key, 'prototype')) {
	                this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
	            }
	            if (!isStatic && this.isPropertyKey(key, 'constructor')) {
	                if (kind !== 'method' || !method || (value && value.generator)) {
	                    this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
	                }
	                if (hasConstructor.value) {
	                    this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
	                }
	                else {
	                    hasConstructor.value = true;
	                }
	                kind = 'constructor';
	            }
	        }
	        return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
	    };
	    Parser.prototype.parseClassElementList = function () {
	        var body = [];
	        var hasConstructor = { value: false };
	        this.expect('{');
	        while (!this.match('}')) {
	            if (this.match(';')) {
	                this.nextToken();
	            }
	            else {
	                body.push(this.parseClassElement(hasConstructor));
	            }
	        }
	        this.expect('}');
	        return body;
	    };
	    Parser.prototype.parseClassBody = function () {
	        var node = this.createNode();
	        var elementList = this.parseClassElementList();
	        return this.finalize(node, new Node.ClassBody(elementList));
	    };
	    Parser.prototype.parseClassDeclaration = function (identifierIsOptional) {
	        var node = this.createNode();
	        var previousStrict = this.context.strict;
	        this.context.strict = true;
	        this.expectKeyword('class');
	        var id = (identifierIsOptional && (this.lookahead.type !== 3 /* Identifier */)) ? null : this.parseVariableIdentifier();
	        var superClass = null;
	        if (this.matchKeyword('extends')) {
	            this.nextToken();
	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	        }
	        var classBody = this.parseClassBody();
	        this.context.strict = previousStrict;
	        return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
	    };
	    Parser.prototype.parseClassExpression = function () {
	        var node = this.createNode();
	        var previousStrict = this.context.strict;
	        this.context.strict = true;
	        this.expectKeyword('class');
	        var id = (this.lookahead.type === 3 /* Identifier */) ? this.parseVariableIdentifier() : null;
	        var superClass = null;
	        if (this.matchKeyword('extends')) {
	            this.nextToken();
	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	        }
	        var classBody = this.parseClassBody();
	        this.context.strict = previousStrict;
	        return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
	    };
	    // https://tc39.github.io/ecma262/#sec-scripts
	    // https://tc39.github.io/ecma262/#sec-modules
	    Parser.prototype.parseModule = function () {
	        this.context.strict = true;
	        this.context.isModule = true;
	        var node = this.createNode();
	        var body = this.parseDirectivePrologues();
	        while (this.lookahead.type !== 2 /* EOF */) {
	            body.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.Module(body));
	    };
	    Parser.prototype.parseScript = function () {
	        var node = this.createNode();
	        var body = this.parseDirectivePrologues();
	        while (this.lookahead.type !== 2 /* EOF */) {
	            body.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.Script(body));
	    };
	    // https://tc39.github.io/ecma262/#sec-imports
	    Parser.prototype.parseModuleSpecifier = function () {
	        var node = this.createNode();
	        if (this.lookahead.type !== 8 /* StringLiteral */) {
	            this.throwError(messages_1.Messages.InvalidModuleSpecifier);
	        }
	        var token = this.nextToken();
	        var raw = this.getTokenRaw(token);
	        return this.finalize(node, new Node.Literal(token.value, raw));
	    };
	    // import {<foo as bar>} ...;
	    Parser.prototype.parseImportSpecifier = function () {
	        var node = this.createNode();
	        var imported;
	        var local;
	        if (this.lookahead.type === 3 /* Identifier */) {
	            imported = this.parseVariableIdentifier();
	            local = imported;
	            if (this.matchContextualKeyword('as')) {
	                this.nextToken();
	                local = this.parseVariableIdentifier();
	            }
	        }
	        else {
	            imported = this.parseIdentifierName();
	            local = imported;
	            if (this.matchContextualKeyword('as')) {
	                this.nextToken();
	                local = this.parseVariableIdentifier();
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	        }
	        return this.finalize(node, new Node.ImportSpecifier(local, imported));
	    };
	    // {foo, bar as bas}
	    Parser.prototype.parseNamedImports = function () {
	        this.expect('{');
	        var specifiers = [];
	        while (!this.match('}')) {
	            specifiers.push(this.parseImportSpecifier());
	            if (!this.match('}')) {
	                this.expect(',');
	            }
	        }
	        this.expect('}');
	        return specifiers;
	    };
	    // import <foo> ...;
	    Parser.prototype.parseImportDefaultSpecifier = function () {
	        var node = this.createNode();
	        var local = this.parseIdentifierName();
	        return this.finalize(node, new Node.ImportDefaultSpecifier(local));
	    };
	    // import <* as foo> ...;
	    Parser.prototype.parseImportNamespaceSpecifier = function () {
	        var node = this.createNode();
	        this.expect('*');
	        if (!this.matchContextualKeyword('as')) {
	            this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
	        }
	        this.nextToken();
	        var local = this.parseIdentifierName();
	        return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
	    };
	    Parser.prototype.parseImportDeclaration = function () {
	        if (this.context.inFunctionBody) {
	            this.throwError(messages_1.Messages.IllegalImportDeclaration);
	        }
	        var node = this.createNode();
	        this.expectKeyword('import');
	        var src;
	        var specifiers = [];
	        if (this.lookahead.type === 8 /* StringLiteral */) {
	            // import 'foo';
	            src = this.parseModuleSpecifier();
	        }
	        else {
	            if (this.match('{')) {
	                // import {bar}
	                specifiers = specifiers.concat(this.parseNamedImports());
	            }
	            else if (this.match('*')) {
	                // import * as foo
	                specifiers.push(this.parseImportNamespaceSpecifier());
	            }
	            else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword('default')) {
	                // import foo
	                specifiers.push(this.parseImportDefaultSpecifier());
	                if (this.match(',')) {
	                    this.nextToken();
	                    if (this.match('*')) {
	                        // import foo, * as foo
	                        specifiers.push(this.parseImportNamespaceSpecifier());
	                    }
	                    else if (this.match('{')) {
	                        // import foo, {bar}
	                        specifiers = specifiers.concat(this.parseNamedImports());
	                    }
	                    else {
	                        this.throwUnexpectedToken(this.lookahead);
	                    }
	                }
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	            if (!this.matchContextualKeyword('from')) {
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            this.nextToken();
	            src = this.parseModuleSpecifier();
	        }
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
	    };
	    // https://tc39.github.io/ecma262/#sec-exports
	    Parser.prototype.parseExportSpecifier = function () {
	        var node = this.createNode();
	        var local = this.parseIdentifierName();
	        var exported = local;
	        if (this.matchContextualKeyword('as')) {
	            this.nextToken();
	            exported = this.parseIdentifierName();
	        }
	        return this.finalize(node, new Node.ExportSpecifier(local, exported));
	    };
	    Parser.prototype.parseExportDeclaration = function () {
	        if (this.context.inFunctionBody) {
	            this.throwError(messages_1.Messages.IllegalExportDeclaration);
	        }
	        var node = this.createNode();
	        this.expectKeyword('export');
	        var exportDeclaration;
	        if (this.matchKeyword('default')) {
	            // export default ...
	            this.nextToken();
	            if (this.matchKeyword('function')) {
	                // export default function foo () {}
	                // export default function () {}
	                var declaration = this.parseFunctionDeclaration(true);
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else if (this.matchKeyword('class')) {
	                // export default class foo {}
	                var declaration = this.parseClassDeclaration(true);
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else if (this.matchContextualKeyword('async')) {
	                // export default async function f () {}
	                // export default async function () {}
	                // export default async x => x
	                var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else {
	                if (this.matchContextualKeyword('from')) {
	                    this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
	                }
	                // export default {};
	                // export default [];
	                // export default (1 + 2);
	                var declaration = this.match('{') ? this.parseObjectInitializer() :
	                    this.match('[') ? this.parseArrayInitializer() : this.parseAssignmentExpression();
	                this.consumeSemicolon();
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	        }
	        else if (this.match('*')) {
	            // export * from 'foo';
	            this.nextToken();
	            if (!this.matchContextualKeyword('from')) {
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            this.nextToken();
	            var src = this.parseModuleSpecifier();
	            this.consumeSemicolon();
	            exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
	        }
	        else if (this.lookahead.type === 4 /* Keyword */) {
	            // export var f = 1;
	            var declaration = void 0;
	            switch (this.lookahead.value) {
	                case 'let':
	                case 'const':
	                    declaration = this.parseLexicalDeclaration({ inFor: false });
	                    break;
	                case 'var':
	                case 'class':
	                case 'function':
	                    declaration = this.parseStatementListItem();
	                    break;
	                default:
	                    this.throwUnexpectedToken(this.lookahead);
	            }
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
	        }
	        else if (this.matchAsyncFunction()) {
	            var declaration = this.parseFunctionDeclaration();
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
	        }
	        else {
	            var specifiers = [];
	            var source = null;
	            var isExportFromIdentifier = false;
	            this.expect('{');
	            while (!this.match('}')) {
	                isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword('default');
	                specifiers.push(this.parseExportSpecifier());
	                if (!this.match('}')) {
	                    this.expect(',');
	                }
	            }
	            this.expect('}');
	            if (this.matchContextualKeyword('from')) {
	                // export {default} from 'foo';
	                // export {foo} from 'foo';
	                this.nextToken();
	                source = this.parseModuleSpecifier();
	                this.consumeSemicolon();
	            }
	            else if (isExportFromIdentifier) {
	                // export {default}; // missing fromClause
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            else {
	                // export {foo};
	                this.consumeSemicolon();
	            }
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
	        }
	        return exportDeclaration;
	    };
	    return Parser;
	}());
	exports.Parser = Parser;


/***/ },
/* 9 */
/***/ function(module, exports) {

	"use strict";
	// Ensure the condition is true, otherwise throw an error.
	// This is only to have a better contract semantic, i.e. another safety net
	// to catch a logic error. The condition shall be fulfilled in normal case.
	// Do NOT use this to enforce a certain condition on any user input.
	Object.defineProperty(exports, "__esModule", { value: true });
	function assert(condition, message) {
	    /* istanbul ignore if */
	    if (!condition) {
	        throw new Error('ASSERT: ' + message);
	    }
	}
	exports.assert = assert;


/***/ },
/* 10 */
/***/ function(module, exports) {

	"use strict";
	/* tslint:disable:max-classes-per-file */
	Object.defineProperty(exports, "__esModule", { value: true });
	var ErrorHandler = (function () {
	    function ErrorHandler() {
	        this.errors = [];
	        this.tolerant = false;
	    }
	    ErrorHandler.prototype.recordError = function (error) {
	        this.errors.push(error);
	    };
	    ErrorHandler.prototype.tolerate = function (error) {
	        if (this.tolerant) {
	            this.recordError(error);
	        }
	        else {
	            throw error;
	        }
	    };
	    ErrorHandler.prototype.constructError = function (msg, column) {
	        var error = new Error(msg);
	        try {
	            throw error;
	        }
	        catch (base) {
	            /* istanbul ignore else */
	            if (Object.create && Object.defineProperty) {
	                error = Object.create(base);
	                Object.defineProperty(error, 'column', { value: column });
	            }
	        }
	        /* istanbul ignore next */
	        return error;
	    };
	    ErrorHandler.prototype.createError = function (index, line, col, description) {
	        var msg = 'Line ' + line + ': ' + description;
	        var error = this.constructError(msg, col);
	        error.index = index;
	        error.lineNumber = line;
	        error.description = description;
	        return error;
	    };
	    ErrorHandler.prototype.throwError = function (index, line, col, description) {
	        throw this.createError(index, line, col, description);
	    };
	    ErrorHandler.prototype.tolerateError = function (index, line, col, description) {
	        var error = this.createError(index, line, col, description);
	        if (this.tolerant) {
	            this.recordError(error);
	        }
	        else {
	            throw error;
	        }
	    };
	    return ErrorHandler;
	}());
	exports.ErrorHandler = ErrorHandler;


/***/ },
/* 11 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// Error messages should be identical to V8.
	exports.Messages = {
	    BadGetterArity: 'Getter must not have any formal parameters',
	    BadSetterArity: 'Setter must have exactly one formal parameter',
	    BadSetterRestParameter: 'Setter function argument must not be a rest parameter',
	    ConstructorIsAsync: 'Class constructor may not be an async method',
	    ConstructorSpecialMethod: 'Class constructor may not be an accessor',
	    DeclarationMissingInitializer: 'Missing initializer in %0 declaration',
	    DefaultRestParameter: 'Unexpected token =',
	    DuplicateBinding: 'Duplicate binding %0',
	    DuplicateConstructor: 'A class may only have one constructor',
	    DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
	    ForInOfLoopInitializer: '%0 loop variable declaration may not have an initializer',
	    GeneratorInLegacyContext: 'Generator declarations are not allowed in legacy contexts',
	    IllegalBreak: 'Illegal break statement',
	    IllegalContinue: 'Illegal continue statement',
	    IllegalExportDeclaration: 'Unexpected token',
	    IllegalImportDeclaration: 'Unexpected token',
	    IllegalLanguageModeDirective: 'Illegal \'use strict\' directive in function with non-simple parameter list',
	    IllegalReturn: 'Illegal return statement',
	    InvalidEscapedReservedWord: 'Keyword must not contain escaped characters',
	    InvalidHexEscapeSequence: 'Invalid hexadecimal escape sequence',
	    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
	    InvalidLHSInForIn: 'Invalid left-hand side in for-in',
	    InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
	    InvalidModuleSpecifier: 'Unexpected token',
	    InvalidRegExp: 'Invalid regular expression',
	    LetInLexicalBinding: 'let is disallowed as a lexically bound name',
	    MissingFromClause: 'Unexpected token',
	    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
	    NewlineAfterThrow: 'Illegal newline after throw',
	    NoAsAfterImportNamespace: 'Unexpected token',
	    NoCatchOrFinally: 'Missing catch or finally after try',
	    ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
	    Redeclaration: '%0 \'%1\' has already been declared',
	    StaticPrototype: 'Classes may not have static property named prototype',
	    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
	    StrictDelete: 'Delete of an unqualified identifier in strict mode.',
	    StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block',
	    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
	    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
	    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
	    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
	    StrictModeWith: 'Strict mode code may not include a with statement',
	    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
	    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
	    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
	    StrictReservedWord: 'Use of future reserved word in strict mode',
	    StrictVarName: 'Variable name may not be eval or arguments in strict mode',
	    TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
	    UnexpectedEOS: 'Unexpected end of input',
	    UnexpectedIdentifier: 'Unexpected identifier',
	    UnexpectedNumber: 'Unexpected number',
	    UnexpectedReserved: 'Unexpected reserved word',
	    UnexpectedString: 'Unexpected string',
	    UnexpectedTemplate: 'Unexpected quasi %0',
	    UnexpectedToken: 'Unexpected token %0',
	    UnexpectedTokenIllegal: 'Unexpected token ILLEGAL',
	    UnknownLabel: 'Undefined label \'%0\'',
	    UnterminatedRegExp: 'Invalid regular expression: missing /'
	};


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = __webpack_require__(9);
	var character_1 = __webpack_require__(4);
	var messages_1 = __webpack_require__(11);
	function hexValue(ch) {
	    return '0123456789abcdef'.indexOf(ch.toLowerCase());
	}
	function octalValue(ch) {
	    return '01234567'.indexOf(ch);
	}
	var Scanner = (function () {
	    function Scanner(code, handler) {
	        this.source = code;
	        this.errorHandler = handler;
	        this.trackComment = false;
	        this.length = code.length;
	        this.index = 0;
	        this.lineNumber = (code.length > 0) ? 1 : 0;
	        this.lineStart = 0;
	        this.curlyStack = [];
	    }
	    Scanner.prototype.saveState = function () {
	        return {
	            index: this.index,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart
	        };
	    };
	    Scanner.prototype.restoreState = function (state) {
	        this.index = state.index;
	        this.lineNumber = state.lineNumber;
	        this.lineStart = state.lineStart;
	    };
	    Scanner.prototype.eof = function () {
	        return this.index >= this.length;
	    };
	    Scanner.prototype.throwUnexpectedToken = function (message) {
	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
	        return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	    };
	    Scanner.prototype.tolerateUnexpectedToken = function (message) {
	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
	        this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	    };
	    // https://tc39.github.io/ecma262/#sec-comments
	    Scanner.prototype.skipSingleLineComment = function (offset) {
	        var comments = [];
	        var start, loc;
	        if (this.trackComment) {
	            comments = [];
	            start = this.index - offset;
	            loc = {
	                start: {
	                    line: this.lineNumber,
	                    column: this.index - this.lineStart - offset
	                },
	                end: {}
	            };
	        }
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            ++this.index;
	            if (character_1.Character.isLineTerminator(ch)) {
	                if (this.trackComment) {
	                    loc.end = {
	                        line: this.lineNumber,
	                        column: this.index - this.lineStart - 1
	                    };
	                    var entry = {
	                        multiLine: false,
	                        slice: [start + offset, this.index - 1],
	                        range: [start, this.index - 1],
	                        loc: loc
	                    };
	                    comments.push(entry);
	                }
	                if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                this.lineStart = this.index;
	                return comments;
	            }
	        }
	        if (this.trackComment) {
	            loc.end = {
	                line: this.lineNumber,
	                column: this.index - this.lineStart
	            };
	            var entry = {
	                multiLine: false,
	                slice: [start + offset, this.index],
	                range: [start, this.index],
	                loc: loc
	            };
	            comments.push(entry);
	        }
	        return comments;
	    };
	    Scanner.prototype.skipMultiLineComment = function () {
	        var comments = [];
	        var start, loc;
	        if (this.trackComment) {
	            comments = [];
	            start = this.index - 2;
	            loc = {
	                start: {
	                    line: this.lineNumber,
	                    column: this.index - this.lineStart - 2
	                },
	                end: {}
	            };
	        }
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (character_1.Character.isLineTerminator(ch)) {
	                if (ch === 0x0D && this.source.charCodeAt(this.index + 1) === 0x0A) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                ++this.index;
	                this.lineStart = this.index;
	            }
	            else if (ch === 0x2A) {
	                // Block comment ends with '*/'.
	                if (this.source.charCodeAt(this.index + 1) === 0x2F) {
	                    this.index += 2;
	                    if (this.trackComment) {
	                        loc.end = {
	                            line: this.lineNumber,
	                            column: this.index - this.lineStart
	                        };
	                        var entry = {
	                            multiLine: true,
	                            slice: [start + 2, this.index - 2],
	                            range: [start, this.index],
	                            loc: loc
	                        };
	                        comments.push(entry);
	                    }
	                    return comments;
	                }
	                ++this.index;
	            }
	            else {
	                ++this.index;
	            }
	        }
	        // Ran off the end of the file - the whole thing is a comment
	        if (this.trackComment) {
	            loc.end = {
	                line: this.lineNumber,
	                column: this.index - this.lineStart
	            };
	            var entry = {
	                multiLine: true,
	                slice: [start + 2, this.index],
	                range: [start, this.index],
	                loc: loc
	            };
	            comments.push(entry);
	        }
	        this.tolerateUnexpectedToken();
	        return comments;
	    };
	    Scanner.prototype.scanComments = function () {
	        var comments;
	        if (this.trackComment) {
	            comments = [];
	        }
	        var start = (this.index === 0);
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (character_1.Character.isWhiteSpace(ch)) {
	                ++this.index;
	            }
	            else if (character_1.Character.isLineTerminator(ch)) {
	                ++this.index;
	                if (ch === 0x0D && this.source.charCodeAt(this.index) === 0x0A) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                this.lineStart = this.index;
	                start = true;
	            }
	            else if (ch === 0x2F) {
	                ch = this.source.charCodeAt(this.index + 1);
	                if (ch === 0x2F) {
	                    this.index += 2;
	                    var comment = this.skipSingleLineComment(2);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                    start = true;
	                }
	                else if (ch === 0x2A) {
	                    this.index += 2;
	                    var comment = this.skipMultiLineComment();
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else if (start && ch === 0x2D) {
	                // U+003E is '>'
	                if ((this.source.charCodeAt(this.index + 1) === 0x2D) && (this.source.charCodeAt(this.index + 2) === 0x3E)) {
	                    // '-->' is a single-line comment
	                    this.index += 3;
	                    var comment = this.skipSingleLineComment(3);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else if (ch === 0x3C) {
	                if (this.source.slice(this.index + 1, this.index + 4) === '!--') {
	                    this.index += 4; // `<!--`
	                    var comment = this.skipSingleLineComment(4);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else {
	                break;
	            }
	        }
	        return comments;
	    };
	    // https://tc39.github.io/ecma262/#sec-future-reserved-words
	    Scanner.prototype.isFutureReservedWord = function (id) {
	        switch (id) {
	            case 'enum':
	            case 'export':
	            case 'import':
	            case 'super':
	                return true;
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.isStrictModeReservedWord = function (id) {
	        switch (id) {
	            case 'implements':
	            case 'interface':
	            case 'package':
	            case 'private':
	            case 'protected':
	            case 'public':
	            case 'static':
	            case 'yield':
	            case 'let':
	                return true;
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.isRestrictedWord = function (id) {
	        return id === 'eval' || id === 'arguments';
	    };
	    // https://tc39.github.io/ecma262/#sec-keywords
	    Scanner.prototype.isKeyword = function (id) {
	        switch (id.length) {
	            case 2:
	                return (id === 'if') || (id === 'in') || (id === 'do');
	            case 3:
	                return (id === 'var') || (id === 'for') || (id === 'new') ||
	                    (id === 'try') || (id === 'let');
	            case 4:
	                return (id === 'this') || (id === 'else') || (id === 'case') ||
	                    (id === 'void') || (id === 'with') || (id === 'enum');
	            case 5:
	                return (id === 'while') || (id === 'break') || (id === 'catch') ||
	                    (id === 'throw') || (id === 'const') || (id === 'yield') ||
	                    (id === 'class') || (id === 'super');
	            case 6:
	                return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
	                    (id === 'switch') || (id === 'export') || (id === 'import');
	            case 7:
	                return (id === 'default') || (id === 'finally') || (id === 'extends');
	            case 8:
	                return (id === 'function') || (id === 'continue') || (id === 'debugger');
	            case 10:
	                return (id === 'instanceof');
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.codePointAt = function (i) {
	        var cp = this.source.charCodeAt(i);
	        if (cp >= 0xD800 && cp <= 0xDBFF) {
	            var second = this.source.charCodeAt(i + 1);
	            if (second >= 0xDC00 && second <= 0xDFFF) {
	                var first = cp;
	                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
	            }
	        }
	        return cp;
	    };
	    Scanner.prototype.scanHexEscape = function (prefix) {
	        var len = (prefix === 'u') ? 4 : 2;
	        var code = 0;
	        for (var i = 0; i < len; ++i) {
	            if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
	                code = code * 16 + hexValue(this.source[this.index++]);
	            }
	            else {
	                return null;
	            }
	        }
	        return String.fromCharCode(code);
	    };
	    Scanner.prototype.scanUnicodeCodePointEscape = function () {
	        var ch = this.source[this.index];
	        var code = 0;
	        // At least, one hex digit is required.
	        if (ch === '}') {
	            this.throwUnexpectedToken();
	        }
	        while (!this.eof()) {
	            ch = this.source[this.index++];
	            if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
	                break;
	            }
	            code = code * 16 + hexValue(ch);
	        }
	        if (code > 0x10FFFF || ch !== '}') {
	            this.throwUnexpectedToken();
	        }
	        return character_1.Character.fromCodePoint(code);
	    };
	    Scanner.prototype.getIdentifier = function () {
	        var start = this.index++;
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (ch === 0x5C) {
	                // Blackslash (U+005C) marks Unicode escape sequence.
	                this.index = start;
	                return this.getComplexIdentifier();
	            }
	            else if (ch >= 0xD800 && ch < 0xDFFF) {
	                // Need to handle surrogate pairs.
	                this.index = start;
	                return this.getComplexIdentifier();
	            }
	            if (character_1.Character.isIdentifierPart(ch)) {
	                ++this.index;
	            }
	            else {
	                break;
	            }
	        }
	        return this.source.slice(start, this.index);
	    };
	    Scanner.prototype.getComplexIdentifier = function () {
	        var cp = this.codePointAt(this.index);
	        var id = character_1.Character.fromCodePoint(cp);
	        this.index += id.length;
	        // '\u' (U+005C, U+0075) denotes an escaped character.
	        var ch;
	        if (cp === 0x5C) {
	            if (this.source.charCodeAt(this.index) !== 0x75) {
	                this.throwUnexpectedToken();
	            }
	            ++this.index;
	            if (this.source[this.index] === '{') {
	                ++this.index;
	                ch = this.scanUnicodeCodePointEscape();
	            }
	            else {
	                ch = this.scanHexEscape('u');
	                if (ch === null || ch === '\\' || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
	                    this.throwUnexpectedToken();
	                }
	            }
	            id = ch;
	        }
	        while (!this.eof()) {
	            cp = this.codePointAt(this.index);
	            if (!character_1.Character.isIdentifierPart(cp)) {
	                break;
	            }
	            ch = character_1.Character.fromCodePoint(cp);
	            id += ch;
	            this.index += ch.length;
	            // '\u' (U+005C, U+0075) denotes an escaped character.
	            if (cp === 0x5C) {
	                id = id.substr(0, id.length - 1);
	                if (this.source.charCodeAt(this.index) !== 0x75) {
	                    this.throwUnexpectedToken();
	                }
	                ++this.index;
	                if (this.source[this.index] === '{') {
	                    ++this.index;
	                    ch = this.scanUnicodeCodePointEscape();
	                }
	                else {
	                    ch = this.scanHexEscape('u');
	                    if (ch === null || ch === '\\' || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
	                        this.throwUnexpectedToken();
	                    }
	                }
	                id += ch;
	            }
	        }
	        return id;
	    };
	    Scanner.prototype.octalToDecimal = function (ch) {
	        // \0 is not octal escape sequence
	        var octal = (ch !== '0');
	        var code = octalValue(ch);
	        if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	            octal = true;
	            code = code * 8 + octalValue(this.source[this.index++]);
	            // 3 digits are only allowed when string starts
	            // with 0, 1, 2, 3
	            if ('0123'.indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	                code = code * 8 + octalValue(this.source[this.index++]);
	            }
	        }
	        return {
	            code: code,
	            octal: octal
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
	    Scanner.prototype.scanIdentifier = function () {
	        var type;
	        var start = this.index;
	        // Backslash (U+005C) starts an escaped character.
	        var id = (this.source.charCodeAt(start) === 0x5C) ? this.getComplexIdentifier() : this.getIdentifier();
	        // There is no keyword or literal with only one character.
	        // Thus, it must be an identifier.
	        if (id.length === 1) {
	            type = 3 /* Identifier */;
	        }
	        else if (this.isKeyword(id)) {
	            type = 4 /* Keyword */;
	        }
	        else if (id === 'null') {
	            type = 5 /* NullLiteral */;
	        }
	        else if (id === 'true' || id === 'false') {
	            type = 1 /* BooleanLiteral */;
	        }
	        else {
	            type = 3 /* Identifier */;
	        }
	        if (type !== 3 /* Identifier */ && (start + id.length !== this.index)) {
	            var restore = this.index;
	            this.index = start;
	            this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
	            this.index = restore;
	        }
	        return {
	            type: type,
	            value: id,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-punctuators
	    Scanner.prototype.scanPunctuator = function () {
	        var start = this.index;
	        // Check for most common single-character punctuators.
	        var str = this.source[this.index];
	        switch (str) {
	            case '(':
	            case '{':
	                if (str === '{') {
	                    this.curlyStack.push('{');
	                }
	                ++this.index;
	                break;
	            case '.':
	                ++this.index;
	                if (this.source[this.index] === '.' && this.source[this.index + 1] === '.') {
	                    // Spread operator: ...
	                    this.index += 2;
	                    str = '...';
	                }
	                break;
	            case '}':
	                ++this.index;
	                this.curlyStack.pop();
	                break;
	            case ')':
	            case ';':
	            case ',':
	            case '[':
	            case ']':
	            case ':':
	            case '?':
	            case '~':
	                ++this.index;
	                break;
	            default:
	                // 4-character punctuator.
	                str = this.source.substr(this.index, 4);
	                if (str === '>>>=') {
	                    this.index += 4;
	                }
	                else {
	                    // 3-character punctuators.
	                    str = str.substr(0, 3);
	                    if (str === '===' || str === '!==' || str === '>>>' ||
	                        str === '<<=' || str === '>>=' || str === '**=') {
	                        this.index += 3;
	                    }
	                    else {
	                        // 2-character punctuators.
	                        str = str.substr(0, 2);
	                        if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
	                            str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
	                            str === '++' || str === '--' || str === '<<' || str === '>>' ||
	                            str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
	                            str === '<=' || str === '>=' || str === '=>' || str === '**') {
	                            this.index += 2;
	                        }
	                        else {
	                            // 1-character punctuators.
	                            str = this.source[this.index];
	                            if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
	                                ++this.index;
	                            }
	                        }
	                    }
	                }
	        }
	        if (this.index === start) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 7 /* Punctuator */,
	            value: str,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
	    Scanner.prototype.scanHexLiteral = function (start) {
	        var num = '';
	        while (!this.eof()) {
	            if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (num.length === 0) {
	            this.throwUnexpectedToken();
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt('0x' + num, 16),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.scanBinaryLiteral = function (start) {
	        var num = '';
	        var ch;
	        while (!this.eof()) {
	            ch = this.source[this.index];
	            if (ch !== '0' && ch !== '1') {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (num.length === 0) {
	            // only 0b or 0B
	            this.throwUnexpectedToken();
	        }
	        if (!this.eof()) {
	            ch = this.source.charCodeAt(this.index);
	            /* istanbul ignore else */
	            if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
	                this.throwUnexpectedToken();
	            }
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt(num, 2),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.scanOctalLiteral = function (prefix, start) {
	        var num = '';
	        var octal = false;
	        if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
	            octal = true;
	            num = '0' + this.source[this.index++];
	        }
	        else {
	            ++this.index;
	        }
	        while (!this.eof()) {
	            if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (!octal && num.length === 0) {
	            // only 0o or 0O
	            this.throwUnexpectedToken();
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt(num, 8),
	            octal: octal,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.isImplicitOctalLiteral = function () {
	        // Implicit octal, unless there is a non-octal digit.
	        // (Annex B.1.1 on Numeric Literals)
	        for (var i = this.index + 1; i < this.length; ++i) {
	            var ch = this.source[i];
	            if (ch === '8' || ch === '9') {
	                return false;
	            }
	            if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                return true;
	            }
	        }
	        return true;
	    };
	    Scanner.prototype.scanNumericLiteral = function () {
	        var start = this.index;
	        var ch = this.source[start];
	        assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'), 'Numeric literal must start with a decimal digit or a decimal point');
	        var num = '';
	        if (ch !== '.') {
	            num = this.source[this.index++];
	            ch = this.source[this.index];
	            // Hex number starts with '0x'.
	            // Octal number starts with '0'.
	            // Octal number in ES6 starts with '0o'.
	            // Binary number in ES6 starts with '0b'.
	            if (num === '0') {
	                if (ch === 'x' || ch === 'X') {
	                    ++this.index;
	                    return this.scanHexLiteral(start);
	                }
	                if (ch === 'b' || ch === 'B') {
	                    ++this.index;
	                    return this.scanBinaryLiteral(start);
	                }
	                if (ch === 'o' || ch === 'O') {
	                    return this.scanOctalLiteral(ch, start);
	                }
	                if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                    if (this.isImplicitOctalLiteral()) {
	                        return this.scanOctalLiteral(ch, start);
	                    }
	                }
	            }
	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                num += this.source[this.index++];
	            }
	            ch = this.source[this.index];
	        }
	        if (ch === '.') {
	            num += this.source[this.index++];
	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                num += this.source[this.index++];
	            }
	            ch = this.source[this.index];
	        }
	        if (ch === 'e' || ch === 'E') {
	            num += this.source[this.index++];
	            ch = this.source[this.index];
	            if (ch === '+' || ch === '-') {
	                num += this.source[this.index++];
	            }
	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                    num += this.source[this.index++];
	                }
	            }
	            else {
	                this.throwUnexpectedToken();
	            }
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseFloat(num),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-string-literals
	    Scanner.prototype.scanStringLiteral = function () {
	        var start = this.index;
	        var quote = this.source[start];
	        assert_1.assert((quote === '\'' || quote === '"'), 'String literal must starts with a quote');
	        ++this.index;
	        var octal = false;
	        var str = '';
	        while (!this.eof()) {
	            var ch = this.source[this.index++];
	            if (ch === quote) {
	                quote = '';
	                break;
	            }
	            else if (ch === '\\') {
	                ch = this.source[this.index++];
	                if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                        case 'u':
	                            if (this.source[this.index] === '{') {
	                                ++this.index;
	                                str += this.scanUnicodeCodePointEscape();
	                            }
	                            else {
	                                var unescaped_1 = this.scanHexEscape(ch);
	                                if (unescaped_1 === null) {
	                                    this.throwUnexpectedToken();
	                                }
	                                str += unescaped_1;
	                            }
	                            break;
	                        case 'x':
	                            var unescaped = this.scanHexEscape(ch);
	                            if (unescaped === null) {
	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
	                            }
	                            str += unescaped;
	                            break;
	                        case 'n':
	                            str += '\n';
	                            break;
	                        case 'r':
	                            str += '\r';
	                            break;
	                        case 't':
	                            str += '\t';
	                            break;
	                        case 'b':
	                            str += '\b';
	                            break;
	                        case 'f':
	                            str += '\f';
	                            break;
	                        case 'v':
	                            str += '\x0B';
	                            break;
	                        case '8':
	                        case '9':
	                            str += ch;
	                            this.tolerateUnexpectedToken();
	                            break;
	                        default:
	                            if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                                var octToDec = this.octalToDecimal(ch);
	                                octal = octToDec.octal || octal;
	                                str += String.fromCharCode(octToDec.code);
	                            }
	                            else {
	                                str += ch;
	                            }
	                            break;
	                    }
	                }
	                else {
	                    ++this.lineNumber;
	                    if (ch === '\r' && this.source[this.index] === '\n') {
	                        ++this.index;
	                    }
	                    this.lineStart = this.index;
	                }
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                break;
	            }
	            else {
	                str += ch;
	            }
	        }
	        if (quote !== '') {
	            this.index = start;
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 8 /* StringLiteral */,
	            value: str,
	            octal: octal,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-template-literal-lexical-components
	    Scanner.prototype.scanTemplate = function () {
	        var cooked = '';
	        var terminated = false;
	        var start = this.index;
	        var head = (this.source[start] === '`');
	        var tail = false;
	        var rawOffset = 2;
	        ++this.index;
	        while (!this.eof()) {
	            var ch = this.source[this.index++];
	            if (ch === '`') {
	                rawOffset = 1;
	                tail = true;
	                terminated = true;
	                break;
	            }
	            else if (ch === '$') {
	                if (this.source[this.index] === '{') {
	                    this.curlyStack.push('${');
	                    ++this.index;
	                    terminated = true;
	                    break;
	                }
	                cooked += ch;
	            }
	            else if (ch === '\\') {
	                ch = this.source[this.index++];
	                if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                        case 'n':
	                            cooked += '\n';
	                            break;
	                        case 'r':
	                            cooked += '\r';
	                            break;
	                        case 't':
	                            cooked += '\t';
	                            break;
	                        case 'u':
	                            if (this.source[this.index] === '{') {
	                                ++this.index;
	                                cooked += this.scanUnicodeCodePointEscape();
	                            }
	                            else {
	                                var restore = this.index;
	                                var unescaped_2 = this.scanHexEscape(ch);
	                                if (unescaped_2 !== null) {
	                                    cooked += unescaped_2;
	                                }
	                                else {
	                                    this.index = restore;
	                                    cooked += ch;
	                                }
	                            }
	                            break;
	                        case 'x':
	                            var unescaped = this.scanHexEscape(ch);
	                            if (unescaped === null) {
	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
	                            }
	                            cooked += unescaped;
	                            break;
	                        case 'b':
	                            cooked += '\b';
	                            break;
	                        case 'f':
	                            cooked += '\f';
	                            break;
	                        case 'v':
	                            cooked += '\v';
	                            break;
	                        default:
	                            if (ch === '0') {
	                                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                                    // Illegal: \01 \02 and so on
	                                    this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
	                                }
	                                cooked += '\0';
	                            }
	                            else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                                // Illegal: \1 \2
	                                this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
	                            }
	                            else {
	                                cooked += ch;
	                            }
	                            break;
	                    }
	                }
	                else {
	                    ++this.lineNumber;
	                    if (ch === '\r' && this.source[this.index] === '\n') {
	                        ++this.index;
	                    }
	                    this.lineStart = this.index;
	                }
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                ++this.lineNumber;
	                if (ch === '\r' && this.source[this.index] === '\n') {
	                    ++this.index;
	                }
	                this.lineStart = this.index;
	                cooked += '\n';
	            }
	            else {
	                cooked += ch;
	            }
	        }
	        if (!terminated) {
	            this.throwUnexpectedToken();
	        }
	        if (!head) {
	            this.curlyStack.pop();
	        }
	        return {
	            type: 10 /* Template */,
	            value: this.source.slice(start + 1, this.index - rawOffset),
	            cooked: cooked,
	            head: head,
	            tail: tail,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
	    Scanner.prototype.testRegExp = function (pattern, flags) {
	        // The BMP character to use as a replacement for astral symbols when
	        // translating an ES6 "u"-flagged pattern to an ES5-compatible
	        // approximation.
	        // Note: replacing with '\uFFFF' enables false positives in unlikely
	        // scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
	        // pattern that would not be detected by this substitution.
	        var astralSubstitute = '\uFFFF';
	        var tmp = pattern;
	        var self = this;
	        if (flags.indexOf('u') >= 0) {
	            tmp = tmp
	                .replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
	                var codePoint = parseInt($1 || $2, 16);
	                if (codePoint > 0x10FFFF) {
	                    self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
	                }
	                if (codePoint <= 0xFFFF) {
	                    return String.fromCharCode(codePoint);
	                }
	                return astralSubstitute;
	            })
	                .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
	        }
	        // First, detect invalid regular expressions.
	        try {
	            RegExp(tmp);
	        }
	        catch (e) {
	            this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
	        }
	        // Return a regular expression object for this pattern-flag pair, or
	        // `null` in case the current environment doesn't support the flags it
	        // uses.
	        try {
	            return new RegExp(pattern, flags);
	        }
	        catch (exception) {
	            /* istanbul ignore next */
	            return null;
	        }
	    };
	    Scanner.prototype.scanRegExpBody = function () {
	        var ch = this.source[this.index];
	        assert_1.assert(ch === '/', 'Regular expression literal must start with a slash');
	        var str = this.source[this.index++];
	        var classMarker = false;
	        var terminated = false;
	        while (!this.eof()) {
	            ch = this.source[this.index++];
	            str += ch;
	            if (ch === '\\') {
	                ch = this.source[this.index++];
	                // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
	                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	                }
	                str += ch;
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	            }
	            else if (classMarker) {
	                if (ch === ']') {
	                    classMarker = false;
	                }
	            }
	            else {
	                if (ch === '/') {
	                    terminated = true;
	                    break;
	                }
	                else if (ch === '[') {
	                    classMarker = true;
	                }
	            }
	        }
	        if (!terminated) {
	            this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	        }
	        // Exclude leading and trailing slash.
	        return str.substr(1, str.length - 2);
	    };
	    Scanner.prototype.scanRegExpFlags = function () {
	        var str = '';
	        var flags = '';
	        while (!this.eof()) {
	            var ch = this.source[this.index];
	            if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
	                break;
	            }
	            ++this.index;
	            if (ch === '\\' && !this.eof()) {
	                ch = this.source[this.index];
	                if (ch === 'u') {
	                    ++this.index;
	                    var restore = this.index;
	                    var char = this.scanHexEscape('u');
	                    if (char !== null) {
	                        flags += char;
	                        for (str += '\\u'; restore < this.index; ++restore) {
	                            str += this.source[restore];
	                        }
	                    }
	                    else {
	                        this.index = restore;
	                        flags += 'u';
	                        str += '\\u';
	                    }
	                    this.tolerateUnexpectedToken();
	                }
	                else {
	                    str += '\\';
	                    this.tolerateUnexpectedToken();
	                }
	            }
	            else {
	                flags += ch;
	                str += ch;
	            }
	        }
	        return flags;
	    };
	    Scanner.prototype.scanRegExp = function () {
	        var start = this.index;
	        var pattern = this.scanRegExpBody();
	        var flags = this.scanRegExpFlags();
	        var value = this.testRegExp(pattern, flags);
	        return {
	            type: 9 /* RegularExpression */,
	            value: '',
	            pattern: pattern,
	            flags: flags,
	            regex: value,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.lex = function () {
	        if (this.eof()) {
	            return {
	                type: 2 /* EOF */,
	                value: '',
	                lineNumber: this.lineNumber,
	                lineStart: this.lineStart,
	                start: this.index,
	                end: this.index
	            };
	        }
	        var cp = this.source.charCodeAt(this.index);
	        if (character_1.Character.isIdentifierStart(cp)) {
	            return this.scanIdentifier();
	        }
	        // Very common: ( and ) and ;
	        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
	            return this.scanPunctuator();
	        }
	        // String literal starts with single quote (U+0027) or double quote (U+0022).
	        if (cp === 0x27 || cp === 0x22) {
	            return this.scanStringLiteral();
	        }
	        // Dot (.) U+002E can also start a floating-point number, hence the need
	        // to check the next character.
	        if (cp === 0x2E) {
	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
	                return this.scanNumericLiteral();
	            }
	            return this.scanPunctuator();
	        }
	        if (character_1.Character.isDecimalDigit(cp)) {
	            return this.scanNumericLiteral();
	        }
	        // Template literals start with ` (U+0060) for template head
	        // or } (U+007D) for template middle or template tail.
	        if (cp === 0x60 || (cp === 0x7D && this.curlyStack[this.curlyStack.length - 1] === '${')) {
	            return this.scanTemplate();
	        }
	        // Possible identifier start in a surrogate pair.
	        if (cp >= 0xD800 && cp < 0xDFFF) {
	            if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
	                return this.scanIdentifier();
	            }
	        }
	        return this.scanPunctuator();
	    };
	    return Scanner;
	}());
	exports.Scanner = Scanner;


/***/ },
/* 13 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.TokenName = {};
	exports.TokenName[1 /* BooleanLiteral */] = 'Boolean';
	exports.TokenName[2 /* EOF */] = '<end>';
	exports.TokenName[3 /* Identifier */] = 'Identifier';
	exports.TokenName[4 /* Keyword */] = 'Keyword';
	exports.TokenName[5 /* NullLiteral */] = 'Null';
	exports.TokenName[6 /* NumericLiteral */] = 'Numeric';
	exports.TokenName[7 /* Punctuator */] = 'Punctuator';
	exports.TokenName[8 /* StringLiteral */] = 'String';
	exports.TokenName[9 /* RegularExpression */] = 'RegularExpression';
	exports.TokenName[10 /* Template */] = 'Template';


/***/ },
/* 14 */
/***/ function(module, exports) {

	"use strict";
	// Generated by generate-xhtml-entities.js. DO NOT MODIFY!
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.XHTMLEntities = {
	    quot: '\u0022',
	    amp: '\u0026',
	    apos: '\u0027',
	    gt: '\u003E',
	    nbsp: '\u00A0',
	    iexcl: '\u00A1',
	    cent: '\u00A2',
	    pound: '\u00A3',
	    curren: '\u00A4',
	    yen: '\u00A5',
	    brvbar: '\u00A6',
	    sect: '\u00A7',
	    uml: '\u00A8',
	    copy: '\u00A9',
	    ordf: '\u00AA',
	    laquo: '\u00AB',
	    not: '\u00AC',
	    shy: '\u00AD',
	    reg: '\u00AE',
	    macr: '\u00AF',
	    deg: '\u00B0',
	    plusmn: '\u00B1',
	    sup2: '\u00B2',
	    sup3: '\u00B3',
	    acute: '\u00B4',
	    micro: '\u00B5',
	    para: '\u00B6',
	    middot: '\u00B7',
	    cedil: '\u00B8',
	    sup1: '\u00B9',
	    ordm: '\u00BA',
	    raquo: '\u00BB',
	    frac14: '\u00BC',
	    frac12: '\u00BD',
	    frac34: '\u00BE',
	    iquest: '\u00BF',
	    Agrave: '\u00C0',
	    Aacute: '\u00C1',
	    Acirc: '\u00C2',
	    Atilde: '\u00C3',
	    Auml: '\u00C4',
	    Aring: '\u00C5',
	    AElig: '\u00C6',
	    Ccedil: '\u00C7',
	    Egrave: '\u00C8',
	    Eacute: '\u00C9',
	    Ecirc: '\u00CA',
	    Euml: '\u00CB',
	    Igrave: '\u00CC',
	    Iacute: '\u00CD',
	    Icirc: '\u00CE',
	    Iuml: '\u00CF',
	    ETH: '\u00D0',
	    Ntilde: '\u00D1',
	    Ograve: '\u00D2',
	    Oacute: '\u00D3',
	    Ocirc: '\u00D4',
	    Otilde: '\u00D5',
	    Ouml: '\u00D6',
	    times: '\u00D7',
	    Oslash: '\u00D8',
	    Ugrave: '\u00D9',
	    Uacute: '\u00DA',
	    Ucirc: '\u00DB',
	    Uuml: '\u00DC',
	    Yacute: '\u00DD',
	    THORN: '\u00DE',
	    szlig: '\u00DF',
	    agrave: '\u00E0',
	    aacute: '\u00E1',
	    acirc: '\u00E2',
	    atilde: '\u00E3',
	    auml: '\u00E4',
	    aring: '\u00E5',
	    aelig: '\u00E6',
	    ccedil: '\u00E7',
	    egrave: '\u00E8',
	    eacute: '\u00E9',
	    ecirc: '\u00EA',
	    euml: '\u00EB',
	    igrave: '\u00EC',
	    iacute: '\u00ED',
	    icirc: '\u00EE',
	    iuml: '\u00EF',
	    eth: '\u00F0',
	    ntilde: '\u00F1',
	    ograve: '\u00F2',
	    oacute: '\u00F3',
	    ocirc: '\u00F4',
	    otilde: '\u00F5',
	    ouml: '\u00F6',
	    divide: '\u00F7',
	    oslash: '\u00F8',
	    ugrave: '\u00F9',
	    uacute: '\u00FA',
	    ucirc: '\u00FB',
	    uuml: '\u00FC',
	    yacute: '\u00FD',
	    thorn: '\u00FE',
	    yuml: '\u00FF',
	    OElig: '\u0152',
	    oelig: '\u0153',
	    Scaron: '\u0160',
	    scaron: '\u0161',
	    Yuml: '\u0178',
	    fnof: '\u0192',
	    circ: '\u02C6',
	    tilde: '\u02DC',
	    Alpha: '\u0391',
	    Beta: '\u0392',
	    Gamma: '\u0393',
	    Delta: '\u0394',
	    Epsilon: '\u0395',
	    Zeta: '\u0396',
	    Eta: '\u0397',
	    Theta: '\u0398',
	    Iota: '\u0399',
	    Kappa: '\u039A',
	    Lambda: '\u039B',
	    Mu: '\u039C',
	    Nu: '\u039D',
	    Xi: '\u039E',
	    Omicron: '\u039F',
	    Pi: '\u03A0',
	    Rho: '\u03A1',
	    Sigma: '\u03A3',
	    Tau: '\u03A4',
	    Upsilon: '\u03A5',
	    Phi: '\u03A6',
	    Chi: '\u03A7',
	    Psi: '\u03A8',
	    Omega: '\u03A9',
	    alpha: '\u03B1',
	    beta: '\u03B2',
	    gamma: '\u03B3',
	    delta: '\u03B4',
	    epsilon: '\u03B5',
	    zeta: '\u03B6',
	    eta: '\u03B7',
	    theta: '\u03B8',
	    iota: '\u03B9',
	    kappa: '\u03BA',
	    lambda: '\u03BB',
	    mu: '\u03BC',
	    nu: '\u03BD',
	    xi: '\u03BE',
	    omicron: '\u03BF',
	    pi: '\u03C0',
	    rho: '\u03C1',
	    sigmaf: '\u03C2',
	    sigma: '\u03C3',
	    tau: '\u03C4',
	    upsilon: '\u03C5',
	    phi: '\u03C6',
	    chi: '\u03C7',
	    psi: '\u03C8',
	    omega: '\u03C9',
	    thetasym: '\u03D1',
	    upsih: '\u03D2',
	    piv: '\u03D6',
	    ensp: '\u2002',
	    emsp: '\u2003',
	    thinsp: '\u2009',
	    zwnj: '\u200C',
	    zwj: '\u200D',
	    lrm: '\u200E',
	    rlm: '\u200F',
	    ndash: '\u2013',
	    mdash: '\u2014',
	    lsquo: '\u2018',
	    rsquo: '\u2019',
	    sbquo: '\u201A',
	    ldquo: '\u201C',
	    rdquo: '\u201D',
	    bdquo: '\u201E',
	    dagger: '\u2020',
	    Dagger: '\u2021',
	    bull: '\u2022',
	    hellip: '\u2026',
	    permil: '\u2030',
	    prime: '\u2032',
	    Prime: '\u2033',
	    lsaquo: '\u2039',
	    rsaquo: '\u203A',
	    oline: '\u203E',
	    frasl: '\u2044',
	    euro: '\u20AC',
	    image: '\u2111',
	    weierp: '\u2118',
	    real: '\u211C',
	    trade: '\u2122',
	    alefsym: '\u2135',
	    larr: '\u2190',
	    uarr: '\u2191',
	    rarr: '\u2192',
	    darr: '\u2193',
	    harr: '\u2194',
	    crarr: '\u21B5',
	    lArr: '\u21D0',
	    uArr: '\u21D1',
	    rArr: '\u21D2',
	    dArr: '\u21D3',
	    hArr: '\u21D4',
	    forall: '\u2200',
	    part: '\u2202',
	    exist: '\u2203',
	    empty: '\u2205',
	    nabla: '\u2207',
	    isin: '\u2208',
	    notin: '\u2209',
	    ni: '\u220B',
	    prod: '\u220F',
	    sum: '\u2211',
	    minus: '\u2212',
	    lowast: '\u2217',
	    radic: '\u221A',
	    prop: '\u221D',
	    infin: '\u221E',
	    ang: '\u2220',
	    and: '\u2227',
	    or: '\u2228',
	    cap: '\u2229',
	    cup: '\u222A',
	    int: '\u222B',
	    there4: '\u2234',
	    sim: '\u223C',
	    cong: '\u2245',
	    asymp: '\u2248',
	    ne: '\u2260',
	    equiv: '\u2261',
	    le: '\u2264',
	    ge: '\u2265',
	    sub: '\u2282',
	    sup: '\u2283',
	    nsub: '\u2284',
	    sube: '\u2286',
	    supe: '\u2287',
	    oplus: '\u2295',
	    otimes: '\u2297',
	    perp: '\u22A5',
	    sdot: '\u22C5',
	    lceil: '\u2308',
	    rceil: '\u2309',
	    lfloor: '\u230A',
	    rfloor: '\u230B',
	    loz: '\u25CA',
	    spades: '\u2660',
	    clubs: '\u2663',
	    hearts: '\u2665',
	    diams: '\u2666',
	    lang: '\u27E8',
	    rang: '\u27E9'
	};


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var error_handler_1 = __webpack_require__(10);
	var scanner_1 = __webpack_require__(12);
	var token_1 = __webpack_require__(13);
	var Reader = (function () {
	    function Reader() {
	        this.values = [];
	        this.curly = this.paren = -1;
	    }
	    // A function following one of those tokens is an expression.
	    Reader.prototype.beforeFunctionExpression = function (t) {
	        return ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
	            'return', 'case', 'delete', 'throw', 'void',
	            // assignment operators
	            '=', '+=', '-=', '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=',
	            '&=', '|=', '^=', ',',
	            // binary/unary operators
	            '+', '-', '*', '**', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
	            '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
	            '<=', '<', '>', '!=', '!=='].indexOf(t) >= 0;
	    };
	    // Determine if forward slash (/) is an operator or part of a regular expression
	    // https://github.com/mozilla/sweet.js/wiki/design
	    Reader.prototype.isRegexStart = function () {
	        var previous = this.values[this.values.length - 1];
	        var regex = (previous !== null);
	        switch (previous) {
	            case 'this':
	            case ']':
	                regex = false;
	                break;
	            case ')':
	                var keyword = this.values[this.paren - 1];
	                regex = (keyword === 'if' || keyword === 'while' || keyword === 'for' || keyword === 'with');
	                break;
	            case '}':
	                // Dividing a function by anything makes little sense,
	                // but we have to check for that.
	                regex = false;
	                if (this.values[this.curly - 3] === 'function') {
	                    // Anonymous function, e.g. function(){} /42
	                    var check = this.values[this.curly - 4];
	                    regex = check ? !this.beforeFunctionExpression(check) : false;
	                }
	                else if (this.values[this.curly - 4] === 'function') {
	                    // Named function, e.g. function f(){} /42/
	                    var check = this.values[this.curly - 5];
	                    regex = check ? !this.beforeFunctionExpression(check) : true;
	                }
	                break;
	            default:
	                break;
	        }
	        return regex;
	    };
	    Reader.prototype.push = function (token) {
	        if (token.type === 7 /* Punctuator */ || token.type === 4 /* Keyword */) {
	            if (token.value === '{') {
	                this.curly = this.values.length;
	            }
	            else if (token.value === '(') {
	                this.paren = this.values.length;
	            }
	            this.values.push(token.value);
	        }
	        else {
	            this.values.push(null);
	        }
	    };
	    return Reader;
	}());
	var Tokenizer = (function () {
	    function Tokenizer(code, config) {
	        this.errorHandler = new error_handler_1.ErrorHandler();
	        this.errorHandler.tolerant = config ? (typeof config.tolerant === 'boolean' && config.tolerant) : false;
	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
	        this.scanner.trackComment = config ? (typeof config.comment === 'boolean' && config.comment) : false;
	        this.trackRange = config ? (typeof config.range === 'boolean' && config.range) : false;
	        this.trackLoc = config ? (typeof config.loc === 'boolean' && config.loc) : false;
	        this.buffer = [];
	        this.reader = new Reader();
	    }
	    Tokenizer.prototype.errors = function () {
	        return this.errorHandler.errors;
	    };
	    Tokenizer.prototype.getNextToken = function () {
	        if (this.buffer.length === 0) {
	            var comments = this.scanner.scanComments();
	            if (this.scanner.trackComment) {
	                for (var i = 0; i < comments.length; ++i) {
	                    var e = comments[i];
	                    var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
	                    var comment = {
	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
	                        value: value
	                    };
	                    if (this.trackRange) {
	                        comment.range = e.range;
	                    }
	                    if (this.trackLoc) {
	                        comment.loc = e.loc;
	                    }
	                    this.buffer.push(comment);
	                }
	            }
	            if (!this.scanner.eof()) {
	                var loc = void 0;
	                if (this.trackLoc) {
	                    loc = {
	                        start: {
	                            line: this.scanner.lineNumber,
	                            column: this.scanner.index - this.scanner.lineStart
	                        },
	                        end: {}
	                    };
	                }
	                var startRegex = (this.scanner.source[this.scanner.index] === '/') && this.reader.isRegexStart();
	                var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
	                this.reader.push(token);
	                var entry = {
	                    type: token_1.TokenName[token.type],
	                    value: this.scanner.source.slice(token.start, token.end)
	                };
	                if (this.trackRange) {
	                    entry.range = [token.start, token.end];
	                }
	                if (this.trackLoc) {
	                    loc.end = {
	                        line: this.scanner.lineNumber,
	                        column: this.scanner.index - this.scanner.lineStart
	                    };
	                    entry.loc = loc;
	                }
	                if (token.type === 9 /* RegularExpression */) {
	                    var pattern = token.pattern;
	                    var flags = token.flags;
	                    entry.regex = { pattern: pattern, flags: flags };
	                }
	                this.buffer.push(entry);
	            }
	        }
	        return this.buffer.shift();
	    };
	    return Tokenizer;
	}());
	exports.Tokenizer = Tokenizer;


/***/ }
/******/ ])
});
;
},{}],52:[function(require,module,exports){
'use strict'
var readonlyProxies = new WeakMap
var currentSandbox = undefined
var GLOBAL = new Function('return this')()
var unscopablesSymbol = Symbol.unscopables
var FunctionConstructor = 0..constructor.constructor

function compileExpression(src) {
	if (typeof src !== 'string') {
		throw new TypeError('Expected argument to be a string.')
	}
	
	new FunctionConstructor('"use strict"; return ' + src) // Tests for syntax errors without running the code
	var code = new FunctionConstructor('sandbox', 'with (sandbox) {return (function () {"use strict"; return ' + src + '}).call(this)}')
	
	return function (sandbox) {
		if (!isObject(sandbox)) {
			throw new TypeError('Expected argument to be an object or function.')
		}
		if (currentSandbox) {
			throw new Error('You cannot run sandboxed code inside an already-running sandbox.')
		}
		var sandboxProxy = getProxy(sandbox)
		var result, error
		
		currentSandbox = sandbox
		try {
			result = code.call(sandboxProxy, sandboxProxy)
			currentSandbox = undefined
		} catch (ex) {
			currentSandbox = undefined
			if (ex instanceof Error) {
				error = new ex.constructor('' + ex.message)
				error.stack = '' + ex.stack
				throw error
			}
			throw new Error(String(ex))
		}
		if (isObject(result)) {
			throw TypeError('Sandboxes are only allowed to return primitive values.')
		}
		return result
	}
}
module.exports = compileExpression

var traps = {
	get: function (target, key, receiver) {
		if (currentSandbox) {
			if (key === unscopablesSymbol && target === currentSandbox) {
				return undefined
			}
			if (!notPrivate(key)) {
				return undefined
			}
			return getProxyOrPrimitive(Reflect.get(target, key, receiver))
		}
		return Reflect.get(target, key, receiver)
	},
	set: function (target, key, value, receiver) {
		if (currentSandbox) {
			throw new TypeError('You cannot set properties on a sandboxed object.')
		}
		return Reflect.set(target, key, value, receiver)
	},
	has: function (target, key) {
		if (currentSandbox) {
			if (target === currentSandbox) {
				return true
			}
			if (!notPrivate(key)) {
				return false
			}
			return getProxyOrPrimitive(Reflect.has(target, key))
		}
		return Reflect.has(target, key)
	},
	getPrototypeOf: function (target) {
		if (currentSandbox) {
			return getProxyOrPrimitive(Reflect.getPrototypeOf(target))
		}
		return Reflect.getPrototypeOf(target)
	},
	setPrototypeOf: function (target, proto) {
		if (currentSandbox) {
			throw new TypeError('You cannot set the prototype of a sandboxed object.')
		}
		return Reflect.setPrototypeOf(target, proto)
	},
	isExtensible: function (target) {
		if (currentSandbox) {
			return getProxyOrPrimitive(Reflect.isExtensible(target))
		}
		return Reflect.isExtensible(target)
	},
	preventExtensions: function (target) {
		if (currentSandbox) {
			throw new TypeError('You cannot change the extensibility of a sandboxed object.')
		}
		return Reflect.preventExtensions(target)
	},
	getOwnPropertyDescriptor: function (target, key) {
		if (currentSandbox) {
			if (key === Symbol.unscopables && target === currentSandbox) {
				return undefined
			}
			if (!notPrivate(key)) {
				return undefined
			}
			return getProxyOrPrimitive(Reflect.getOwnPropertyDescriptor(target, key))
		}
		return Reflect.getOwnPropertyDescriptor(target, key)
	},
	defineProperty: function (target, key, descriptor) {
		if (currentSandbox) {
			throw new TypeError('You cannot define properties on a sandboxed object.')
		}
		return Reflect.defineProperty(target, key, descriptor)
	},
	deleteProperty: function (target, key) {
		if (currentSandbox) {
			throw new TypeError('You cannot delete properties on a sandboxed object.')
		}
		return Reflect.deleteProperty(target, key)
	},
	ownKeys: function (target) {
		if (currentSandbox) {
			return getProxyOrPrimitive(Reflect.ownKeys(target).filter(notPrivate))
		}
		return Reflect.ownKeys(target)
	},
	apply: function (target, thisArg, argumentsList) {
		if (currentSandbox) {
			if (target === FunctionConstructor || target === FunctionConstructorProxy) {
				throw new TypeError('You cannot use the Function constructor in a sandboxed context.')
			}
			return getProxyOrPrimitive(Reflect.apply(target, thisArg, argumentsList))
		}
		return Reflect.apply(target, thisArg, argumentsList)
	},
	construct: function (target, argumentsList, newTarget) {
		if (currentSandbox) {
			if (target === FunctionConstructor || target === FunctionConstructorProxy) {
				throw new TypeError('You cannot use the Function constructor in a sandboxed context.')
			}
			return getProxyOrPrimitive(Reflect.construct(target, argumentsList, newTarget))
		}
		return Reflect.construct(target, argumentsList, newTarget)
	}
}

function isObject(value) {
	return typeof value === 'function' || (value !== null && typeof value === 'object')
}

function getProxyOrPrimitive(value) {
	if (isObject(value)) {
		return safeObjects.indexOf(value) >= 0 ? value : getProxy(value)
	}
	return value
}

function getProxy(object, hideOriginal) {
	if (object === GLOBAL) {
		throw new TypeError('The global object is forbidden from entering a sandboxed context.')
	}
	if (object === evalFunction) {
		throw new TypeError('The eval function is forbidden from entering a sandboxed context.')
	}
	var proxy = readonlyProxies.get(object)
	if (typeof proxy === 'undefined') {
		proxy = new Proxy(object, traps)
		readonlyProxies.set(hideOriginal ? proxy : object, proxy)
	}
	return proxy
}

function notPrivate(key) {
	return typeof key !== 'string' || key[0] !== '_'
}

// Freeze and proxy anything that is accessible through JavaScript syntax alone
// This should include any value that you can get from JavaScript syntax itself.
// For example:
//     "my string".foobar
//     try {throw 1} catch (err) {err.foobar}
// Symbols are included here because they are not protected by our proxying
// because they are primitives.
var safeObjects = require('./lib/make-safe')([
	Boolean.prototype,
	Number.prototype,
	String.prototype,
	Symbol.prototype,
	Function.prototype,
	Object.prototype,
	Array.prototype,
	RegExp.prototype,
	Error.prototype,
	EvalError.prototype,
	RangeError.prototype,
	ReferenceError.prototype,
	SyntaxError.prototype,
	TypeError.prototype,
	URIError.prototype,
	Promise.prototype,
	Object.getPrototypeOf(function*(){}),
	Object.getPrototypeOf(function*(){}())
], isObject, getProxy, GLOBAL)

var evalFunction = GLOBAL.eval
var FunctionConstructorProxy = 0..constructor.constructor

module.exports.equals = function (a, b) {
	return a === b || (readonlyProxies.get(a) || a) === (readonlyProxies.get(b) || b)
}



},{"./lib/make-safe":53}],53:[function(require,module,exports){
'use strict'

module.exports = function (unsafeObjects, isObject, getProxy, GLOBAL) {
	var proxies = []
	var safeObjects = []
	var returnsSafeValues = [
		Function.prototype[Symbol.hasInstance]
	]
	var globalKeys = Object.getOwnPropertyNames(GLOBAL).filter(function (key) {return key !== 'root' && key !== 'GLOBAL' && key !== 'global' && key !== 'window' && key !== 'self'})
	var globalValues = globalKeys.map(function (key) {return this[key]}, GLOBAL)
	
	while (unsafeObjects.length) {
		makeSafe(unsafeObjects.shift())
	}
	
	function makeSafe(object) {
		if (isSafe(object)) {
			return
		}
		
		var reachable = Object.getOwnPropertyNames(object)
			.concat(Object.getOwnPropertySymbols(object))
		
		if (object === Function.prototype) {
			reachable = reachable.filter(ignoredKeys)
		}
		
		reachable.forEach(replaceWithProxy, object)
		Object.freeze(object)
		safeObjects.push(object)
		
		unsafeObjects.push(Object.getPrototypeOf(object))
	}
	
	function ignoredKeys(key) {
		return key !== 'caller' && key !== 'arguments'
	}
	
	function isSafe(value) {
		return !isObject(value) || proxies.indexOf(value) >= 0 || safeObjects.indexOf(value) >= 0
	}
	
	function replaceWithProxy(key) {
		var d = Object.getOwnPropertyDescriptor(this, key)
		if (!('value' in d)) {
			if (key === '__proto__' && isSafe(this[key])) {
				return
			}
			if (!d.configurable) {
				d.get && unsafeObjects.push(d.get)
				d.set && unsafeObjects.push(d.set)
				// This getter/setter could potentially return a non-proxied object
				console.warn('Potentially vulnerable getter/setter at %s in %s', key, this)
				return
			}
			var getter = d.get && getProxy(d.get, true)
			var setter = d.set && getProxy(d.set, true)
			Object.defineProperty(this, key, {
				get: getter,
				set: setter,
				enumerable: d.enumerable,
				configurable: false
			})
			getter && proxies.push(getter)
			setter && proxies.push(setter)
			return
		}
		
		var value = this[key]
		if (isSafe(value)) {
			return
		}
		
		if (d.writable) {
			var proxy = getProxy(value, true)
			proxies.push(this[key] = proxy)
			replaceInGlobal(value, proxy)
			return
		}
		
		if (d.configurable) {
			var proxy = getProxy(value, true)
			Object.defineProperty(this, key, {
				value: proxy,
				writable: false,
				enumerable: d.enumerable,
				configurable: false
			})
			replaceInGlobal(value, proxy)
			proxies.push(proxy)
			return
		}
		
		unsafeObjects.push(value)
		if (typeof value === 'function' && returnsSafeValues.indexOf(value) === -1) {
			// This function could potentially return a non-proxied object
			console.warn('Potentially vulnerable function at %s in %s', key, this)
		}
	}
	
	function replaceInGlobal(value, proxy) {
		var index = globalValues.indexOf(value)
		if (index >= 0) {
			var key = globalKeys[index]
			var d = Object.getOwnPropertyDescriptor(GLOBAL, key)
			if (d.writable) {
				GLOBAL[key] = proxy
			} else if (d.configurable) {
				Object.defineProperty(GLOBAL, key, {
					value: proxy,
					writable: false,
					enumerable: d.enumerable,
					configurable: false
				})
			} else {
				console.warn('Was not able to replace %s in global object', key)
			}
		}
	}
	
	return safeObjects
}

},{}],54:[function(require,module,exports){
'use strict';
var ansiRegex = require('ansi-regex');
var re = new RegExp(ansiRegex().source); // remove the `g` flag
module.exports = re.test.bind(re);

},{"ansi-regex":46}],55:[function(require,module,exports){
(function (global){
/**
 * Â© Copyright IBM Corp. 2016, 2017 All Rights Reserved
 *   Project name: JSONata
 *   This project is licensed under the MIT License, see LICENSE
 */

/**
 * @module JSONata
 * @description JSON query and transformation language
 */

/**
 * jsonata
 * @function
 * @param {Object} expr - JSONata expression
 * @returns {{evaluate: evaluate, assign: assign}} Evaluated expression
 */
var jsonata = (function() {
    'use strict';

    var operators = {
        '.': 75,
        '[': 80,
        ']': 0,
        '{': 70,
        '}': 0,
        '(': 80,
        ')': 0,
        ',': 0,
        '@': 75,
        '#': 70,
        ';': 80,
        ':': 80,
        '?': 20,
        '+': 50,
        '-': 50,
        '*': 60,
        '/': 60,
        '%': 60,
        '|': 20,
        '=': 40,
        '<': 40,
        '>': 40,
        '^': 40,
        '**': 60,
        '..': 20,
        ':=': 10,
        '!=': 40,
        '<=': 40,
        '>=': 40,
        '~>': 40,
        'and': 30,
        'or': 25,
        'in': 40,
        '&': 50,
        '!': 0,   // not an operator, but needed as a stop character for name tokens
        '~': 0   // not an operator, but needed as a stop character for name tokens
    };

    var escapes = {  // JSON string escape sequences - see json.org
        '"': '"',
        '\\': '\\',
        '/': '/',
        'b': '\b',
        'f': '\f',
        'n': '\n',
        'r': '\r',
        't': '\t'
    };

    // Tokenizer (lexer) - invoked by the parser to return one token at a time
    var tokenizer = function (path) {
        var position = 0;
        var length = path.length;

        var create = function (type, value) {
            var obj = {type: type, value: value, position: position};
            return obj;
        };

        var scanRegex = function() {
            // the prefix '/' will have been previously scanned. Find the end of the regex.
            // search for closing '/' ignoring any that are escaped, or within brackets
            var start = position;
            var depth = 0;
            var pattern;
            var flags;
            while(position < length) {
                var currentChar = path.charAt(position);
                if(currentChar === '/' && path.charAt(position - 1) !== '\\' && depth === 0) {
                    // end of regex found
                    pattern = path.substring(start, position);
                    if(pattern === '') {
                        throw {
                            code: "S0301",
                            stack: (new Error()).stack,
                            position: position
                        };
                    }
                    position++;
                    currentChar = path.charAt(position);
                    // flags
                    start = position;
                    while(currentChar === 'i' || currentChar === 'm') {
                        position++;
                        currentChar = path.charAt(position);
                    }
                    flags = path.substring(start, position) + 'g';
                    return new RegExp(pattern, flags);
                }
                if((currentChar === '(' || currentChar === '[' || currentChar === '{') && path.charAt(position - 1) !== '\\' ) {
                    depth++;
                }
                if((currentChar === ')' || currentChar === ']' || currentChar === '}') && path.charAt(position - 1) !== '\\' ) {
                    depth--;
                }

                position++;
            }
            throw {
                code: "S0302",
                stack: (new Error()).stack,
                position: position
            };
        };

        var next = function (prefix) {
            if (position >= length) return null;
            var currentChar = path.charAt(position);
            // skip whitespace
            while (position < length && ' \t\n\r\v'.indexOf(currentChar) > -1) {
                position++;
                currentChar = path.charAt(position);
            }
            // test for regex
            if (prefix !== true && currentChar === '/') {
                position++;
                return create('regex', scanRegex());
            }
            // handle double-char operators
            if (currentChar === '.' && path.charAt(position + 1) === '.') {
                // double-dot .. range operator
                position += 2;
                return create('operator', '..');
            }
            if (currentChar === ':' && path.charAt(position + 1) === '=') {
                // := assignment
                position += 2;
                return create('operator', ':=');
            }
            if (currentChar === '!' && path.charAt(position + 1) === '=') {
                // !=
                position += 2;
                return create('operator', '!=');
            }
            if (currentChar === '>' && path.charAt(position + 1) === '=') {
                // >=
                position += 2;
                return create('operator', '>=');
            }
            if (currentChar === '<' && path.charAt(position + 1) === '=') {
                // <=
                position += 2;
                return create('operator', '<=');
            }
            if (currentChar === '*' && path.charAt(position + 1) === '*') {
                // **  descendant wildcard
                position += 2;
                return create('operator', '**');
            }
            if (currentChar === '~' && path.charAt(position + 1) === '>') {
                // ~>  chain function
                position += 2;
                return create('operator', '~>');
            }
            // test for single char operators
            if (operators.hasOwnProperty(currentChar)) {
                position++;
                return create('operator', currentChar);
            }
            // test for string literals
            if (currentChar === '"' || currentChar === "'") {
                var quoteType = currentChar;
                // double quoted string literal - find end of string
                position++;
                var qstr = "";
                while (position < length) {
                    currentChar = path.charAt(position);
                    if (currentChar === '\\') { // escape sequence
                        position++;
                        currentChar = path.charAt(position);
                        if (escapes.hasOwnProperty(currentChar)) {
                            qstr += escapes[currentChar];
                        } else if (currentChar === 'u') {
                            // \u should be followed by 4 hex digits
                            var octets = path.substr(position + 1, 4);
                            if (/^[0-9a-fA-F]+$/.test(octets)) {
                                var codepoint = parseInt(octets, 16);
                                qstr += String.fromCharCode(codepoint);
                                position += 4;
                            } else {
                                throw {
                                    code: "S0104",
                                    stack: (new Error()).stack,
                                    position: position
                                };
                            }
                        } else {
                            // illegal escape sequence
                            throw {
                                code: "S0103",
                                stack: (new Error()).stack,
                                position: position,
                                token: currentChar
                            };

                        }
                    } else if (currentChar === quoteType) {
                        position++;
                        return create('string', qstr);
                    } else {
                        qstr += currentChar;
                    }
                    position++;
                }
                throw {
                    code: "S0101",
                    stack: (new Error()).stack,
                    position: position
                };
            }
            // test for numbers
            var numregex = /^-?(0|([1-9][0-9]*))(\.[0-9]+)?([Ee][-+]?[0-9]+)?/;
            var match = numregex.exec(path.substring(position));
            if (match !== null) {
                var num = parseFloat(match[0]);
                if (!isNaN(num) && isFinite(num)) {
                    position += match[0].length;
                    return create('number', num);
                } else {
                    throw {
                        code: "S0102",
                        stack: (new Error()).stack,
                        position: position,
                        token: match[0]
                    };
                }
            }
            // test for quoted names (backticks)
            var name;
            if(currentChar === '`') {
                // scan for closing quote
                position++;
                var end = path.indexOf('`', position);
                if(end !== -1) {
                    name = path.substring(position, end);
                    position = end + 1;
                    return create('name', name);
                }
                position = length;
                throw {
                    code: "S0105",
                    stack: (new Error()).stack,
                    position: position
                };
            }
            // test for names
            var i = position;
            var ch;
            for (;;) {
                ch = path.charAt(i);
                if (i === length || ' \t\n\r\v'.indexOf(ch) > -1 || operators.hasOwnProperty(ch)) {
                    if (path.charAt(position) === '$') {
                        // variable reference
                        name = path.substring(position + 1, i);
                        position = i;
                        return create('variable', name);
                    } else {
                        name = path.substring(position, i);
                        position = i;
                        switch (name) {
                            case 'or':
                            case 'in':
                            case 'and':
                                return create('operator', name);
                            case 'true':
                                return create('value', true);
                            case 'false':
                                return create('value', false);
                            case 'null':
                                return create('value', null);
                            default:
                                if (position === length && name === '') {
                                    // whitespace at end of input
                                    return null;
                                }
                                return create('name', name);
                        }
                    }
                } else {
                    i++;
                }
            }
        };

        return next;
    };

    /**
     * Parses a function signature definition and returns a validation function
     * @param {string} signature - the signature between the <angle brackets>
     * @returns {Function} validation function
     */
    function parseSignature(signature) {
        // create a Regex that represents this signature and return a function that when invoked,
        // returns the validated (possibly fixed-up) arguments, or throws a validation error
        // step through the signature, one symbol at a time
        var position = 1;
        var params = [];
        var param = {};
        var prevParam = param;
        while (position < signature.length) {
            var symbol = signature.charAt(position);
            if(symbol === ':') {
                // TODO figure out what to do with the return type
                // ignore it for now
                break;
            }

            var next = function() {
                params.push(param);
                prevParam = param;
                param = {};
            };

            var findClosingBracket = function(str, start, openSymbol, closeSymbol) {
                // returns the position of the closing symbol (e.g. bracket) in a string
                // that balances the opening symbol at position start
                var depth = 1;
                var position = start;
                while(position < str.length) {
                    position++;
                    symbol = str.charAt(position);
                    if(symbol === closeSymbol) {
                        depth--;
                        if(depth === 0) {
                            // we're done
                            break; // out of while loop
                        }
                    } else if(symbol === openSymbol) {
                        depth++;
                    }
                }
                return position;
            };

            switch (symbol) {
                case 's': // string
                case 'n': // number
                case 'b': // boolean
                case 'l': // not so sure about expecting null?
                case 'o': // object
                    param.regex = '[' + symbol + 'm]';
                    param.type = symbol;
                    next();
                    break;
                case 'a': // array
                    //  normally treat any value as singleton array
                    param.regex = '[asnblfom]';
                    param.type = symbol;
                    param.array = true;
                    next();
                    break;
                case 'f': // function
                    param.regex = 'f';
                    param.type = symbol;
                    next();
                    break;
                case 'j': // any JSON type
                    param.regex = '[asnblom]';
                    param.type = symbol;
                    next();
                    break;
                case 'x': // any type
                    param.regex = '[asnblfom]';
                    param.type = symbol;
                    next();
                    break;
                case '-': // use context if param not supplied
                    prevParam.context = true;
                    prevParam.contextRegex = new RegExp(prevParam.regex); // pre-compiled to test the context type at runtime
                    prevParam.regex += '?';
                    break;
                case '?': // optional param
                case '+': // one or more
                    prevParam.regex += symbol;
                    break;
                case '(': // choice of types
                    // search forward for matching ')'
                    var endParen = findClosingBracket(signature, position, '(', ')');
                    var choice = signature.substring(position + 1, endParen);
                    if(choice.indexOf('<') === -1) {
                        // no parameterized types, simple regex
                        param.regex = '[' + choice + 'm]';
                    } else {
                        // TODO harder
                        throw {
                            code: "S0402",
                            stack: (new Error()).stack,
                            value: choice,
                            offset: position
                        };
                    }
                    param.type = '(' + choice + ')';
                    position = endParen;
                    next();
                    break;
                case '<': // type parameter - can only be applied to 'a' and 'f'
                    if(prevParam.type === 'a' || prevParam.type === 'f') {
                        // search forward for matching '>'
                        var endPos = findClosingBracket(signature, position, '<', '>');
                        prevParam.subtype = signature.substring(position + 1, endPos);
                        position = endPos;
                    } else {
                        throw {
                            code: "S0401",
                            stack: (new Error()).stack,
                            value: prevParam.type,
                            offset: position
                        };
                    }
                    break;
            }
            position++;
        }
        var regexStr = '^' +
          params.map(function(param) {
              return '(' + param.regex + ')';
          }).join('') +
          '$';
        var regex = new RegExp(regexStr);
        var getSymbol = function(value) {
            var symbol;
            if(isFunction(value)) {
                symbol = 'f';
            } else {
                var type = typeof value;
                switch (type) {
                    case 'string':
                        symbol = 's';
                        break;
                    case 'number':
                        symbol = 'n';
                        break;
                    case 'boolean':
                        symbol = 'b';
                        break;
                    case 'object':
                        if (value === null) {
                            symbol = 'l';
                        } else if (Array.isArray(value)) {
                            symbol = 'a';
                        } else {
                            symbol = 'o';
                        }
                        break;
                    case 'undefined':
                        // any value can be undefined, but should be allowed to match
                        symbol = 'm'; // m for missing
                }
            }
            return symbol;
        };

        var throwValidationError = function(badArgs, badSig) {
            // to figure out where this went wrong we need apply each component of the
            // regex to each argument until we get to the one that fails to match
            var partialPattern = '^';
            var goodTo = 0;
            for(var index = 0; index < params.length; index++) {
                partialPattern += params[index].regex;
                var match = badSig.match(partialPattern);
                if(match === null) {
                    // failed here
                    throw {
                        code: "T0410",
                        stack: (new Error()).stack,
                        value: badArgs[goodTo],
                        index: goodTo + 1
                    };
                }
                goodTo = match[0].length;
            }
            // if it got this far, it's probably because of extraneous arguments (we
            // haven't added the trailing '$' in the regex yet.
            throw {
                code: "T0410",
                stack: (new Error()).stack,
                value: badArgs[goodTo],
                index: goodTo + 1
            };
        };

        return {
            definition: signature,
            validate: function(args, context) {
                var suppliedSig = '';
                args.forEach(function(arg) {
                    suppliedSig += getSymbol(arg);
                });
                var isValid = regex.exec(suppliedSig);
                if(isValid) {
                    var validatedArgs = [];
                    var argIndex = 0;
                    params.forEach(function(param, index) {
                        var arg = args[argIndex];
                        var match = isValid[index + 1];
                        if(match === '') {
                            if (param.context) {
                                // substitute context value for missing arg
                                // first check that the context value is the right type
                                var contextType = getSymbol(context);
                                // test contextType against the regex for this arg (without the trailing ?)
                                if(param.contextRegex.test(contextType)) {
                                    validatedArgs.push(context);
                                } else {
                                    // context value not compatible with this argument
                                    throw {
                                        code: "T0411",
                                        stack: (new Error()).stack,
                                        value: context,
                                        index: argIndex + 1
                                    };
                                }
                            } else {
                                validatedArgs.push(arg);
                                argIndex++;
                            }
                        } else {
                            // may have matched multiple args (if the regex ends with a '+'
                            // split into single tokens
                            match.split('').forEach(function(single) {
                                if (param.type === 'a') {
                                    if (single === 'm') {
                                        // missing (undefined)
                                        arg = undefined;
                                    } else {
                                        arg = args[argIndex];
                                        var arrayOK = true;
                                        // is there type information on the contents of the array?
                                        if (typeof param.subtype !== 'undefined') {
                                            if (single !== 'a' && match !== param.subtype) {
                                                arrayOK = false;
                                            } else if (single === 'a') {
                                                if (arg.length > 0) {
                                                    var itemType = getSymbol(arg[0]);
                                                    if (itemType !== param.subtype.charAt(0)) { // TODO recurse further
                                                        arrayOK = false;
                                                    } else {
                                                        // make sure every item in the array is this type
                                                        var differentItems = arg.filter(function (val) {
                                                            return (getSymbol(val) !== itemType);
                                                        });
                                                        arrayOK = (differentItems.length === 0);
                                                    }
                                                }
                                            }
                                        }
                                        if (!arrayOK) {
                                            throw {
                                                code: "T0412",
                                                stack: (new Error()).stack,
                                                value: arg,
                                                index: argIndex + 1,
                                                type: param.subtype // TODO translate symbol to type name
                                            };
                                        }
                                        // the function expects an array. If it's not one, make it so
                                        if (single !== 'a') {
                                            arg = [arg];
                                        }
                                    }
                                    validatedArgs.push(arg);
                                    argIndex++;
                                } else {
                                    validatedArgs.push(arg);
                                    argIndex++;
                                }
                            });
                        }
                    });
                    return validatedArgs;
                }
                throwValidationError(args, suppliedSig);
            }
        };
    }

    // This parser implements the 'Top down operator precedence' algorithm developed by Vaughan R Pratt; http://dl.acm.org/citation.cfm?id=512931.
    // and builds on the Javascript framework described by Douglas Crockford at http://javascript.crockford.com/tdop/tdop.html
    // and in 'Beautiful Code', edited by Andy Oram and Greg Wilson, Copyright 2007 O'Reilly Media, Inc. 798-0-596-51004-6

    var parser = function (source, recover) {
        var node;
        var lexer;

        var symbol_table = {};
        var errors = [];

        var remainingTokens = function() {
            var remaining = [];
            if(node.id !== '(end)') {
                remaining.push({type: node.type, value: node.value, position: node.position});
            }
            var nxt = lexer();
            while(nxt !== null) {
                remaining.push(nxt);
                nxt = lexer();
            }
            return remaining;
        };

        var base_symbol = {
            nud: function () {
                // error - symbol has been invoked as a unary operator
                var err = {
                    code: 'S0211',
                    token: this.value,
                    position: this.position
                };

                if(recover) {
                    err.remaining = remainingTokens();
                    err.type = 'error';
                    errors.push(err);
                    return err;
                } else {
                    err.stack = (new Error()).stack;
                    throw err;
                }
            }
        };

        var symbol = function (id, bp) {
            var s = symbol_table[id];
            bp = bp || 0;
            if (s) {
                if (bp >= s.lbp) {
                    s.lbp = bp;
                }
            } else {
                s = Object.create(base_symbol);
                s.id = s.value = id;
                s.lbp = bp;
                symbol_table[id] = s;
            }
            return s;
        };

        var handleError = function(err) {
            if(recover) {
                // tokenize the rest of the buffer and add it to an error token
                err.remaining = remainingTokens();
                errors.push(err);
                var symbol = symbol_table["(error)"];
                node = Object.create(symbol);
                node.error = err;
                node.type = "(error)";
                return node;
            } else {
                err.stack = (new Error()).stack;
                throw err;
            }
        };

        var advance = function (id, infix) {
            if (id && node.id !== id) {
                var code;
                if(node.id === '(end)') {
                    // unexpected end of buffer
                    code = "S0203";
                } else {
                    code = "S0202";
                }
                var err = {
                    code: code,
                    position: node.position,
                    token: node.value,
                    value: id
                };
                return handleError(err);
            }
            var next_token = lexer(infix);
            if (next_token === null) {
                node = symbol_table["(end)"];
                node.position = source.length;
                return node;
            }
            var value = next_token.value;
            var type = next_token.type;
            var symbol;
            switch (type) {
                case 'name':
                case 'variable':
                    symbol = symbol_table["(name)"];
                    break;
                case 'operator':
                    symbol = symbol_table[value];
                    if (!symbol) {
                        return handleError( {
                            code: "S0204",
                            stack: (new Error()).stack,
                            position: next_token.position,
                            token: value
                        });
                    }
                    break;
                case 'string':
                case 'number':
                case 'value':
                    type = "literal";
                    symbol = symbol_table["(literal)"];
                    break;
                case 'regex':
                    type = "regex";
                    symbol = symbol_table["(regex)"];
                    break;
                    /* istanbul ignore next */
                default:
                    return handleError( {
                        code: "S0205",
                        stack: (new Error()).stack,
                        position: next_token.position,
                        token: value
                    });
            }

            node = Object.create(symbol);
            node.value = value;
            node.type = type;
            node.position = next_token.position;
            return node;
        };

        // Pratt's algorithm
        var expression = function (rbp) {
            var left;
            var t = node;
            advance(null, true);
            left = t.nud();
            while (rbp < node.lbp) {
                t = node;
                advance();
                left = t.led(left);
            }
            return left;
        };

        var terminal = function(id) {
            var s = symbol(id, 0);
            s.nud = function() {
                return this;
            };
        };

        // match infix operators
        // <expression> <operator> <expression>
        // left associative
        var infix = function (id, bp, led) {
            var bindingPower = bp || operators[id];
            var s = symbol(id, bindingPower);
            s.led = led || function (left) {
                this.lhs = left;
                this.rhs = expression(bindingPower);
                this.type = "binary";
                return this;
            };
            return s;
        };

        // match infix operators
        // <expression> <operator> <expression>
        // right associative
        var infixr = function (id, bp, led) {
            var bindingPower = bp || operators[id];
            var s = symbol(id, bindingPower);
            s.led = led || function (left) {
                this.lhs = left;
                this.rhs = expression(bindingPower - 1); // subtract 1 from bindingPower for right associative operators
                this.type = "binary";
                return this;
            };
            return s;
        };

        // match prefix operators
        // <operator> <expression>
        var prefix = function (id, nud) {
            var s = symbol(id);
            s.nud = nud || function () {
                this.expression = expression(70);
                this.type = "unary";
                return this;
            };
            return s;
        };

        terminal("(end)");
        terminal("(name)");
        terminal("(literal)");
        terminal("(regex)");
        symbol(":");
        symbol(";");
        symbol(",");
        symbol(")");
        symbol("]");
        symbol("}");
        symbol(".."); // range operator
        infix("."); // field reference
        infix("+"); // numeric addition
        infix("-"); // numeric subtraction
        infix("*"); // numeric multiplication
        infix("/"); // numeric division
        infix("%"); // numeric modulus
        infix("="); // equality
        infix("<"); // less than
        infix(">"); // greater than
        infix("!="); // not equal to
        infix("<="); // less than or equal
        infix(">="); // greater than or equal
        infix("&"); // string concatenation
        infix("and"); // Boolean AND
        infix("or"); // Boolean OR
        infix("in"); // is member of array
        terminal("and"); // the 'keywords' can also be used as terminals (field names)
        terminal("or"); //
        terminal("in"); //
        infixr(":="); // bind variable
        prefix("-"); // unary numeric negation
        infix("~>"); // function application

        infixr("(error)", 10, function(left) {
            this.lhs = left;

            this.error = node.error;
            this.remaining = remainingTokens();
            this.type = 'error';
            return this;
        });

        // field wildcard (single level)
        prefix('*', function () {
            this.type = "wildcard";
            return this;
        });

        // descendant wildcard (multi-level)
        prefix('**', function () {
            this.type = "descendant";
            return this;
        });

        // function invocation
        infix("(", operators['('], function (left) {
            // left is is what we are trying to invoke
            this.procedure = left;
            this.type = 'function';
            this.arguments = [];
            if (node.id !== ')') {
                for (;;) {
                    if (node.type === 'operator' && node.id === '?') {
                        // partial function application
                        this.type = 'partial';
                        this.arguments.push(node);
                        advance('?');
                    } else {
                        this.arguments.push(expression(0));
                    }
                    if (node.id !== ',') break;
                    advance(',');
                }
            }
            advance(")", true);
            // if the name of the function is 'function' or Î», then this is function definition (lambda function)
            if (left.type === 'name' && (left.value === 'function' || left.value === '\u03BB')) {
                // all of the args must be VARIABLE tokens
                this.arguments.forEach(function (arg, index) {
                    if (arg.type !== 'variable') {
                        return handleError( {
                            code: "S0208",
                            stack: (new Error()).stack,
                            position: arg.position,
                            token: arg.value,
                            value: index + 1
                        });
                    }
                });
                this.type = 'lambda';
                // is the next token a '<' - if so, parse the function signature
                if(node.id === '<') {
                    var sigPos = node.position;
                    var depth = 1;
                    var sig = '<';
                    while(depth > 0 && node.id !== '{' && node.id !== '(end)') {
                        var tok = advance();
                        if(tok.id === '>') {
                            depth--;
                        } else if(tok.id === '<') {
                            depth++;
                        }
                        sig += tok.value;
                    }
                    advance('>');
                    try {
                        this.signature = parseSignature(sig);
                    } catch(err) {
                        // insert the position into this error
                        err.position = sigPos + err.offset;
                        return handleError( err );
                    }
                }
                // parse the function body
                advance('{');
                this.body = expression(0);
                advance('}');
            }
            return this;
        });

        // parenthesis - block expression
        prefix("(", function () {
            var expressions = [];
            while (node.id !== ")") {
                expressions.push(expression(0));
                if (node.id !== ";") {
                    break;
                }
                advance(";");
            }
            advance(")", true);
            this.type = 'block';
            this.expressions = expressions;
            return this;
        });

        // array constructor
        prefix("[", function () {
            var a = [];
            if (node.id !== "]") {
                for (;;) {
                    var item = expression(0);
                    if (node.id === "..") {
                        // range operator
                        var range = {type: "binary", value: "..", position: node.position, lhs: item};
                        advance("..");
                        range.rhs = expression(0);
                        item = range;
                    }
                    a.push(item);
                    if (node.id !== ",") {
                        break;
                    }
                    advance(",");
                }
            }
            advance("]", true);
            this.expressions = a;
            this.type = "unary";
            return this;
        });

        // filter - predicate or array index
        infix("[", operators['['], function (left) {
            if(node.id === "]") {
                // empty predicate means maintain singleton arrays in the output
                var step = left;
                while(step && step.type === 'binary' && step.value === '[') {
                    step = step.lhs;
                }
                step.keepArray = true;
                advance("]");
                return left;
            } else {
                this.lhs = left;
                this.rhs = expression(operators[']']);
                this.type = 'binary';
                advance("]", true);
                return this;
            }
        });

        // order-by
        infix("^", operators['^'], function (left) {
            advance("(");
            var terms = [];
            for(;;) {
                var term = {
                    descending: false
                };
                if (node.id === "<") {
                    // ascending sort
                    advance("<");
                } else if (node.id === ">") {
                    // descending sort
                    term.descending = true;
                    advance(">");
                } else {
                    //unspecified - default to ascending
                }
                term.expression = expression(0);
                terms.push(term);
                if(node.id !== ",") {
                    break;
                }
                advance(",");
            }
            advance(")");
            this.lhs = left;
            this.rhs = terms;
            this.type = 'binary';
            return this;
        });

        var objectParser = function (left) {
            var a = [];
            if (node.id !== "}") {
                for (;;) {
                    var n = expression(0);
                    advance(":");
                    var v = expression(0);
                    a.push([n, v]); // holds an array of name/value expression pairs
                    if (node.id !== ",") {
                        break;
                    }
                    advance(",");
                }
            }
            advance("}", true);
            if(typeof left === 'undefined') {
                // NUD - unary prefix form
                this.lhs = a;
                this.type = "unary";
            } else {
                // LED - binary infix form
                this.lhs = left;
                this.rhs = a;
                this.type = 'binary';
            }
            return this;
        };

        // object constructor
        prefix("{", objectParser);

        // object grouping
        infix("{", operators['{'], objectParser);

        // if/then/else ternary operator ?:
        infix("?", operators['?'], function (left) {
            this.type = 'condition';
            this.condition = left;
            this.then = expression(0);
            if (node.id === ':') {
                // else condition
                advance(":");
                this.else = expression(0);
            }
            return this;
        });

        // object transformer
        prefix("|", function () {
            this.type = 'transform';
            this.pattern = expression(0);
            advance('|');
            this.update = expression(0);
            if(node.id === ',') {
                advance(',');
                this.delete = expression(0);
            }
            advance('|');
            return this;
        });

        // tail call optimization
        // this is invoked by the post parser to analyse lambda functions to see
        // if they make a tail call.  If so, it is replaced by a thunk which will
        // be invoked by the trampoline loop during function application.
        // This enables tail-recursive functions to be written without growing the stack
        var tail_call_optimize = function(expr) {
            var result;
            if(expr.type === 'function') {
                var thunk = {type: 'lambda', thunk: true, arguments: [], position: expr.position};
                thunk.body = expr;
                result = thunk;
            } else if(expr.type === 'condition') {
                // analyse both branches
                expr.then = tail_call_optimize(expr.then);
                if(typeof expr.else !== 'undefined') {
                    expr.else = tail_call_optimize(expr.else);
                }
                result = expr;
            } else if(expr.type === 'block') {
                // only the last expression in the block
                var length = expr.expressions.length;
                if(length > 0) {
                    expr.expressions[length - 1] = tail_call_optimize(expr.expressions[length - 1]);
                }
                result = expr;
            } else {
                result = expr;
            }
            return result;
        };

        // post-parse stage
        // the purpose of this is flatten the parts of the AST representing location paths,
        // converting them to arrays of steps which in turn may contain arrays of predicates.
        // following this, nodes containing '.' and '[' should be eliminated from the AST.
        var ast_optimize = function (expr) {
            var result;
            switch (expr.type) {
                case 'binary':
                    switch (expr.value) {
                        case '.':
                            var lstep = ast_optimize(expr.lhs);
                            result = {type: 'path', steps: []};
                            if (lstep.type === 'path') {
                                Array.prototype.push.apply(result.steps, lstep.steps);
                            } else {
                                result.steps = [lstep];
                            }
                            var rest = ast_optimize(expr.rhs);
                            if(rest.type === 'function' &&
                              rest.procedure.type === 'path' &&
                              rest.procedure.steps.length === 1 &&
                              rest.procedure.steps[0].type === 'name' &&
                              result.steps[result.steps.length-1].type === 'function') {
                                // next function in chain of functions - will override a thenable
                                result.steps[result.steps.length-1].nextFunction = rest.procedure.steps[0].value;
                            }
                            if(rest.type !== 'path') {
                                rest = {type: 'path', steps: [rest]};
                            }
                            Array.prototype.push.apply(result.steps, rest.steps);
                            // any steps within a path that are literals, should be changed to 'name'
                            result.steps.filter(function(step) {
                                return step.type === 'literal';
                            }).forEach(function(lit) {
                                lit.type = 'name';
                            });
                            // any step that signals keeping a singleton array, should be flagged on the path
                            if(result.steps.filter(function(step) { return step.keepArray === true;}).length > 0) {
                                result.keepSingletonArray = true;
                            }
                            // if first step is a path constructor, flag it for special handling
                            if(result.steps[0].type === 'unary' && result.steps[0].value === '[') {
                                result.steps[0].consarray = true;
                            }
                            break;
                        case '[':
                            // predicated step
                            // LHS is a step or a predicated step
                            // RHS is the predicate expr
                            result = ast_optimize(expr.lhs);
                            var step = result;
                            if(result.type === 'path') {
                                step = result.steps[result.steps.length - 1];
                            }
                            if (typeof step.group !== 'undefined') {
                                throw {
                                    code: "S0209",
                                    stack: (new Error()).stack,
                                    position: expr.position
                                };
                            }
                            if (typeof step.predicate === 'undefined') {
                                step.predicate = [];
                            }
                            step.predicate.push(ast_optimize(expr.rhs));
                            break;
                        case '{':
                            // group-by
                            // LHS is a step or a predicated step
                            // RHS is the object constructor expr
                            result = ast_optimize(expr.lhs);
                            if (typeof result.group !== 'undefined') {
                                throw {
                                    code: "S0210",
                                    stack: (new Error()).stack,
                                    position: expr.position
                                };
                            }
                            // object constructor - process each pair
                            result.group = {
                                lhs: expr.rhs.map(function (pair) {
                                    return [ast_optimize(pair[0]), ast_optimize(pair[1])];
                                }),
                                position: expr.position
                            };
                            break;
                        case '^':
                            // order-by
                            // LHS is the array to be ordered
                            // RHS defines the terms
                            result = {type: 'sort', value: expr.value, position: expr.position};
                            result.lhs = ast_optimize(expr.lhs);
                            result.rhs = expr.rhs.map(function (terms) {
                                return {
                                    descending: terms.descending,
                                    expression: ast_optimize(terms.expression)
                                };
                            });
                            break;
                        case ':=':
                            result = {type: 'bind', value: expr.value, position: expr.position};
                            result.lhs = ast_optimize(expr.lhs);
                            result.rhs = ast_optimize(expr.rhs);
                            break;
                        case '~>':
                            result = {type: 'apply', value: expr.value, position: expr.position};
                            result.lhs = ast_optimize(expr.lhs);
                            result.rhs = ast_optimize(expr.rhs);
                            break;
                        default:
                            result = {type: expr.type, value: expr.value, position: expr.position};
                            result.lhs = ast_optimize(expr.lhs);
                            result.rhs = ast_optimize(expr.rhs);
                    }
                    break;
                case 'unary':
                    result = {type: expr.type, value: expr.value, position: expr.position};
                    if (expr.value === '[') {
                        // array constructor - process each item
                        result.expressions = expr.expressions.map(function (item) {
                            return ast_optimize(item);
                        });
                    } else if (expr.value === '{') {
                        // object constructor - process each pair
                        result.lhs = expr.lhs.map(function (pair) {
                            return [ast_optimize(pair[0]), ast_optimize(pair[1])];
                        });
                    } else {
                        // all other unary expressions - just process the expression
                        result.expression = ast_optimize(expr.expression);
                        // if unary minus on a number, then pre-process
                        if (expr.value === '-' && result.expression.type === 'literal' && isNumeric(result.expression.value)) {
                            result = result.expression;
                            result.value = -result.value;
                        }
                    }
                    break;
                case 'function':
                case 'partial':
                    result = {type: expr.type, name: expr.name, value: expr.value, position: expr.position};
                    result.arguments = expr.arguments.map(function (arg) {
                        return ast_optimize(arg);
                    });
                    result.procedure = ast_optimize(expr.procedure);
                    break;
                case 'lambda':
                    result = {type: expr.type, arguments: expr.arguments, signature: expr.signature, position: expr.position};
                    var body = ast_optimize(expr.body);
                    result.body = tail_call_optimize(body);
                    break;
                case 'condition':
                    result = {type: expr.type, position: expr.position};
                    result.condition = ast_optimize(expr.condition);
                    result.then = ast_optimize(expr.then);
                    if (typeof expr.else !== 'undefined') {
                        result.else = ast_optimize(expr.else);
                    }
                    break;
                case 'transform':
                    result = {type: expr.type, position: expr.position};
                    result.pattern = ast_optimize(expr.pattern);
                    result.update = ast_optimize(expr.update);
                    if(typeof expr.delete !== 'undefined') {
                        result.delete = ast_optimize(expr.delete);
                    }
                    break;
                case 'block':
                    result = {type: expr.type, position: expr.position};
                    // array of expressions - process each one
                    result.expressions = expr.expressions.map(function (item) {
                        return ast_optimize(item);
                    });
                    // TODO scan the array of expressions to see if any of them assign variables
                    // if so, need to mark the block as one that needs to create a new frame
                    break;
                case 'name':
                    result = {type: 'path', steps: [expr]};
                    if(expr.keepArray) {
                        result.keepSingletonArray = true;
                    }
                    break;
                case 'literal':
                case 'wildcard':
                case 'descendant':
                case 'variable':
                case 'regex':
                    result = expr;
                    break;
                case 'operator':
                    // the tokens 'and' and 'or' might have been used as a name rather than an operator
                    if (expr.value === 'and' || expr.value === 'or' || expr.value === 'in') {
                        expr.type = 'name';
                        result = ast_optimize(expr);
                    } else /* istanbul ignore else */ if (expr.value === '?') {
                        // partial application
                        result = expr;
                    } else {
                        throw {
                            code: "S0201",
                            stack: (new Error()).stack,
                            position: expr.position,
                            token: expr.value
                        };
                    }
                    break;
                case 'error':
                    result = expr;
                    if(expr.lhs) {
                        result = ast_optimize(expr.lhs);
                    }
                    break;
                default:
                    var code = "S0206";
                    /* istanbul ignore else */
                    if (expr.id === '(end)') {
                        code = "S0207";
                    }
                    var err = {
                        code: code,
                        position: expr.position,
                        token: expr.value
                    };
                    if(recover) {
                        errors.push(err);
                        return {type: 'error', error: err};
                    } else {
                        err.stack = (new Error()).stack;
                        throw err;
                    }
            }
            return result;
        };

        // now invoke the tokenizer and the parser and return the syntax tree
        lexer = tokenizer(source);
        advance();
        // parse the tokens
        var expr = expression(0);
        if (node.id !== '(end)') {
            var err = {
                code: "S0201",
                position: node.position,
                token: node.value
            };
            handleError(err);
        }
        expr = ast_optimize(expr);

        if(errors.length > 0) {
            expr.errors = errors;
        }

        return expr;
    };

    // Start of Evaluator code

    var staticFrame = createFrame(null);

    /**
     * Check if value is a finite number
     * @param {float} n - number to evaluate
     * @returns {boolean} True if n is a finite number
     */
    function isNumeric(n) {
        var isNum = false;
        if(typeof n === 'number') {
            var num = parseFloat(n);
            isNum = !isNaN(num);
            if (isNum && !isFinite(num)) {
                throw {
                    code: "D1001",
                    value: n,
                    stack: (new Error()).stack
                };
            }
        }
        return isNum;
    }

    /**
     * Returns true if the arg is an array of strings
     * @param {*} arg - the item to test
     * @returns {boolean} True if arg is an array of strings
     */
    function isArrayOfStrings(arg) {
        var result = false;
        /* istanbul ignore else */
        if(Array.isArray(arg)) {
            result = (arg.filter(function(item){return typeof item !== 'string';}).length === 0);
        }
        return result;
    }

    /**
     * Returns true if the arg is an array of numbers
     * @param {*} arg - the item to test
     * @returns {boolean} True if arg is an array of numbers
     */
    function isArrayOfNumbers(arg) {
        var result = false;
        if(Array.isArray(arg)) {
            result = (arg.filter(function(item){return !isNumeric(item);}).length === 0);
        }
        return result;
    }

    // Polyfill
    /* istanbul ignore next */
    Number.isInteger = Number.isInteger || function(value) {
        return typeof value === "number" &&
          isFinite(value) &&
          Math.floor(value) === value;
    };

    /**
     * Evaluate expression against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluate(expr, input, environment) {
        var result;

        var entryCallback = environment.lookup('__evaluate_entry');
        if(entryCallback) {
            entryCallback(expr, input, environment);
        }

        switch (expr.type) {
            case 'path':
                result = yield * evaluatePath(expr.steps, input, environment);
                result = normalizeSequence(result, expr.keepSingletonArray);
                break;
            case 'binary':
                result = yield * evaluateBinary(expr, input, environment);
                break;
            case 'unary':
                result = yield * evaluateUnary(expr, input, environment);
                break;
            case 'name':
                result = evaluateName(expr, input, environment);
                break;
            case 'literal':
                result = evaluateLiteral(expr, input, environment);
                break;
            case 'wildcard':
                result = evaluateWildcard(expr, input, environment);
                break;
            case 'descendant':
                result = evaluateDescendants(expr, input, environment);
                break;
            case 'condition':
                result = yield * evaluateCondition(expr, input, environment);
                break;
            case 'block':
                result = yield * evaluateBlock(expr, input, environment);
                break;
            case 'bind':
                result = yield * evaluateBindExpression(expr, input, environment);
                break;
            case 'regex':
                result = evaluateRegex(expr, input, environment);
                break;
            case 'function':
                result = yield * evaluateFunction(expr, input, environment);
                break;
            case 'variable':
                result = evaluateVariable(expr, input, environment);
                break;
            case 'lambda':
                result = evaluateLambda(expr, input, environment);
                break;
            case 'partial':
                result = yield * evaluatePartialApplication(expr, input, environment);
                break;
            case 'apply':
                result = yield * evaluateApplyExpression(expr, input, environment);
                break;
            case 'sort':
                result = yield * evaluateSortExpression(expr, input, environment);
                break;
            case 'transform':
                result = evaluateTransformExpression(expr, input, environment);
                break;
        }

        if(environment.lookup('__jsonata_async') &&
          (typeof result === 'undefined' || result === null || typeof result.then !== 'function')) {
            result = Promise.resolve(result);
        }
        if(environment.lookup('__jsonata_async') && typeof result.then === 'function' && expr.nextFunction && typeof result[expr.nextFunction] === 'function') {
            // although this is a 'thenable', it is chaining a different function
            // so don't yield since yielding will trigger the .then()
        } else {
            result = yield result;
        }


        if (expr.hasOwnProperty('predicate')) {
            result = yield * applyPredicates(expr.predicate, result, environment);
            result = normalizeSequence(result);

        }
        if (expr.hasOwnProperty('group')) {
            result = yield * evaluateGroupExpression(expr.group, result, environment);
        }

        var exitCallback = environment.lookup('__evaluate_exit');
        if(exitCallback) {
            exitCallback(expr, input, environment, result);
        }

        return result;
    }

    /**
     * Evaluate path expression against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluatePath(expr, input, environment) {
        var inputSequence;
        // expr is an array of steps
        // if the first step is a variable reference ($...), including root reference ($$),
        //   then the path is absolute rather than relative
        if (expr[0].type === 'variable') {
            inputSequence = [input]; // dummy singleton sequence for first (absolute) step
        } else if (Array.isArray(input)) {
            inputSequence = input;
        } else {
            // if input is not an array, make it so
            inputSequence = [input];
        }

        var resultSequence;

        // evaluate each step in turn
        for(var ii = 0; ii < expr.length; ii++) {
            var step = expr[ii];

            // if the first step is an explicit array constructor, then just evaluate that (i.e. don't iterate over a context array)
            if(ii === 0 && step.consarray) {
                resultSequence = yield * evaluate(step, inputSequence, environment);
            } else {
                resultSequence = yield * evaluateStep(step, inputSequence, environment);
            }

            if(typeof resultSequence === 'undefined' || resultSequence.length === 0) {
                break;
            }
            inputSequence = resultSequence;
        }

        return resultSequence;
    }

    /**
     * Normalize a JSONata sequence - singleton arrays become atomic values
     * @param {Array} sequence - input sequence
     * @param {Boolean} keepSingleton - keep singleton sequences as arrays
     * @returns {*} normalized sequence
     */
    function normalizeSequence(sequence, keepSingleton) {
        var result;
        if(typeof sequence === 'undefined') {
            result = undefined;
        } else if(!Array.isArray(sequence)) {
            result = sequence;
        } else if (sequence.length === 1) {
            if(keepSingleton) {
                result = sequence;
            } else {
                result = sequence[0];
            }
        } else if (sequence.length > 1) {
            result = sequence;
        }
        return result;
    }

    /**
     * Evaluate a step within a path
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluateStep(expr, input, environment) {
        var result = [];


        for(var ii = 0; ii < input.length; ii++) {
            var res = yield * evaluate(expr, input[ii], environment);
            if (!(Array.isArray(res) && (expr.value !== '[' )) && !expr.consarray) {
                res = [res];
            }
            // is res an array - if so, flatten it into the parent array
            res.forEach(function (innerRes) {
                if (typeof innerRes !== 'undefined') {
                    result.push(innerRes);
                }
            });
        }
        return result;
    }

    /**
     * Apply predicates to input data
     * @param {Object} predicates - Predicates
     * @param {Object} input - Input data to apply predicates against
     * @param {Object} environment - Environment
     * @returns {*} Result after applying predicates
     */
    function* applyPredicates(predicates, input, environment) {
        var inputSequence = input;
        // lhs potentially holds an array
        // we want to iterate over the array, and only keep the items that are
        // truthy when applied to the predicate.
        // if the predicate evaluates to an integer, then select that index

        var results = [];
        for(var ii = 0; ii < predicates.length; ii++) {
            var predicate = predicates[ii];
            // if it's not an array, turn it into one
            // since in XPath >= 2.0 an item is equivalent to a singleton sequence of that item
            // if input is not an array, make it so
            if (!Array.isArray(inputSequence)) {
                inputSequence = [inputSequence];
            }
            results = [];
            if (predicate.type === 'literal' && isNumeric(predicate.value)) {
                var index = predicate.value;
                if (!Number.isInteger(index)) {
                    // round it down
                    index = Math.floor(index);
                }
                if (index < 0) {
                    // count in from end of array
                    index = inputSequence.length + index;
                }
                results = inputSequence[index];
            } else {
                results = yield * evaluateFilter(predicate, inputSequence, environment);
            }
            inputSequence = results;
        }
        return results;
    }

    /**
     * Apply filter predicate to input data
     * @param {Object} predicate - filter expression
     * @param {Object} input - Input data to apply predicates against
     * @param {Object} environment - Environment
     * @returns {*} Result after applying predicates
     */
    function* evaluateFilter(predicate, input, environment) {
        var results = [];
        for(var index = 0; index < input.length; index++) {
            var item = input[index];
            var res = yield * evaluate(predicate, item, environment);
            if (isNumeric(res)) {
                res = [res];
            }
            if(isArrayOfNumbers(res)) {
                res.forEach(function(ires) {
                    if (!Number.isInteger(ires)) {
                        // round it down
                        ires = Math.floor(ires);
                    }
                    if (ires < 0) {
                        // count in from end of array
                        ires = input.length + ires;
                    }
                    if (ires === index) {
                        results.push(item);
                    }
                });
            } else if (functionBoolean(res)) { // truthy
                results.push(item);
            }
        }
        return results;
    }

    /**
     * Evaluate binary expression against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function * evaluateBinary(expr, input, environment) {
        var result;
        var lhs = yield * evaluate(expr.lhs, input, environment);
        var rhs = yield * evaluate(expr.rhs, input, environment);
        var op = expr.value;

        try {
            switch (op) {
                case '+':
                case '-':
                case '*':
                case '/':
                case '%':
                    result = evaluateNumericExpression(lhs, rhs, op);
                    break;
                case '=':
                case '!=':
                case '<':
                case '<=':
                case '>':
                case '>=':
                    result = evaluateComparisonExpression(lhs, rhs, op);
                    break;
                case '&':
                    result = evaluateStringConcat(lhs, rhs);
                    break;
                case 'and':
                case 'or':
                    result = evaluateBooleanExpression(lhs, rhs, op);
                    break;
                case '..':
                    result = evaluateRangeExpression(lhs, rhs);
                    break;
                case 'in':
                    result = evaluateIncludesExpression(lhs, rhs);
                    break;
            }
        } catch(err) {
            err.position = expr.position;
            err.token = op;
            throw err;
        }
        return result;
    }

    /**
     * Evaluate unary expression against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluateUnary(expr, input, environment) {
        var result;

        switch (expr.value) {
            case '-':
                result = yield * evaluate(expr.expression, input, environment);
                if (isNumeric(result)) {
                    result = -result;
                } else {
                    throw {
                        code: "D1002",
                        stack: (new Error()).stack,
                        position: expr.position,
                        token: expr.value,
                        value: result
                    };
                }
                break;
            case '[':
                // array constructor - evaluate each item
                result = [];
                for(var ii = 0; ii < expr.expressions.length; ii++) {
                    var item = expr.expressions[ii];
                    var value = yield * evaluate(item, input, environment);
                    if (typeof value !== 'undefined') {
                        if(item.value === '[') {
                            result.push(value);
                        } else {
                            result = functionAppend(result, value);
                        }
                    }
                }
                break;
            case '{':
                // object constructor - apply grouping
                result = yield * evaluateGroupExpression(expr, input, environment);
                break;

        }
        return result;
    }

    /**
     * Evaluate name object against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function evaluateName(expr, input, environment) {
        // lookup the 'name' item in the input
        var result;
        if (Array.isArray(input)) {
            result = [];
            for(var ii = 0; ii < input.length; ii++) {
                var res =  evaluateName(expr, input[ii], environment);
                if (typeof res !== 'undefined') {
                    result.push(res);
                }
            }
        } else if (input !== null && typeof input === 'object') {
            result = input[expr.value];
        }
        result = normalizeSequence(result);
        return result;
    }

    /**
     * Evaluate literal against input data
     * @param {Object} expr - JSONata expression
     * @returns {*} Evaluated input data
     */
    function evaluateLiteral(expr) {
        return expr.value;
    }

    /**
     * Evaluate wildcard against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @returns {*} Evaluated input data
     */
    function evaluateWildcard(expr, input) {
        var result;
        var results = [];
        if (input !== null && typeof input === 'object') {
            Object.keys(input).forEach(function (key) {
                var value = input[key];
                if(Array.isArray(value)) {
                    value = flatten(value);
                    results = functionAppend(results, value);
                } else {
                    results.push(value);
                }
            });
        }

        result = normalizeSequence(results);
        return result;
    }

    /**
     * Returns a flattened array
     * @param {Array} arg - the array to be flatten
     * @param {Array} flattened - carries the flattened array - if not defined, will initialize to []
     * @returns {Array} - the flattened array
     */
    function flatten(arg, flattened) {
        if(typeof flattened === 'undefined') {
            flattened = [];
        }
        if(Array.isArray(arg)) {
            arg.forEach(function (item) {
                flatten(item, flattened);
            });
        } else {
            flattened.push(arg);
        }
        return flattened;
    }

    /**
     * Evaluate descendants against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @returns {*} Evaluated input data
     */
    function evaluateDescendants(expr, input) {
        var result;
        var resultSequence = [];
        if (typeof input !== 'undefined') {
            // traverse all descendants of this object/array
            recurseDescendants(input, resultSequence);
            if (resultSequence.length === 1) {
                result = resultSequence[0];
            } else {
                result = resultSequence;
            }
        }
        return result;
    }

    /**
     * Recurse through descendants
     * @param {Object} input - Input data
     * @param {Object} results - Results
     */
    function recurseDescendants(input, results) {
        // this is the equivalent of //* in XPath
        if (!Array.isArray(input)) {
            results.push(input);
        }
        if (Array.isArray(input)) {
            input.forEach(function (member) {
                recurseDescendants(member, results);
            });
        } else if (input !== null && typeof input === 'object') {
            Object.keys(input).forEach(function (key) {
                recurseDescendants(input[key], results);
            });
        }
    }

    /**
     * Evaluate numeric expression against input data
     * @param {Object} lhs - LHS value
     * @param {Object} rhs - RHS value
     * @param {Object} op - opcode
     * @returns {*} Result
     */
    function evaluateNumericExpression(lhs, rhs, op) {
        var result;

        if (typeof lhs === 'undefined' || typeof rhs === 'undefined') {
            // if either side is undefined, the result is undefined
            return result;
        }

        if (!isNumeric(lhs)) {
            throw {
                code: "T2001",
                stack: (new Error()).stack,
                value: lhs
            };
        }
        if (!isNumeric(rhs)) {
            throw {
                code: "T2002",
                stack: (new Error()).stack,
                value: rhs
            };
        }

        switch (op) {
            case '+':
                result = lhs + rhs;
                break;
            case '-':
                result = lhs - rhs;
                break;
            case '*':
                result = lhs * rhs;
                break;
            case '/':
                result = lhs / rhs;
                break;
            case '%':
                result = lhs % rhs;
                break;
        }
        return result;
    }

    /**
     * Evaluate comparison expression against input data
     * @param {Object} lhs - LHS value
     * @param {Object} rhs - RHS value
     * @param {Object} op - opcode
     * @returns {*} Result
     */
    function evaluateComparisonExpression(lhs, rhs, op) {
        var result;

        // type checks
        var ltype = typeof lhs;
        var rtype = typeof rhs;

        if (ltype === 'undefined' || rtype === 'undefined') {
            // if either side is undefined, the result is false
            return false;
        }

        var validate = function() {
            // if aa or bb are not string or numeric values, then throw an error
            if (!(ltype === 'string' || ltype === 'number') || !(rtype === 'string' || rtype === 'number')) {
                throw {
                    code: "T2010",
                    stack: (new Error()).stack,
                    value: !(ltype === 'string' || ltype === 'number') ? lhs : rhs
                };
            }

            //if aa and bb are not of the same type
            if (ltype !== rtype) {
                throw {
                    code: "T2009",
                    stack: (new Error()).stack,
                    value: lhs,
                    value2: rhs
                };
            }
        };

        switch (op) {
            case '=':
                result = lhs === rhs;
                break;
            case '!=':
                result = (lhs !== rhs);
                break;
            case '<':
                validate();
                result = lhs < rhs;
                break;
            case '<=':
                validate();
                result = lhs <= rhs;
                break;
            case '>':
                validate();
                result = lhs > rhs;
                break;
            case '>=':
                validate();
                result = lhs >= rhs;
                break;
        }
        return result;
    }

    /**
     * Inclusion operator - in
     *
     * @param {Object} lhs - LHS value
     * @param {Object} rhs - RHS value
     * @returns {boolean} - true if lhs is a member of rhs
     */
    function evaluateIncludesExpression(lhs, rhs) {
        var result = false;

        if (typeof lhs === 'undefined' || typeof rhs === 'undefined') {
            // if either side is undefined, the result is false
            return false;
        }

        if(!Array.isArray(rhs)) {
            rhs = [rhs];
        }

        for(var i = 0; i < rhs.length; i++) {
            if(rhs[i] === lhs) {
                result = true;
                break;
            }
        }

        return result;
    }

    /**
     * Evaluate boolean expression against input data
     * @param {Object} lhs - LHS value
     * @param {Object} rhs - RHS value
     * @param {Object} op - opcode
     * @returns {*} Result
     */
    function evaluateBooleanExpression(lhs, rhs, op) {
        var result;

        switch (op) {
            case 'and':
                result = functionBoolean(lhs) && functionBoolean(rhs);
                break;
            case 'or':
                result = functionBoolean(lhs) || functionBoolean(rhs);
                break;
        }
        return result;
    }

    /**
     * Evaluate string concatenation against input data
     * @param {Object} lhs - LHS value
     * @param {Object} rhs - RHS value
     * @returns {string|*} Concatenated string
     */
    function evaluateStringConcat(lhs, rhs) {
        var result;

        var lstr = '';
        var rstr = '';
        if (typeof lhs !== 'undefined') {
            lstr = functionString(lhs);
        }
        if (typeof rhs !== 'undefined') {
            rstr = functionString(rhs);
        }

        result = lstr.concat(rstr);
        return result;
    }

    /**
     * Evaluate group expression against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {{}} Evaluated input data
     */
    function* evaluateGroupExpression(expr, input, environment) {
        var result = {};
        var groups = {};
        // group the input sequence by 'key' expression
        if (!Array.isArray(input)) {
            input = [input];
        }
        for(var itemIndex = 0; itemIndex < input.length; itemIndex++) {
            var item = input[itemIndex];
            for(var pairIndex = 0; pairIndex < expr.lhs.length; pairIndex++) {
                var pair = expr.lhs[pairIndex];
                var key = yield * evaluate(pair[0], item, environment);
                // key has to be a string
                if (typeof  key !== 'string') {
                    throw {
                        code: "T1003",
                        stack: (new Error()).stack,
                        position: expr.position,
                        value: key
                    };
                }
                var entry = {data: item, expr: pair[1]};
                if (groups.hasOwnProperty(key)) {
                    // a value already exists in this slot
                    // append it as an array
                    groups[key].data = functionAppend(groups[key].data, item);
                } else {
                    groups[key] = entry;
                }
            }
        }

        // iterate over the groups to evaluate the 'value' expression
        for (key in groups) {
            entry = groups[key];
            var value = yield * evaluate(entry.expr, entry.data, environment);
            if(typeof value !== 'undefined') {
                result[key] = value;
            }
        }

        return result;
    }

    /**
     * Evaluate range expression against input data
     * @param {Object} lhs - LHS value
     * @param {Object} rhs - RHS value
     * @returns {Array} Resultant array
     */
    function evaluateRangeExpression(lhs, rhs) {
        var result;

        if (typeof lhs === 'undefined' || typeof rhs === 'undefined') {
            // if either side is undefined, the result is undefined
            return result;
        }

        if (lhs > rhs) {
            // if the lhs is greater than the rhs, return undefined
            return result;
        }

        if (!Number.isInteger(lhs)) {
            throw {
                code: "T2003",
                stack: (new Error()).stack,
                value: lhs
            };
        }
        if (!Number.isInteger(rhs)) {
            throw {
                code: "T2004",
                stack: (new Error()).stack,
                value: rhs
            };
        }

        result = new Array(rhs - lhs + 1);
        for (var item = lhs, index = 0; item <= rhs; item++, index++) {
            result[index] = item;
        }
        return result;
    }

    /**
     * Evaluate bind expression against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluateBindExpression(expr, input, environment) {
        // The RHS is the expression to evaluate
        // The LHS is the name of the variable to bind to - should be a VARIABLE token
        var value = yield * evaluate(expr.rhs, input, environment);
        if (expr.lhs.type !== 'variable') {
            throw {
                code: "D2005",
                stack: (new Error()).stack,
                position: expr.position,
                token: expr.value,
                value: expr.lhs.type === 'path' ? expr.lhs.steps[0].value : expr.lhs.value
            };
        }
        environment.bind(expr.lhs.value, value);
        return value;
    }

    /**
     * Evaluate condition against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluateCondition(expr, input, environment) {
        var result;
        var condition = yield * evaluate(expr.condition, input, environment);
        if (functionBoolean(condition)) {
            result = yield * evaluate(expr.then, input, environment);
        } else if (typeof expr.else !== 'undefined') {
            result = yield * evaluate(expr.else, input, environment);
        }
        return result;
    }

    /**
     * Evaluate block against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluateBlock(expr, input, environment) {
        var result;
        // create a new frame to limit the scope of variable assignments
        // TODO, only do this if the post-parse stage has flagged this as required
        var frame = createFrame(environment);
        // invoke each expression in turn
        // only return the result of the last one
        for(var ii = 0; ii < expr.expressions.length; ii++) {
            result = yield * evaluate(expr.expressions[ii], input, frame);
        }

        return result;
    }

    /**
     * Prepare a regex
     * @param {Object} expr - expression containing regex
     * @returns {Function} Higher order function representing prepared regex
     */
    function evaluateRegex(expr) {
        expr.value.lastIndex = 0;
        var closure = function(str) {
            var re = expr.value;
            var result;
            var match = re.exec(str);
            if(match !== null) {
                result = {
                    match: match[0],
                    start: match.index,
                    end: match.index + match[0].length,
                    groups: []
                };
                if(match.length > 1) {
                    for(var i = 1; i < match.length; i++) {
                        result.groups.push(match[i]);
                    }
                }
                result.next = function() {
                    if(re.lastIndex >= str.length) {
                        return undefined;
                    } else {
                        var next = closure(str);
                        if(next && next.match === '' && re.lastIndex === expr.value.lastIndex) {
                            // matches zero length string; this will never progress
                            throw {
                                code: "D1004",
                                stack: (new Error()).stack,
                                position: expr.position,
                                value: expr.value.source
                            };
                        }
                        return next;
                    }
                };
            }

            return result;
        };
        return closure;
    }

    /**
     * Evaluate variable against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function evaluateVariable(expr, input, environment) {
        // lookup the variable value in the environment
        var result;
        // if the variable name is empty string, then it refers to context value
        if (expr.value === '') {
            result = input;
        } else {
            result = environment.lookup(expr.value);
        }
        return result;
    }

    /**
     * sort / order-by operator
     * @param {Object} expr - AST for operator
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Ordered sequence
     */
    function* evaluateSortExpression(expr, input, environment) {
        var result;

        // evaluate the lhs, then sort the results in order according to rhs expression
        var lhs = yield * evaluate(expr.lhs, input, environment);

        // sort the lhs array
        // use comparator function
        var comparator = function(a, b) {
            // expr.rhs is an array of order-by in priority order
            var comp = 0;
            for(var index = 0; comp === 0 && index < expr.rhs.length; index++) {
                var term = expr.rhs[index];
                //evaluate the rhs expression in the context of a
                var aa = driveGenerator(term.expression, a, environment);
                //evaluate the rhs expression in the context of b
                var bb = driveGenerator(term.expression, b, environment);

                // type checks
                var atype = typeof aa;
                var btype = typeof bb;
                // undefined should be last in sort order
                if(atype === 'undefined') {
                    // swap them, unless btype is also undefined
                    comp = (btype === 'undefined') ? 0 : 1;
                    continue;
                }
                if(btype === 'undefined') {
                    comp = -1;
                    continue;
                }

                // if aa or bb are not string or numeric values, then throw an error
                if(!(atype === 'string' || atype === 'number') || !(btype === 'string' || btype === 'number')) {
                    throw {
                        code: "T2008",
                        stack: (new Error()).stack,
                        position: expr.position,
                        value: !(atype === 'string' || atype === 'number') ? aa : bb
                    };
                }

                //if aa and bb are not of the same type
                if(atype !== btype) {
                    throw {
                        code: "T2007",
                        stack: (new Error()).stack,
                        position: expr.position,
                        value: aa,
                        value2: bb
                    };
                }
                if(aa === bb) {
                    // both the same - move on to next term
                    continue;
                } else if (aa < bb) {
                    comp = -1;
                } else {
                    comp = 1;
                }
                if(term.descending === true) {
                    comp = -comp;
                }
            }
            // only swap a & b if comp equals 1
            return comp === 1;
        };

        result = functionSort(lhs, comparator);

        return result;
    }

    /**
     * create a transformer function
     * @param {Object} expr - AST for operator
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} tranformer function
     */
    function evaluateTransformExpression(expr, input, environment) {
        // create a function to implement the transform definition
        var transformer = function*(obj) { // signature <(oa):o>
            // undefined inputs always return undefined
            if(typeof obj === 'undefined') {
                return undefined;
            }

            // this function returns a copy of obj with changes specified by the pattern/operation
            var cloneFunction = environment.lookup('clone');
            if(!isFunction(cloneFunction)) {
                // throw type error
                throw {
                    code: "T2013",
                    stack: (new Error()).stack,
                    position: expr.position
                };
            }
            var result = yield * apply(cloneFunction, [obj], environment);
            var matches = yield * evaluate(expr.pattern, result, environment);
            if(typeof matches !== 'undefined') {
                if(!Array.isArray(matches)) {
                    matches = [matches];
                }
                for(var ii = 0; ii < matches.length; ii++) {
                    var match = matches[ii];
                    // evaluate the update value for each match
                    var update = yield * evaluate(expr.update, match, environment);
                    // update must be an object
                    var updateType = typeof update;
                    if(updateType !== 'undefined') {
                        if(updateType !== 'object' || update === null) {
                            // throw type error
                            throw {
                                code: "T2011",
                                stack: (new Error()).stack,
                                position: expr.update.position,
                                value: update
                            };
                        }
                        // merge the update
                        for(var prop in update) {
                            match[prop] = update[prop];
                        }
                    }

                    // delete, if specified, must be an array of strings (or single string)
                    if(typeof expr.delete !== 'undefined') {
                        var deletions = yield * evaluate(expr.delete, match, environment);
                        if(typeof deletions !== 'undefined') {
                            var val = deletions;
                            if (!Array.isArray(deletions)) {
                                deletions = [deletions];
                            }
                            if (!isArrayOfStrings(deletions)) {
                                // throw type error
                                throw {
                                    code: "T2012",
                                    stack: (new Error()).stack,
                                    position: expr.delete.position,
                                    value: val
                                };
                            }
                            for (var jj = 0; jj < deletions.length; jj++) {
                                delete match[deletions[jj]];
                            }
                        }
                    }
                }
            }

            return result;
        };

        return defineFunction(transformer, '<(oa):o>');
    }

    /**
     * Evaluate an expression by driving the generator to completion
     * Used when it's not possible to yield
     * @param {Object} expr - AST
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} result
     */
    function driveGenerator(expr, input, environment) {
        var gen = evaluate(expr, input, environment);
        // returns a generator - so iterate over it
        var comp = gen.next();
        while (!comp.done) {
            comp = gen.next(comp.value);
        }
        return comp.value;
    }

    var chain = driveGenerator(parser('function($f, $g) { function($x){ $g($f($x)) } }'), null, staticFrame);

    /**
     * Apply the function on the RHS using the sequence on the LHS as the first argument
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluateApplyExpression(expr, input, environment) {
        var result;


        if(expr.rhs.type === 'function') {
            // this is a function _invocation_; invoke it with lhs expression as the first argument
            expr.rhs.arguments.unshift(expr.lhs);
            result = yield * evaluateFunction(expr.rhs, input, environment);
            expr.rhs.arguments.shift();
        } else {
            var lhs = yield * evaluate(expr.lhs, input, environment);
            var func = yield * evaluate(expr.rhs, input, environment);

            if(!isFunction(func)) {
                throw {
                    code: "T2006",
                    stack: (new Error()).stack,
                    position: expr.position,
                    value: func
                };
            }

            if(isFunction(lhs)) {
                // this is function chaining (func1 ~> func2)
                // Î»($f, $g) { Î»($x){ $g($f($x)) } }
                result = yield * apply(chain, [lhs, func], environment, null);
            } else {
                result = yield * apply(func, [lhs], environment, null);
            }

        }

        return result;
    }

    /**
     *
     * @param {Object} arg - expression to test
     * @returns {boolean} - true if it is a function (lambda or built-in)
     */
    function isFunction(arg) {
        return ((arg && (arg._jsonata_function === true || arg._jsonata_lambda === true)) || typeof arg === 'function');
    }

    /**
     * Tests whether arg is a lambda function
     * @param {*} arg - the value to test
     * @returns {boolean} - true if it is a lambda function
     */
    function isLambda(arg) {
        return arg && arg._jsonata_lambda === true;
    }

    /**
     * @param {Object} arg - expression to test
     * @returns {boolean} - true if it is a generator i.e. the result from calling a
     * generator function
     */
    function isGenerator(arg) {
        return (
            typeof arg === 'object' &&
            arg !== null &&
            Symbol.iterator in arg &&
            typeof arg[Symbol.iterator] === 'function' &&
            'next' in arg &&
            typeof arg.next === 'function'
        );
    }

    /**
     * Evaluate function against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @param {Object} [applyto] - LHS of ~> operator
     * @returns {*} Evaluated input data
     */
    function* evaluateFunction(expr, input, environment) {
        var result;

        // create the procedure
        // can't assume that expr.procedure is a lambda type directly
        // could be an expression that evaluates to a function (e.g. variable reference, parens expr etc.
        // evaluate it generically first, then check that it is a function.  Throw error if not.
        var proc = yield * evaluate(expr.procedure, input, environment);

        if (typeof proc === 'undefined' && expr.procedure.type === 'path' && environment.lookup(expr.procedure.steps[0].value)) {
            // help the user out here if they simply forgot the leading $
            throw {
                code: "T1005",
                stack: (new Error()).stack,
                position: expr.position,
                token: expr.procedure.steps[0].value
            };
        }

        var evaluatedArgs = [];
        // eager evaluation - evaluate the arguments
        for (var jj = 0; jj < expr.arguments.length; jj++) {
            // only evaluate 'eager' arguments at this stage; wrap the 'lazy' ones in a closure
            evaluatedArgs.push(yield* evaluate(expr.arguments[jj], input, environment));
        }
        // apply the procedure
        try {
            // if(input instanceof Object) {
            //     Object.defineProperty(input, '__env__', {
            //         enumerable: false,
            //         configurable: true,
            //         get: function () {
            //             return environment;
            //         }
            //     });
            // }
            result = yield * apply(proc, evaluatedArgs, input);
        } catch (err) {
            // add the position field to the error
            err.position = expr.position;
            // and the function identifier
            err.token = expr.procedure.type === 'path' ? expr.procedure.steps[0].value : expr.procedure.value;
            throw err;
        }
        return result;
    }

    /**
     * Apply procedure or function
     * @param {Object} proc - Procedure
     * @param {Array} args - Arguments
     * @param {Object} self - Self
     * @returns {*} Result of procedure
     */
    function* apply(proc, args, self) {
        var result;
        result = yield * applyInner(proc, args, self);
        while(isLambda(result) && result.thunk === true) {
            // trampoline loop - this gets invoked as a result of tail-call optimization
            // the function returned a tail-call thunk
            // unpack it, evaluate its arguments, and apply the tail call
            var next = yield * evaluate(result.body.procedure, result.input, result.environment);
            var evaluatedArgs = [];
            for(var ii = 0; ii < result.body.arguments.length; ii++) {
                evaluatedArgs.push(yield * evaluate(result.body.arguments[ii], result.input, result.environment));
            }

            result = yield * applyInner(next, evaluatedArgs, self);
        }
        return result;
    }

    /**
     * Apply procedure or function
     * @param {Object} proc - Procedure
     * @param {Array} args - Arguments
     * @param {Object} self - Self
     * @returns {*} Result of procedure
     */
    function* applyInner(proc, args, self) {
        var result;
        var validatedArgs = args;
        if(proc) {
            validatedArgs = validateArguments(proc.signature, args, self);
        }
        if (isLambda(proc)) {
            result = yield * applyProcedure(proc, validatedArgs);
        } else if (proc && proc._jsonata_function === true) {
            result = proc.implementation.apply(self, validatedArgs);
            // `proc.implementation` might be a generator function
            // and `result` might be a generator - if so, yield
            if(isGenerator(result)) {
                result = yield *result;
            }
        } else if (typeof proc === 'function') {
            result = proc.apply(self, validatedArgs);
            /* istanbul ignore next */
            if(isGenerator(result)) {
                result = yield *result;
            }
        } else {
            throw {
                code: "T1006",
                stack: (new Error()).stack
            };
        }
        return result;
    }

    /**
     * Evaluate lambda against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {{lambda: boolean, input: *, environment: *, arguments: *, body: *}} Evaluated input data
     */
    function evaluateLambda(expr, input, environment) {
        // make a function (closure)
        var procedure = {
            _jsonata_lambda: true,
            input: input,
            environment: environment,
            arguments: expr.arguments,
            signature: expr.signature,
            body: expr.body
        };
        if(expr.thunk === true) {
            procedure.thunk = true;
        }
        return procedure;
    }

    /**
     * Evaluate partial application
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluatePartialApplication(expr, input, environment) {
        // partially apply a function
        var result;
        // evaluate the arguments
        var evaluatedArgs = [];
        for(var ii = 0; ii < expr.arguments.length; ii++) {
            var arg = expr.arguments[ii];
            if (arg.type === 'operator' && arg.value === '?') {
                evaluatedArgs.push(arg);
            } else {
                evaluatedArgs.push(yield * evaluate(arg, input, environment));
            }
        }
        // lookup the procedure
        var proc = yield * evaluate(expr.procedure, input, environment);
        if (typeof proc === 'undefined' && expr.procedure.type === 'path' && environment.lookup(expr.procedure.steps[0].value)) {
            // help the user out here if they simply forgot the leading $
            throw {
                code: "T1007",
                stack: (new Error()).stack,
                position: expr.position,
                token: expr.procedure.steps[0].value
            };
        }
        if (isLambda(proc)) {
            result = partialApplyProcedure(proc, evaluatedArgs);
        } else if (proc && proc._jsonata_function === true) {
            result = partialApplyNativeFunction(proc.implementation, evaluatedArgs);
        } else if (typeof proc === 'function') {
            result = partialApplyNativeFunction(proc, evaluatedArgs);
        } else {
            throw {
                code: "T1008",
                stack: (new Error()).stack,
                position: expr.position,
                token: expr.procedure.type === 'path' ? expr.procedure.steps[0].value : expr.procedure.value
            };
        }
        return result;
    }

    /**
     * Validate the arguments against the signature validator (if it exists)
     * @param {Function} signature - validator function
     * @param {Array} args - function arguments
     * @param {*} context - context value
     * @returns {Array} - validated arguments
     */
    function validateArguments(signature, args, context) {
        if(typeof signature === 'undefined') {
            // nothing to validate
            return args;
        }
        var validatedArgs = signature.validate(args, context);
        return validatedArgs;
    }

    /**
     * Apply procedure
     * @param {Object} proc - Procedure
     * @param {Array} args - Arguments
     * @returns {*} Result of procedure
     */
    function* applyProcedure(proc, args) {
        var result;
        var env = createFrame(proc.environment);
        proc.arguments.forEach(function (param, index) {
            env.bind(param.value, args[index]);
        });
        if (typeof proc.body === 'function') {
            // this is a lambda that wraps a native function - generated by partially evaluating a native
            result = yield * applyNativeFunction(proc.body, env);
        } else {
            result = yield * evaluate(proc.body, proc.input, env);
        }
        return result;
    }

    /**
     * Partially apply procedure
     * @param {Object} proc - Procedure
     * @param {Array} args - Arguments
     * @returns {{lambda: boolean, input: *, environment: {bind, lookup}, arguments: Array, body: *}} Result of partially applied procedure
     */
    function partialApplyProcedure(proc, args) {
        // create a closure, bind the supplied parameters and return a function that takes the remaining (?) parameters
        var env = createFrame(proc.environment);
        var unboundArgs = [];
        proc.arguments.forEach(function (param, index) {
            var arg = args[index];
            if (arg && arg.type === 'operator' && arg.value === '?') {
                unboundArgs.push(param);
            } else {
                env.bind(param.value, arg);
            }
        });
        var procedure = {
            _jsonata_lambda: true,
            input: proc.input,
            environment: env,
            arguments: unboundArgs,
            body: proc.body
        };
        return procedure;
    }

    /**
     * Partially apply native function
     * @param {Function} native - Native function
     * @param {Array} args - Arguments
     * @returns {{lambda: boolean, input: *, environment: {bind, lookup}, arguments: Array, body: *}} Result of partially applying native function
     */
    function partialApplyNativeFunction(native, args) {
        // create a lambda function that wraps and invokes the native function
        // get the list of declared arguments from the native function
        // this has to be picked out from the toString() value
        var sigArgs = getNativeFunctionArguments(native);
        sigArgs = sigArgs.map(function (sigArg) {
            return '$' + sigArg.trim();
        });
        var body = 'function(' + sigArgs.join(', ') + '){ _ }';

        var bodyAST = parser(body);
        bodyAST.body = native;

        var partial = partialApplyProcedure(bodyAST, args);
        return partial;
    }

    /**
     * Apply native function
     * @param {Object} proc - Procedure
     * @param {Object} env - Environment
     * @returns {*} Result of applying native function
     */
    function* applyNativeFunction(proc, env) {
        var sigArgs = getNativeFunctionArguments(proc);
        // generate the array of arguments for invoking the function - look them up in the environment
        var args = sigArgs.map(function (sigArg) {
            return env.lookup(sigArg.trim());
        });

        var result = proc.apply(null, args);
        if(isGenerator(result)) {
            result = yield * result;
        }
        return result;
    }

    /**
     * Get native function arguments
     * @param {Function} func - Function
     * @returns {*|Array} Native function arguments
     */
    function getNativeFunctionArguments(func) {
        var signature = func.toString();
        var sigParens = /\(([^)]*)\)/.exec(signature)[1]; // the contents of the parens
        var sigArgs = sigParens.split(',');
        return sigArgs;
    }

    /**
     * Creates a function definition
     * @param {Function} func - function implementation in Javascript
     * @param {string} signature - JSONata function signature definition
     * @returns {{implementation: *, signature: *}} function definition
     */
    function defineFunction(func, signature) {
        var definition = {
            _jsonata_function: true,
            implementation: func
        };
        if(typeof signature !== 'undefined') {
            definition.signature = parseSignature(signature);
        }
        return definition;
    }

    /**
     * Sum function
     * @param {Object} args - Arguments
     * @returns {number} Total value of arguments
     */
    function functionSum(args) {
        // undefined inputs always return undefined
        if(typeof args === 'undefined') {
            return undefined;
        }

        var total = 0;
        args.forEach(function(num){total += num;});
        return total;
    }

    /**
     * Count function
     * @param {Object} args - Arguments
     * @returns {number} Number of elements in the array
     */
    function functionCount(args) {
        // undefined inputs always return undefined
        if(typeof args === 'undefined') {
            return 0;
        }

        return args.length;
    }

    /**
     * Max function
     * @param {Object} args - Arguments
     * @returns {number} Max element in the array
     */
    function functionMax(args) {
        // undefined inputs always return undefined
        if(typeof args === 'undefined' || args.length === 0) {
            return undefined;
        }

        return Math.max.apply(Math, args);
    }

    /**
     * Min function
     * @param {Object} args - Arguments
     * @returns {number} Min element in the array
     */
    function functionMin(args) {
        // undefined inputs always return undefined
        if(typeof args === 'undefined' || args.length === 0) {
            return undefined;
        }

        return Math.min.apply(Math, args);
    }

    /**
     * Average function
     * @param {Object} args - Arguments
     * @returns {number} Average element in the array
     */
    function functionAverage(args) {
        // undefined inputs always return undefined
        if(typeof args === 'undefined' || args.length === 0) {
            return undefined;
        }

        var total = 0;
        args.forEach(function(num){total += num;});
        return total/args.length;
    }

    /**
     * Stingify arguments
     * @param {Object} arg - Arguments
     * @returns {String} String from arguments
     */
    function functionString(arg) {
        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        var str;

        if (typeof arg === 'string') {
            // already a string
            str = arg;
        } else if(isFunction(arg)) {
            // functions (built-in and lambda convert to empty string
            str = '';
        } else if (typeof arg === 'number' && !isFinite(arg)) {
            throw {
                code: "D3001",
                value: arg,
                stack: (new Error()).stack
            };
        } else
            str = JSON.stringify(arg, function (key, val) {
                return (typeof val !== 'undefined' && val !== null && val.toPrecision && isNumeric(val)) ? Number(val.toPrecision(13)) :
                    (val && isFunction(val)) ? '' : val;
            });
        return str;
    }

    /**
     * Create substring based on character number and length
     * @param {String} str - String to evaluate
     * @param {Integer} start - Character number to start substring
     * @param {Integer} [length] - Number of characters in substring
     * @returns {string|*} Substring
     */
    function functionSubstring(str, start, length) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        return str.substr(start, length);
    }

    /**
     * Create substring up until a character
     * @param {String} str - String to evaluate
     * @param {String} chars - Character to define substring boundary
     * @returns {*} Substring
     */
    function functionSubstringBefore(str, chars) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        var pos = str.indexOf(chars);
        if (pos > -1) {
            return str.substr(0, pos);
        } else {
            return str;
        }
    }

    /**
     * Create substring after a character
     * @param {String} str - String to evaluate
     * @param {String} chars - Character to define substring boundary
     * @returns {*} Substring
     */
    function functionSubstringAfter(str, chars) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        var pos = str.indexOf(chars);
        if (pos > -1) {
            return str.substr(pos + chars.length);
        } else {
            return str;
        }
    }

    /**
     * Lowercase a string
     * @param {String} str - String to evaluate
     * @returns {string} Lowercase string
     */
    function functionLowercase(str) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        return str.toLowerCase();
    }

    /**
     * Uppercase a string
     * @param {String} str - String to evaluate
     * @returns {string} Uppercase string
     */
    function functionUppercase(str) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        return str.toUpperCase();
    }

    /**
     * length of a string
     * @param {String} str - string
     * @returns {Number} The number of characters in the string
     */
    function functionLength(str) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        return str.length;
    }

    /**
     * Normalize and trim whitespace within a string
     * @param {string} str - string to be trimmed
     * @returns {string} - trimmed string
     */
    function functionTrim(str) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        // normalize whitespace
        var result = str.replace(/[ \t\n\r]+/gm, ' ');
        if(result.charAt(0) === ' ') {
            // strip leading space
            result = result.substring(1);
        }
        if(result.charAt(result.length - 1) === ' ') {
            // strip trailing space
            result = result.substring(0, result.length - 1);
        }
        return result;
    }

    /**
     * Pad a string to a minimum width by adding characters to the start or end
     * @param {string} str - string to be padded
     * @param {number} width - the minimum width; +ve pads to the right, -ve pads to the left
     * @param {string} [char] - the pad character(s); defaults to ' '
     * @returns {string} - padded string
     */
    function functionPad(str, width, char) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        if(typeof char === 'undefined' || char.length === 0) {
            char = ' ';
        }

        var result;
        var padLength = Math.abs(width) - str.length;
        if(padLength > 0) {
            var padding = (new Array(padLength + 1)).join(char);
            if(char.length > 1) {
                padding = padding.substring(0, padLength);
            }
            if(width > 0) {
                result = str + padding;
            } else {
                result = padding + str;
            }
        } else {
            result = str;
        }
        return result;
    }

    /**
     * Tests if the str contains the token
     * @param {String} str - string to test
     * @param {String} token - substring or regex to find
     * @returns {Boolean} - true if str contains token
     */
    function functionContains(str, token) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        var result;

        if(typeof token === 'string') {
            result = (str.indexOf(token) !== -1);
        } else {
            var matches = token(str);
            result = (typeof matches !== 'undefined');
        }

        return result;
    }

    /**
     * Match a string with a regex returning an array of object containing details of each match
     * @param {String} str - string
     * @param {String} regex - the regex applied to the string
     * @param {Integer} [limit] - max number of matches to return
     * @returns {Array} The array of match objects
     */
    function functionMatch(str, regex, limit) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        // limit, if specified, must be a non-negative number
        if(limit < 0) {
            throw {
                stack: (new Error()).stack,
                value: limit,
                code: 'D3040',
                index: 3
            };
        }

        var result = [];

        if(typeof limit === 'undefined' || limit > 0) {
            var count = 0;
            var matches = regex(str);
            if (typeof matches !== 'undefined') {
                while (typeof matches !== 'undefined' && (typeof limit === 'undefined' || count < limit)) {
                    result.push({
                        match: matches.match,
                        index: matches.start,
                        groups: matches.groups
                    });
                    matches = matches.next();
                    count++;
                }
            }
        }

        return result;
    }

    /**
     * Match a string with a regex returning an array of object containing details of each match
     * @param {String} str - string
     * @param {String} pattern - the substring/regex applied to the string
     * @param {String} replacement - text to replace the matched substrings
     * @param {Integer} [limit] - max number of matches to return
     * @returns {Array} The array of match objects
     */
    function* functionReplace(str, pattern, replacement, limit) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        // pattern cannot be an empty string
        if(pattern === '') {
            throw {
                code: "D3010",
                stack: (new Error()).stack,
                value: pattern,
                index: 2
            };
        }

        // limit, if specified, must be a non-negative number
        if(limit < 0) {
            throw {
                code: "D3011",
                stack: (new Error()).stack,
                value: limit,
                index: 4
            };
        }

        var replacer;
        if(typeof replacement === 'string') {
            replacer = function (regexMatch) {
                var substitute = '';
                // scan forward, copying the replacement text into the substitute string
                // and replace any occurrence of $n with the values matched by the regex
                var position = 0;
                var index = replacement.indexOf('$', position);
                while (index !== -1 && position < replacement.length) {
                    substitute += replacement.substring(position, index);
                    position = index + 1;
                    var dollarVal = replacement.charAt(position);
                    if (dollarVal === '$') {
                        // literal $
                        substitute += '$';
                        position++;
                    } else if (dollarVal === '0') {
                        substitute += regexMatch.match;
                        position++;
                    } else {
                        var maxDigits;
                        if(regexMatch.groups.length === 0) {
                            // no sub-matches; any $ followed by a digit will be replaced by an empty string
                            maxDigits = 1;
                        } else {
                            // max number of digits to parse following the $
                            maxDigits = Math.floor(Math.log(regexMatch.groups.length) * Math.LOG10E) + 1;
                        }
                        index = parseInt(replacement.substring(position, position + maxDigits), 10);
                        if(maxDigits > 1 && index > regexMatch.groups.length) {
                            index = parseInt(replacement.substring(position, position + maxDigits - 1), 10);
                        }
                        if (!isNaN(index)) {
                            if(regexMatch.groups.length > 0 ) {
                                var submatch = regexMatch.groups[index - 1];
                                if (typeof submatch !== 'undefined') {
                                    substitute += submatch;
                                }
                            }
                            position += index.toString().length;
                        } else {
                            // not a capture group, treat the $ as literal
                            substitute += '$';
                        }
                    }
                    index = replacement.indexOf('$', position);
                }
                substitute += replacement.substring(position);
                return substitute;
            };
        } else {
            replacer = replacement;
        }

        var result = '';
        var position = 0;

        if(typeof limit === 'undefined' || limit > 0) {
            var count = 0;
            if(typeof pattern === 'string') {
                var index = str.indexOf(pattern, position);
                while(index !== -1 && (typeof limit === 'undefined' || count < limit)) {
                    result += str.substring(position, index);
                    result += replacement;
                    position = index + pattern.length;
                    count++;
                    index = str.indexOf(pattern, position);
                }
                result += str.substring(position);
            } else {
                var matches = pattern(str);
                if (typeof matches !== 'undefined') {
                    while (typeof matches !== 'undefined' && (typeof limit === 'undefined' || count < limit)) {
                        result += str.substring(position, matches.start);
                        var replacedWith = yield * apply(replacer, [matches], null);
                        // check replacedWith is a string
                        if(typeof replacedWith === 'string') {
                            result += replacedWith;
                        } else {
                            // not a string - throw error
                            throw {
                                code: "D3012",
                                stack: (new Error()).stack,
                                value: replacedWith
                            };
                        }
                        position = matches.start + matches.match.length;
                        count++;
                        matches = matches.next();
                    }
                    result += str.substring(position);
                } else {
                    result = str;
                }
            }
        } else {
            result = str;
        }

        return result;
    }

    /**
     * Base64 encode a string
     * @param {String} str - string
     * @returns {String} Base 64 encoding of the binary data
     */
    function functionBase64encode(str) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }
        // Use btoa in a browser, or Buffer in Node.js

        var btoa = typeof window !== 'undefined' ?
            /* istanbul ignore next */ window.btoa :
            function(str) {
                // Simply doing `new Buffer` at this point causes Browserify to pull
                // in the entire Buffer browser library, which is large and unnecessary.
                // Using `global.Buffer` defeats this.
                return new global.Buffer(str, 'binary').toString('base64');
            };
        return btoa(str);
    }

    /**
     * Base64 decode a string
     * @param {String} str - string
     * @returns {String} Base 64 encoding of the binary data
     */
    function functionBase64decode(str) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }
        // Use btoa in a browser, or Buffer in Node.js
        var atob = typeof window !== 'undefined' ?
            /* istanbul ignore next */ window.atob :
            function(str) {
                // Simply doing `new Buffer` at this point causes Browserify to pull
                // in the entire Buffer browser library, which is large and unnecessary.
                // Using `global.Buffer` defeats this.
                return new global.Buffer(str, 'base64').toString('binary');
            };
        return atob(str);
    }

    /**
     * Split a string into an array of substrings
     * @param {String} str - string
     * @param {String} separator - the token or regex that splits the string
     * @param {Integer} [limit] - max number of substrings
     * @returns {Array} The array of string
     */
    function functionSplit(str, separator, limit) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        // limit, if specified, must be a non-negative number
        if(limit < 0) {
            throw {
                code: "D3020",
                stack: (new Error()).stack,
                value: limit,
                index: 3
            };
        }

        var result = [];

        if(typeof limit === 'undefined' || limit > 0) {
            if (typeof separator === 'string') {
                result = str.split(separator, limit);
            } else {
                var count = 0;
                var matches = separator(str);
                if (typeof matches !== 'undefined') {
                    var start = 0;
                    while (typeof matches !== 'undefined' && (typeof limit === 'undefined' || count < limit)) {
                        result.push(str.substring(start, matches.start));
                        start = matches.end;
                        matches = matches.next();
                        count++;
                    }
                    if(typeof limit === 'undefined' || count < limit) {
                        result.push(str.substring(start));
                    }
                } else {
                    result = [str];
                }
            }
        }

        return result;
    }

    /**
     * Join an array of strings
     * @param {Array} strs - array of string
     * @param {String} [separator] - the token that splits the string
     * @returns {String} The concatenated string
     */
    function functionJoin(strs, separator) {
        // undefined inputs always return undefined
        if(typeof strs === 'undefined') {
            return undefined;
        }

        // if separator is not specified, default to empty string
        if(typeof separator === 'undefined') {
            separator = "";
        }

        return strs.join(separator);
    }

    /**
     * Formats a number into a decimal string representation using XPath 3.1 F&O fn:format-number spec
     * @param {number} value - number to format
     * @param {String} picture - picture string definition
     * @param {Object} [options] - override locale defaults
     * @returns {String} The formatted string
     */
    function functionFormatNumber(value, picture, options) {
        var defaults = {
            "decimal-separator": ".",
            "grouping-separator": ",",
            "exponent-separator": "e",
            "infinity": "Infinity",
            "minus-sign": "-",
            "NaN": "NaN",
            "percent": "%",
            "per-mille": "\u2030",
            "zero-digit": "0",
            "digit": "#",
            "pattern-separator": ";"
        };

        // if `options` is specified, then its entries override defaults
        var properties = defaults;
        if(typeof options !== 'undefined') {
            Object.keys(options).forEach(function (key) {
                properties[key] = options[key];
            });
        }

        var decimalDigitFamily = [];
        var zeroCharCode = properties['zero-digit'].charCodeAt(0);
        for(var ii = zeroCharCode; ii < zeroCharCode + 10; ii++) {
            decimalDigitFamily.push(String.fromCharCode(ii));
        }

        var activeChars = decimalDigitFamily.concat([properties['decimal-separator'], properties['exponent-separator'], properties['grouping-separator'], properties.digit, properties['pattern-separator']]);

        var subPictures = picture.split(properties['pattern-separator']);

        if(subPictures.length > 2) {
            throw {
                code: 'D3080',
                stack: (new Error()).stack
            };
        }

        var splitParts = function(subpicture) {
            var prefix = (function() {
                var ch;
                for(var ii = 0; ii < subpicture.length; ii++) {
                    ch = subpicture.charAt(ii);
                    if(activeChars.indexOf(ch) !== -1 && ch !== properties['exponent-separator']) {
                        return subpicture.substring(0, ii);
                    }
                }
            })();
            var suffix = (function() {
                var ch;
                for(var ii = subpicture.length - 1; ii >= 0; ii--) {
                    ch = subpicture.charAt(ii);
                    if(activeChars.indexOf(ch) !== -1 && ch !== properties['exponent-separator']) {
                        return subpicture.substring(ii + 1);
                    }
                }
            })();
            var activePart = subpicture.substring(prefix.length, subpicture.length - suffix.length);
            var mantissaPart, exponentPart, integerPart, fractionalPart;
            var exponentPosition = subpicture.indexOf(properties['exponent-separator'], prefix.length);
            if(exponentPosition === -1 || exponentPosition > subpicture.length - suffix.length) {
                mantissaPart = activePart;
                exponentPart = undefined;
            } else {
                mantissaPart = activePart.substring(0, exponentPosition);
                exponentPart = activePart.substring(exponentPosition + 1);
            }
            var decimalPosition = mantissaPart.indexOf(properties['decimal-separator']);
            if(decimalPosition === -1) {
                integerPart = mantissaPart;
                fractionalPart = suffix;
            } else {
                integerPart = mantissaPart.substring(0, decimalPosition);
                fractionalPart = mantissaPart.substring(decimalPosition + 1);
            }
            return {
                prefix: prefix,
                suffix: suffix,
                activePart: activePart,
                mantissaPart: mantissaPart,
                exponentPart: exponentPart,
                integerPart: integerPart,
                fractionalPart: fractionalPart,
                subpicture: subpicture
            };
        };

        // validate the picture string, F&O 4.7.3
        var validate = function(parts) {
            var error;
            var ii;
            var subpicture = parts.subpicture;
            var decimalPos = subpicture.indexOf(properties['decimal-separator']);
            if(decimalPos !== subpicture.lastIndexOf(properties['decimal-separator'])) {
                error = 'D3081';
            }
            if(subpicture.indexOf(properties.percent) !== subpicture.lastIndexOf(properties.percent)) {
                error = 'D3082';
            }
            if(subpicture.indexOf(properties['per-mille']) !== subpicture.lastIndexOf(properties['per-mille'])) {
                error = 'D3083';
            }
            if(subpicture.indexOf(properties.percent) !== -1 && subpicture.indexOf(properties['per-mille']) !== -1) {
                error = 'D3084';
            }
            var valid = false;
            for(ii = 0; ii < parts.mantissaPart.length; ii++) {
                var ch = parts.mantissaPart.charAt(ii);
                if(decimalDigitFamily.indexOf(ch) !== -1 || ch === properties.digit) {
                    valid = true;
                    break;
                }
            }
            if(!valid) {
                error = 'D3085';
            }
            var charTypes = parts.activePart.split('').map(function(char) {
                return activeChars.indexOf(char) === -1 ? 'p' : 'a';
            }).join('');
            if(charTypes.indexOf('p') !== -1) {
                error = 'D3086';
            }
            if(decimalPos !== -1) {
                if(subpicture.charAt(decimalPos - 1) === properties['grouping-separator'] || subpicture.charAt(decimalPos + 1) === properties['grouping-separator']) {
                    error = 'D3087';
                }
            } else if(parts.integerPart.charAt(parts.integerPart.length - 1) === properties['grouping-separator']) {
                error = 'D3088';
            }
            if(subpicture.indexOf(properties['grouping-separator'] + properties['grouping-separator']) !== -1) {
                error = 'D3089';
            }
            var optionalDigitPos = parts.integerPart.indexOf(properties.digit);
            if(optionalDigitPos !== -1 && parts.integerPart.substring(0, optionalDigitPos).split('').filter(function(char) {
                return decimalDigitFamily.indexOf(char) > -1;
            }).length > 0) {
                error = 'D3090';
            }
            optionalDigitPos = parts.fractionalPart.lastIndexOf(properties.digit);
            if(optionalDigitPos !== -1 && parts.fractionalPart.substring(optionalDigitPos).split('').filter(function(char) {
                return decimalDigitFamily.indexOf(char) > -1;
            }).length > 0) {
                error = 'D3091';
            }
            var exponentExists = (typeof parts.exponentPart === 'string');
            if(exponentExists && parts.exponentPart.length > 0 && (subpicture.indexOf(properties.percent) !== -1 || subpicture.indexOf(properties['per-mille']) !== -1)) {
                error = 'D3092';
            }
            if(exponentExists && (parts.exponentPart.length === 0 || parts.exponentPart.split('').filter(function(char) {
                return decimalDigitFamily.indexOf(char) === -1;
            }).length > 0)) {
                error = 'D3093';
            }
            if(error) {
                throw {
                    code: error,
                    stack: (new Error()).stack
                };
            }
        };

        // analyse the picture string, F&O 4.7.4
        var analyse = function(parts) {
            var getGroupingPositions = function(part, toLeft) {
                var positions = [];
                var groupingPosition = part.indexOf(properties['grouping-separator']);
                while(groupingPosition !== -1) {
                    var charsToTheRight = (toLeft ? part.substring(0, groupingPosition) : part.substring(groupingPosition)).split('').filter(function(char) {
                        return decimalDigitFamily.indexOf(char) !== -1 || char === properties.digit;
                    }).length;
                    positions.push(charsToTheRight);
                    groupingPosition = parts.integerPart.indexOf(properties['grouping-separator'], groupingPosition + 1);
                }
                return positions;
            };
            var integerPartGroupingPositions = getGroupingPositions(parts.integerPart);
            var regular = function(indexes) {
                // are the grouping positions regular? i.e. same interval between each of them
                if(indexes.length === 0) {
                    return 0;
                }
                var gcd = function(a, b) {
                    return b === 0 ? a : gcd(b, a % b);
                };
                // find the greatest common divisor of all the positions
                var factor = indexes.reduce(gcd);
                // is every position separated by this divisor? If so, it's regular
                for(var index = 1; index <= indexes.length; index++) {
                    if(indexes.indexOf(index * factor) === -1) {
                        return 0;
                    }
                }
                return factor;
            };

            var regularGrouping = regular(integerPartGroupingPositions);
            var fractionalPartGroupingPositions = getGroupingPositions(parts.fractionalPart, true);

            var minimumIntegerPartSize = parts.integerPart.split('').filter(function(char) { return decimalDigitFamily.indexOf(char) !== -1; }).length;
            var scalingFactor = minimumIntegerPartSize;

            var fractionalPartArray = parts.fractionalPart.split('');
            var minimumFactionalPartSize = fractionalPartArray.filter(function(char) { return decimalDigitFamily.indexOf(char) !== -1; }).length;
            var maximumFactionalPartSize = fractionalPartArray.filter(function(char) { return decimalDigitFamily.indexOf(char) !== -1 || char === properties.digit; }).length;
            var exponentPresent = typeof parts.exponentPart === 'string';
            if(minimumIntegerPartSize === 0 && maximumFactionalPartSize === 0) {
                if(exponentPresent) {
                    minimumFactionalPartSize = 1;
                    maximumFactionalPartSize = 1;
                } else {
                    minimumIntegerPartSize = 1;
                }
            }
            if(exponentPresent && minimumIntegerPartSize === 0 && parts.integerPart.indexOf(properties.digit) !== -1) {
                minimumIntegerPartSize = 1;
            }
            if(minimumIntegerPartSize === 0 && minimumFactionalPartSize === 0) {
                minimumFactionalPartSize = 1;
            }
            var minimumExponentSize = 0;
            if(exponentPresent) {
                minimumExponentSize = parts.exponentPart.split('').filter(function(char) { return decimalDigitFamily.indexOf(char) !== -1; }).length;
            }

            return {
                integerPartGroupingPositions: integerPartGroupingPositions,
                regularGrouping: regularGrouping,
                minimumIntegerPartSize: minimumIntegerPartSize,
                scalingFactor: scalingFactor,
                prefix: parts.prefix,
                fractionalPartGroupingPositions: fractionalPartGroupingPositions,
                minimumFactionalPartSize: minimumFactionalPartSize,
                maximumFactionalPartSize: maximumFactionalPartSize,
                minimumExponentSize: minimumExponentSize,
                suffix: parts.suffix,
                picture: parts.subpicture
            };
        };

        var parts = subPictures.map(splitParts);
        parts.forEach(validate);

        var variables = parts.map(analyse);

        if(variables.length === 1) {
            variables.push(JSON.parse(JSON.stringify(variables[0])));
            variables[1].prefix = properties['minus-sign'] + variables[1].prefix;
        }

        // TODO cache the result of the analysis

        // format the number
        // bullet 1: TODO: NaN - not sure we'd ever get this in JSON
        var pic;
        // bullet 2:
        if(value >= 0) {
            pic = variables[0];
        } else {
            pic = variables[1];
        }
        var adjustedNumber;
        // bullet 3:
        if(pic.picture.indexOf(properties.percent) !== -1) {
            adjustedNumber = value * 100;
        } else if(pic.picture.indexOf(properties['per-mille']) !== -1) {
            adjustedNumber = value * 1000;
        } else {
            adjustedNumber = value;
        }
        // bullet 4:
        // TODO: infinity - not sure we'd ever get this in JSON
        // bullet 5:
        var mantissa, exponent;
        if(pic.minimumExponentSize === 0) {
            mantissa = adjustedNumber;
        } else {
            // mantissa * 10^exponent = adjustedNumber
            var maxMantissa = Math.pow(10, pic.scalingFactor);
            var minMantissa = Math.pow(10, pic.scalingFactor - 1);
            mantissa = adjustedNumber;
            exponent = 0;
            while(mantissa < minMantissa) {
                mantissa *= 10;
                exponent -= 1;
            }
            while(mantissa > maxMantissa) {
                mantissa /= 10;
                exponent += 1;
            }
        }
        // bullet 6:
        var roundedNumber = functionRound(mantissa, pic.maximumFactionalPartSize);
        // bullet 7:
        var makeString = function(value, dp) {
            var str = Math.abs(value).toFixed(dp);
            if (properties['zero-digit'] !== '0') {
                str = str.split('').map(function (digit) {
                    if(digit >= '0' && digit <='9') {
                        return decimalDigitFamily[digit.charCodeAt(0) - 48];
                    } else {
                        return digit;
                    }
                }).join('');
            }
            return str;
        };
        var stringValue = makeString(roundedNumber, pic.maximumFactionalPartSize);
        var decimalPos = stringValue.indexOf('.');
        if(decimalPos === -1) {
            stringValue = stringValue + properties['decimal-separator'];
        } else {
            stringValue = stringValue.replace('.', properties['decimal-separator']);
        }
        while(stringValue.charAt(0) === properties['zero-digit']) {
            stringValue = stringValue.substring(1);
        }
        while(stringValue.charAt(stringValue.length - 1) === properties['zero-digit']) {
            stringValue = stringValue.substring(0, stringValue.length - 1);
        }
        // bullets 8 & 9:
        decimalPos = stringValue.indexOf(properties['decimal-separator']);
        var padLeft = pic.minimumIntegerPartSize - decimalPos;
        var padRight = pic.minimumFactionalPartSize - (stringValue.length - decimalPos - 1);
        stringValue = (padLeft > 0 ? new Array(padLeft + 1).join('0') : '') + stringValue;
        stringValue = stringValue + (padRight > 0 ? new Array(padRight + 1).join('0') : '');
        decimalPos = stringValue.indexOf(properties['decimal-separator']);
        // bullet 10:
        if(pic.regularGrouping > 0) {
            var groupCount = Math.floor((decimalPos - 1) / pic.regularGrouping);
            for(var group = 1; group <= groupCount; group++) {
                stringValue = [stringValue.slice(0, decimalPos - group * pic.regularGrouping), properties['grouping-separator'], stringValue.slice(decimalPos - group * pic.regularGrouping)].join('');
            }
        } else {
            pic.integerPartGroupingPositions.forEach(function (pos) {
                stringValue = [stringValue.slice(0, decimalPos - pos), properties['grouping-separator'], stringValue.slice(decimalPos - pos)].join('');
                decimalPos++;
            });
        }
        // bullet 11:
        decimalPos = stringValue.indexOf(properties['decimal-separator']);
        pic.fractionalPartGroupingPositions.forEach(function(pos) {
            stringValue = [stringValue.slice(0, pos + decimalPos + 1), properties['grouping-separator'], stringValue.slice(pos + decimalPos + 1)].join('');
        });
        // bullet 12:
        decimalPos = stringValue.indexOf(properties['decimal-separator']);
        if(pic.picture.indexOf(properties['decimal-separator']) === -1 || decimalPos === stringValue.length - 1) {
            stringValue = stringValue.substring(0, stringValue.length - 1);
        }
        // bullet 13:
        if(typeof exponent !== 'undefined') {
            var stringExponent = makeString(exponent, 0);
            padLeft = pic.minimumExponentSize - stringExponent.length;
            if(padLeft > 0) {
                stringExponent = new Array(padLeft + 1).join('0') + stringExponent;
            }
            stringValue = stringValue + properties['exponent-separator'] + (exponent < 0 ? properties['minus-sign'] : '') + stringExponent;
        }
        // bullet 14:
        stringValue = pic.prefix + stringValue + pic.suffix;
        return stringValue;
    }

    /**
     * Converts a number to a string using a specified number base
     * @param {string} value - the number to convert
     * @param {number} [radix] - the number base; must be between 2 and 36. Defaults to 10
     * @returns {string} - the converted string
     */
    function functionFormatBase(value, radix) {
        // undefined inputs always return undefined
        if(typeof value === 'undefined') {
            return undefined;
        }

        value = functionRound(value);

        if(typeof radix === 'undefined') {
            radix = 10;
        } else {
            radix = functionRound(radix);
        }

        if(radix < 2 || radix > 36) {
            throw {
                code: 'D3100',
                stack: (new Error()).stack,
                value: radix
            };

        }

        var result = value.toString(radix);

        return result;
    }

    /**
     * Cast argument to number
     * @param {Object} arg - Argument
     * @returns {Number} numeric value of argument
     */
    function functionNumber(arg) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        if (typeof arg === 'number') {
            // already a number
            result = arg;
        } else if(typeof arg === 'string' && /^-?(0|([1-9][0-9]*))(\.[0-9]+)?([Ee][-+]?[0-9]+)?$/.test(arg) && !isNaN(parseFloat(arg)) && isFinite(arg)) {
            result = parseFloat(arg);
        } else {
            throw {
                code: "D3030",
                value: arg,
                stack: (new Error()).stack,
                index: 1
            };
        }
        return result;
    }

    /**
     * Absolute value of a number
     * @param {Number} arg - Argument
     * @returns {Number} absolute value of argument
     */
    function functionAbs(arg) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        result = Math.abs(arg);
        return result;
    }

    /**
     * Rounds a number down to integer
     * @param {Number} arg - Argument
     * @returns {Number} rounded integer
     */
    function functionFloor(arg) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        result = Math.floor(arg);
        return result;
    }

    /**
     * Rounds a number up to integer
     * @param {Number} arg - Argument
     * @returns {Number} rounded integer
     */
    function functionCeil(arg) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        result = Math.ceil(arg);
        return result;
    }

    /**
     * Round to half even
     * @param {Number} arg - Argument
     * @param {Number} precision - number of decimal places
     * @returns {Number} rounded integer
     */
    function functionRound(arg, precision) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        if(precision) {
            // shift the decimal place - this needs to be done in a string since multiplying
            // by a power of ten can introduce floating point precision errors which mess up
            // this rounding algorithm - See 'Decimal rounding' in
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round
            // Shift
            var value = arg.toString().split('e');
            arg = +(value[0] + 'e' + (value[1] ? (+value[1] + precision) : precision));

        }

        // round up to nearest int
        result = Math.round(arg);
        var diff = result - arg;
        if(Math.abs(diff) === 0.5 && Math.abs(result % 2) === 1) {
            // rounded the wrong way - adjust to nearest even number
            result = result - 1;
        }
        if(precision) {
            // Shift back
            value = result.toString().split('e');
            /* istanbul ignore next */
            result = +(value[0] + 'e' + (value[1] ? (+value[1] - precision) : -precision));
        }
        if(Object.is(result, -0)) { // ESLint rule 'no-compare-neg-zero' suggests this way
            // JSON doesn't do -0
            result = 0;
        }
        return result;
    }

    /**
     * Square root of number
     * @param {Number} arg - Argument
     * @returns {Number} square root
     */
    function functionSqrt(arg) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        if(arg < 0) {
            throw {
                stack: (new Error()).stack,
                code: "D3060",
                index: 1,
                value: arg
            };
        }

        result = Math.sqrt(arg);

        return result;
    }

    /**
     * Raises number to the power of the second number
     * @param {Number} arg - the base
     * @param {Number} exp - the exponent
     * @returns {Number} rounded integer
     */
    function functionPower(arg, exp) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        result = Math.pow(arg, exp);

        if(!isFinite(result)) {
            throw {
                stack: (new Error()).stack,
                code: "D3061",
                index: 1,
                value: arg,
                exp: exp
            };
        }

        return result;
    }

    /**
     * Returns a random number 0 <= n < 1
     * @returns {number} random number
     */
    function functionRandom() {
        return Math.random();
    }

    /**
     * Evaluate an input and return a boolean
     * @param {*} arg - Arguments
     * @returns {boolean} Boolean
     */
    function functionBoolean(arg) {
        // cast arg to its effective boolean value
        // boolean: unchanged
        // string: zero-length -> false; otherwise -> true
        // number: 0 -> false; otherwise -> true
        // null -> false
        // array: empty -> false; length > 1 -> true
        // object: empty -> false; non-empty -> true
        // function -> false

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        var result = false;
        if (Array.isArray(arg)) {
            if (arg.length === 1) {
                result = functionBoolean(arg[0]);
            } else if (arg.length > 1) {
                var trues = arg.filter(function(val) {return functionBoolean(val);});
                result = trues.length > 0;
            }
        } else if (typeof arg === 'string') {
            if (arg.length > 0) {
                result = true;
            }
        } else if (isNumeric(arg)) {
            if (arg !== 0) {
                result = true;
            }
        } else if (arg !== null && typeof arg === 'object') {
            if (Object.keys(arg).length > 0) {
                // make sure it's not a lambda function
                if (!(isLambda(arg) || arg._jsonata_function)) {
                    result = true;
                }
            }
        } else if (typeof arg === 'boolean' && arg === true) {
            result = true;
        }
        return result;
    }

    /**
     * returns the Boolean NOT of the arg
     * @param {*} arg - argument
     * @returns {boolean} - NOT arg
     */
    function functionNot(arg) {
        return !functionBoolean(arg);
    }

    /**
     * Create a map from an array of arguments
     * @param {Array} [arr] - array to map over
     * @param {Function} func - function to apply
     * @returns {Array} Map array
     */
    function* functionMap(arr, func) {
        // undefined inputs always return undefined
        if(typeof arr === 'undefined') {
            return undefined;
        }

        var result = [];
        // do the map - iterate over the arrays, and invoke func
        for (var i = 0; i < arr.length; i++) {
            var func_args = [arr[i]]; // the first arg (value) is required
            // the other two are optional - only supply it if the function can take it
            var length = typeof func === 'function' ? func.length :
                func._jsonata_function === true ? func.implementation.length : func.arguments.length;
            if(length >= 2) {
                func_args.push(i);
            }
            if(length >= 3) {
                func_args.push(arr);
            }
            // invoke func
            var res = yield * apply(func, func_args, null);
            if(typeof res !== 'undefined') {
                result.push(res);
            }
        }

        return result;
    }

    // This generator function does not have a yield(), presumably to make it
    // consistent with other similar functions.
    /**
     * Create a map from an array of arguments
     * @param {Array} [arr] - array to filter
     * @param {Function} func - predicate function
     * @returns {Array} Map array
     */
    function* functionFilter(arr, func) { // eslint-disable-line require-yield
        // undefined inputs always return undefined
        if(typeof arr === 'undefined') {
            return undefined;
        }

        var result = [];

        var predicate = function (value, index, array) {
            var it = apply(func, [value, index, array], null);
            // returns a generator - so iterate over it
            var res = it.next();
            while (!res.done) {
                res = it.next(res.value);
            }
            return res.value;
        };

        for(var i = 0; i < arr.length; i++) {
            var entry = arr[i];
            if(functionBoolean(predicate(entry, i, arr))) {
                result.push(entry);
            }
        }

        return result;
    }

    /**
     * Convolves (zips) each value from a set of arrays
     * @param {Array} [args] - arrays to zip
     * @returns {Array} Zipped array
     */
    function functionZip() {
        // this can take a variable number of arguments
        var result = [];
        var args = Array.prototype.slice.call(arguments);
        // length of the shortest array
        var length = Math.min.apply(Math, args.map(function(arg) {
            if(Array.isArray(arg)) {
                return arg.length;
            }
            return 0;
        }));
        for(var i = 0; i < length; i++) {
            var tuple = args.map((arg) => {return arg[i];});
            result.push(tuple);
        }
        return result;
    }

    /**
     * Fold left function
     * @param {Array} sequence - Sequence
     * @param {Function} func - Function
     * @param {Object} init - Initial value
     * @returns {*} Result
     */
    function* functionFoldLeft(sequence, func, init) {
        // undefined inputs always return undefined
        if(typeof sequence === 'undefined') {
            return undefined;
        }

        var result;

        if (!(func.length === 2 || (func._jsonata_function === true && func.implementation.length === 2) || func.arguments.length === 2)) {
            throw {
                stack: (new Error()).stack,
                code: "D3050",
                index: 1
            };
        }

        var index;
        if (typeof init === 'undefined' && sequence.length > 0) {
            result = sequence[0];
            index = 1;
        } else {
            result = init;
            index = 0;
        }

        while (index < sequence.length) {
            result = yield * apply(func, [result, sequence[index]], null);
            index++;
        }

        return result;
    }

    /**
     * Return keys for an object
     * @param {Object} arg - Object
     * @returns {Array} Array of keys
     */
    function functionKeys(arg) {
        var result = [];

        if(Array.isArray(arg)) {
            // merge the keys of all of the items in the array
            var merge = {};
            arg.forEach(function(item) {
                var keys = functionKeys(item);
                if(Array.isArray(keys)) {
                    keys.forEach(function(key) {
                        merge[key] = true;
                    });
                }
            });
            result = functionKeys(merge);
        } else if(arg !== null && typeof arg === 'object' && !(isLambda(arg))) {
            result = Object.keys(arg);
            if(result.length === 0) {
                result = undefined;
            }
        } else {
            result = undefined;
        }
        return result;
    }

    /**
     * Return value from an object for a given key
     * @param {Object} object - Object
     * @param {String} key - Key in object
     * @returns {*} Value of key in object
     */
    function functionLookup(object, key) {
        var result = evaluateName({value: key}, object);
        return result;
    }

    /**
     * Append second argument to first
     * @param {Array|Object} arg1 - First argument
     * @param {Array|Object} arg2 - Second argument
     * @returns {*} Appended arguments
     */
    function functionAppend(arg1, arg2) {
        // disregard undefined args
        if (typeof arg1 === 'undefined') {
            return arg2;
        }
        if (typeof arg2 === 'undefined') {
            return arg1;
        }
        // if either argument is not an array, make it so
        if (!Array.isArray(arg1)) {
            arg1 = [arg1];
        }
        if (!Array.isArray(arg2)) {
            arg2 = [arg2];
        }
        Array.prototype.push.apply(arg1, arg2);
        return arg1;
    }

    /**
     * Determines if the argument is undefined
     * @param {*} arg - argument
     * @returns {boolean} False if argument undefined, otherwise true
     */
    function functionExists(arg){
        if (typeof arg === 'undefined') {
            return false;
        } else {
            return true;
        }
    }

    /**
     * Splits an object into an array of object with one property each
     * @param {*} arg - the object to split
     * @returns {*} - the array
     */
    function functionSpread(arg) {
        var result = [];

        if(Array.isArray(arg)) {
            // spread all of the items in the array
            arg.forEach(function(item) {
                result = functionAppend(result, functionSpread(item));
            });
        } else if(arg !== null && typeof arg === 'object' && !isLambda(arg)) {
            for(var key in arg) {
                var obj = {};
                obj[key] = arg[key];
                result.push(obj);
            }
        } else {
            result = arg;
        }
        return result;
    }

    /**
     * Merges an array of objects into a single object.  Duplicate properties are
     * overridden by entries later in the array
     * @param {*} arg - the objects to merge
     * @returns {*} - the object
     */
    function functionMerge(arg) {
        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        var result = {};

        arg.forEach(function(obj) {
            for(var prop in obj) {
                result[prop] = obj[prop];
            }
        });
        return result;
    }

    /**
     * Reverses the order of items in an array
     * @param {Array} arr - the array to reverse
     * @returns {Array} - the reversed array
     */
    function functionReverse(arr) {
        // undefined inputs always return undefined
        if(typeof arr === 'undefined') {
            return undefined;
        }

        if(arr.length <= 1) {
            return arr;
        }

        var length = arr.length;
        var result = new Array(length);
        for(var i = 0; i < length; i++) {
            result[length - i - 1] = arr[i];
        }

        return result;
    }

    /**
     *
     * @param {*} obj - the input object to iterate over
     * @param {*} func - the function to apply to each key/value pair
     * @returns {Array} - the resultant array
     */
    function* functionEach(obj, func) {
        var result = [];

        for(var key in obj) {
            var func_args = [obj[key], key];
            // invoke func
            result.push(yield * apply(func, func_args, null));
        }

        return result;
    }

    /**
     * Implements the merge sort (stable) with optional comparator function
     *
     * @param {Array} arr - the array to sort
     * @param {*} comparator - comparator function
     * @returns {Array} - sorted array
     */
    function functionSort(arr, comparator) {
        // undefined inputs always return undefined
        if(typeof arr === 'undefined') {
            return undefined;
        }

        if(arr.length <= 1) {
            return arr;
        }

        var comp;
        if(typeof comparator === 'undefined') {
            // inject a default comparator - only works for numeric or string arrays
            if (!isArrayOfNumbers(arr) && !isArrayOfStrings(arr)) {
                throw {
                    stack: (new Error()).stack,
                    code: "D3070",
                    index: 1
                };
            }

            comp = function (a, b) {
                return a > b;
            };
        } else if(typeof comparator === 'function') {
            // for internal usage of functionSort (i.e. order-by syntax)
            comp = comparator;
        } else {
            comp = function (a, b) {
                var it = apply(comparator, [a, b], null);
                // returns a generator - so iterate over it
                var comp = it.next();
                while (!comp.done) {
                    comp = it.next(comp.value);
                }
                return comp.value;
            };
        }

        var merge = function(l, r) {
            var merge_iter = function(result, left, right) {
                if (left.length === 0) {
                    Array.prototype.push.apply(result, right);
                } else if (right.length === 0) {
                    Array.prototype.push.apply(result, left);
                } else if (comp(left[0], right[0])) { // invoke the comparator function
                    // if it returns true - swap left and right
                    result.push(right[0]);
                    merge_iter(result, left, right.slice(1));
                } else {
                    // otherwise keep the same order
                    result.push(left[0]);
                    merge_iter(result, left.slice(1), right);
                }
            };
            var merged = [];
            merge_iter(merged, l, r);
            return merged;
        };

        var sort = function(array) {
            if(array.length <= 1) {
                return array;
            } else {
                var middle = Math.floor(array.length / 2);
                var left = array.slice(0, middle);
                var right = array.slice(middle);
                left = sort(left);
                right = sort(right);
                return merge(left, right);
            }
        };

        var result = sort(arr);

        return result;
    }

    /**
     * Randomly shuffles the contents of an array
     * @param {Array} arr - the input array
     * @returns {Array} the shuffled array
     */
    function functionShuffle(arr) {
        // undefined inputs always return undefined
        if(typeof arr === 'undefined') {
            return undefined;
        }

        if(arr.length <= 1) {
            return arr;
        }

        // shuffle using the 'inside-out' variant of the Fisher-Yates algorithm
        var result = new Array(arr.length);
        for(var i = 0; i < arr.length; i++) {
            var j = Math.floor(Math.random() * (i + 1)); // random integer such that 0 â¤ j â¤ i
            if(i !== j) {
                result[i] = result[j];
            }
            result[j] = arr[i];
        }

        return result;
    }

    /**
     * Applies a predicate function to each key/value pair in an object, and returns an object containing
     * only the key/value pairs that passed the predicate
     *
     * @param {object} arg - the object to be sifted
     * @param {object} func - the predicate function (lambda or native)
     * @returns {object} - sifted object
     */
    function functionSift(arg, func) {
        var result = {};

        var predicate = function (value, key, object) {
            var it = apply(func, [value, key, object], null);
            // returns a generator - so iterate over it
            var res = it.next();
            while (!res.done) {
                res = it.next(res.value);
            }
            return res.value;
        };

        for(var item in arg) {
            var entry = arg[item];
            if(functionBoolean(predicate(entry, item, arg))) {
                result[item] = entry;
            }
        }

        // empty objects should be changed to undefined
        if(Object.keys(result).length === 0) {
            result = undefined;
        }

        return result;
    }

    // Regular expression to match an ISO 8601 formatted timestamp
    var iso8601regex = new RegExp('^\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z)$');

    /**
     * Converts an ISO 8601 timestamp to milliseconds since the epoch
     *
     * @param {string} timestamp - the ISO 8601 timestamp to be converted
     * @returns {Number} - milliseconds since the epoch
     */
    function functionToMillis(timestamp) {
        // undefined inputs always return undefined
        if(typeof timestamp === 'undefined') {
            return undefined;
        }

        if(!iso8601regex.test(timestamp)) {
            throw {
                stack: (new Error()).stack,
                code: "D3110",
                value: timestamp
            };
        }

        return Date.parse(timestamp);
    }

    /**
     * Converts milliseconds since the epoch to an ISO 8601 timestamp
     * @param {Number} millis - milliseconds since the epoch to be converted
     * @returns {String} - an ISO 8601 formatted timestamp
     */
    function functionFromMillis(millis) {
        // undefined inputs always return undefined
        if(typeof millis === 'undefined') {
            return undefined;
        }

        return new Date(millis).toISOString();
    }

    /**
     * Clones an object
     * @param {Object} arg - object to clone (deep copy)
     * @returns {*} - the cloned object
     */
    function functionClone(arg) {
        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        return JSON.parse(functionString(arg));
    }

    /**
     * Create frame
     * @param {Object} enclosingEnvironment - Enclosing environment
     * @returns {{bind: bind, lookup: lookup}} Created frame
     */
    function createFrame(enclosingEnvironment) {
        var bindings = {};
        return {
            bind: function (name, value) {
                bindings[name] = value;
            },
            lookup: function (name) {
                var value;
                if(bindings.hasOwnProperty(name)) {
                    value = bindings[name];
                } else if (enclosingEnvironment) {
                    value = enclosingEnvironment.lookup(name);
                }
                return value;
            }
        };
    }

    // Function registration
    staticFrame.bind('sum', defineFunction(functionSum, '<a<n>:n>'));
    staticFrame.bind('count', defineFunction(functionCount, '<a:n>'));
    staticFrame.bind('max', defineFunction(functionMax, '<a<n>:n>'));
    staticFrame.bind('min', defineFunction(functionMin, '<a<n>:n>'));
    staticFrame.bind('average', defineFunction(functionAverage, '<a<n>:n>'));
    staticFrame.bind('string', defineFunction(functionString, '<x-:s>'));
    staticFrame.bind('substring', defineFunction(functionSubstring, '<s-nn?:s>'));
    staticFrame.bind('substringBefore', defineFunction(functionSubstringBefore, '<s-s:s>'));
    staticFrame.bind('substringAfter', defineFunction(functionSubstringAfter, '<s-s:s>'));
    staticFrame.bind('lowercase', defineFunction(functionLowercase, '<s-:s>'));
    staticFrame.bind('uppercase', defineFunction(functionUppercase, '<s-:s>'));
    staticFrame.bind('length', defineFunction(functionLength, '<s-:n>'));
    staticFrame.bind('trim', defineFunction(functionTrim, '<s-:s>'));
    staticFrame.bind('pad', defineFunction(functionPad, '<s-ns?:s>'));
    staticFrame.bind('match', defineFunction(functionMatch, '<s-f<s:o>n?:a<o>>'));
    staticFrame.bind('contains', defineFunction(functionContains, '<s-(sf):b>')); // TODO <s-(sf<s:o>):b>
    staticFrame.bind('replace', defineFunction(functionReplace, '<s-(sf)(sf)n?:s>')); // TODO <s-(sf<s:o>)(sf<o:s>)n?:s>
    staticFrame.bind('split', defineFunction(functionSplit, '<s-(sf)n?:a<s>>')); // TODO <s-(sf<s:o>)n?:a<s>>
    staticFrame.bind('join', defineFunction(functionJoin, '<a<s>s?:s>'));
    staticFrame.bind('formatNumber', defineFunction(functionFormatNumber, '<n-so?:s>'));
    staticFrame.bind('formatBase', defineFunction(functionFormatBase, '<n-n?:s>'));
    staticFrame.bind('number', defineFunction(functionNumber, '<(ns)-:n>'));
    staticFrame.bind('floor', defineFunction(functionFloor, '<n-:n>'));
    staticFrame.bind('ceil', defineFunction(functionCeil, '<n-:n>'));
    staticFrame.bind('round', defineFunction(functionRound, '<n-n?:n>'));
    staticFrame.bind('abs', defineFunction(functionAbs, '<n-:n>'));
    staticFrame.bind('sqrt', defineFunction(functionSqrt, '<n-:n>'));
    staticFrame.bind('power', defineFunction(functionPower, '<n-n:n>'));
    staticFrame.bind('random', defineFunction(functionRandom, '<:n>'));
    staticFrame.bind('boolean', defineFunction(functionBoolean, '<x-:b>'));
    staticFrame.bind('not', defineFunction(functionNot, '<x-:b>'));
    staticFrame.bind('map', defineFunction(functionMap, '<af>'));
    staticFrame.bind('zip', defineFunction(functionZip, '<a+>'));
    staticFrame.bind('filter', defineFunction(functionFilter, '<af>'));
    staticFrame.bind('reduce', defineFunction(functionFoldLeft, '<afj?:j>')); // TODO <f<jj:j>a<j>j?:j>
    staticFrame.bind('sift', defineFunction(functionSift, '<o-f?:o>'));
    staticFrame.bind('keys', defineFunction(functionKeys, '<x-:a<s>>'));
    staticFrame.bind('lookup', defineFunction(functionLookup, '<x-s:x>'));
    staticFrame.bind('append', defineFunction(functionAppend, '<xx:a>'));
    staticFrame.bind('exists', defineFunction(functionExists, '<x:b>'));
    staticFrame.bind('spread', defineFunction(functionSpread, '<x-:a<o>>'));
    staticFrame.bind('merge', defineFunction(functionMerge, '<a<o>:o>'));
    staticFrame.bind('reverse', defineFunction(functionReverse, '<a:a>'));
    staticFrame.bind('each', defineFunction(functionEach, '<o-f:a>'));
    staticFrame.bind('sort', defineFunction(functionSort, '<af?:a>'));
    staticFrame.bind('shuffle', defineFunction(functionShuffle, '<a:a>'));
    staticFrame.bind('base64encode', defineFunction(functionBase64encode, '<s-:s>'));
    staticFrame.bind('base64decode', defineFunction(functionBase64decode, '<s-:s>'));
    staticFrame.bind('toMillis', defineFunction(functionToMillis, '<s-:n>'));
    staticFrame.bind('fromMillis', defineFunction(functionFromMillis, '<n-:s>'));
    staticFrame.bind('clone', defineFunction(functionClone, '<(oa)-:o>'));

    /**
     * Error codes
     *
     */
    var errorCodes = {
        "S0101": "String literal must be terminated by a matching quote",
        "S0102": "Number out of range: {{token}}",
        "S0103": "Unsupported escape sequence: \\{{token}}",
        "S0104": "The escape sequence \\u must be followed by 4 hex digits",
        "S0105": "Quoted property name must be terminated with a backquote (`)",
        "S0201": "Syntax error: {{token}}",
        "S0202": "Expected {{value}}, got {{token}}",
        "S0203": "Expected {{value}} before end of expression",
        "S0204": "Unknown operator: {{token}}",
        "S0205": "Unexpected token: {{token}}",
        "S0206": "Unknown expression type: {{token}}",
        "S0207": "Unexpected end of expression",
        "S0208": "Parameter {{value}} of function definition must be a variable name (start with $)",
        "S0209": "A predicate cannot follow a grouping expression in a step",
        "S0210": "Each step can only have one grouping expression",
        "S0211": "The symbol {{token}} cannot be used as a unary operator",
        "S0301": "Empty regular expressions are not allowed",
        "S0302": "No terminating / in regular expression",
        "S0402": "Choice groups containing parameterized types are not supported",
        "S0401": "Type parameters can only be applied to functions and arrays",
        "S0500": "Attempted to evaluate an expression containing syntax error(s)",
        "T0410": "Argument {{index}} of function {{token}} does not match function signature",
        "T0411": "Context value is not a compatible type with argument {{index}} of function {{token}}",
        "T0412": "Argument {{index}} of function {{token}} must be an array of {{type}}",
        "D1001": "Number out of range: {{value}}",
        "D1002": "Cannot negate a non-numeric value: {{value}}",
        "T1003": "Key in object structure must evaluate to a string; got: {{value}}",
        "D1004": "Regular expression matches zero length string",
        "T1005": "Attempted to invoke a non-function. Did you mean ${{{token}}}?",
        "T1006": "Attempted to invoke a non-function",
        "T1007": "Attempted to partially apply a non-function. Did you mean ${{{token}}}?",
        "T1008": "Attempted to partially apply a non-function",
        "T2001": "The left side of the {{token}} operator must evaluate to a number",
        "T2002": "The right side of the {{token}} operator must evaluate to a number",
        "T2003": "The left side of the range operator (..) must evaluate to an integer",
        "T2004": "The right side of the range operator (..) must evaluate to an integer",
        "D2005": "The left side of := must be a variable name (start with $)",
        "T2006": "The right side of the function application operator ~> must be a function",
        "T2007": "Type mismatch when comparing values {{value}} and {{value2}} in order-by clause",
        "T2008": "The expressions within an order-by clause must evaluate to numeric or string values",
        "T2009": "The values {{value}} and {{value2}} either side of operator {{token}} must be of the same data type",
        "T2010": "The expressions either side of operator {{token}} must evaluate to numeric or string values",
        "T2011": "The insert/update clause of the transform expression must evaluate to an object: {{value}}",
        "T2012": "The delete clause of the transform expression must evaluate to a string or array of strings: {{value}}",
        "T2013": "The transform expression clones the input object using the $clone() function.  This has been overridden in the current scope by a non-function.",
        "D3001": "Attempting to invoke string function on Infinity or NaN",
        "D3010": "Second argument of replace function cannot be an empty string",
        "D3011": "Fourth argument of replace function must evaluate to a positive number",
        "D3012": "Attempted to replace a matched string with a non-string value",
        "D3020": "Third argument of split function must evaluate to a positive number",
        "D3030": "Unable to cast value to a number: {{value}}",
        "D3040": "Third argument of match function must evaluate to a positive number",
        "D3050": "First argument of reduce function must be a function with two arguments",
        "D3060": "The sqrt function cannot be applied to a negative number: {{value}}",
        "D3061": "The power function has resulted in a value that cannot be represented as a JSON number: base={{value}}, exponent={{exp}}",
        "D3070": "The single argument form of the sort function can only be applied to an array of strings or an array of numbers.  Use the second argument to specify a comparison function",
        "D3080": "The picture string must only contain a maximum of two sub-pictures",
        "D3081": "The sub-picture must not contain more than one instance of the 'decimal-separator' character",
        "D3082": "The sub-picture must not contain more than one instance of the 'percent' character",
        "D3083": "The sub-picture must not contain more than one instance of the 'per-mille' character",
        "D3084": "The sub-picture must not contain both a 'percent' and a 'per-mille' character",
        "D3085": "The mantissa part of a sub-picture must contain at least one character that is either an 'optional digit character' or a member of the 'decimal digit family'",
        "D3086": "The sub-picture must not contain a passive character that is preceded by an active character and that is followed by another active character",
        "D3087": "The sub-picture must not contain a 'grouping-separator' character that appears adjacent to a 'decimal-separator' character",
        "D3088": "The sub-picture must not contain a 'grouping-separator' at the end of the integer part",
        "D3089": "The sub-picture must not contain two adjacent instances of the 'grouping-separator' character",
        "D3090": "The integer part of the sub-picture must not contain a member of the 'decimal digit family' that is followed by an instance of the 'optional digit character'",
        "D3091": "The fractional part of the sub-picture must not contain an instance of the 'optional digit character' that is followed by a member of the 'decimal digit family'",
        "D3092": "A sub-picture that contains a 'percent' or 'per-mille' character must not contain a character treated as an 'exponent-separator'",
        "D3093": "The exponent part of the sub-picture must comprise only of one or more characters that are members of the 'decimal digit family'",
        "D3100": "The radix of the formatBase function must be between 2 and 36.  It was given {{value}}",
        "D3110": "The argument of the toMillis function must be an ISO 8601 formatted timestamp. Given {{value}}"
    };

    /**
     * lookup a message template from the catalog and substitute the inserts
     * @param {string} err - error code to lookup
     * @returns {string} message
     */
    function lookupMessage(err) {
        var message = 'Unknown error';
        if(typeof err.message !== 'undefined') {
            message = err.message;
        }
        var template = errorCodes[err.code];
        if(typeof template !== 'undefined') {
            // if there are any handlebars, replace them with the field references
            // triple braces - replace with value
            // double braces - replace with json stringified value
            message = template.replace(/\{\{\{([^}]+)}}}/g, function() {
                return err[arguments[1]];
            });
            message = message.replace(/\{\{([^}]+)}}/g, function() {
                return JSON.stringify(err[arguments[1]]);
            });
        }
        return message;
    }

    /**
     * JSONata
     * @param {Object} expr - JSONata expression
     * @param {boolean} options - recover: attempt to recover on parse error
     * @returns {{evaluate: evaluate, assign: assign}} Evaluated expression
     */
    function jsonata(expr, options) {
        var ast;
        var errors;
        try {
            ast = parser(expr, options && options.recover);
            errors = ast.errors;
            delete ast.errors;
        } catch(err) {
            // insert error message into structure
            err.message = lookupMessage(err);
            throw err;
        }
        var environment = createFrame(staticFrame);

        var timestamp = new Date(); // will be overridden on each call to evalute()
        environment.bind('now', defineFunction(function() {
            return timestamp.toJSON();
        }, '<:s>'));
        environment.bind('millis', defineFunction(function() {
            return timestamp.getTime();
        }, '<:n>'));

        return {
            evaluate: function (input, bindings, callback) {
                // throw if the expression compiled with syntax errors
                if(typeof errors !== 'undefined') {
                    var err = {
                        code: 'S0500',
                        position: 0
                    };
                    err.message = lookupMessage(err);
                    throw err;
                }

                if (typeof bindings !== 'undefined') {
                    var exec_env;
                    // the variable bindings have been passed in - create a frame to hold these
                    exec_env = createFrame(environment);
                    for (var v in bindings) {
                        exec_env.bind(v, bindings[v]);
                    }
                } else {
                    exec_env = environment;
                }
                // put the input document into the environment as the root object
                exec_env.bind('$', input);

                // capture the timestamp and put it in the execution environment
                // the $now() and $millis() functions will return this value - whenever it is called
                timestamp = new Date();

                var result, it;
                // if a callback function is supplied, then drive the generator in a promise chain
                if(typeof callback === 'function') {
                    exec_env.bind('__jsonata_async', true);
                    var thenHandler = function (response) {
                        result = it.next(response);
                        if (result.done) {
                            callback(null, result.value);
                        } else {
                            result.value.then(thenHandler)
                                .catch(function (err) {
                                    err.message = lookupMessage(err);
                                    callback(err, null);
                                });
                        }
                    };
                    it = evaluate(ast, input, exec_env);
                    result = it.next();
                    result.value.then(thenHandler);
                } else {
                    // no callback function - drive the generator to completion synchronously
                    try {
                        it = evaluate(ast, input, exec_env);
                        result = it.next();
                        while (!result.done) {
                            result = it.next(result.value);
                        }
                        return result.value;
                    } catch (err) {
                        // insert error message into structure
                        err.message = lookupMessage(err);
                        throw err;
                    }
                }
            },
            assign: function (name, value) {
                environment.bind(name, value);
            },
            registerFunction: function(name, implementation, signature) {
                var func = defineFunction(implementation, signature);
                environment.bind(name, func);
            },
            ast: function() {
                return ast;
            },
            errors: function() {
                return errors;
            }
        };
    }

    jsonata.parser = parser; // TODO remove this in a future release - use ast() instead

    return jsonata;

})();

// node.js only - export the jsonata and parser functions
// istanbul ignore else
if(typeof module !== 'undefined') {
    module.exports = jsonata;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],56:[function(require,module,exports){
(function (process){
'use strict';

var loglevel = require('loglevel');
var chalk = require('chalk');

var loggers = {};

module.exports = getLogger;

function getLogger() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$level = _ref.level,
      level = _ref$level === undefined ? getDefaultLevel() : _ref$level,
      _ref$prefix = _ref.prefix,
      prefix = _ref$prefix === undefined ? '' : _ref$prefix;

  if (loggers[prefix]) {
    return loggers[prefix];
  }
  var coloredPrefix = prefix ? `${chalk.dim(prefix)} ` : '';
  var levelPrefix = {
    TRACE: chalk.dim('[TRACE]'),
    DEBUG: chalk.cyan('[DEBUG]'),
    INFO: chalk.blue('[INFO]'),
    WARN: chalk.yellow('[WARN]'),
    ERROR: chalk.red('[ERROR]')
  };

  var logger = loglevel.getLogger(`${prefix}-logger`);

  // this is the plugin "api"
  var originalFactory = logger.methodFactory;
  logger.methodFactory = methodFactory;

  var originalSetLevel = logger.setLevel;
  logger.setLevel = setLevel;
  logger.setLevel(level);
  loggers[prefix] = logger;
  return logger;

  function methodFactory() {
    for (var _len = arguments.length, factoryArgs = Array(_len), _key = 0; _key < _len; _key++) {
      factoryArgs[_key] = arguments[_key];
    }

    var logLevel = factoryArgs[0];

    var rawMethod = originalFactory.apply(undefined, factoryArgs);
    return function () {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return rawMethod.apply(undefined, [`${coloredPrefix}${levelPrefix[logLevel.toUpperCase()]}:`].concat(args));
    };
  }

  function setLevel(levelToSetTo) {
    var persist = false; // uses browser localStorage
    return originalSetLevel.call(logger, levelToSetTo, persist);
  }
}

function getDefaultLevel() {
  var logLevel = process.env.LOG_LEVEL;

  if (logLevel === 'undefined' || !logLevel) {
    return 'warn';
  }
  return logLevel;
}
}).call(this,require('_process'))

},{"_process":2,"chalk":48,"loglevel":57}],57:[function(require,module,exports){
/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (typeof define === 'function' && define.amd) {
        define(definition);
    } else if (typeof module === 'object' && module.exports) {
        module.exports = definition();
    } else {
        root.log = definition();
    }
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      var storageKey = "loglevel";
      if (name) {
        storageKey += ":" + name;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    return defaultLogger;
}));

},{}],58:[function(require,module,exports){
(function (global){
var performance = global.performance || {};

var present = (function () {
  var names = ['now', 'webkitNow', 'msNow', 'mozNow', 'oNow'];
  while (names.length) {
    var name = names.shift();
    if (name in performance) {
      return performance[name].bind(performance);
    }
  }

  var dateNow = Date.now || function () { return new Date().getTime(); };
  var navigationStart = (performance.timing || {}).navigationStart || dateNow();
  return function () {
    return dateNow() - navigationStart;
  };
}());

present.performanceNow = performance.now;
present.noConflict = function () {
  performance.now = present.performanceNow;
};
present.conflict = function () {
  performance.now = present;
};
present.conflict();

module.exports = present;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],59:[function(require,module,exports){
// Export ./lib/randgen

module.exports = require("./lib/randgen");

},{"./lib/randgen":60}],60:[function(require,module,exports){
/*jslint indent: 2, plusplus: true, sloppy: true */
// Generate uniformly distributed random numbers
// Gives a random number on the interval [min, max).
// If discrete is true, the number will be an integer.
function runif(min, max, discrete) {
  if (min === undefined) {
    min = 0;
  }
  if (max === undefined) {
    max = 1;
  }
  if (discrete === undefined) {
    discrete = false;
  }
  if (discrete) {
    return Math.floor(runif(min, max, false));
  }
  return Math.random() * (max - min) + min;
}

// Generate normally-distributed random nubmers
// Algorithm adapted from:
// http://c-faq.com/lib/gaussian.html
function rnorm(mean, stdev) {
  var u1, u2, v1, v2, s;
  if (mean === undefined) {
    mean = 0.0;
  }
  if (stdev === undefined) {
    stdev = 1.0;
  }
  if (rnorm.v2 === null) {
    do {
      u1 = Math.random();
      u2 = Math.random();

      v1 = 2 * u1 - 1;
      v2 = 2 * u2 - 1;
      s = v1 * v1 + v2 * v2;
    } while (s === 0 || s >= 1);

    rnorm.v2 = v2 * Math.sqrt(-2 * Math.log(s) / s);
    return stdev * v1 * Math.sqrt(-2 * Math.log(s) / s) + mean;
  }

  v2 = rnorm.v2;
  rnorm.v2 = null;
  return stdev * v2 + mean;
}

rnorm.v2 = null;

// Generate Chi-square distributed random numbers
function rchisq(degreesOfFreedom) {
  if (degreesOfFreedom === undefined) {
    degreesOfFreedom = 1;
  }
  var i, z, sum = 0.0;
  for (i = 0; i < degreesOfFreedom; i++) {
    z = rnorm();
    sum += z * z;
  }

  return sum;
}

// Generate Poisson distributed random numbers
function rpoisson(lambda) {
  if (lambda === undefined) {
    lambda = 1;
  }
  var l = Math.exp(-lambda),
    k = 0,
    p = 1.0;
  do {
    k++;
    p *= Math.random();
  } while (p > l);

  return k - 1;
}

// Generate Cauchy distributed random numbers
function rcauchy(loc, scale) {
  if (loc === undefined) {
    loc = 0.0;
  }
  if (scale === undefined) {
    scale = 1.0;
  }
  var n2, n1 = rnorm();
  do {
    n2 = rnorm();
  } while (n2 === 0.0);

  return loc + scale * n1 / n2;
}

// Bernoulli distribution: gives 1 with probability p
function rbernoulli(p) {
  return Math.random() < p ? 1 : 0;
}

// Vectorize a random generator
function vectorize(generator) {
  return function () {
    var n, result, i, args;
    args = [].slice.call(arguments)
    n = args.shift();
    result = [];
    for (i = 0; i < n; i++) {
      result.push(generator.apply(this, args));
    }
    return result;
  };
}

// Generate a histogram from a list of numbers
function histogram(data, binCount) {
  binCount = binCount || 10;

  var bins, i, scaled,
    max = Math.max.apply(this, data),
    min = Math.min.apply(this, data);

  // edge case: max == min
  if (max === min) {
    return [data.length];
  }

  bins = [];

  // zero each bin
  for (i = 0; i < binCount; i++) {
    bins.push(0);
  }

  for (i = 0; i < data.length; i++) {
    // scale it to be between 0 and 1
    scaled = (data[i] - min) / (max - min);

    // scale it up to the histogram size
    scaled *= binCount;

    // drop it in a bin
    scaled = Math.floor(scaled);

    // edge case: the max
    if (scaled === binCount) { scaled--; }

    bins[scaled]++;
  }

  return bins;
}

/**
 * Get a random element from a list
 */
function rlist(list) {
  return list[runif(0, list.length, true)];
}

exports.runif = runif;
exports.rnorm = rnorm;
exports.rchisq = rchisq;
exports.rpoisson = rpoisson;
exports.rcauchy = rcauchy;
exports.rbernoulli = rbernoulli;
exports.rlist = rlist;

exports.rvunif = vectorize(runif);
exports.rvnorm = vectorize(rnorm);
exports.rvchisq = vectorize(rchisq);
exports.rvpoisson = vectorize(rpoisson);
exports.rvcauchy = vectorize(rcauchy);
exports.rvbernoulli = vectorize(rbernoulli);
exports.rvlist = vectorize(rlist);

exports.histogram = histogram;

},{}],61:[function(require,module,exports){
'use strict';
var ansiRegex = require('ansi-regex')();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};

},{"ansi-regex":46}],62:[function(require,module,exports){
/* jshint node: true */
"use strict";
function makeArrayFrom(obj) {
  return Array.prototype.slice.apply(obj);
}
var
  PENDING = "pending",
  RESOLVED = "resolved",
  REJECTED = "rejected";

function SynchronousPromise(handler) {
  this.status = PENDING;
  this._continuations = [];
  this._parent = null;
  this._paused = false;
  if (handler) {
    handler.call(
      this,
      this._continueWith.bind(this),
      this._failWith.bind(this)
    );
  }
}

function looksLikeAPromise(obj) {
  return obj && typeof (obj.then) === "function";
}

SynchronousPromise.prototype = {
  then: function (nextFn, catchFn) {
    var next = SynchronousPromise.unresolved()._setParent(this);
    if (this._isRejected()) {
      if (this._paused) {
        this._continuations.push({
          promise: next,
          nextFn: nextFn,
          catchFn: catchFn
        });
        return next;
      }
      if (catchFn) {
        try {
          var catchResult = catchFn(this._error);
          if (looksLikeAPromise(catchResult)) {
            this._chainPromiseData(catchResult, next);
            return next;
          } else {
            return SynchronousPromise.resolve(catchResult)._setParent(this);
          }
        } catch (e) {
          return SynchronousPromise.reject(e)._setParent(this);
        }
      }
      return SynchronousPromise.reject(this._error)._setParent(this);
    }
    this._continuations.push({
      promise: next,
      nextFn: nextFn,
      catchFn: catchFn
    });
    this._runResolutions();
    return next;
  },
  catch: function (handler) {
    if (this._isResolved()) {
      return SynchronousPromise.resolve(this._data)._setParent(this);
    }
    var next = SynchronousPromise.unresolved()._setParent(this);
    this._continuations.push({
      promise: next,
      catchFn: handler
    });
    this._runRejections();
    return next;
  },
  pause: function () {
    this._paused = true;
    return this;
  },
  resume: function () {
    var firstPaused = this._findFirstPaused();
    if (firstPaused) {
      firstPaused._paused = false;
      firstPaused._runResolutions();
      firstPaused._runRejections();
    }
    return this;
  },
  _findAncestry: function () {
    return this._continuations.reduce(function (acc, cur) {
      if (cur.promise) {
        var node = {
          promise: cur.promise,
          children: cur.promise._findAncestry()
        };
        acc.push(node);
      }
      return acc;
    }, []);
  },
  _setParent: function (parent) {
    if (this._parent) {
      throw new Error("parent already set");
    }
    this._parent = parent;
    return this;
  },
  _continueWith: function (data) {
    var firstPending = this._findFirstPending();
    if (firstPending) {
      firstPending._data = data;
      firstPending._setResolved();
    }
  },
  _findFirstPending: function () {
    return this._findFirstAncestor(function (test) {
      return test._isPending && test._isPending();
    });
  },
  _findFirstPaused: function () {
    return this._findFirstAncestor(function (test) {
      return test._paused;
    });
  },
  _findFirstAncestor: function (matching) {
    var test = this;
    var result;
    while (test) {
      if (matching(test)) {
        result = test;
      }
      test = test._parent;
    }
    return result;
  },
  _failWith: function (error) {
    var firstRejected = this._findFirstPending();
    if (firstRejected) {
      firstRejected._error = error;
      firstRejected._setRejected();
    }
  },
  _takeContinuations: function () {
    return this._continuations.splice(0, this._continuations.length);
  },
  _runRejections: function () {
    if (this._paused || !this._isRejected()) {
      return;
    }
    var
      error = this._error,
      continuations = this._takeContinuations(),
      self = this;
    continuations.forEach(function (cont) {
      if (cont.catchFn) {
        var catchResult = cont.catchFn(error);
        self._handleUserFunctionResult(catchResult, cont.promise);
      } else {
        cont.promise.reject(error);
      }
    });
  },
  _runResolutions: function () {
    if (this._paused || !this._isResolved()) {
      return;
    }
    var continuations = this._takeContinuations();
    if (looksLikeAPromise(this._data)) {
      return this._handleWhenResolvedDataIsPromise(this._data);
    }
    var data = this._data;
    var self = this;
    continuations.forEach(function (cont) {
      if (cont.nextFn) {
        try {
          var result = cont.nextFn(data);
          self._handleUserFunctionResult(result, cont.promise);
        } catch (e) {
          self._handleResolutionError(e, cont);
        }
      } else if (cont.promise) {
        cont.promise.resolve(data);
      }
    });
  },
  _handleResolutionError: function (e, continuation) {
    this._setRejected();
    if (continuation.catchFn) {
      try {
        continuation.catchFn(e);
        return;
      } catch (e2) {
        e = e2;
      }
    }
    if (continuation.promise) {
      continuation.promise.reject(e);
    }
  },
  _handleWhenResolvedDataIsPromise: function (data) {
    var self = this;
    return data.then(function (result) {
      self._data = result;
      self._runResolutions();
    }).catch(function (error) {
      self._error = error;
      self._setRejected();
      self._runRejections();
    });
  },
  _handleUserFunctionResult: function (data, nextSynchronousPromise) {
    if (looksLikeAPromise(data)) {
      this._chainPromiseData(data, nextSynchronousPromise);
    } else {
      nextSynchronousPromise.resolve(data);
    }
  },
  _chainPromiseData: function (promiseData, nextSynchronousPromise) {
    promiseData.then(function (newData) {
      nextSynchronousPromise.resolve(newData);
    }).catch(function (newError) {
      nextSynchronousPromise.reject(newError);
    });
  },
  _setResolved: function () {
    this.status = RESOLVED;
    if (!this._paused) {
      this._runResolutions();
    }
  },
  _setRejected: function () {
    this.status = REJECTED;
    if (!this._paused) {
      this._runRejections();
    }
  },
  _isPending: function () {
    return this.status === PENDING;
  },
  _isResolved: function () {
    return this.status === RESOLVED;
  },
  _isRejected: function () {
    return this.status === REJECTED;
  }
};

SynchronousPromise.resolve = function (result) {
  return new SynchronousPromise(function (resolve, reject) {
    if (looksLikeAPromise(result)) {
      result.then(function (newResult) {
        resolve(newResult);
      }).catch(function (error) {
        reject(error);
      });
    } else {
      resolve(result);
    }
  });
};

SynchronousPromise.reject = function (result) {
  return new SynchronousPromise(function (resolve, reject) {
    reject(result);
  });
};

SynchronousPromise.unresolved = function () {
  return new SynchronousPromise(function (resolve, reject) {
    this.resolve = resolve;
    this.reject = reject;
  });
};

SynchronousPromise.all = function () {
  var args = makeArrayFrom(arguments);
  if (Array.isArray(args[0])) {
    args = args[0];
  }
  if (!args.length) {
    return SynchronousPromise.resolve([]);
  }
  return new SynchronousPromise(function (resolve, reject) {
    var
      allData = [],
      numResolved = 0,
      doResolve = function () {
        if (numResolved === args.length) {
          resolve(allData);
        }
      },
      rejected = false,
      doReject = function (err) {
        if (rejected) {
          return;
        }
        rejected = true;
        reject(err);
      };
    args.forEach(function (arg, idx) {
      SynchronousPromise.resolve(arg).then(function (thisResult) {
        allData[idx] = thisResult;
        numResolved += 1;
        doResolve();
      }).catch(function (err) {
        doReject(err);
      });
    });
  });
};

/* jshint ignore:start */
if (Promise === SynchronousPromise) {
  throw new Error("Please use SynchronousPromise.installGlobally() to install globally");
}
var RealPromise = Promise;
SynchronousPromise.installGlobally = function(__awaiter) {
  if (Promise === SynchronousPromise) {
    return __awaiter;
  } 
  var result = patchAwaiterIfRequired(__awaiter);
  Promise = SynchronousPromise;
  return result;
};

SynchronousPromise.uninstallGlobally = function() {
  if (Promise === SynchronousPromise) {
    Promise = RealPromise;
  }
};

function patchAwaiterIfRequired(__awaiter) {
  if (typeof(__awaiter) === "undefined" || __awaiter.__patched) {
    return __awaiter;
  }
  var originalAwaiter = __awaiter;
  __awaiter = function() {
    var Promise = RealPromise;
    originalAwaiter.apply(this, makeArrayFrom(arguments));
  };
  __awaiter.__patched = true;
  return __awaiter;
}
/* jshint ignore:end */

module.exports = {
  SynchronousPromise: SynchronousPromise
};
},{}],63:[function(require,module,exports){
"use strict";

// game pieces
var prisonerDilemma = require("./iterated-prisoner-dilemma").createGenerator;
var roundRobin = require("./round-robin");
var { Loop } = require("../lib/engine").Playables;

// helper functions
var { gameWrapper } = require("../lib/helperFunctions")("stock-games")

// Population interfaces
var { Population } = require("../lib/population");
var { generatePopulation } = require("../lib/helperfunctions")("tournament");

var AxelrodTournament = gameWrapper(function(players, parameters = {}) {
	var { generatePlayers = true, repeats = 5, gameLength = 200 } = parameters;

	// Either create an entire population
	if (generatePlayers) {
		// Get two sets of players. The second is so players can play themselves
		players = generatePopulation();
		var copies = generatePopulation();
		parameters.copies = copies;
	}

	// or use the supplied players
	else if (players) {
		// do nothing
	} else {
		// or use the players already present
		players = Population().onlyAlive().onlyAvailable();
	}

	// assign parameters and generate the game
	parameters.initializePlayers = players;
	var iteration = roundRobin(players, prisonerDilemma(gameLength), parameters);

	return Loop(iteration, repeats, { id: "Axelrod-Tournament" });
});



module.exports = AxelrodTournament;

},{"../lib/engine":5,"../lib/helperFunctions":7,"../lib/helperfunctions":16,"../lib/population":42,"./iterated-prisoner-dilemma":66,"./round-robin":71}],64:[function(require,module,exports){
"use strict";

// nashJS engine
var {Population} = require('../lib/engine');
var {Lambda, Simultaneous, Sequence, Loop} = require('../lib/engine').Playables;

// Helper functions
var {isFunction} = require("../lib/helperfunctions")("general");


//Cultural evolution
//
// TODO: add instructions here
function CulturalEvolution(gameGenerator, numLoops=1, {id = "CulturalEvolution", gameProbability=.25, pairProbability=.25, generatePopulation=null, loop=true}={}){
	
	if (loop && isNaN(numLoops)) throw new Error("CulturalEvolution argument 'numLoops must be a number");
	if (!isFunction(gameGenerator)) throw new Error("CulturalEvolution argument 'gameGenerator' must be a function");
	if (isNaN(gameProbability) || gameProbability < 0 || gameProbability > 1) throw new Error("CulturalEvolution argument 'gameProbability' must be between 0 and 1");
	if (isNaN(pairProbability) || pairProbability < 0 || pairProbability > 1) throw new Error("CulturalEvolution argument 'pairProbability' must be between 0 and 1");
	
	// Generate population if user wants us to.
	if (isFunction(generatePopulation)) generatePopulation();
	
	//Reset the scores each round.
	var ResetScores = Lambda(function(){
		Population().onlyAlive().resetScores();
	});
	
	// Calculate number of matches
	var n = Math.floor(Population().onlyAlive().length * gameProbability);
	
	// Create matches.
	var matches = [...Array(n)]
	for (i=0; i<n; i++){
		matches[i] = gameGenerator();
		if (!matches[i].play) throw new Error("CulturalEvolution argument 'gameGenerator' must return a Playable");
	}
	
	//Run all matches simultaneously
	var Round = Simultaneous(matches);
	
	//Calculate number of pairings
	var n = Math.floor(Population().onlyAlive().length * pairProbability)
	
	//Create pairings
	var pairings = [...Array(n)];
	for (i=0; i<n; i++){
		
		pairings[i] =Lambda(function(){
			
			//Find some available players
			var pool = Population().onlyAlive().onlyAvailable();
			var p1 = pool[Math.floor(Math.random()*pool.length)];
			var p2 = pool[Math.floor(Math.random()*pool.length)];
	
			//Mark them busy
			p1.busy();
			p2.busy();

			// Assign strategy of player with higher score
			if (p1.score() > p2.score()) p2.assign(p1.strategy());
			else if (p1.score() == p2.score()) null;
			else p1.assign(p2.strategy());
	
			//Return value of player ids, so the log makes some sense.
			return [p1.id(),p2.id()];
		});
	}
		
	// Run pairings simultaneously
	var Pairing = Simultaneous(pairings);
		
	// After pairings, mark all players as available.
	var ReleasePlayers = Lambda(function(){
		Population().onlyAlive().release();
	});
	
	// Define the game.
	Round(ResetScores);
	Pairing(Round);
	ReleasePlayers(Pairing);
	var Iteration = Sequence(ResetScores, ReleasePlayers);
	
	// User can set loop parameter to false, to avoid wrapping this in a loop.
	if (loop) 
		var CE = Loop(Iteration, numLoops, {playableParameters:{initializePlayers:true}});
	else 
		var CE = Iteration;
	
	return CE;
}


module.exports = CulturalEvolution;
},{"../lib/engine":5,"../lib/helperfunctions":16}],65:[function(require,module,exports){
var StockGames = {
	//Game skeletons
	"Two-Player Normal": require("./simple-normal").TwoPlayerNormal,
	"Normal": require("./simple-normal").Normal,
	"Simple Zero-Sum": require("./simple-zero-sum"),

	// Classic games
	"Matching Pennies": require("./matching-pennies"),
	"Prisoner's Dilemma": require("./prisoner-dilemma"),
	"Rock-Paper-Scissors": require("./rock-paper-scissors"),

	// Iterated games
	"Iterated": require("./iterated"),
	"Iterated Prisoner's Dilemma": require("./iterated-prisoner-dilemma"),

	// Evolutionary games
	"Cultural Evolution": require("./cultural-evolution"),

	//Tournaments
	"Round Robin": require("./round-robin"),
	"Axelrod Tournament": require("./axelrod-tournament")
};

module.exports = StockGames;

},{"./axelrod-tournament":63,"./cultural-evolution":64,"./iterated":67,"./iterated-prisoner-dilemma":66,"./matching-pennies":68,"./prisoner-dilemma":69,"./rock-paper-scissors":70,"./round-robin":71,"./simple-normal":72,"./simple-zero-sum":73}],66:[function(require,module,exports){
"use strict";

// Base game
var prisonerDilemma = require("./prisoner-dilemma").createGenerator();

// game engine
var { Loop } = require("../lib/engine").Playables;

// Game utility
var Iterated = require("./iterated")

// helper functions
var { gameWrapper } = require("../lib/helperFunctions")("stock-games")

var IteratedPrisonerDilemma = gameWrapper(function(players, numberIterations = 50, parameters = {}) {
	return Iterated(players, prisonerDilemma, "Prisoner-Dilemma", numberIterations, parameters)
});
// TODO validate arguments

module.exports = IteratedPrisonerDilemma

},{"../lib/engine":5,"../lib/helperFunctions":7,"./iterated":67,"./prisoner-dilemma":69}],67:[function(require,module,exports){
"use strict";

// game engine
var { Loop } = require("../lib/engine").Playables;

// helper functions
var { gameWrapper } = require("../lib/helperFunctions")("stock-games")


var Iterated = gameWrapper(function(players, gameGenerator, gameName, numberIterations = 50, parameters = {}) {

	var { parameters: gameParameters = {} } = parameters

	gameParameters.id = gameParameters.id || gameName
	parameters.id = parameters.id || "Iterated-" + gameName;

	return Loop(gameGenerator(players, gameParameters), numberIterations, parameters);
})

// TODO validate arguments

module.exports = Iterated;

},{"../lib/engine":5,"../lib/helperFunctions":7}],68:[function(require,module,exports){
"use strict";

// base game
var SimpleZeroSum = require("./simple-zero-sum");

// helper functions
var { gameWrapper } = require("../lib/helperFunctions")("stock-games")

// Play-time logic
var { Expression } = require("../lib/logic");


var MatchingPennies = gameWrapper(function(players, payoff = 1, parameters = {}) {
	parameters.id = parameters.id || "Matching-Pennies";

	var win = payoff;
	var lose = Expression(function() {
		return -payoff;
	});

	var choices = [
		["Heads", "Tails"],
		["Heads", "Tails"]
	];

	var payoffs = [
		[win, lose],
		[lose, win]
	];

	return SimpleZeroSum(players, choices, payoffs, parameters);
});

// Matching Pennies
module.exports = MatchingPennies;

},{"../lib/helperFunctions":7,"../lib/logic":27,"./simple-zero-sum":73}],69:[function(require,module,exports){
"use strict";

// base game
var TwoPlayerNormal = require("./simple-normal").TwoPlayerNormal;

// helper functions
var { gameWrapper } = require("../lib/helperFunctions")("stock-games")

// play-time logic
var { Variable, Expression } = require("../lib/logic");

var prisonerDilemma = gameWrapper(function(players, {
	id = "Prisoner-Dilemma",
	payoffScale = Variable(1),
	payoffSpread = Variable(4)
} = {}) {
	//TODO: fix the case of negative scale.

	var lowerMiddle = Expression(function() {
		return payoffScale * (1 + (payoffSpread - 1) * 1 / 3);
	});
	var upperMiddle = Expression(function() {
		return payoffScale * (1 + (payoffSpread - 1) * 2 / 3);
	});
	var upper = Expression(function() {
		return payoffScale * payoffSpread;
	});

	// Pass along parameters, be sure to include id.
	var parameters = arguments[1] || {};
	parameters.id = parameters.id || id;

	var choices = [
		["Cooperate", "Defect"],
		["Cooperate", "Defect"]
	];
	var payoffs = [
		[
			[upperMiddle, upperMiddle],
			[payoffScale, upper]
		],
		[
			[upper, payoffScale],
			[lowerMiddle, lowerMiddle]
		]
	];

	return TwoPlayerNormal(players, choices, payoffs, parameters);
});


module.exports = prisonerDilemma;

},{"../lib/helperFunctions":7,"../lib/logic":27,"./simple-normal":72}],70:[function(require,module,exports){
"use strict";

// base game
var SimpleZeroSum = require("./simple-zero-sum");

// helper functions
var { gameWrapper } = require("../lib/helperFunctions")("stock-games")

// Play-time logic
var { Expression } = require("../lib/logic");

// Rock-Paper-Scissors
var RockPaperScissors = gameWrapper(function(players, payoff = 1, parameters = {}) {
	parameters.id = parameters.id || "Rock-Paper-Scissors";

	var win = payoff;
	var lose = Expression(function() {
		return -payoff;
	});

	var choices = [
		["Rock", "Paper", "Scissors"],
		["Rock", "Paper", "Scissors"]
	];
	var payoffs = [
		[0, lose, win],
		[win, 0, lose],
		[lose, win, 0]
	];

	return SimpleZeroSum(players, choices, payoffs, parameters);
});

module.exports = RockPaperScissors

},{"../lib/helperFunctions":7,"../lib/logic":27,"./simple-zero-sum":73}],71:[function(require,module,exports){
"use strict";

// helper function
var { shuffle } = require("../lib/helperfunctions")("general");

// nashJS engine component
var { Sequence, Simultaneous } = require("../lib/engine").Playables;

// helper functions
var { gameWrapper } = require("../lib/helperFunctions")("stock-games")

//for information mechanics
var { Information } = require("../lib/information");
var { History } = require("../lib/history");
var { PlayerList } = require("../lib/population");

// gameGenerator should be a function whose first argument is an array of players
var RoundRobin = gameWrapper(function(players, gameGenerator, parameters = {}) {
	parameters.id = parameters.id || "Round-Robin";
	parameters.initializePlayers = parameters.initializePlayers && true;

	// Create array of each combination of players
	var matches = [];

	players.forEach(function(player1, index1) {
		for (var index2 = 0; index2 < index1; index2++) {
			matches.push([players[index2], player1]);
		}

		// optional parameter 'copies.' Pass an extra copy of each player, to play themselves
		if (parameters.copies) matches.push([parameters.copies[index1], player1]);
	});

	//randomize the order
	shuffle(matches);

	// Track scores
	var scoresRecord = [];

	//
	var addRound = function(players, parameters = {}) {
		// information mechanics and other parameters
		var population = new PlayerList(players).generator
		parameters.compartmentalize = { population }
		parameters.initializePlayers = population;

		// generate round
		var round = gameGenerator(players, parameters);

		// track the scores
		var recordScores = Lambda(function() {
			var score = {}
			for (let [strategy, scores] of Object.entries(population().scoresByStrategy())) {
				if (Array.isArray(scores)) {
					if (scores.length == 1) scores = scores[0]
					score[strategy] = scores;
				}
			}
			scoresRecord.push(score);
			console.log("recording scores")
			//return score for history
			return score;
		}, { id: "Record-Scores" });

		//Chain together
		recordScores(round);

		// return both
		return [round, recordScores
			// ,Sequence(round, recordScores) // Uncomment for Simultaneous implementation
		];
	};



	// Sequential implementation
	// load the first match manually
	var [firstRound, firstRecord] = addRound(
		matches.shift(),
		parameters.parameters
	);

	//then load subsequent matches
	var record = firstRecord;
	var lastRecord, lastRound;

	matches.forEach(function(match) {
		[lastRound, lastRecord] = addRound(match, parameters.parameters);

		lastRound(record);
		record = lastRecord;
	});


	return Sequence(firstRound, lastRecord, parameters);

	/* // Simultaneous implementation
	var rounds = [];
	matches.forEach(function(match) {
	  rounds.push(addRound(match, parameters.gameParameters)[2]);
	});

	return Simultaneous(rounds, parameters); */
});

module.exports = RoundRobin;

},{"../lib/engine":5,"../lib/helperFunctions":7,"../lib/helperfunctions":16,"../lib/history":24,"../lib/information":25,"../lib/population":42}],72:[function(require,module,exports){
"use strict";

//Helper functions
var { isFunction } = require("../lib/helperFunctions")("general")
var { gameWrapper } = require("../lib/helperFunctions")("stock-games")

//Game engine
var { Choice, Turn } = require("../lib/engine").Playables;


var Normal = gameWrapper(function(players, choiceLists, payoffs = null, parameters = {}) {

		//propogate the information filter
		parameters.parameters ? parameters.parameters.informationFilter = parameters.informationFilter :
			parameters.parameters = { informationFilter: parameters.informationFilter }

		// construct the choices
		var choices = choiceLists.map(function(list, index) {
			return Choice(players[index], list, parameters.parameters);
		});

		var game = Turn(choices, parameters);
		console.log(payoffs)
		if (payoffs) game.setAllPayoffs(payoffs);

		return game;
	} // 										TODO: validate all arguments
);


var TwoPlayerNormal = gameWrapper(function(players, choices, payoffs = null, parameters = {}) {

	// Information mechanics.. There are only two players, so we can have a 'me' and 'opponent' entry.
	// If user supplied an information filter, wrap that filter in ours.
	var { informationFilter } = parameters;
	if (!isFunction(informationFilter)) informationFilter = null;

	// Wrap the user's filter
	var wrappedFilter = function(information) {
		// Figure out who I am and who the opponent is
		var me = information.me.id
		var players = [information.turn.choices[0].choice.player, information.turn.choices[1].choice.player]
		var opponent = players.splice(players.indexOf(me), 1) && players[0];

		// add entry for opponent
		var opponentDetail = information.population.filter(function(player) {
			return (player.id == opponent)
		})[0];
		information.opponent = opponentDetail;

		// run the user's information filter
		if (informationFilter) information = informationFilter(information);

		return information;
	}

	// Pass the information filter
	parameters.informationFilter = wrappedFilter

	return Normal(players, choices, payoffs, parameters)
}); //				 																												TODO: may want to validate arguments here too



module.exports = { TwoPlayerNormal, Normal };

},{"../lib/engine":5,"../lib/helperFunctions":7}],73:[function(require,module,exports){
"use strict";

// base game
var TwoPlayerNormal = require("./simple-normal").TwoPlayerNormal;

// Game state controller
var { registry } = require("../lib/state");
var { gameWrapper } = require("../lib/helperFunctions")("stock-games");

// Play-time logic
var { Variable, Expression } = require("../lib/logic");

/* beautify preserve:start */
var SimpleZeroSum = gameWrapper(function(players, choices, payoffs = [[0, 0],	[0, 0]], parameters={}) {
/* beautify preserve:end */

	var game = TwoPlayerNormal(players, choices, null, parameters)

	var e;

	choices[0].forEach(function(choice0, index0) {
		choices[1].forEach(function(choice1, index1) {

			// Set expression
			e = Expression(function() {
				//Return the negative payoff, or zero
				return (0 - registry.turns[game.id()].payoffsImplicit[choice0][choice1][0] || 0);
			});

			//Set payoffs
			game[choice0][choice1]([payoffs[index0][index1], e]);
		});
	});

	return game;
}); //					TODO: validate arguments



module.exports = SimpleZeroSum;

},{"../lib/helperFunctions":7,"../lib/logic":27,"../lib/state":43,"./simple-normal":72}]},{},[3])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi8uLi8uLi8uLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzIiwiLi4vLi4vLi4vLi4vLi4vQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIlByaXNvbmVyJ3MgRGlsZW1tYS5qcyIsImluZGV4LmpzIiwibGliL2VuZ2luZS5qcyIsImxpYi9oZWxwZXJGdW5jdGlvbnMvZ2VuZXJhbC5qcyIsImxpYi9oZWxwZXJGdW5jdGlvbnMvaW5kZXguanMiLCJsaWIvaGVscGVyRnVuY3Rpb25zL2xvZ2ljLmpzIiwibGliL2hlbHBlckZ1bmN0aW9ucy9wbGF5YWJsZS5qcyIsImxpYi9oZWxwZXJGdW5jdGlvbnMvcGxheWVyLmpzIiwibGliL2hlbHBlckZ1bmN0aW9ucy9zdGF0ZS5qcyIsImxpYi9oZWxwZXJGdW5jdGlvbnMvc3RvY2stZ2FtZXMuanMiLCJsaWIvaGVscGVyRnVuY3Rpb25zL3RvdXJuYW1lbnQuanMiLCJsaWIvaGVscGVyRnVuY3Rpb25zL3R1cm4uanMiLCJsaWIvaGlzdG9yeS5qcyIsImxpYi9pbmZvcm1hdGlvbi5qcyIsImxpYi9sb2dnZXIuanMiLCJsaWIvbG9naWMuanMiLCJsaWIvcGxheWFibGVzL2Nob2ljZS5qcyIsImxpYi9wbGF5YWJsZXMvaGFsdC1pZi5qcyIsImxpYi9wbGF5YWJsZXMvaW5kZXguanMiLCJsaWIvcGxheWFibGVzL2xhbWJkYS5qcyIsImxpYi9wbGF5YWJsZXMvbG9vcC5qcyIsImxpYi9wbGF5YWJsZXMvcGxheWFibGUuanMiLCJsaWIvcGxheWFibGVzL3BvcHVsYXRpb24tZHluYW1pY3MuanMiLCJsaWIvcGxheWFibGVzL3JhbmRvbS1wbGF5ZXItY2hvaWNlLmpzIiwibGliL3BsYXlhYmxlcy9zZXF1ZW5jZS5qcyIsImxpYi9wbGF5YWJsZXMvc2ltdWx0YW5lb3VzLmpzIiwibGliL3BsYXlhYmxlcy9zdG9jaGFzdGljLWhhbHQuanMiLCJsaWIvcGxheWFibGVzL3N0b2NoYXN0aWNMb29wLmpzIiwibGliL3BsYXlhYmxlcy90dXJuLmpzIiwibGliL3BsYXllci5qcyIsImxpYi9wb3B1bGF0aW9uLmpzIiwibGliL3N0YXRlLmpzIiwibGliL3N0cmF0ZWd5LWxvYWRlci5qcyIsImxpYi9zdHJhdGVneS5qcyIsIm5vZGVfbW9kdWxlcy9hbnNpLXJlZ2V4L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Fuc2ktc3R5bGVzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NoYWxrL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NoYWxrL25vZGVfbW9kdWxlcy9zdXBwb3J0cy1jb2xvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lc2NhcGUtc3RyaW5nLXJlZ2V4cC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lc3ByaW1hL2Rpc3QvZXNwcmltYS5qcyIsIm5vZGVfbW9kdWxlcy9leHByZXNzaW9uLXNhbmRib3gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXhwcmVzc2lvbi1zYW5kYm94L2xpYi9tYWtlLXNhZmUuanMiLCJub2RlX21vZHVsZXMvaGFzLWFuc2kvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNvbmF0YS9qc29uYXRhLmpzIiwibm9kZV9tb2R1bGVzL2xvZ2xldmVsLWNvbG9yZWQtbGV2ZWwtcHJlZml4L2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzIiwibm9kZV9tb2R1bGVzL3ByZXNlbnQvbGliL3ByZXNlbnQtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yYW5kZ2VuL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JhbmRnZW4vbGliL3JhbmRnZW4uanMiLCJub2RlX21vZHVsZXMvc3RyaXAtYW5zaS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zeW5jaHJvbm91cy1wcm9taXNlL2luZGV4LmpzIiwic3RvY2stZ2FtZXMvYXhlbHJvZC10b3VybmFtZW50LmpzIiwic3RvY2stZ2FtZXMvY3VsdHVyYWwtZXZvbHV0aW9uLmpzIiwic3RvY2stZ2FtZXMvaW5kZXguanMiLCJzdG9jay1nYW1lcy9pdGVyYXRlZC1wcmlzb25lci1kaWxlbW1hLmpzIiwic3RvY2stZ2FtZXMvaXRlcmF0ZWQuanMiLCJzdG9jay1nYW1lcy9tYXRjaGluZy1wZW5uaWVzLmpzIiwic3RvY2stZ2FtZXMvcHJpc29uZXItZGlsZW1tYS5qcyIsInN0b2NrLWdhbWVzL3JvY2stcGFwZXItc2Npc3NvcnMuanMiLCJzdG9jay1nYW1lcy9yb3VuZC1yb2Jpbi5qcyIsInN0b2NrLWdhbWVzL3NpbXBsZS1ub3JtYWwuanMiLCJzdG9jay1nYW1lcy9zaW1wbGUtemVyby1zdW0uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2lOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2wySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfXJldHVybiBlfSkoKSIsIiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIoe1xyXG5cdFBsYXllcixcclxuXHRfUGxheWVyLFxyXG5cdGdhbWVQb3B1bGF0aW9uLFxyXG5cdFBvcHVsYXRpb24sXHJcblx0UGxheWVyTGlzdCxcclxuXHRyZWdpc3RlclN0cmF0ZWd5LFxyXG5cdFN0cmF0ZWdpZXMsXHJcblx0c3RyYXRlZ3lMb2FkZXIsXHJcblx0X2V4cG9zZSxcclxuXHRyZWdpc3RyeSxcclxuXHRWYXJpYWJsZSxcclxuXHRFeHByZXNzaW9uLFxyXG5cdGdhbWVIaXN0b3J5LFxyXG5cdGV4Y2x1ZGVkUGxheWVycyxcclxuXHRzdGFydFJFUEwsXHJcblx0bmhpc3RvcnksXHJcblx0SW5mb3JtYXRpb24sXHJcblx0UGVyZmVjdEluZm9ybWF0aW9uXHJcbn0gPSByZXF1aXJlKFwiLi9pbmRleFwiKSk7XHJcbih7XHJcblx0Q2hvaWNlLFxyXG5cdFR1cm4sXHJcblx0U2VxdWVuY2UsXHJcblx0TG9vcCxcclxuXHRTdG9jaGFzdGljTG9vcCxcclxuXHRIYWx0SWYsXHJcblx0U3RvY2hhc3RpY0hhbHQsXHJcblx0TGFtYmRhLFxyXG5cdFJhbmRvbVBsYXllckNob2ljZSxcclxuXHRQb3B1bGF0aW9uRHluYW1pY3MsXHJcblx0U2ltdWx0YW5lb3VzXHJcbn0gPSByZXF1aXJlKFwiLi9pbmRleFwiKS5QbGF5YWJsZXMpO1xyXG5TdG9ja0dhbWVzID0gcmVxdWlyZShcIi4vaW5kZXhcIikuU3RvY2tHYW1lcztcclxuXHJcbnJyID0gU3RvY2tHYW1lc1tcIlJvdW5kIFJvYmluXCJdO1xyXG53cmFwID0gcmVxdWlyZShcIi4vbGliL2hlbHBlcmZ1bmN0aW9uc1wiKShcInN0b2NrLWdhbWVzXCIpXHJcblxyXG5mdW5jdGlvbiBjaG9vc2VGaXJzdE9wdGlvbigpIHtcclxuXHR0aGlzLmNob29zZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIGluZm9ybWF0aW9uKSB7XHJcblxyXG5cdFx0cmV0dXJuIG9wdGlvbnNbMF07XHJcblx0fTtcclxufVxyXG5yZWdpc3RlclN0cmF0ZWd5KGNob29zZUZpcnN0T3B0aW9uLCBcImNob29zZUZpcnN0XCIpO1xyXG5cclxuZnVuY3Rpb24gY2hvb3NlU2Vjb25kT3B0aW9uKCkge1xyXG5cdHRoaXMuY2hvb3NlID0gZnVuY3Rpb24ob3B0aW9ucywgaW5mb3JtYXRpb24pIHtcclxuXHRcdC8vY29uc29sZS5sb2coXCJzZWNvbmQgY2hvaWNlXCIpO1xyXG5cdFx0cmV0dXJuIG9wdGlvbnNbMV07XHJcblx0fTtcclxufVxyXG5yZWdpc3RlclN0cmF0ZWd5KGNob29zZVNlY29uZE9wdGlvbiwgXCJjaG9vc2VTZWNvbmRcIik7XHJcblxyXG5mdW5jdGlvbiByYW5kb21pemUoKSB7XHJcblx0dGhpcy5jaG9vc2UgPSBmdW5jdGlvbihvcHRpb25zLCBpbmZvcm1hdGlvbikge1xyXG5cdFx0dmFyIG51bSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG9wdGlvbnMubGVuZ3RoKTtcclxuXHRcdHJldHVybiBvcHRpb25zW251bV07XHJcblx0fTtcclxufVxyXG5yZWdpc3RlclN0cmF0ZWd5KHJhbmRvbWl6ZSwgXCJyYW5kb21pemVcIik7XHJcblxyXG5wMSA9IFBsYXllcih7IGFzc2lnbjogXCJjaG9vc2VGaXJzdFwiIH0pO1xyXG5cclxucDIgPSBQbGF5ZXIoKTtcclxucDIuYXNzaWduKFwicmFuZG9taXplXCIpO1xyXG5wMyA9IFBsYXllcigpO1xyXG5wMy5hc3NpZ24oXCJjaG9vc2VTZWNvbmRcIik7XHJcbnA0ID0gUGxheWVyKHsgYXNzaWduOiBcInJhbmRvbWl6ZVwiIH0pO1xyXG5cclxuYzEgPSBDaG9pY2UocDEsIFtcImNvb3BlcmF0ZVwiLCBcImRlZmVjdFwiXSk7XHJcbi8vYzFbJ2xlZnQnXSg1KSA7XHJcbi8vYzFbJ3JpZ2h0J10oMik7XHJcbmMyID0gQ2hvaWNlKHAyLCBbXCJDb29wZXJhdGVcIiwgXCJEZWZlY3RcIl0pO1xyXG4vL2MyWyd1cCddKDEpO1xyXG4vL2MyWydkb3duJ10oNyk7XHJcblxyXG50MiA9IFR1cm4oW2MxLCBjMl0pO1xyXG50MyA9IFR1cm4oW2MxLCBjMl0pO1xyXG50NCA9IFR1cm4oW2MxLCBjMl0pO1xyXG50NSA9IFR1cm4oW2MxLCBjMl0pO1xyXG5zMSA9IFNpbXVsdGFuZW91cyhbdDIsIHQzLCB0NCwgdDVdKVxyXG5cclxuYzMgPSBSYW5kb21QbGF5ZXJDaG9pY2UoW1wiY29vcGVyYXRlXCIsIFwiZGVmZWN0XCJdKTtcclxuYzQgPSBSYW5kb21QbGF5ZXJDaG9pY2UoW1wiQ29vcGVyYXRlXCIsIFwiRGVmZWN0XCJdKTtcclxuXHJcbnQxID0gVHVybihbYzMsIGM0XSk7XHJcblxyXG52MSA9IG5ldyBWYXJpYWJsZSgzKTtcclxuXHJcbnQxLmRlZmVjdC5EZWZlY3QoWzIsIDJdKTtcclxudDEuZGVmZWN0LkNvb3BlcmF0ZShbNCwgMV0pO1xyXG50MS5jb29wZXJhdGUuRGVmZWN0KFsxLCA0XSk7XHJcbnQxLmNvb3BlcmF0ZS5Db29wZXJhdGUoW3YxLCB2MV0pO1xyXG5cclxuTDEgPSBMYW1iZGEoZnVuY3Rpb24oKSB7XHJcblx0djEuc2V0KHYxICsgMSk7XHJcbn0pO1xyXG5cclxucGQxID0gUG9wdWxhdGlvbkR5bmFtaWNzKDEuNSwgMSk7XHJcblxyXG5oMiA9IEhhbHRJZihmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gUG9wdWxhdGlvbigpLm9ubHlBbGl2ZSgpLmxlbmd0aCA9PSAwO1xyXG59KTtcclxuXHJcbkwxKHQxKTtcclxucGQxKEwxKTtcclxuaDIocGQxKTtcclxuXHJcbnMxID0gU2VxdWVuY2UodDEsIGgyKTtcclxuXHJcbmwxID0gTG9vcChzMSwgMTAsIHsgbG9nQ29udGludWU6IHRydWUgfSk7XHJcblxyXG4vL2NvbnNvbGUubG9nKF9leHBvc2UodDEpLm5leHQpXHJcbi8vY29uc29sZS5sb2coX2V4cG9zZSh0MSkubmV4dC5jb29wZXJhdGUuQ29vcGVyYXRlKVxyXG5cclxuaDIgPSBIYWx0SWYoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIFBvcHVsYXRpb24oKS5vbmx5QWxpdmUoKS5sZW5ndGggPT0gMDtcclxufSk7XHJcblxyXG5MMiA9IExhbWJkYShmdW5jdGlvbigpIHtcclxuXHRwMS5raWxsKCk7XHJcbn0pO1xyXG5cclxudDIoTDIpO1xyXG5cclxuZ2VuZXJhdGVQb3B1bGF0aW9uID0gZnVuY3Rpb24oKSB7XHJcblx0Zm9yIChpID0gMDsgaSA8IDMwOyBpKyspIHtcclxuXHRcdFBsYXllcih7IGFzc2lnbjogXCJjaG9vc2VGaXJzdFwiIH0pO1xyXG5cdH1cclxuXHRmb3IgKGkgPSAwOyBpIDwgMzA7IGkrKykge1xyXG5cdFx0UGxheWVyKHsgYXNzaWduOiBcImNob29zZVNlY29uZFwiIH0pO1xyXG5cdH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIGdhbWVHZW5lcmF0b3IoKSB7XHJcblx0dmFyIHQgPSBUdXJuKFtcclxuXHRcdFJhbmRvbVBsYXllckNob2ljZShbXCJjb29wZXJhdGVcIiwgXCJkZWZlY3RcIl0pLFxyXG5cdFx0UmFuZG9tUGxheWVyQ2hvaWNlKFtcIkNvb3BlcmF0ZVwiLCBcIkRlZmVjdFwiXSlcclxuXHRdKTtcclxuXHJcblx0dC5kZWZlY3QuRGVmZWN0KFsyLCAyXSk7XHJcblx0dC5kZWZlY3QuQ29vcGVyYXRlKFs0LCAxXSk7XHJcblx0dC5jb29wZXJhdGUuRGVmZWN0KFsxLCA0XSk7XHJcblx0dC5jb29wZXJhdGUuQ29vcGVyYXRlKFszLCAzXSk7XHJcblxyXG5cdHJldHVybiB0O1xyXG59XHJcbi8vXHJcbi8vXHJcbi8vXHJcblxyXG4vL0NFID0gU3RvY2tHYW1lc1tcIkN1bHR1cmFsIEV2b2x1dGlvblwiXShnYW1lR2VuZXJhdG9yLCAxLCB7Z2VuZXJhdGVQb3B1bGF0aW9ufSk7XHJcblxyXG4vL24gPSBTdG9ja0dhbWVzW1wiVHdvLVBsYXllciBOb3JtYWxcIl0ocDEscDIsW1tcImxlZnRcIixcInJpZ2h0XCJdLFtcInVwXCIsXCJkb3duXCJdXSk7XHJcbnBkMSA9IFN0b2NrR2FtZXNbXCJQcmlzb25lcidzIERpbGVtbWFcIl0oW3AxLCBwMl0pO1xyXG5wZDIgPSBTdG9ja0dhbWVzW1wiUHJpc29uZXIncyBEaWxlbW1hXCJdKFtwMywgcDRdKTtcclxuXHJcbnMgPSBTaW11bHRhbmVvdXMoW3BkMSwgcGQyXSlcclxuXHJcbnYyID0gVmFyaWFibGUoMSk7XHJcblxyXG4vL24gPSBTdG9ja0dhbWVzW1wiU2ltcGxlIFplcm8tU3VtXCJdKHAxLHAyLFtbXCJsZWZ0XCIsXCJyaWdodFwiXSxbXCJ1cFwiLFwiZG93blwiXV0sIFtbdjIsMl0sWzMsNF1dKTtcclxuXHJcbnJwYyA9IFN0b2NrR2FtZXNbXCJSb2NrLVBhcGVyLVNjaXNzb3JzXCJdKFtwMSwgcDJdKTtcclxudCA9IFN0b2NrR2FtZXNbXCJBeGVscm9kIFRvdXJuYW1lbnRcIl07XHJcbi8vVGhlIGNvZGUgYmVsb3cgaXMgdG8gcnVuIHRoZSByZXBsIGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxyXG4vL3ZhciB0b1JlcGwgPSB7X2V4cG9zZSwgcmVnaXN0cnksUGxheWVyLENob2ljZSxUdXJuLFNlcXVlbmNlLExvb3AsU3RvY2hhc3RpY0xvb3AsSGFsdElmLCBTdG9jaGFzdGljSGFsdCwgTGFtYmRhLCBwMSxjMSxjMix0MX07XHJcbi8vc3RhcnRSRVBMKHRvUmVwbCk7XHJcbiIsIi8vTWFpbiBtb2R1bGUgY29kZVxyXG52YXIgTmFzaEpTID0gcmVxdWlyZSgnLi9saWIvZW5naW5lJyk7XHJcblxyXG4vL1N0b2NrLWdhbWVzXHJcbk5hc2hKUy5TdG9ja0dhbWVzID0gcmVxdWlyZSgnLi9zdG9jay1nYW1lcycpO1xyXG5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE5hc2hKUztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuLy9Mb2dnaW5nXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xyXG4vL2xvZy51c2VXaW5zdG9uKCk7ICBcdFx0XHRcdFdpbnN0b24gZG9lc24ndCB3b3JrIHdpdGggYnJvd3NlcmlmeSwgc28gdGhpcyBpcyBhIHNoaW0uIFVuY29tbWVudCB0byB1c2UgV2luc3Rvbi5cclxubG9nLnNldExldmVsKCdkZWJ1ZycpO1xyXG5cclxubG9nKCdpbmZvJywgJ1N0YXJ0aW5nIE5hc2hKUycpO1xyXG5cclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIgeyByZWdpc3RyeSwgaWRDb3VudGVycyB9ID0gcmVxdWlyZSgnLi9zdGF0ZScpO1xyXG52YXIgeyBnYW1lSGlzdG9yeSwgSGlzdG9yeSB9ID0gcmVxdWlyZSgnLi9oaXN0b3J5Jyk7XHJcblxyXG5cclxuLy9QbGF5ZXJzXHJcbnZhciB7IF9QbGF5ZXIsIFBsYXllciB9ID0gcmVxdWlyZSgnLi9wbGF5ZXInKTtcclxucmVnaXN0cnkuX2FkZFR5cGVfKFwicGxheWVyc1wiKTtcclxuaWRDb3VudGVycy5fYWRkVHlwZV8oXCJwbGF5ZXJcIik7XHJcblxyXG5cclxuLy9Qb3B1bGF0aW9uXHJcbnZhciB7IGdhbWVQb3B1bGF0aW9uLCBQb3B1bGF0aW9uLCBQbGF5ZXJMaXN0LCBVc2VyUGxheWVyTGlzdCB9ID0gcmVxdWlyZSgnLi9wb3B1bGF0aW9uJyk7XHJcblxyXG5cclxuLy9JbmZvcm1hdGlvbiBtZWNoYW5pY3NcclxudmFyIHsgSW5mb3JtYXRpb24sIFBlcmZlY3RJbmZvcm1hdGlvbiB9ID0gcmVxdWlyZShcIi4vaW5mb3JtYXRpb25cIik7XHJcblxyXG5cclxuLy9QbGF5YWJsZXNcclxudmFyIHsgcGxheWFibGVDbGFzc2VzLCBwbGF5YWJsZUludGVyZmFjZXMgfSA9IHJlcXVpcmUoJy4vcGxheWFibGVzLycpXHJcbmZvciAodmFyIF9jbGFzcyBpbiBwbGF5YWJsZUNsYXNzZXMpIHtcclxuXHRyZWdpc3RyeS5fYWRkVHlwZV8ocGxheWFibGVDbGFzc2VzW19jbGFzc10ucmVnaXN0cnlOYW1lKTtcclxuXHRpZENvdW50ZXJzLl9hZGRUeXBlXyhwbGF5YWJsZUNsYXNzZXNbX2NsYXNzXS5jb3VudGVyTmFtZSk7XHJcbn1cclxuXHJcblxyXG5cclxuLy9TeW1ib2xpYyBMb2dpY1xyXG52YXIgeyB2YXJpYWJsZVByb3RvdHlwZSwgVmFyaWFibGUsIGV4cHJlc3Npb25Qcm90b3R5cGUsIEV4cHJlc3Npb24gfSA9IHJlcXVpcmUoJy4vbG9naWMnKTtcclxuXHJcblxyXG5cclxuLy9TdHJhdGVnaWVzXHJcbnJlZ2lzdHJ5Ll9hZGRUeXBlXyhcInN0cmF0ZWdpZXNcIik7XHJcbmlkQ291bnRlcnMuX2FkZFR5cGVfKFwic3RyYXRlZ3lcIik7XHJcbnZhciB7IHJlZ2lzdGVyU3RyYXRlZ3ksIFN0cmF0ZWdpZXMgfSA9IHJlcXVpcmUoJy4vc3RyYXRlZ3knKTtcclxudmFyIHN0cmF0ZWd5TG9hZGVyID0gcmVxdWlyZSgnLi9zdHJhdGVneS1sb2FkZXInKTtcclxuXHJcblxyXG5cclxuLy9USElTIEZVTkNUSU9OIElTIE9OTFkgRk9SIERFQlVHR0lORy4gUkVNT1ZFIElUIEZST00gTU9EVUxFIEVYUE9SVFMgV0hFTiBQVUJMSVNISU5HXHJcbmZ1bmN0aW9uIGV4cG9zZShpbnRlcmZhY2VQbGF5YWJsZSkge1xyXG5cdHJldHVybiByZWdpc3RyeS5wbGF5YWJsZXNbaW50ZXJmYWNlUGxheWFibGUuaWQoKV07XHJcbn1cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gc3RhcnRSRVBMKHRvUkVQTCkge1xyXG5cdHZhciByZXBsID0gcmVxdWlyZShcInJlcGxcIik7XHJcblxyXG5cdHZhciByZXBsU2VydmVyID0gcmVwbC5zdGFydCh7XHJcblx0XHRwcm9tcHQ6IFwiTmFzaCA+PiBcIixcclxuXHR9KTs7XHJcblxyXG5cdE9iamVjdC5hc3NpZ24ocmVwbFNlcnZlci5jb250ZXh0LCB0b1JFUEwpO1xyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0UGxheWVyLFxyXG5cdF9QbGF5ZXIsIC8vUkVNT1ZFIFRISVMgTElORSBXSEVOIFBVQkxJU0hJTkdcclxuXHRnYW1lUG9wdWxhdGlvbiwgLy9SRU1PVkUgVEhJUyBMSU5FIFdIRU4gUFVCTElTSElOR1xyXG5cdCdQbGF5ZXJMaXN0JzogVXNlclBsYXllckxpc3QsXHJcblx0UG9wdWxhdGlvbixcclxuXHRJbmZvcm1hdGlvbiwgLy9SRU1PVkUgVEhJUyBMSU5FIFdIRU4gUFVCTElTSElOR1xyXG5cdFBlcmZlY3RJbmZvcm1hdGlvbiwgLy9SRU1PVkUgVEhJUyBMSU5FIFdIRU4gUFVCTElTSElOR1xyXG5cdCdQbGF5YWJsZXMnOiBwbGF5YWJsZUludGVyZmFjZXMsXHJcblx0cmVnaXN0ZXJTdHJhdGVneSxcclxuXHRTdHJhdGVnaWVzLFxyXG5cdHN0cmF0ZWd5TG9hZGVyLFxyXG5cdGdhbWVIaXN0b3J5LFxyXG5cdCduaGlzdG9yeSc6IEhpc3RvcnksIC8vUkVNT1ZFIFRISVMgV0hFTiBQVUJMSVNISU5HXHJcblx0J19leHBvc2UnOiBleHBvc2UsIC8vUkVNT1ZFIFRISVMgTElORSBXSEVOIFBVQkxJU0hJTkdcclxuXHRyZWdpc3RyeSwgLy9SRU1PVkUgVEhJUyBMSU5FIFdIRU4gUFVCTElTSElOR1xyXG5cdHN0YXJ0UkVQTCwgLy9TaG91bGQgdGhpcyBsaW5lIGJlIHJlbW92ZWQgd2hlbiBwdWJsaXNoaW5nP1xyXG5cdFZhcmlhYmxlLFxyXG5cdEV4cHJlc3Npb25cclxufTtcclxuIiwidmFyIGdlbmVyYWwgPSB7XHJcbiAgLy9DaGVjayBpZiB2YXJpYWJsZSBpcyBhbiBPYmplY3RcclxuICBpc09iamVjdDogZnVuY3Rpb24oYSkge1xyXG4gICAgcmV0dXJuICEhYSAmJiBhLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XHJcbiAgfSxcclxuXHJcbiAgLy9XaGF0IGRvIHlvdSB0aGluaz9cclxuICBpc0Z1bmN0aW9uOiBmdW5jdGlvbihhKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIGEgPT09IFwiZnVuY3Rpb25cIjtcclxuICB9LFxyXG5cclxuICAvL1Byb3ZpZGUgYSBmdW5jdGlvbiwgYSBjb250ZXh0ICgndGhpcycpLCBhbmQgYW4gYXJndW1lbnQgYXJyYXkuXHJcbiAgLy9SZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgY2FsbGVkLlxyXG4gIGFwcGx5QmluZDogZnVuY3Rpb24oZnVuYywgdGhhdCwgYXJnQXJyYXkpIHtcclxuICAgIHJldHVybiBmdW5jLmJpbmQuYXBwbHkoZnVuYywgW3RoYXRdLmNvbmNhdChhcmdBcnJheSkpO1xyXG4gIH0sXHJcblxyXG4gIC8vV3JhcHMgYSBmdW5jdGlvbiB0byBlbnN1cmUgaXQgb25seSBnZXRzIGNhbGxlZCBvbmUgdGltZS5cclxuICBvbmNlOiBmdW5jdGlvbihmbiwgY29udGV4dCkge1xyXG4gICAgdmFyIHJlc3VsdDtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmIChmbikge1xyXG4gICAgICAgIHJlc3VsdCA9IGZuLmFwcGx5KGNvbnRleHQgfHwgdGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICBmbiA9IG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gIH0sXHJcblxyXG4gIC8vIFJhbmRvbWx5IHJlLW9yZGVyIGFycmF5XHJcbiAgc2h1ZmZsZTogZnVuY3Rpb24oYXJyYXkpIHtcclxuICAgIHZhciBjdXJyZW50SW5kZXggPSBhcnJheS5sZW5ndGgsXHJcbiAgICAgIHRlbXBvcmFyeVZhbHVlLFxyXG4gICAgICByYW5kb21JbmRleDtcclxuXHJcbiAgICAvLyBXaGlsZSB0aGVyZSByZW1haW4gZWxlbWVudHMgdG8gc2h1ZmZsZS4uLlxyXG4gICAgd2hpbGUgKDAgIT09IGN1cnJlbnRJbmRleCkge1xyXG4gICAgICAvLyBQaWNrIGEgcmVtYWluaW5nIGVsZW1lbnQuLi5cclxuICAgICAgcmFuZG9tSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjdXJyZW50SW5kZXgpO1xyXG4gICAgICBjdXJyZW50SW5kZXggLT0gMTtcclxuXHJcbiAgICAgIC8vIEFuZCBzd2FwIGl0IHdpdGggdGhlIGN1cnJlbnQgZWxlbWVudC5cclxuICAgICAgdGVtcG9yYXJ5VmFsdWUgPSBhcnJheVtjdXJyZW50SW5kZXhdO1xyXG4gICAgICBhcnJheVtjdXJyZW50SW5kZXhdID0gYXJyYXlbcmFuZG9tSW5kZXhdO1xyXG4gICAgICBhcnJheVtyYW5kb21JbmRleF0gPSB0ZW1wb3JhcnlWYWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYXJyYXk7XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnZW5lcmFsO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKFwiLi4vbG9nZ2VyXCIpO1xyXG5cclxubG9nKFwiZGVidWdcIiwgXCJoZWxwZXJGdW5jdGlvbnMtaW5kZXg6IExvYWRpbmcgaGVscGVyIGZ1bmN0aW9ucyBsb2FkZXIuXCIpO1xyXG5cclxuLypcclxudmFyIGdlbmVyYWwgID0gcmVxdWlyZSgnLi9nZW5lcmFsJyk7XHJcbnZhciBwbGF5ZXIgICA9IHJlcXVpcmUoJy4vcGxheWVyJyk7XHJcbnZhciBwbGF5YWJsZSA9IHJlcXVpcmUoJy4vcGxheWFibGUnKTtcclxudmFyIHR1cm4gXHQgPSByZXF1aXJlKCcuL3R1cm4nKTtcclxudmFyIHN0YXRlIFx0ID0gcmVxdWlyZSgnLi9zdGF0ZScpOyBcclxuKi9cclxuXHJcbmZ1bmN0aW9uIGxvYWRlcihmaWxlKSB7XHJcblx0cmV0dXJuIHJlcXVpcmUoXCIuL1wiICsgZmlsZSArIFwiLmpzXCIpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGxvYWRlcjtcclxuLy9tb2R1bGUuZXhwb3J0cyA9IHtnZW5lcmFsLCBwbGF5ZXIsIHBsYXlhYmxlLCB0dXJuLCBzdGF0ZX07XHJcblxyXG4vLyBIYWNrIHRvIGNvbXBpbGUgR2xvYiBmaWxlcyAoaW4gYnJvd3NlcmlmeSkuIERvbsK0dCBjYWxsIHRoaXMgZnVuY3Rpb24hXHJcbihmdW5jdGlvbigpIHtcclxuXHRyZXF1aXJlKCcuL2dlbmVyYWwuanMnKTtyZXF1aXJlKCcuL2luZGV4LmpzJyk7cmVxdWlyZSgnLi9sb2dpYy5qcycpO3JlcXVpcmUoJy4vcGxheWFibGUuanMnKTtyZXF1aXJlKCcuL3BsYXllci5qcycpO3JlcXVpcmUoJy4vc3RhdGUuanMnKTtyZXF1aXJlKCcuL3N0b2NrLWdhbWVzLmpzJyk7cmVxdWlyZSgnLi90b3VybmFtZW50LmpzJyk7cmVxdWlyZSgnLi90dXJuLmpzJyk7XHJcbn0pO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2dpYyA9IHtcclxuXHRcclxuXHQvLyBDaGVjayB0byBzZWUgaWYgb2JqZWN0IGlzIFZhcmlhYmxlL0V4cHJlc3Npb24gb3Igbm90LiBSZXR1cm5zIHRydWUvZmFsc2VcclxuXHRpc0xvZ2ljOiBmdW5jdGlvbihsb2dpYyl7XHJcblx0XHRcclxuXHRcdGlmIChsb2dpYyBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIGxvZ2ljID09IGxvZ2ljKjEpIHJldHVybiB0cnVlXHJcblx0XHRlbHNlIHJldHVybiBmYWxzZTtcclxuXHR9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGxvZ2ljOyIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIHtTeW5jaHJvbm91c1Byb21pc2V9ID0gcmVxdWlyZSgnc3luY2hyb25vdXMtcHJvbWlzZScpO1xyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7cmVnaXN0cnl9ID0gcmVxdWlyZSgnLi4vc3RhdGUnKTtcclxuXHJcbnZhciBwbGF5YWJsZSA9IHtcclxuXHQvLyBHZW5lcmF0ZXMgdGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyByZXR1cm5lZCB3aGVuIGEgUGxheWFibGUgaXMgY2FsbGVkLCB3aGljaCBjYW4gdGhlbiBiZSBjYWxsZWQgdG8gY2hhaW4gcGxheWFibGVzIHRvZ2V0aGVyLlxyXG5cdGNoYWluZXJHZW5lcmF0b3I6ZnVuY3Rpb24oZXh0ZXJuYWxPYmosIGludGVybmFsT2JqKXtcclxuXHRcdGV4dGVybmFsT2JqID0gdGhpcztcclxuXHRcdHJldHVybiBmdW5jdGlvbihzb3VyY2Upe1xyXG5cdFx0XHR2YXIgcHJldmlvdXNQbGF5YWJsZSwgcGF0aDtcclxuXHRcdFxyXG5cdFx0XHQvL1RPRE86IHZlcmlmeSB0aGF0IHNvdXJjZSBpcyB0aGUgcmlnaHQgdHlwZVxyXG5cdFx0XHJcblx0XHRcdHJldHVybiBTeW5jaHJvbm91c1Byb21pc2UuYWxsKFtmdW5jdGlvbigpe1xyXG5cdFx0XHRcdGlmIChzb3VyY2UgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHNvdXJjZSBpbnN0YW5jZW9mIFN5bmNocm9ub3VzUHJvbWlzZSkge1xyXG5cdFx0XHRcdFx0c291cmNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcclxuXHRcdFx0XHRcdFx0cHJldmlvdXNQbGF5YWJsZSA9IHJlZ2lzdHJ5LnBsYXlhYmxlc1tyZXN1bHQucGxheWFibGUuaWQoKV07XHJcblx0XHRcdFx0XHRcdHBhdGggPSByZXN1bHQucGF0aFxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUoKTtcclxuXHRcdFx0XHRcdH0pO1x0XHRcdFx0XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBTeW5jaHJvbm91c1Byb21pc2UucmVzb2x2ZSgpXHJcblx0XHRcdH0oKSwgZnVuY3Rpb24oKXtcclxuXHRcdFx0XHRpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHNvdXJjZSBpbnN0YW5jZW9mIFN5bmNocm9ub3VzUHJvbWlzZSkpIHtcclxuXHRcdFx0XHRcdHByZXZpb3VzUGxheWFibGUgPSByZWdpc3RyeS5wbGF5YWJsZXNbc291cmNlLmlkKCldO1x0XHJcblx0XHRcdFx0XHRwYXRoID0gc291cmNlLnBhdGg7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBTeW5jaHJvbm91c1Byb21pc2UucmVzb2x2ZSgpO1xyXG5cdFx0XHR9KCldKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0aWYgKHBhdGggPT0gXCJhbGxcIikgcHJldmlvdXNQbGF5YWJsZS5hZGROZXh0KGludGVybmFsT2JqKTtcclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0b3V0Y29tZVRyZWVHZXRWYWx1ZShwcmV2aW91c1BsYXlhYmxlLm5leHQsIHBhdGgpLnB1c2goaW50ZXJuYWxPYmopOyBcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0XHQvL3ByZXZpb3VzUGxheWFibGUubmV4dFtzZWxlY3RlZF0ucHVzaChfY2hvaWNlKTtcclxuXHRcdFx0XHJcblx0XHRcdFx0cmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlKHtcclxuXHRcdFx0XHRcdCdwbGF5YWJsZSc6ZXh0ZXJuYWxPYmosXHJcblx0XHRcdFx0XHRwYXRoOlwiYWxsXCJcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cclxuXHQvL1VzZSB0byBzZXQgZXZlcnkgdmFsdWUgb2YgYW4gb3V0Y29tZSB0cmVlXHJcblx0b3V0Y29tZVRyZWVBZGRBbGw6ZnVuY3Rpb24odHJlZSwgdmFsdWUpe1xyXG5cdFx0XHJcblx0XHQvL0lmIGl0J3MgYW4gYXJyYXksIHRoZW4gd2UncmUgYWxyZWFkeSBkb25lLlxyXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcclxuXHRcdFx0dHJlZS5wdXNoKHZhbHVlKTtcdFx0XHQvL1VzZSBwdXNoIGhlcmUgYmVjYXVzZSB0aGlzIHdpbGwgYmUgYSB1bmlxdWUgYXJyYXlcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHR2YXIgcmVjdXJzZSA9IGZ1bmN0aW9uKG9iaiwgdmFsKXtcclxuXHRcclxuXHRcdFx0XHRmb3IgKHZhciBrZXlzIGluIG9iaikge1xyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0XHQvL0lmIG5vIGtleXMgbGVmdCB0byB0cmF2ZXJzZSwgdGhlbiBhc3NpZ24gdmFsdWUuIElmIG5vdCwgcmVjdXJzZS5cclxuXHRcdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KG9ialtrZXlzXSkpIHtcclxuXHRcdFx0XHRcdFx0b2JqW2tleXNdID0gb2JqW2tleXNdLnNsaWNlKCkuY29uY2F0KHZhbCk7XHRcdFx0Ly9Vc2Ugc2xpY2UtY29uY2F0IGhlcmUgYmVjYXVzZSB0aGlzIG1pZ2h0IG5vdCBiZSBhIHVuaXF1ZSBhcnJheSAodGhlIGNyZWF0aW9uIHByb2Nlc3MgZHVwbGljYXRlcyB0aGVtKVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSByZWN1cnNlKG9ialtrZXlzXSx2YWwpO1xyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cdFx0cmVjdXJzZSh0cmVlLCB2YWx1ZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0XHJcblx0Ly9UcmF2ZXJzZSBhbiBvdXRjb21lIHRyZWUgdG8gb2J0YWluIHRoZSB2YWx1ZSBmb3IgYSBkZXNpcmVkIGtleS1zZXRcclxuXHQvL0FyZ3VtZW50IG9uZSBpcyBhIG5lc3RlZCBvYmplY3QsIHdoaWxlIGFyZ3VtZW50IDIgaXMgYW4gYXJyYXkgb2Yga2V5cyBmb3IgdGhlIG9iamVjdCwgMSBsYXllciBhdCBhIHRpbWUuXHJcblx0b3V0Y29tZVRyZWVHZXRWYWx1ZTpmdW5jdGlvbih0cmVlLCBzZWxlY3Rvcil7XHJcblx0XHJcblx0XHQvL0ZpbmQgdGhlIG5leHQgaXRlbSBpbiB0aGUgY2hhaW4gYXNzb2NpYXRlZCB3aXRoIHRoZSByZXN1bHRhbnQgb3V0Y29tZVx0XHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gc2VsZWN0b3IubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0dHJlZSA9IHRyZWVbc2VsZWN0b3JbaV1dO1xyXG5cdFx0fVxyXG5cdFx0XHRcclxuXHRcdHJldHVybiB0cmVlO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvL1RyYXZlcnNlIGFuIG91dGNvbWUgdHJlZSB0byBzZXQgdGhlIHZhbHVlIGZvciBhIGRlc2lyZWQga2V5LXNldFxyXG5cdC8vQXJndW1lbnQgb25lIGlzIGEgbmVzdGVkIG9iamVjdCwgd2hpbGUgYXJndW1lbnQgMiBpcyBhbiBhcnJheSBvZiBrZXlzIGZvciB0aGUgb2JqZWN0LCAxIGxheWVyIGF0IGEgdGltZS5cclxuXHRvdXRjb21lVHJlZVNldFZhbHVlOmZ1bmN0aW9uKHRyZWUsIHNlbGVjdG9yLCB2YWx1ZSl7XHJcblx0XHJcblx0XHQvL0ZpbmQgdGhlIG5leHQgaXRlbSBpbiB0aGUgY2hhaW4gYXNzb2NpYXRlZCB3aXRoIHRoZSByZXN1bHRhbnQgb3V0Y29tZVx0XHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gc2VsZWN0b3IubGVuZ3RoIC0xOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0dHJlZSA9IHRyZWVbc2VsZWN0b3JbaV1dO1xyXG5cdFx0fVxyXG5cdFx0XHRcclxuXHRcdHJldHVybiB0cmVlW3NlbGVjdG9yW2ldXSA9IHZhbHVlO1xyXG5cdH1cclxufVxyXG5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHBsYXlhYmxlOyIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gIEdhbWUgc3RhdGVcclxudmFyIHsgcmVnaXN0cnkgfSA9IHJlcXVpcmUoXCIuLi9zdGF0ZVwiKTtcclxuXHJcbi8vIGhlbHBlciBmdW5jdGlvblxyXG52YXIgeyBpc0Z1bmN0aW9uIH0gPSByZXF1aXJlKFwiLi9nZW5lcmFsXCIpO1xyXG5cclxuLy8gUGxheWVyIGNsYWFzc1xyXG52YXIgeyBfUGxheWVyIH0gPSByZXF1aXJlKFwiLi4vcGxheWVyXCIpO1xyXG5cclxuLy8gUG9wdWxhdGlvblxyXG52YXIgeyBnYW1lUG9wdWxhdGlvbiB9ID0gcmVxdWlyZShcIi4uL3BvcHVsYXRpb25cIilcclxuXHJcbnZhciBwbGF5ZXIgPSB7XHJcblxyXG5cdC8vcmVzZXQgYWxsIHBsYXllcnMuIFJlY3JlYXRlIGZyb20gY2xhc3MsIHJlLWFzc2lnbiBzdHJhdGVneSwgbG9vcCB0aHJvdWdoIG9iamVjdHMgdGhhdCByZWZlcmVuY2UgcGxheWVyIHRvIHNldCBuZXcgcmVmZXJlbmNlLiByZXN1bHQgYXJndW1lbnQgaXMgb25seSBmb3IgcGFzcy10aHJvdWdoLlxyXG5cdHJlaW5pdGlhbGl6ZVBsYXllcnM6IGZ1bmN0aW9uKHBvcHVsYXRpb24gPSBcImFsbFwiLCByZXN1bHQgPSBudWxsKSB7XHJcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIG9sZFBsYXllciwgc3RyYXRlZ3ksIHBhcmFtZXRlcnM7XHJcblxyXG5cdFx0XHQvLyBpZiBubyBwb3B1bGF0aW9uIGlzIHN1cHBsaWVkLCBmZXRjaCBldmVyeWJvZHlcclxuXHRcdFx0aWYgKHBvcHVsYXRpb24gPT09IFwiYWxsXCIpIHBvcHVsYXRpb24gPSBPYmplY3Qua2V5cyhyZWdpc3RyeS5wbGF5ZXJzKVxyXG5cdFx0XHRlbHNlKHBvcHVsYXRpb24gPSBwb3B1bGF0aW9uLmlkcygpKVxyXG5cclxuXHRcdFx0Ly9SZWRlZmluZSBlYWNoIHBsYXllclxyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBvcHVsYXRpb24ubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHR2YXIgcGxheWVyID0gcG9wdWxhdGlvbltpXTtcclxuXHJcblx0XHRcdFx0b2xkUGxheWVyID0gcmVnaXN0cnkucGxheWVyc1twbGF5ZXJdO1xyXG5cdFx0XHRcdHN0cmF0ZWd5ID0gb2xkUGxheWVyLnN0cmF0ZWd5Ll9pZDtcclxuXHRcdFx0XHRwYXJhbWV0ZXJzID0ge307IC8vVE9ETzogd2hlbiBhZGRpbmcgcGxheWVyIHBhcmFtZXRlcnMsIGJlIHN1cmUgdGhleSdyZSBpbmNsdWRlZCBoZXJlXHJcblxyXG5cdFx0XHRcdHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyXSA9IG5ldyBfUGxheWVyKG9sZFBsYXllci5pZCwgcGFyYW1ldGVycyk7XHJcblx0XHRcdFx0cmVnaXN0cnkucGxheWVyc1twbGF5ZXJdLmludGVyZmFjZSA9IG9sZFBsYXllci5pbnRlcmZhY2U7XHJcblx0XHRcdFx0cmVnaXN0cnkucGxheWVyc1twbGF5ZXJdLmFzc2lnbihzdHJhdGVneSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vRm9yIGVhY2ggY2hvaWNlLCByZWNyZWF0ZSBwbGF5ZXIgcmVmZXJlbmNlc1xyXG5cdFx0XHRmb3IgKHZhciBjaG9pY2UgaW4gcmVnaXN0cnkuY2hvaWNlcykge1xyXG5cdFx0XHRcdGlmIChyZWdpc3RyeS5jaG9pY2VzW2Nob2ljZV0ucGxheWVyKVxyXG5cdFx0XHRcdFx0cmVnaXN0cnkuY2hvaWNlc1tjaG9pY2VdLnBsYXllciA9IHJlZ2lzdHJ5LnBsYXllcnNbcmVnaXN0cnkuY2hvaWNlc1tjaG9pY2VdLnBsYXllci5pZF07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuXHRcdH0pO1xyXG5cdH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcGxheWVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcclxuXHJcbi8vIFN0YXRlIHZhcmlhYmxlc1xyXG52YXIge2lkQ291bnRlcnMsIHJlZ2lzdHJ5fSA9IHJlcXVpcmUoJy4uL3N0YXRlJyk7XHJcblxyXG52YXIgc3RhdGUgPSB7XHJcblx0XHJcblx0Ly9IYW5kbGUgSUQgc2V0dGluZyBmb3IgYWxsIG9iamVjdHMgdGhhdCBnZXQgc3RvcmVkIGluIHRoZSByZWdpc3RyeVxyXG5cdGlkSGFuZGxlcjogZnVuY3Rpb24gaWRIYW5kbGVyKGlkLCB0eXBlLCByZWN1cnNpbmc9ZmFsc2Upe1xyXG5cdFx0Ly9Bc3NpZ24gaWRcclxuXHRcdFxyXG5cdFx0aWRDb3VudGVyc1t0eXBlXSsrO1xyXG5cdFx0dmFyIGNvdW50ZXIgPSBpZENvdW50ZXJzW3R5cGVdO1xyXG5cdFx0XHJcblx0XHRpZiAoIWlkKSB7XHJcblx0XHRcdHJldHVybiB0eXBlICsgY291bnRlci50b1N0cmluZygpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBDaGVjayB0aGF0IGlkIGlzbid0IHRha2VuLiBJZiBpdCBpcywgY29uc3RydWN0IGEgbmV3IG9uZS5cclxuXHRcdFx0XHJcblx0XHRcdC8vQ29uc3RydWN0IGxpc3Qgb2YgYWxsIG9iamVjdHMgYnkgZXh0cmFjdGluZyBhbGwgcmVnaXN0cnkgZW50cmllc1xyXG5cdFx0XHR2YXIgaXRlbXMgPSBbXVxyXG5cdFx0XHRPYmplY3Qua2V5cyhyZWdpc3RyeSkuZm9yRWFjaChmdW5jdGlvbihyZWcpe2l0ZW1zLnB1c2guYXBwbHkoaXRlbXMsIE9iamVjdC5rZXlzKHJlZ2lzdHJ5W3JlZ10pKX0pXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBpZiBpZCBpcyBhbHJlYWR5IHRha2VuLCBnZW5lcmF0ZSBhIG5ldyBvbmUgYnkgYWRkaW5nIGEgbnVtYmVyIGF0IHRoZSBlbmQuXHJcblx0XHRcdGlmIChpdGVtcy5pbmRleE9mKGlkKSA+IC0xKSB7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0dmFyIG1hdGNoLCBvbGROdW0sIGV4cCwgbmV3SWQ7XHJcblx0XHRcdFx0dmFyIG9sZElkID0gaWQ7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0ZG8ge1xyXG5cdFx0XHRcdFx0Ly8gVGhpcyBmaW5kcyBhIG51bWJlciBhdCB0aGUgZW5kLCBhbmQgaW5jcmVtZW50cyBpdCwgb3Igc3RhcnRzIHdpdGggMSBpZiB0aGVyZSB3YXNuJ3Qgb25lLlxyXG5cdFx0XHRcdFx0bWF0Y2ggPSAvXFxkKyQvLmV4ZWMoaWQpO1xyXG5cdFx0XHRcdFx0b2xkTnVtID0gbWF0Y2ggPyBtYXRjaFswXSA6IFwiXCI7XHJcblx0XHRcdFx0XHRleHAgPSBuZXcgUmVnRXhwKG9sZE51bSArIFwiJFwiKTtcclxuXHRcdFx0XHRcdGlkID0gaWQucmVwbGFjZShleHAsIE51bWJlcihvbGROdW0pICsgMSlcclxuXHRcdFx0XHRcclxuXHRcdFx0XHR9XHRcclxuXHRcdFx0XHR3aGlsZSAoaXRlbXMuaW5kZXhPZihpZCkgPi0xKVxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIExvZyB3YXJuaW5nXHJcblx0XHRcdFx0bG9nKFwid2FyblwiLCBcIklEIFwiICsgb2xkSWQgKyBcIiBpcyB0YWtlbi4gVXNpbmcgaW5zdGVhZCBcIiArIGlkKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0cmV0dXJuIGlkXHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBzdGF0ZTsiLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vRXh0ZXJuYWwgZGVwZW5kZW5jeVxyXG52YXIgZXNwcmltYSA9IHJlcXVpcmUoXCJlc3ByaW1hXCIpO1xyXG5cclxudmFyIHN0b2NrR2FtZXMgPSB7XHJcblx0Ly8gdXRpbGl0eSBmdW5jdGlvbiB0byBjcmVhdGUgdHdvIHdheXMgdG8gY2FsbCBhIGdhbWUsIGVpdGhlciB3aXRoIGFsbCB0aGUgYXJndW1lbnRzLCBvciBjdXJyaWVkLCB3aGVyZSB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gdGFrZXMgcGxheWVycyBhbmQgcGFyYW1ldGVyc1xyXG5cdC8vIFRoZSBjb21iaW5lUGFyYW1ldGVycyBzZXR0aW5nIHdpbGxcclxuXHRnYW1lV3JhcHBlcjogZnVuY3Rpb24oZ2FtZSwgYXJndW1lbnRWYWxpZGF0b3IgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0sIHtcclxuXHRcdGNvbWJpbmVQYXJhbWV0ZXJzID1cclxuXHRcdHRydWVcclxuXHR9ID0ge30pIHtcclxuXHJcblx0XHQvLyBydW4gdGhlIGdhbWUuIE9wdGlvbmFsbHksIHZhbGlkYXRlIHRoZSBhcmd1bWVudHMgZmlyc3QuXHJcblx0XHR2YXIgZ2VuZXJhdGUgPSBmdW5jdGlvbiguLi5hcmdzKSB7XHJcblx0XHRcdHZhciByZXN1bHQgPSBhcmd1bWVudFZhbGlkYXRvciguLi5hcmdzKVxyXG5cdFx0XHRpZiAocmVzdWx0ID09PSB0cnVlKSByZXR1cm4gZ2FtZSguLi5hcmdzKTtcclxuXHRcdFx0ZWxzZSB0aHJvdyBuZXcgRXJyb3IocmVzdWx0KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBjcmVhdGVzIGEgd3JhcHBlciBhcm91bmQgdGhlIGdhbWUsIHdoaWNoIGFjY2VwdHMgdGhlIGZpcnN0IGFyZ3VtZW50IChwbGF5ZXJzKSBhbmQgbGFzdCBhcmd1bWVudCAocGFyYW1ldGVycyksIGFuZCBwYXNzZXMgaXQgZm9yd2FyZC5cclxuXHRcdC8vIElmIGNvbWJpbmVQYXJhbWV0ZXJzIGlzIHNldCB0byB0cnVlLCB0aGVuIHRoZSBzZWNvbmQgYXJndW1lbnQgb2YgdGhlIHJldHVybmVkIGZ1bmN0aW9uIHdpbGwgZ2V0IG1lcmdlZCB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50XHJcblx0XHQvLyBnaXZlbiB3aGVuIGdlbmVyYXRvciBpcyBjYWxsZWQuXHJcblx0XHRnZW5lcmF0ZS5jcmVhdGVHZW5lcmF0b3IgPSBmdW5jdGlvbiguLi5hcmdzKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmxvZyhnYW1lLCBnYW1lLnRvU3RyaW5nKCkpXHJcblx0XHRcdHZhciBnYW1lQ29kZSA9IGVzcHJpbWEucGFyc2VTY3JpcHQoXCIoXCIgKyBnYW1lLnRvU3RyaW5nKCkgKyBcIilcIilcclxuXHRcdFx0Y29uc29sZS5sb2coZ2FtZUNvZGUpXHJcblxyXG5cdFx0XHR2YXIgZ2FtZUFyZ3MgPSBnYW1lQ29kZS5ib2R5WzBdLmV4cHJlc3Npb24ucGFyYW1zXHJcblx0XHRcdHZhciBsYXN0QXJnID0gZ2FtZUFyZ3NbZ2FtZUFyZ3MubGVuZ3RoIC0gMV1cclxuXHJcblx0XHRcdHZhciBvcmlnaW5hbFBhcmFtZXRlcnNcclxuXHRcdFx0aWYgKChsYXN0QXJnLm5hbWUgJiYgbGFzdEFyZy5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwicGFyYW1ldGVyc1wiKSB8fCBsYXN0QXJnLnR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiIHx8XHJcblx0XHRcdFx0KGxhc3RBcmcudHlwZSA9PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIgJiYgbGFzdEFyZy5sZWZ0LnR5cGUgPT0gXCJPYmplY3RQYXR0ZXJuXCIpKSB7XHJcblx0XHRcdFx0Ly8gQ2hlY2sgdGhhdCB0aGUgZ2FtZSBhcmd1bWVudHMgYW5kIGNyZWF0ZUdlbmVyYXRvciBhcmd1bWVudHMgYXJlIHRoZSBjb3JyZWN0IGxlbmd0aHMuIGNyZWF0ZUdlbmVyYXRvciBzaG91bGQgYmVcclxuXHRcdFx0XHQvLyAxIGxlc3MgdGhhbiBnYW1lLCBiZWNhdXNlIHBsYXllcnMgaXMgb21pdHRlZC5cclxuXHRcdFx0XHQvLyBUT0RPOiB1c2UgZXNwcmltYSB0byBhbGxvdyBwbGF5ZXJzIHRvIGJlIGFueXdoZXJlIGluIHRoZSBnYW1lIGRlZmluaXRpb24gKG9yIGV2ZW4gb21pdHRlZCkgcmF0aGVyIHRoYW4gZmlyc3RcclxuXHRcdFx0XHRpZiAoYXJncy5sZW5ndGggPT0gZ2FtZUFyZ3MubGVuZ3RoIC0gMSkgb3JpZ2luYWxQYXJhbWV0ZXJzID0gYXJncy5wb3AoKTtcclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbihwbGF5ZXJzLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHJcblx0XHRcdFx0Ly8gSWYgY29tYmluaW5nIHBhcmFtZXRlcnMsIG1lcmdlIGFuZCByZW1vdmUgZnJvbSBhcmd1bWVudHNcclxuXHRcdFx0XHRpZiAoY29tYmluZVBhcmFtZXRlcnMgJiYgb3JpZ2luYWxQYXJhbWV0ZXJzKSBwYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgb3JpZ2luYWxQYXJhbWV0ZXJzLFxyXG5cdFx0XHRcdFx0cGFyYW1ldGVycylcclxuXHJcblx0XHRcdFx0cmV0dXJuIGdlbmVyYXRlKHBsYXllcnMsIC4uLmFyZ3MsIHBhcmFtZXRlcnMpXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZ2VuZXJhdGU7XHJcblx0fVxyXG5cclxuXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gc3RvY2tHYW1lcztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBTdHJhdGVnaWVzXHJcbnZhciB7IFN0cmF0ZWdpZXMgfSA9IHJlcXVpcmUoXCIuLi9zdHJhdGVneVwiKTtcclxuXHJcbi8vIFBsYXllcnNcclxudmFyIHsgUGxheWVyIH0gPSByZXF1aXJlKFwiLi4vcGxheWVyXCIpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgLy8gQ3JlYXRlIGEgcGxheWVyIGZvciBlYWNoIGF2YWlsYWJsZSBzdHJhdGVneVxyXG4gIGdlbmVyYXRlUG9wdWxhdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcGxheWVycyA9IFtdO1xyXG5cclxuICAgIFN0cmF0ZWdpZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKHN0cmF0ZWd5KSB7XHJcbiAgICAgIHBsYXllcnMucHVzaChQbGF5ZXIoeyBhc3NpZ246IHN0cmF0ZWd5IH0pKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBwbGF5ZXJzO1xyXG4gIH1cclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIge1N5bmNocm9ub3VzUHJvbWlzZX0gPSByZXF1aXJlKCdzeW5jaHJvbm91cy1wcm9taXNlJyk7XHJcblxyXG52YXIgdHVybiA9IHtcclxuXHRcclxuXHQvL1JlY3Vyc2UgdGhyb3VnaCB0aGUgb3B0aW9ucyBpbiBpbnB1dCwgYW5kIHdyaXRlIHZhbCB0byBvdXRwdXQuIFxyXG5cdHJlY3Vyc2UgOiBmdW5jdGlvbiByZWN1cnNlKGlucHV0LCBvdXRwdXQsIHZhbCwgdmFsR2VuZXJhdG9yPWZ1bmN0aW9uKCl7fSwgcGF0aD1bXSl7XHJcblx0XHRyZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUocGF0aCkudGhlbihmdW5jdGlvbihwYXRoKXtcclxuXHRcdFx0XHJcblx0XHRcdC8vU2luY2Ugd2Ugc2xpY2UgdGhlIGFycmF5IGVhY2ggdGltZSwgaWYgdGhlcmUgYXJlIG5vIG1vcmUgZW50cmllcyBsZWZ0IHRoZW4gd2UncmUgZG9uZSB3aXRoIHRoaXMgYnJhbmNoLlxyXG5cdFx0XHRpZiAoaW5wdXQubGVuZ3RoID09IDApIHJldHVybiBTeW5jaHJvbm91c1Byb21pc2UucmVzb2x2ZShwYXRoKVxyXG5cdFx0XHRcclxuXHRcdFx0XHJcblx0XHRcdC8vQW1vbmcgYWxsIHZhbHVlcyBmcm9tIHRoZSBhcnJheVxyXG5cdFx0XHRyZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLmFsbChpbnB1dFswXS5tYXAoZnVuY3Rpb24oaXRlbSl7XHJcblx0XHRcdFx0dmFyIHZhbHVlO1xyXG5cdFx0XHRcdHZhciBzcGxpdFBhdGggPSBwYXRoLnNsaWNlKDApLmNvbmNhdChpdGVtKTtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvL0lmIHRoZXJlIGFyZSBtb3JlIGl0ZW1zIHRvIGl0ZXJhdGUgb3ZlciwgaW5jbHVkZSB0aGVtIGluIHRoZSBvdXRwdXQgdGhlbiByZWN1cnNlLlxyXG5cdFx0XHRcdC8vSWYgbm90LCBwdXQgaW4gdGhlIG5ldyB2YWx1ZS5cclxuXHRcdFx0XHRpZiAoaW5wdXQubGVuZ3RoID09IDEpIHtcclxuXHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0Ly9JZiB2YWwgaXMgYSBmdW5jdGlvbiwgd3JhcCBpdCBpbiBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBnZXQgc3VwcGxpZWQgYW4gYXJndW1lbnQgd2l0aCB3aGVyZSB3ZSBhcmVcdFx0XHRcdFxyXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiB2YWwgPT0gXCJmdW5jdGlvblwiKSB7XHJcblx0XHRcdFx0XHRcdHZhbHVlID0gZnVuY3Rpb24oKXtcdFxyXG5cdFx0XHRcdFx0XHRcdHZhciBhcmdzID0gW3NwbGl0UGF0aF0uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWwuYXBwbHkobnVsbCwgYXJncyk7XHJcblx0XHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlIHZhbHVlID0gdmFsIHx8IHZhbEdlbmVyYXRvcihzcGxpdFBhdGgpO1xyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0XHRvdXRwdXRbaXRlbV0gPSB2YWx1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSBvdXRwdXRbaXRlbV0gPSB7fTtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRyZXR1cm4gcmVjdXJzZShpbnB1dC5zbGljZSgxKSxvdXRwdXRbaXRlbV0sIHZhbCwgdmFsR2VuZXJhdG9yLCBzcGxpdFBhdGgpO1xyXG5cdFx0XHR9KSk7XHRcdFxyXG5cdFx0fSk7XHJcblx0fVxyXG59O1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gdHVybjsiLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vRXh0ZXJuYWwgZGVwZW5kZW5jeVxyXG52YXIganNvbmF0YSA9IHJlcXVpcmUoXCJqc29uYXRhXCIpO1xyXG5cclxuXHJcbnZhciB7IGlzT2JqZWN0LCBpc0Z1bmN0aW9uIH0gPSByZXF1aXJlKFwiLi9oZWxwZXJmdW5jdGlvbnNcIikoXCJnZW5lcmFsXCIpO1xyXG5cclxuLy9FeHRlbnNpb24gb2YgYXJyYXkgdG8gaGFuZGxlIGhpc3RvcnkgbGlzdHMuXHJcbmZ1bmN0aW9uIEhpc3RvcnkoLi4uYXJncykge1xyXG5cdGlmIChBcnJheS5pc0FycmF5KGFyZ3NbMF0pKSBhcmdzID0gYXJnc1swXTtcclxuXHJcblx0T2JqZWN0LnNldFByb3RvdHlwZU9mKGFyZ3MsIEhpc3RvcnkucHJvdG90eXBlKTtcclxuXHJcblx0YXJncy5sb2cgPSBhcmdzLnNsaWNlKCk7XHJcblx0YXJncy5sb2cudHJlZSA9IGFyZ3M7XHJcblx0T2JqZWN0LnNldFByb3RvdHlwZU9mKGFyZ3MubG9nLCBIaXN0b3J5LnByb3RvdHlwZSk7XHJcblxyXG5cdGFyZ3Muc2NvcmVzID0gW107XHJcblx0YXJncy5zY29yZXMudHJlZSA9IGFyZ3M7XHJcblx0T2JqZWN0LnNldFByb3RvdHlwZU9mKGFyZ3Muc2NvcmVzLCBIaXN0b3J5LnByb3RvdHlwZSk7XHJcblxyXG5cdHJldHVybiBhcmdzO1xyXG59XHJcblxyXG5IaXN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQXJyYXkucHJvdG90eXBlKTtcclxuSGlzdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIaXN0b3J5O1xyXG5cclxuLy9UbyBhZGQgZW50cnlcclxuSGlzdG9yeS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oZW50cnkpIHtcclxuXHQvL0FkZCB0byBoaXN0b3J5IGFuZCB0byBsb2dcclxuXHR0aGlzLnB1c2goZW50cnkpO1xyXG5cdGlmICh0aGlzLmxvZykgdGhpcy5sb2cucHVzaChlbnRyeSk7XHJcblxyXG5cdC8vQ3ljbGUgdXAgdGhlIHBhcmVudCB0cmVlLCBhZGQgdG8gZWFjaCBsb2dcclxuXHR2YXIgY2hlY2sgPSB0aGlzO1xyXG5cdGlmIChjaGVjay50cmVlIGluc3RhbmNlb2YgSGlzdG9yeSAmJiBjaGVjay50cmVlLnBhcmVudCBpbnN0YW5jZW9mIEhpc3RvcnkpIHtcclxuXHRcdGNoZWNrLnRyZWUucGFyZW50LmxvZy5hZGQoZW50cnkpO1xyXG5cdH1cclxuXHRpZiAoY2hlY2sucGFyZW50IGluc3RhbmNlb2YgSGlzdG9yeSkge1xyXG5cdFx0Y2hlY2sucGFyZW50LmxvZy5hZGQoZW50cnkpO1xyXG5cdH1cclxuXHJcblx0Ly9JZiB3ZSdyZSBiZWluZyBjYWxsZWQgZnJcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vL1RvIGFkZCBlbnRyeSB3aXRob3V0IGxvZ2dpbmcgKGZvciBwbGF5YWJsZXMgdGhhdCB3b3VsZCBsaWtlIHRoZSB0cmVlIGhpc3RvcnlcclxuLy90byBiZSBzdHJ1Y3R1cmVkIGRpZmZlcmVudGx5IHRoYW4gdGhlIGxvZyBoaXN0b3J5LlxyXG5IaXN0b3J5LnByb3RvdHlwZS5hZGROb0xvZyA9IGZ1bmN0aW9uKGVudHJ5KSB7XHJcblx0dGhpcy5wdXNoKGVudHJ5KTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcblxyXG5IaXN0b3J5LnByb3RvdHlwZS5hZGRTY29yZXMgPSBmdW5jdGlvbihlbnRyeSkge1xyXG5cdC8vQWRkIHRvIGhpc3RvcnlcclxuXHR0aGlzLnNjb3Jlcy5wdXNoKGVudHJ5KTtcclxuXHJcblx0Ly9DeWNsZSB1cCB0aGUgcGFyZW50IHRyZWUsIGFkZCB0byBlYWNoIGxvZ1xyXG5cdHZhciBjaGVjayA9IHRoaXM7XHJcblx0aWYgKGNoZWNrLnBhcmVudCBpbnN0YW5jZW9mIEhpc3RvcnkpIHtcclxuXHRcdGNoZWNrLnBhcmVudC5hZGRTY29yZXMoZW50cnkpO1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcblxyXG4vL0EgdGVtcG9yYXJ5IEhpc3RvcnkgdGhhdCBjYW4gYmUgbWVyZ2VkIGJhY2sgaW4gbGF0ZXIuIFRoZSBjaGlsZCBhbmQgcGFyZW50IGFyZSBsaW5rZWQgdW50aWwgLm9ycGhhbigpIGlzIGNhbGxlZC5cclxuSGlzdG9yeS5wcm90b3R5cGUuY2hpbGQgPSBmdW5jdGlvbihwYXJlbnQgPSB0aGlzKSB7XHJcblx0dmFyIGggPSBuZXcgSGlzdG9yeSgpO1xyXG5cdGgucGFyZW50ID0gcGFyZW50O1xyXG5cdHJldHVybiBoO1xyXG59O1xyXG5cclxuLy9TYW1lIGFzIC5jaGlsZCBleGNlcHQgaW5jbHVkZXMgcHJpb3IgcGFyZW50IGhpc3Rvcnkgd2hlbiAucHJpbnQoKSBpcyBjYWxsZWQuXHJcbkhpc3RvcnkucHJvdG90eXBlLmNoaWxkV2l0aENvbnRlbnQgPSBmdW5jdGlvbihwYXJlbnQgPSB0aGlzKSB7XHJcblx0dmFyIHN0b3JlZExvZyA9IHBhcmVudC5zbGljZSgpO1xyXG5cdHZhciBzdG9yZWRTY29yZXMgPSBwYXJlbnQuc2xpY2UoKTtcclxuXHJcblx0dmFyIGggPSBuZXcgSGlzdG9yeSgpO1xyXG5cclxuXHJcblx0aC5sb2cucHJpbnQgPSBmdW5jdGlvbigpIHtcclxuXHRcdEhpc3RvcnkucHJvdG90eXBlLnByaW50LmNhbGwoc3RvcmVkTG9nLmNvbmNhdChoLmxvZykpXHJcblx0fVxyXG5cdGguc2NvcmVzLnByaW50ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRIaXN0b3J5LnByb3RvdHlwZS5wcmludC5jYWxsKHN0b3JlZFNjb3Jlcy5jb25jYXQoaC5zY29yZXMpKVxyXG5cdH1cclxuXHJcblx0aC5wYXJlbnQgPSBwYXJlbnQ7XHJcblx0cmV0dXJuIGg7XHJcbn07XHJcblxyXG4vL1RoaXMgc2V2ZXJzIHRoZSBsaW5rIGJldHdlZW4gdGhlIHRlbXBvcmFyeSBoaXN0b3J5IGFuZCBpdHMgcGFyZW50LiBVc2UgdGhpcyB3aGVuIG1lcmdpbmcgY29tcG9zaXRlIGVudHJpZXMuXHJcbkhpc3RvcnkucHJvdG90eXBlLm9ycGhhbiA9IGZ1bmN0aW9uKCkge1xyXG5cdGRlbGV0ZSB0aGlzLnBhcmVudDtcclxuXHRkZWxldGUgdGhpcy5sb2c7XHJcblx0ZGVsZXRlIHRoaXMuc2NvcmVzO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy9DbGVhciBoaXN0b3J5XHJcbkhpc3RvcnkucHJvdG90eXBlLmNsZWFySGlzdG9yeSA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMuc3BsaWNlKDAsIHRoaXMubGVuZ3RoKTtcclxuXHRpZiAodGhpcy5sb2cpIHRoaXMubG9nLnNwbGljZSgwLCB0aGlzLmxvZy5sZW5ndGgpO1xyXG5cdGlmICh0aGlzLnNjb3JlcykgdGhpcy5zY29yZXMuc3BsaWNlKDAsIHRoaXMuc2NvcmVzLmxlbmd0aCk7XHJcblx0ZGVsZXRlIHRoaXMucGFyZW50O1xyXG59O1xyXG5cclxuLy9FbmQgdGhlIGdhbWUuXHJcbkhpc3RvcnkucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMuc3RvcCA9IHRydWU7XHJcblx0aWYgKHRoaXMucGFyZW50KSB0aGlzLnBhcmVudC5lbmQoKTtcclxufTtcclxuXHJcbi8vR2V0IGEgcGFydGljdWxhciBzb3J0IG9mIGVudHJ5LCBlZy4gVHVybi5cclxuSGlzdG9yeS5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuXHRyZXR1cm4gbmV3IEhpc3RvcnkoXHJcblx0XHR0aGlzLmZpbHRlcihmdW5jdGlvbihlbnRyeSkge1xyXG5cdFx0XHQvL0lmIGl0J3Mgbm90IGFuIG9iamVjdCwgZG9uJ3QgZXZlbiBib3RoZXIuXHJcblx0XHRcdGlmICghaXNPYmplY3QoZW50cnkpKSByZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gZW50cnkpIHtcclxuXHRcdFx0XHRpZiAoa2V5ID09IHR5cGUpIHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9KVxyXG5cdCk7XHJcbn07XHJcblxyXG4vL0hlbHAgcmVhZCB0aGUgaGlzdG9yeSBpbiBDaHJvbWUgd2l0aCBsZXNzIGNsdXR0ZXIuXHJcbkhpc3RvcnkucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGhpc3RvcnkgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMpKTtcclxuXHRoaXN0b3J5LnF1ZXJ5ID0gSGlzdG9yeS5wcm90b3R5cGUucXVlcnlcclxuXHRyZXR1cm4gaGlzdG9yeTtcclxufTtcclxuXHJcbkhpc3RvcnkucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24ocXVlcnlTdHJpbmcsIC4uLmFyZ3MpIHtcclxuXHRyZXR1cm4ganNvbmF0YShxdWVyeVN0cmluZykuZXZhbHVhdGUodGhpcywgLi4uYXJncyk7XHJcbn1cclxuXHJcbi8vU3VwcGx5IGFuIGVudHJ5LCBpdCB3aWxsIGNoZWNrIGZvciBhIHByb3BlcnR5IHRoYXQgaXMgYSBIaXN0b3J5XHJcbkhpc3RvcnkucHJvdG90eXBlLnJlY3Vyc2UgPSBmdW5jdGlvbih0eXBlKSB7XHJcblx0dmFyIGxpc3QgPSB0aGlzO1xyXG5cclxuXHRyZXR1cm4gbmV3IEhpc3RvcnkoXHJcblx0XHRsaXN0Lm1hcChmdW5jdGlvbihlbnRyeSkge1xyXG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gZW50cnkpIHtcclxuXHRcdFx0XHRjb25zb2xlLmxvZyhrZXksIGVudHJ5KTtcclxuXHRcdFx0XHRpZiAoZW50cnlba2V5XSBpbnN0YW5jZW9mIEhpc3RvcnkpIHJldHVybiBlbnRyeVtrZXldLnJlY3Vyc2UodHlwZSk7XHJcblx0XHRcdFx0ZWxzZSBpZiAoa2V5ID09IHR5cGUpIHJldHVybiBlbnRyeTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH0pXHJcblx0KTtcclxufTtcclxuXHJcbi8vQWNjZXB0IGEgSGlzdG9yeSBhbmQgcmV0dXJuIG9uZSBzdWl0YWJsZSBmb3IgdGhlIHVzZXJcclxuZnVuY3Rpb24gVXNlckhpc3RvcnkoaGlzdG9yeSkge1xyXG5cdHZhciB1c2VySGlzdG9yeSA9IGhpc3RvcnkubWFwKGZ1bmN0aW9uKGVudHJ5KSB7XHJcblx0XHRyZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlbnRyeSkpO1xyXG5cdH0pO1xyXG5cclxuXHRPYmplY3Quc2V0UHJvdG90eXBlT2YodXNlckhpc3RvcnksIFVzZXJIaXN0b3J5LnByb3RvdHlwZSk7XHJcblxyXG5cdC8vQXR0YWNoIG1ldGhvZHMgZnJvbSBIaXN0b3J5LCB3cmFwcGVkIGluIGEgZnVuY3Rpb24uIElmIHRob3NlIG1ldGhvZHMgcmV0dXJuIGEgaGlzdG9yeSxcclxuXHQvL3RoZW4gdGhlIGZ1bmN0aW9uIHdpbGwgY29udmVydCB0aGF0IHRvIGEgdXNlckhpc3RvcnkuXHJcblx0Zm9yICh2YXIgbWV0aG9kIGluIEhpc3RvcnkucHJvdG90eXBlKSB7XHJcblx0XHRpZiAoaXNGdW5jdGlvbihoaXN0b3J5W21ldGhvZF0pKSB7XHJcblx0XHRcdGlmIChtZXRob2QgIT0gXCJjb25zdHJ1Y3RvclwiKVxyXG5cdFx0XHRcdHVzZXJIaXN0b3J5W21ldGhvZF0gPSAoZnVuY3Rpb24obWV0aG9kKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdHZhciByZXN1bHQgPSBoaXN0b3J5W21ldGhvZF0uYXBwbHkoaGlzdG9yeSwgYXJndW1lbnRzKTtcclxuXHRcdFx0XHRcdFx0aWYgKHJlc3VsdCBpbnN0YW5jZW9mIEhpc3RvcnkpIHJldHVybiBuZXcgVXNlckhpc3RvcnkocmVzdWx0KTtcclxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAoaXNPYmplY3QocmVzdWx0KSlcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyZXN1bHQpKTtcclxuXHRcdFx0XHRcdFx0ZWxzZSByZXR1cm4gcmVzdWx0O1xyXG5cdFx0XHRcdFx0fTtcclxuXHRcdFx0XHR9KShtZXRob2QpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHVzZXJIaXN0b3J5O1xyXG59XHJcblxyXG5Vc2VySGlzdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEhpc3RvcnkucHJvdG90eXBlKTtcclxuVXNlckhpc3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVXNlckhpc3Rvcnk7XHJcblxyXG52YXIgZ2FtZUhpc3RvcnkgPSBuZXcgSGlzdG9yeSgpOyAvL1RPRE86IGFkZCBjaG9pY2Utb25seSBoaXN0b3J5XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgSGlzdG9yeSwgVXNlckhpc3RvcnksIGdhbWVIaXN0b3J5IH07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy9XaGVuIGEgc3RyYXRlZ3kncyAuY2hvb3NlKCkgZnVuY3Rpb24gaXMgY2FsbGVkLCBpdCBpcyBnaXZlbiBhbiBpbmZvcm1hdGlvbiBzZXQuIFRoYXQgZGF0YSBpcyBhIGxpbWl0ZWQgbWFwIG9mIHRoZSBpbnRlcm5hbCBvYmplY3RzIG9mIHRoZSBnYW1lIGVuZ2luZSwgaW5jbHVkaW5nIGluZm9ybWF0aW9uIG9uIHRoZSBnYW1lIGhpc3RvcnkgYW5kIHRoZSBwbGF5ZXJzLiBUaGlzIGlzIHRocmVhZGVkIHRocm91Z2ggcGxheWFibGVzLCBtdWNoIGxpa2UgSGlzdG9yeSwgc28gdGhhdCBhIHBhcmVudCBwbGF5YWJsZSBjYW4gc3BlY2lmeSBhbiBpbmZvcm1hdGlvbiBzZXQgZm9yIHRoZSBwbGF5YWJsZXMgaXQgY2FsbHMsIG9yIGVsc2UgdGhlIGRlZmF1bHQgY29uc3RydWN0aW9uIHdpbGwgYmUgdXNlZC4gQWRkaXRpb25hbGx5LCB0aGUgdXNlciBjYW4gcHJvdmlkZSBhIGZpbHRlciBmdW5jdGlvbiwgdG8gc2VsZWN0aXZlbHkgZGVsZXRlIChvciBhZGQpIGluZm9ybWF0aW9uIGVsZW1lbnRzIGJlZm9yZSB0aGV5IGFyZSBwYXNzZWQgdG8gLmNob29zZSgpLlxyXG5cclxuLy9IaXN0b3J5IGZ1bmN0aW9uc1xyXG52YXIgeyBnYW1lSGlzdG9yeSwgSGlzdG9yeSB9ID0gcmVxdWlyZSgnLi9oaXN0b3J5Jyk7XHJcblxyXG4vL1BvcHVsYXRpb24gZnVuY3Rpb25zXHJcbnZhciB7IGdhbWVQb3B1bGF0aW9uLCBQbGF5ZXJMaXN0IH0gPSByZXF1aXJlKCcuL3BvcHVsYXRpb24nKTtcclxuXHJcblxyXG5mdW5jdGlvbiBJbmZvcm1hdGlvbihoaXN0b3J5ID0gZ2FtZUhpc3RvcnksIHBvcHVsYXRpb24gPSBnYW1lUG9wdWxhdGlvbikge1xyXG5cdHRoaXMuaGlzdG9yeSA9IGhpc3Rvcnk7XHJcblx0dGhpcy5wb3B1bGF0aW9uID0gcG9wdWxhdGlvbjtcclxuXHJcblx0dGhpcy5hZGRpdGlvbmFsID0gW107XHJcblxyXG5cdHRoaXMudXBkYXRlKCk7XHJcbn07XHJcblxyXG4vL0NoZWNrIHRoZSBzb3VyY2UgdGhlbiBjYWNoZSBhIGhhcmQtY29weS5cclxuSW5mb3JtYXRpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKHBsYXllciwgbG9jYWwpIHtcclxuXHR0aGlzLmluZm9Qb3B1bGF0aW9uID0gdGhpcy5wb3B1bGF0aW9uKCkuaW5mbygpO1xyXG5cclxuXHR0aGlzLmluZm9IaXN0b3J5ID0geyBsb2c6IHRoaXMuaGlzdG9yeS5sb2cucHJpbnQoKSwgc2NvcmVzOiB0aGlzLmhpc3Rvcnkuc2NvcmVzLnByaW50KCkgfTtcclxuXHJcblx0dGhpcy5hZGRpdGlvbmFsID0gW107XHJcblxyXG5cdC8vUmV0dXJuIHZhbHVlLiBNaW1pY3MgLmRlbGl2ZXIoKVxyXG5cdHZhciBpbmZvcm1hdGlvbiA9IHtcclxuXHRcdGhpc3Rvcnk6IHsgbG9nOiB0aGlzLmluZm9IaXN0b3J5LmxvZywgc2NvcmVzOiB0aGlzLmluZm9IaXN0b3J5LnNjb3JlcyB9LFxyXG5cdFx0cG9wdWxhdGlvbjogdGhpc1xyXG5cdFx0XHQuaW5mb1BvcHVsYXRpb25cclxuXHR9XHJcblx0aWYgKHBsYXllcikgaW5mb3JtYXRpb24ubWUgPSBpbmZvcm1hdGlvbi5wb3B1bGF0aW9uLmdldChwbGF5ZXIuaWQpO1xyXG5cdGlmIChsb2NhbCkgT2JqZWN0LmFzc2lnbihpbmZvcm1hdGlvbiwgbG9jYWwpO1xyXG5cclxuXHRyZXR1cm4gaW5mb3JtYXRpb247XHJcbn07XHJcblxyXG4vL0Nsb25lIHRoZSBjYWNoZWQgY29waWVzIGFuZCBwcm92aWRlIHRoZW0uIFdpbGwgZGVsaXZlciB0aGUgc2FtZSB0aGluZyBldmVyeSB0aW1lIHVudGlsIHVwZGF0ZSBpcyBjYWxsZWQuXHJcbkluZm9ybWF0aW9uLnByb3RvdHlwZS5kZWxpdmVyID0gZnVuY3Rpb24ocGxheWVyLCBsb2NhbCkge1xyXG5cdHZhciBpbmZvcm1hdGlvbiA9IHtcclxuXHRcdGhpc3Rvcnk6IHsgbG9nOiB0aGlzLmluZm9IaXN0b3J5LmxvZywgc2NvcmVzOiB0aGlzLmluZm9IaXN0b3J5LnNjb3JlcyB9LFxyXG5cdFx0cG9wdWxhdGlvbjogdGhpc1xyXG5cdFx0XHQuaW5mb1BvcHVsYXRpb25cclxuXHR9XHJcblxyXG5cclxuXHRpZiAocGxheWVyKSBpbmZvcm1hdGlvbi5tZSA9IGluZm9ybWF0aW9uLnBvcHVsYXRpb24uZ2V0KHBsYXllci5pZCk7XHJcblx0aWYgKGxvY2FsKSBPYmplY3QuYXNzaWduKGluZm9ybWF0aW9uLCBsb2NhbCk7XHJcblx0aWYgKHRoaXMuYWRkaXRpb25hbCkgdGhpcy5hZGRpdGlvbmFsLmZvckVhY2goZnVuY3Rpb24oZW50cnkpIHsgT2JqZWN0LmFzc2lnbihpbmZvcm1hdGlvbiwgZW50cnkpIH0pO1xyXG5cclxuXHRyZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShpbmZvcm1hdGlvbikpO1xyXG59O1xyXG5cclxuLy9UaGlzIHByb2JhYmx5IGRvZXNuJ3QgbmVlZCB0byBiZSBhIHNlcGFyYXRlIGZ1bmN0aW9uLCBidXQgYWRkaW5nIGl0IGluIGNhc2UgaXQgZXhwYW5kcyBsYXRlci5cclxuSW5mb3JtYXRpb24ucHJvdG90eXBlLmFkZEFkZGl0aW9uYWwgPSBmdW5jdGlvbihlbnRyeSA9IG51bGwpIHtcclxuXHRpZiAoZW50cnkpIHRoaXMuYWRkaXRpb25hbC5wdXNoKGVudHJ5KTtcclxufTtcclxuXHJcbi8vTWFrZSBjb3B5IG9mIHRoaXMgaW5mb3JtYXRpb24gZnVuY3Rpb24sIHdoaWNoIGFsbG93cyBmb3IgdXBkYXRpbmcgYW5kIGZyZWV6aW5nLlxyXG5JbmZvcm1hdGlvbi5wcm90b3R5cGUuY2hpbGQgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgaW5mb3JtYXRpb24gPSBuZXcgSW5mb3JtYXRpb24odGhpcy5oaXN0b3J5LCB0aGlzLnBvcHVsYXRpb24pO1xyXG5cclxuXHRyZXR1cm4gaW5mb3JtYXRpb247XHJcbn07XHJcblxyXG5cclxuXHJcbi8vR2FtZSBzdGF0ZSwgYW5hbG9nb3VzIHRvIGdhbWVIaXN0b3J5XHJcbnZhciBQZXJmZWN0SW5mb3JtYXRpb24gPSBuZXcgSW5mb3JtYXRpb24oZ2FtZUhpc3RvcnksIGdhbWVQb3B1bGF0aW9uKTtcclxuXHJcbi8vT3ZlcndyaXRlIC5kZWxpdmVyKCkuIFBlcmZlY3RJbmZvcm1hdGlvbiBpcyBhbHdheXMgdXAtdG8tZGF0ZSEgVGh1cyBubyBuZWVkIHRvIGRvIGEgMm5kIEpTT04uc3RyaW5naWZ5LlxyXG5QZXJmZWN0SW5mb3JtYXRpb24uZGVsaXZlciA9IGZ1bmN0aW9uKHBsYXllciwgbG9jYWwpIHtcclxuXHJcblx0dmFyIGluZm9ybWF0aW9uID0gdGhpcy51cGRhdGUocGxheWVyLCBsb2NhbCk7XHJcblxyXG5cdGlmIChwbGF5ZXIpIGluZm9ybWF0aW9uLm1lID0gaW5mb3JtYXRpb24ucG9wdWxhdGlvbi5nZXQocGxheWVyLmlkKTtcclxuXHRpZiAobG9jYWwpIE9iamVjdC5hc3NpZ24oaW5mb3JtYXRpb24sIGxvY2FsKTtcclxuXHJcblx0cmV0dXJuIGluZm9ybWF0aW9uO1xyXG59O1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0geyBJbmZvcm1hdGlvbiwgUGVyZmVjdEluZm9ybWF0aW9uIH07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcblxyXG52YXIgbG9nZ2VyID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGFyZ3MgPSBbLi4uYXJndW1lbnRzXTtcclxuXHR2YXIgbGV2ZWwgPSAoYXJnc1swXSA9PSBcInNpbGx5XCIgfHwgIWFyZ3NbMF0pID8gXCJ0cmFjZVwiIDogYXJnc1swXTtcclxuXHRhcmdzLnNoaWZ0KCk7XHJcblxyXG5cdGxvZ2dlci5sb2dnZXJbbGV2ZWxdLmFwcGx5KGxvZ2dlci5sb2dnZXIsIGFyZ3MpO1xyXG59O1xyXG5cclxuLy9sb2dnZXIubG9nZ2VyID0gY29uc29sZTtcdFx0XHRcdFx0Ly9UT0RPIGNsZWFuIHRoaXMgYWxsIHVwIGEgbG90LlxyXG5cclxudmFyIGdldExvZ2dlciA9IHJlcXVpcmUoXCJsb2dsZXZlbC1jb2xvcmVkLWxldmVsLXByZWZpeFwiKTtcclxudmFyIG9wdGlvbnMgPSB7IHByZWZpeDogJ25hc2hKUycsIGxldmVsOiAndHJhY2UnIH1cclxubG9nZ2VyLmxvZ2dlciA9IGdldExvZ2dlcihvcHRpb25zKVxyXG5cclxubG9nZ2VyLnNldExldmVsID0gZnVuY3Rpb24obGV2ZWwpIHtcclxuXHRsb2dnZXIubG9nZ2VyLmxldmVsID0gbGV2ZWw7XHJcblx0bG9nZ2VyLmxvZ2dlci5zZXRMZXZlbChsZXZlbClcclxufTtcclxuXHJcbi8qXHJcbmxvZ2dlci51c2VXaW5zdG9uID0gZnVuY3Rpb24oKXtcclxuXHJcblx0dmFyIHdpbnN0b24gPSByZXF1aXJlKCd3aW5zdG9uJyk7XHJcblx0dmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XHJcblxyXG5cdHdpbnN0b24ubGV2ZWwgPSBcIndhcm5cIjtcclxuXHJcblx0d2luc3Rvbi5jbGVhcigpXHJcblx0d2luc3Rvbi5hZGQod2luc3Rvbi50cmFuc3BvcnRzLkNvbnNvbGUsIHtcclxuXHRcdGxldmVsOiAndHJhY2UnLFxyXG5cdFx0cHJldHR5UHJpbnQ6ICBmdW5jdGlvbiAoIG9iamVjdCApe1xyXG5cdFx0XHRyZXR1cm4gdXRpbC5pbnNwZWN0KG9iamVjdCk7XHJcblx0XHR9LFxyXG5cdFx0Y29sb3JpemU6IHRydWUsXHJcblx0XHRzaWxlbnQ6IGZhbHNlLFxyXG5cdFx0dGltZXN0YW1wOiBmYWxzZVxyXG5cdH0pO1xyXG5cclxuXHR0aGlzLmxvZ2dlciA9IHdpbnN0b247XHJcbn07XHJcbiovXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGxvZ2dlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZSgnLi9sb2dnZXInKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIge2lzRnVuY3Rpb259ID0gcmVxdWlyZSgnLi9oZWxwZXJGdW5jdGlvbnMnKSgnZ2VuZXJhbCcpO1xyXG5cclxuXHJcbi8vIEV4dGVuZCBmdW5jdGlvbiwgdGhlIHNuZWFreSB3YXkuXHJcbnZhciB2YXJpYWJsZVByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRnVuY3Rpb24ucHJvdG90eXBlKTtcclxuXHJcblxyXG52YXJpYWJsZVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdFxyXG5cdHZhciB2YXJpYWJsZSA9IHRoaXM7XHJcblx0dmFyaWFibGUudmFsdWUgPSB2YWx1ZTtcdFx0XHRcdFx0XHRcdFx0Ly9UT0RPOiBhZGQgYSB3YXkgdG8gaGF2ZSBhIGZ1bmN0aW9uIHRoYXQgYXV0b21hdGljYWxseSBnZW5lcmF0ZXMgYSB2YWx1ZS5cclxuXHJcblx0dGhpcy5pZCA9IGZ1bmN0aW9uKCl7cmV0dXJuIF9wbGF5YWJsZS5pZDt9O1x0XHRcdC8vVE9ETzogd29yayBvbiBpZHMgYW5kIHJlZ2lzdHJhdGlvblxyXG59O1xyXG5cclxuXHJcbnZhcmlhYmxlUHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoKSB7XHJcblx0cmV0dXJuIHRoaXMudmFsdWU7XHJcbn07XHJcblx0XHJcbnZhcmlhYmxlUHJvdG90eXBlLnRvSlNPTiBcdD0gZnVuY3Rpb24oKXtcclxuXHRyZXR1cm4gdGhpcy5jYWxsKCk7XHJcbn1cdFx0XHJcbnZhcmlhYmxlUHJvdG90eXBlLnRvU3RyaW5nIFx0PSBmdW5jdGlvbigpe1xyXG5cdHJldHVybiB0aGlzLmNhbGwoKTtcclxufVxyXG52YXJpYWJsZVByb3RvdHlwZS52YWx1ZU9mIFx0PSBmdW5jdGlvbigpe1xyXG5cdHJldHVybiB0aGlzLmNhbGwoKTtcclxufTtcclxuXHJcblxyXG52YXJpYWJsZVByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuZXdWYWx1ZSl7XHJcblx0dGhpcy52YWx1ZSA9IG5ld1ZhbHVlO1xyXG5cdHJldHVybiB0aGlzLnZhbHVlO1xyXG59O1xyXG5cclxuXHJcblxyXG4vL1JlcHVycG9zZSB0aGUgdmVyeS1zaW1pbGFyIGNvZGUgZm9yIFZhcmlhYmxlLCBidXQgcmUtd3JpdGUgY2VydGFpbiBrZXlzXHJcbnZhciBleHByZXNzaW9uUHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGdW5jdGlvbi5wcm90b3R5cGUpO1xyXG5cclxuZXhwcmVzc2lvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKGV4cHJlc3Npb24pe1xyXG5cdGlmICghaXNGdW5jdGlvbihleHByZXNzaW9uKSkgbG9nKFwiZXJyb3JcIiwgXCJFeHByZXNzaW9uIG11c3QgYmUgYSBmdW5jdGlvbi5cIik7XHJcblx0XHJcblx0dmFyIHZhbHVlID0gZXhwcmVzc2lvbigpO1xyXG5cdGlmIChpc05hTih2YWx1ZSkpIGxvZyhcImVycm9yXCIsIFwiRXhwcmVzc2lvbiBtdXN0IHJldHVybiBhIG51bWJlclwiKTtcdFx0XHQvL1RPRE86IHNob3VsZCBFeHByZXNzaW9ucy9WYXJpYWJsZXMgYWxsb3cgc3RyaW5ncz9cclxuXHRcdFxyXG5cdHRoaXMudmFsdWUgPSBleHByZXNzaW9uO1x0XHJcblx0XHJcblx0cmV0dXJuIHZhbHVlO1xyXG59O1xyXG5cclxuZXhwcmVzc2lvblByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24oKXtcclxuXHRyZXR1cm4gdGhpcy52YWx1ZSgpICogMTtcclxufTtcclxuXHJcbmV4cHJlc3Npb25Qcm90b3R5cGUudG9KU09OXHQgXHQ9IGZ1bmN0aW9uKCl7XHJcblx0cmV0dXJuIHRoaXMuY2FsbCgpO1xyXG59XHJcbmV4cHJlc3Npb25Qcm90b3R5cGUudG9TdHJpbmcgXHQ9IGZ1bmN0aW9uKCl7XHJcblx0cmV0dXJuIHRoaXMuY2FsbCgpO1xyXG59XHJcbmV4cHJlc3Npb25Qcm90b3R5cGUudmFsdWVPZiBcdD0gZnVuY3Rpb24oKXtcclxuXHRyZXR1cm4gdGhpcy5jYWxsKCk7XHJcbn07XHJcblxyXG5leHByZXNzaW9uUHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5ld0V4cHJlc3Npb24pe1xyXG5cdGlmICghaXNGdW5jdGlvbihuZXdFeHByZXNzaW9uKSkgbG9nKFwiZXJyb3JcIiwgXCJFeHByZXNzaW9uIG11c3QgYmUgYSBmdW5jdGlvbi5cIik7XHJcblx0XHJcblx0dmFyIHZhbHVlID0gbmV3RXhwcmVzc2lvbigpO1xyXG5cdHRoaXMudmFsdWUgPSBuZXdFeHByZXNzaW9uO1xyXG5cdFxyXG5cdHJldHVybiB2YWx1ZTtcclxufTtcclxuXHJcblxyXG5cclxuLy9Qcm9kdWNlcyB0aGUgZnVuY3Rpb24gdGhhdCB3aWxsIHByb2R1Y2UgdGhlIGVuZCByZXN1bHQuIFRoaXMgcGFydCBpcyByZXVzYWJsZSBpZiB5b3UgbmVlZCB0byBkbyB0aGlzIGFnYWluLlxyXG52YXIgY2xhc3NGYWN0b3J5ID0gZnVuY3Rpb24gKHByb3RvKSB7XHJcblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHRcdFxyXG5cdFx0dmFyIGYgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHJldHVybiBmLmNhbGwuYXBwbHkoZiwgYXJndW1lbnRzKTsgICAgICBcclxuXHRcdH07XHJcblx0XHRcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCBcImNvbnN0cnVjdG9yXCIsIHtjb25maWd1cmFibGU6dHJ1ZSwgd3JpdGFibGU6dHJ1ZX0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIFwiY2FsbFwiLCB7d3JpdGFibGU6dHJ1ZX0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIFwidG9TdHJpbmdcIiwge3dyaXRhYmxlOnRydWV9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCBcInZhbHVlT2ZcIiwge3dyaXRhYmxlOnRydWV9KTtcclxuXHRcdFxyXG5cdFx0T2JqZWN0LmtleXMocHJvdG8pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG5cdFx0XHRmW2tleV0gPSBwcm90b1trZXldO1xyXG5cdFx0fSk7XHJcblx0XHRcclxuXHRcdGYuY29uc3RydWN0b3IuYXBwbHkoZiwgYXJndW1lbnRzKTtcdFx0XHJcblx0XHRcclxuXHRcdHJldHVybiBmO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG52YXIgVmFyaWFibGUgPSBjbGFzc0ZhY3RvcnkodmFyaWFibGVQcm90b3R5cGUpO1xyXG52YXIgRXhwcmVzc2lvbiA9IGNsYXNzRmFjdG9yeShleHByZXNzaW9uUHJvdG90eXBlKTtcclxuLy8gY2FsbGVkIGFzOiB2YXIgaW5zdGFuY2UgPSBWYXJpYWJsZSgpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7dmFyaWFibGVQcm90b3R5cGUsIFZhcmlhYmxlLCBleHByZXNzaW9uUHJvdG90eXBlLCBFeHByZXNzaW9ufTsiLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKFwiLi4vbG9nZ2VyXCIpO1xyXG5sb2coXCJkZWJ1Z1wiLCBcIkxvYWRpbmcgQ2xhc3M6IENob2ljZVwiKTtcclxuXHJcbi8vIEV4dGVybmFsIGRlcGVuZGVuY3lcclxudmFyIHsgU3luY2hyb25vdXNQcm9taXNlIH0gPSByZXF1aXJlKFwic3luY2hyb25vdXMtcHJvbWlzZVwiKTtcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIgeyByZWdpc3RyeSB9ID0gcmVxdWlyZShcIi4uL3N0YXRlXCIpO1xyXG52YXIgeyBnYW1lSGlzdG9yeSB9ID0gcmVxdWlyZShcIi4uL2hpc3RvcnlcIik7XHJcbnZhciB7IFBlcmZlY3RJbmZvcm1hdGlvbiB9ID0gcmVxdWlyZShcIi4uL2luZm9ybWF0aW9uXCIpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGlkSGFuZGxlciB9ID0gcmVxdWlyZShcIi4uL2hlbHBlckZ1bmN0aW9uc1wiKShcInN0YXRlXCIpO1xyXG52YXIgeyBpc0Z1bmN0aW9uIH0gPSByZXF1aXJlKFwiLi4vaGVscGVyRnVuY3Rpb25zXCIpKFwiZ2VuZXJhbFwiKTtcclxudmFyIHsgY2hhaW5lckdlbmVyYXRvciB9ID0gcmVxdWlyZShcIi4uL2hlbHBlckZ1bmN0aW9uc1wiKShcInBsYXlhYmxlXCIpO1xyXG5cclxuLy9QYXJlbnQgY2xhc3NcclxudmFyIHsgX1BsYXlhYmxlLCBQbGF5YWJsZSB9ID0gcmVxdWlyZShcIi4vcGxheWFibGVcIik7XHJcblxyXG4vL0JhY2tlbmQgZnVuY3Rpb24gY2xhc3MgZm9yIENob2ljZVxyXG5mdW5jdGlvbiBfQ2hvaWNlKGlkLCBwbGF5ZXIsIG9wdGlvbnMsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdF9QbGF5YWJsZS5jYWxsKHRoaXMsIGlkKTtcclxuXHJcblx0dGhpcy5uZXh0ID0ge307XHJcblxyXG5cdHRoaXMucGxheWVyID0gcmVnaXN0cnkucGxheWVyc1twbGF5ZXJdO1xyXG5cdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcblx0dGhpcy5kZWZhdWx0T3B0aW9uID0gcGFyYW1ldGVycy5kZWZhdWx0T3B0aW9uIHx8IG9wdGlvbnNbMF07IC8vVE9ETzogbWFrZSBkZWZhdWx0T3B0aW9uIGZ1bmN0aW9uYWxcclxuXHR0aGlzLmluZm9ybWF0aW9uRmlsdGVyID0gcGFyYW1ldGVycy5pbmZvcm1hdGlvbkZpbHRlciB8fCBudWxsO1xyXG5cclxuXHRyZWdpc3RyeS5jaG9pY2VzW2lkXSA9IHRoaXM7XHJcblxyXG5cdHZhciBjaG9pY2UgPSB0aGlzO1xyXG5cdHRoaXMub3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcclxuXHRcdGNob2ljZS5uZXh0W2l0ZW1dID0gW107XHJcblx0fSk7XHJcbn1cclxuXHJcbl9DaG9pY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShfUGxheWFibGUucHJvdG90eXBlKTtcclxuX0Nob2ljZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBfQ2hvaWNlO1xyXG5cclxuX0Nob2ljZS5yZWdpc3RyeU5hbWUgPSBcImNob2ljZXNcIjtcclxuX0Nob2ljZS5jb3VudGVyTmFtZSA9IFwiY2hvaWNlXCI7XHJcblxyXG5fQ2hvaWNlLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24oe1xyXG5cdHVzZVBheW9mZnMgPSBmYWxzZSxcclxuXHRoaXN0b3J5ID0gZ2FtZUhpc3RvcnksXHJcblx0aW5mb3JtYXRpb246IHJhd0luZm9ybWF0aW9uID0gUGVyZmVjdEluZm9ybWF0aW9uLFxyXG5cdHJlbGVhc2VQbGF5ZXIgPSB0cnVlLFxyXG5cdGluZm9ybWF0aW9uRmlsdGVyID0gdGhpcy5pbmZvcm1hdGlvbkZpbHRlcixcclxuXHRfY29tcGlsZUluZm9ybWF0aW9uID0gbnVsbFxyXG59ID0ge30pIHtcclxuXHR2YXIgY2hvaWNlID0gdGhpcztcclxuXHJcblx0aWYgKCFjaG9pY2UucGxheWVyLmFsaXZlKVxyXG5cdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KHtcclxuXHRcdFx0cmVzdWx0OiBjaG9pY2UuaWQgKyBcIjogUGxheWVyIFwiICsgY2hvaWNlLnBsYXllci5pZCArIFwiIGlzIGRlYWQuXCJcclxuXHRcdH0pO1xyXG5cclxuXHQvL1doaWxlIHRoaXMgY2hvaWNlIGlzIGhhcHBlbmluZywgZG9uJ3QgYWxsb3cgb3RoZXIgY2hvaWNlcyB0byB1c2UgdGhpcyBwbGF5ZXIuXHJcblx0Y2hvaWNlLnBsYXllci5hdmFpbGFibGUgPSBmYWxzZTtcclxuXHJcblx0Ly9JbmZvcm1hdGlvbiBtZWNoYW5pY3MuIElmIHdlJ3JlIGRlYWxpbmcgd2l0aCBQZXJmZWN0SW5mb3JtYXRpb24sIHRoaXMgd29uJ3QgZ2V0IGRlbGl2ZXJlZCwgc28gd2UnbGwgaW5jbHVkZSBpdCBpbiB0aGUgY2FsbCB0byAuZGVsaXZlcigpLiBJZiB3ZSdyZSB1c2luZyBhbiBpbmZvcm1hdGlvbiBzdXBwbGllZCBmcm9tIHNvbWUgb3RoZXIgcGxheWFibGUsIHRoZW4gdGhleSBjYW4gZG8gd2hhdCB0aGV5IGxpa2Ugd2l0aCBpdC5cclxuXHR2YXIgY2hvaWNlSW5mbyA9IHtcclxuXHRcdGNob2ljZToge1xyXG5cdFx0XHRpZDogY2hvaWNlLmlkLFxyXG5cdFx0XHRwbGF5ZXI6IGNob2ljZS5wbGF5ZXIuaWQsXHJcblx0XHRcdG9wdGlvbnM6IGNob2ljZS5vcHRpb25zXHJcblx0XHR9XHJcblx0fTtcclxuXHRyYXdJbmZvcm1hdGlvbi5hZGRBZGRpdGlvbmFsKGNob2ljZUluZm8pO1xyXG5cdC8vUGVyZm9ybSBzb21lIGRhdGEgcHJvY2Vzc2luZyBpZiBvdGhlciBwbGF5YWJsZXMgbmVlZCBpdC5cclxuXHRpZiAoX2NvbXBpbGVJbmZvcm1hdGlvbikgX2NvbXBpbGVJbmZvcm1hdGlvbihyYXdJbmZvcm1hdGlvbik7XHJcblxyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxyXG5cdFx0LnRoZW4oZnVuY3Rpb24oKSB7XHJcblx0XHRcdC8vUHJlcCBpbmZvcm1hdGlvblxyXG5cdFx0XHR2YXIgaW5mb3JtYXRpb24gPSByYXdJbmZvcm1hdGlvbi5kZWxpdmVyKGNob2ljZS5wbGF5ZXIsIGNob2ljZUluZm8pO1xyXG5cdFx0XHRpZiAoaW5mb3JtYXRpb25GaWx0ZXIpIGluZm9ybWF0aW9uID0gaW5mb3JtYXRpb25GaWx0ZXIoaW5mb3JtYXRpb24pO1xyXG5cclxuXHRcdFx0cmV0dXJuIGNob2ljZS5wbGF5ZXIuY2hvb3NlKGNob2ljZS5vcHRpb25zLnNsaWNlKDApLCBpbmZvcm1hdGlvbik7XHJcblx0XHR9KVxyXG5cdFx0LnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdHZhciBwbGF5ZXIgPSBjaG9pY2UucGxheWVyO1xyXG5cdFx0XHR2YXIgaWQgPSBjaG9pY2UuaWQ7XHJcblxyXG5cdFx0XHQvL0FkZCB0byBwbGF5ZXIncyBpbmRpdmlkdWFsIGhpc3Rvcnk7XHJcblx0XHRcdHBsYXllci5oaXN0b3J5LnB1c2goe1xyXG5cdFx0XHRcdGNob2ljZTogaWQsXHJcblx0XHRcdFx0b3B0aW9uczogY2hvaWNlLm9wdGlvbnMsXHJcblx0XHRcdFx0cmVzdWx0XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0cmVzdWx0ID0gcmVzdWx0IHx8IGNob2ljZS5kZWZhdWx0T3B0aW9uO1xyXG5cclxuXHRcdFx0dmFyIHJlc3VsdE9iamVjdCA9IHtcclxuXHRcdFx0XHRyZXN1bHQsXHJcblx0XHRcdFx0aGlzdG9yeUVudHJ5OiB7XHJcblx0XHRcdFx0XHRjaG9pY2U6IGlkLFxyXG5cdFx0XHRcdFx0cGxheWVyOiBwbGF5ZXIuaWQsXHJcblx0XHRcdFx0XHRtb3ZlOiByZXN1bHRcclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHQvL1RoaXMgd2lsbCBwcm9iYWJseSBvbmx5IGhhcHBlbiBpZiBpdCdzIGEgc2luZ2xlLXBsYXllciBnYW1lLCBvdGhlcndpc2Ugd2UnbGwgdXNlIHBsYXlvZmZzIGRlZmluZWQgaW4gYSBUdXJuXHJcblx0XHRcdGlmICh1c2VQYXlvZmZzKSB7XHJcblx0XHRcdFx0dmFyIHBheW91dCA9IGNob2ljZS5wYXlvZmZzW3Jlc3VsdF07XHJcblxyXG5cdFx0XHRcdHBsYXllci5zY29yZSArPSBwYXlvdXQ7XHJcblxyXG5cdFx0XHRcdC8vdHJhY2sgdGhlIHBheW9mZlxyXG5cdFx0XHRcdHZhciBzY29yZUVudHJ5ID0ge1xyXG5cdFx0XHRcdFx0Y2hvaWNlOiBpZCxcclxuXHRcdFx0XHRcdHBheW91dHM6IHtcclxuXHRcdFx0XHRcdFx0W3BsYXllci5pZF06IE51bWJlcihwYXlvdXQpXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0aGlzdG9yeS5hZGRTY29yZXMoc2NvcmVFbnRyeSk7XHJcblx0XHRcdFx0cmVzdWx0T2JqZWN0Lmhpc3RvcnlFbnRyeS5wYXlvdXRzID0ge1xyXG5cdFx0XHRcdFx0W3BsYXllci5pZF06IHBheW91dCB9O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsb2coXHJcblx0XHRcdFx0XCJzaWxseVwiLFxyXG5cdFx0XHRcdFwiX0Nob2ljZS5wbGF5OiByZW1vdmluZyBmcm9tIG9jY3VwaWVkUGxheWVyczogXCIsXHJcblx0XHRcdFx0Y2hvaWNlLnBsYXllci5pZFxyXG5cdFx0XHQpO1xyXG5cdFx0XHRpZiAocmVsZWFzZVBsYXllcikgY2hvaWNlLnJlbGVhc2VQbGF5ZXIoKTtcclxuXHJcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0T2JqZWN0KTsgLy9UT0RPOiBhZGQgaW5mb3JtYXRpb24gbWVjaGFuaXNtc1xyXG5cdFx0fSk7XHJcbn07XHJcblxyXG4vL1JlbGVhc2UgcGxheWVyIGZyb20gZXhjbHVkZWQgcGxheWVycyBsaXN0LCBzbyB0aGF0IG90aGVyIG9iamVjdHMgY2FuIHVzZSBpdC5cclxuX0Nob2ljZS5wcm90b3R5cGUucmVsZWFzZVBsYXllciA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMucGxheWVyLmF2YWlsYWJsZSA9IHRydWU7XHJcbn07XHJcblxyXG5fQ2hvaWNlLnByb3RvdHlwZS5maW5kTmV4dCA9IGZ1bmN0aW9uKHsgcmVzdWx0IH0gPSB7fSkge1xyXG5cdHJldHVybiB0aGlzLm5leHRbcmVzdWx0LnJlc3VsdF07XHJcbn07XHJcblxyXG5fQ2hvaWNlLnByb3RvdHlwZS5nZW5lcmF0ZUNoYWluaW5nRnVuY3Rpb25zID0gZnVuY3Rpb24oY2hvaWNlKSB7XHJcblx0dmFyIF9jaG9pY2UgPSB0aGlzO1xyXG5cclxuXHRfY2hvaWNlLm9wdGlvbnMuZm9yRWFjaChmdW5jdGlvbihvcHRpb24pIHtcclxuXHRcdF9jaG9pY2UucGF5b2Zmc1tvcHRpb25dID0gMDsgLy9TdGFydCBwYXlvZmZzIGF0IHplcm9cclxuXHJcblx0XHRjaG9pY2Vbb3B0aW9uXSA9IGZ1bmN0aW9uKHBheW9mZikge1xyXG5cdFx0XHQvL0NyZWF0ZSBmdW5jdGlvbnMgZm9yIHVzZXIgdG8gYXNzaWduIHBheW9mZnNcclxuXHRcdFx0aWYgKCFpc05hTihwYXlvZmYpKSBfY2hvaWNlLnBheW9mZnNbb3B0aW9uXSA9IHBheW9mZjtcclxuXHRcdFx0cmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlKHtcclxuXHRcdFx0XHRwbGF5YWJsZTogY2hvaWNlLFxyXG5cdFx0XHRcdHBhdGg6IFtvcHRpb25dXHJcblx0XHRcdH0pO1xyXG5cdFx0fTtcclxuXHR9KTtcclxufTtcclxuXHJcbl9DaG9pY2UucHJvdG90eXBlLnN1bW1hcnlUaGlzID0gZnVuY3Rpb24oc3VtbWFyeSkge1xyXG5cdHN1bW1hcnkucGxheWVyID0gdGhpcy5wbGF5ZXIuaWQ7XHJcblx0c3VtbWFyeS5vcHRpb25zID0gdGhpcy5vcHRpb25zLnNsaWNlKCk7XHJcblxyXG5cdHJldHVybiBzdW1tYXJ5O1xyXG59O1xyXG5cclxuLy9UT0RPOiB1bi1mdWNrIHRoaXMuXHJcbl9DaG9pY2UucHJvdG90eXBlLnN1bW1hcnlOZXh0ID0gZnVuY3Rpb24oXHJcblx0c3VtbWFyeSxcclxuXHRlbnRyaWVzID0ge30sXHJcblx0c2hvcnRDaXJjdWl0ID0gZmFsc2UsXHJcblx0bWF4RW50cmllcyA9IDEwXHJcbikge1xyXG5cdC8vIENvcHkgb3ZlciB0aGUgY2hvaWNlIG9wdGlvbnNcclxuXHRzdW1tYXJ5Lm5leHQgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm5leHQpO1xyXG5cclxuXHQvLyBMb29wIHRocm91Z2ggdGhlbSBhbmQgc3VtbWFyaXplIGF0IGVhY2ggc3RlcC5cclxuXHR2YXIgY291bnQgPSAwO1xyXG5cdGZvciAodmFyIGtleSBpbiBzdW1tYXJ5Lm5leHQpIHtcclxuXHRcdHN1bW1hcnkubmV4dFtrZXldID0gc3VtbWFyeS5uZXh0W2tleV0ubWFwKGZ1bmN0aW9uKHBsYXlhYmxlKSB7XHJcblx0XHRcdGNvdW50Kys7XHJcblx0XHRcdHJldHVybiBwbGF5YWJsZS5zdW1tYXJpemUoe30sIGVudHJpZXMpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHQvLyBJZiB0aGVyZSB3ZXJlbid0IGFueSBuZXh0IHN0ZXBzLCBkZWxldGUgdGhlIG5leHQga2V5LCB0byByZWR1Y2UgY2x1dHRlci5cclxuXHRpZiAoY291bnQgPT0gMCkgZGVsZXRlIHN1bW1hcnkubmV4dDtcclxuXHJcblx0cmV0dXJuIHN1bW1hcnk7XHJcbn07XHJcblxyXG4vL1NldCBhbGwgcGF5b2ZmcyB0byB6ZXJvLlxyXG5fQ2hvaWNlLnByb3RvdHlwZS56ZXJvUGF5b2ZmcyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjaG9pY2UgPSB0aGlzO1xyXG5cclxuXHRjaG9pY2UucGF5b2ZmcyA9IHt9O1xyXG5cclxuXHRjaG9pY2Uub3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKG9wdGlvbikge1xyXG5cdFx0Y2hvaWNlLnBheW9mZnNbb3B0aW9uXSA9IDA7XHJcblx0fSk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBDaG9pY2UocGxheWVyLCBvcHRpb25zLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHR2YXIgaWQgPSBpZEhhbmRsZXIocGFyYW1ldGVycy5pZCwgXCJjaG9pY2VcIik7XHJcblxyXG5cdC8vSWYgaW5mb3JtYXRpb25GaWx0ZXIgd2FzIHN1cHBsaWVkLCBpdCBtdXN0IGJlIGEgZnVuY3Rpb25cclxuXHRpZiAocGFyYW1ldGVycy5pbmZvcm1hdGlvbkZpbHRlciAmJiAhaXNGdW5jdGlvbihwYXJhbWV0ZXJzLmluZm9ybWF0aW9uRmlsdGVyKSlcclxuXHRcdHRocm93IG5ldyBFcnJvcihcImluZm9ybWF0aW9uRmlsdGVyIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcclxuXHJcblx0Ly9DcmVhdGUgYmFja2VuZCBjaG9pY2Ugb2JqZWN0XHJcblx0dmFyIF9jaG9pY2UgPSBuZXcgX0Nob2ljZShpZCwgcGxheWVyLmlkKCksIG9wdGlvbnMsIHBhcmFtZXRlcnMpO1xyXG5cclxuXHQvL1JldHVybiB0aGlzIHJlZmVyZW5jZSBvYmplY3QgdG8gdGhlIHVzZXIuIFJ1biB0aGUgZnVuY3Rpb24gdG8gc2VsZWN0IGEgc291cmNlXHJcblx0dmFyIGNob2ljZSA9IFBsYXlhYmxlKF9jaG9pY2UpO1xyXG5cclxuXHQvL0ludGVyZmFjZSB0byBzcGVjaWZ5IHNpbmdsZS1wbGF5ZXIgcGF5b2ZmcyBpbiBzaW5nbGUtcGxheWVyL3NpbmdsZS1jaG9pY2UgZ2FtZXNcclxuXHRfY2hvaWNlLnplcm9QYXlvZmZzKCk7XHJcblxyXG5cdF9jaG9pY2UuZ2VuZXJhdGVDaGFpbmluZ0Z1bmN0aW9ucyhjaG9pY2UpO1xyXG5cclxuXHQvKlxyXG5cdG9wdGlvbnMuZm9yRWFjaChmdW5jdGlvbihvcHRpb24pe1xyXG5cdFx0X2Nob2ljZS5wYXlvZmZzW29wdGlvbl0gPSAwO1x0XHRcdC8vU3RhcnQgcGF5b2ZmcyBhdCB6ZXJvXHJcblxyXG5cdFx0Y2hvaWNlW29wdGlvbl0gPSBmdW5jdGlvbihwYXlvZmYpe1x0XHRcdFx0XHQvL0NyZWF0ZSBmdW5jdGlvbnMgZm9yIHVzZXIgdG8gYXNzaWduIHBheW9mZnNcclxuXHRcdFx0aWYgKCFpc05hTihwYXlvZmYpKV9jaG9pY2UucGF5b2Zmc1tvcHRpb25dID0gcGF5b2ZmO1xyXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcclxuXHRcdFx0XHRwbGF5YWJsZTpjaG9pY2UsXHJcblx0XHRcdFx0cGF0aDpbb3B0aW9uXVxyXG5cdFx0XHR9KVxyXG5cdFx0fTtcclxuXHR9KTtcclxuXHQqL1xyXG5cclxuXHQvL0Z1bmN0aW9uIHRvIHNldCBhbGwgcGF5b2ZmcyBhdCBvbmNlXHJcblx0Y2hvaWNlLnNldEFsbFBheW9mZnMgPSBmdW5jdGlvbihwYXlvZmZzKSB7XHJcblx0XHQvL1RPRE86IG1ha2UgdGhpcyB3b3JrLiBJbmNsdWRlIGVycm9yIGhhbmRsaW5nIGlmIGFycmF5IGdpdmVuIGlzbid0IGV4cGVjdGVkIGRpbWVuc2lvbnMuXHJcblx0fTtcclxuXHJcblx0Ly9XYXkgZm9yIHVzZXIgdG8gaW50ZXJhY3Qgd2l0aCBwYXlvZmZzXHJcblx0Y2hvaWNlLnBheW9mZnMgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiByZWdpc3RyeS5jaG9pY2VzW2lkXS5wYXlvZmZzO1xyXG5cdH07XHJcblxyXG5cdHJldHVybiBjaG9pY2U7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0geyBfQ2hvaWNlLCBDaG9pY2UgfTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XHJcbmxvZyhcImRlYnVnXCIsIFwiTG9hZGluZyBDbGFzczogSGFsdElmXCIpXHJcblxyXG4vL0dhbWUgc3RhdGUgY29udHJvbGxlcnNcclxudmFyIHtyZWdpc3RyeX0gPSByZXF1aXJlKCcuLi9zdGF0ZScpO1xyXG52YXIge2dhbWVIaXN0b3J5fSA9IHJlcXVpcmUoJy4uL2hpc3RvcnknKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIge2lzRnVuY3Rpb259XHQ9IHJlcXVpcmUoJy4uL2hlbHBlckZ1bmN0aW9ucycpKFwiZ2VuZXJhbFwiKTtcclxudmFyIHtpZEhhbmRsZXJ9IFx0PSByZXF1aXJlKCcuLi9oZWxwZXJGdW5jdGlvbnMnKShcInN0YXRlXCIpO1xyXG5cclxuLy9QYXJlbnQgY2xhc3NcclxudmFyIHtfUGxheWFibGUsIFBsYXlhYmxlfSA9IHJlcXVpcmUoJy4vcGxheWFibGUnKTtcclxuXHJcblxyXG5cclxuLy9CYWNrZW5kIGZ1bmN0aW9uIGNsYXNzIGZvciBHYW1lXHJcbmZ1bmN0aW9uIF9IYWx0KGlkLHRlc3RDb25kaXRpb24sIHtsb2dDb250aW51ZSA9IGZhbHNlfSl7XHJcblx0X1BsYXlhYmxlLmNhbGwodGhpcyxpZCk7XHJcblx0XHJcblx0dGhpcy50ZXN0Q29uZGl0aW9uID0gdGVzdENvbmRpdGlvbjtcclxuXHR0aGlzLmxvZ0NvbnRpbnVlID0gbG9nQ29udGludWU7XHJcblx0XHJcblx0cmVnaXN0cnkuaGFsdHNbaWRdID0gdGhpcztcclxufVxyXG5cclxuX0hhbHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShfUGxheWFibGUucHJvdG90eXBlKTtcclxuX0hhbHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gX0hhbHQ7XHJcblxyXG5fSGFsdC5yZWdpc3RyeU5hbWUgPSBcImhhbHRzXCI7XHJcbl9IYWx0LmNvdW50ZXJOYW1lID0gXCJoYWx0SWZcIjtcclxuXHJcbl9IYWx0LnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24oe2luaXRpYWxpemVQbGF5ZXJzPWZhbHNlLCBzaG9ydENpcmN1aXQ9ZmFsc2UsIGhpc3Rvcnk9Z2FtZUhpc3Rvcnl9PXt9KXtcclxuXHRcclxuXHR2YXIgaGFsdCA9IHRoaXM7XHJcblx0XHJcblx0dmFyIHJlc3VsdE9iamVjdCA9IHtcclxuXHRcdCdwbGF5YWJsZSc6aGFsdCxcclxuXHRcdCdoaXN0b3J5RW50cnknOntcclxuXHRcdFx0J2hhbHQnOmhhbHQuaWRcclxuXHRcdH1cclxuXHR9O1xyXG5cdFxyXG5cdFxyXG5cdHZhciB0ZXN0ID0gaGFsdC50ZXN0Q29uZGl0aW9uKCk7XHJcblx0XHJcblx0XHJcblx0aWYgKHRlc3QpIHtcclxuXHRcdGxvZyhcImluZm9cIiwgXCJIYWx0aW5nIGF0IFwiICsgaGFsdC5pZClcclxuXHRcdFxyXG5cdFx0cmVzdWx0T2JqZWN0Lmhpc3RvcnlFbnRyeS5hY3Rpb24gPSBcImhhbHRcIjtcclxuXHRcdHJlc3VsdE9iamVjdC5yZXN1bHQgPSBcIkhhbHRcIjtcclxuXHRcclxuXHRcdHJldHVybiBQcm9taXNlLnJlamVjdChyZXN1bHRPYmplY3QpO1xyXG5cdH1cclxuXHRcclxuXHQvL0hhbHQgcHJvYmFibHkgZ2V0cyB1c2VkIGZvciBsb29wcywgYW5kIHdlIG1pZ2h0IG5vdCB3YW50IHRvIHNlZSBsb3RzIG9mIGNvbnRpbnVlIG1lc3NhZ2VzLCBzbyBcImxvZ0NvbnRpbnVlXCIgd2lsbCBvbWl0IHRoZW0uXHJcblx0aWYgKGhhbHQubG9nQ29udGludWUpIHtcclxuXHRcdHJlc3VsdE9iamVjdC5oaXN0b3J5RW50cnkuYWN0aW9uID0gXCJjb250aW51ZVwiO1xyXG5cdH1cclxuXHRlbHNlIGRlbGV0ZSByZXN1bHRPYmplY3QuaGlzdG9yeUVudHJ5XHJcblx0XHJcblx0XHJcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHRPYmplY3QpXHJcbn07XHJcblxyXG5cclxuX0hhbHQucHJvdG90eXBlLnN1bW1hcnlUaGlzID0gZnVuY3Rpb24oc3VtbWFyeSl7XHJcblx0c3VtbWFyeS5jb25kaXRpb24gPSB0aGlzLnRlc3RDb25kaXRpb24udG9TdHJpbmcoKTtcclxufVxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBIYWx0SWYodGVzdENvbmRpdGlvbj1mdW5jdGlvbigpe30sIHtpZD1udWxsLCBsb2dDb250aW51ZT1mYWxzZX09e30pe1xyXG5cdHZhciBpZCA9IGlkSGFuZGxlcihpZCxcImhhbHRJZlwiKVxyXG5cdFxyXG5cdGlmICghaXNGdW5jdGlvbih0ZXN0Q29uZGl0aW9uKSkgbG9nKFwid2FyblwiLGlkICsgXCI6IHRlc3RDb25kaXRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24sIG9yIGVsc2UgZ2FtZSB3aWxsIG5vdCBoYWx0LlwiKVxyXG5cclxuXHQvL0NyZWF0ZSBiYWNrZW5kIGxvb3Agb2JqZWN0XHJcblx0dmFyIF9oYWx0ID0gbmV3IF9IYWx0KGlkLCB0ZXN0Q29uZGl0aW9uLCB7bG9nQ29udGludWV9KTtcclxuXHRcclxuXHRcclxuXHQvL1JldHVybiB0aGlzIHJlZmVyZW5jZSBvYmplY3QgdG8gdGhlIHVzZXIuIFJ1biB0aGUgZnVuY3Rpb24gdG8gc2VsZWN0IGEgc291cmNlXHJcblx0dmFyIGhhbHQgPSBQbGF5YWJsZShfaGFsdCk7XHRcclxuXHRyZXR1cm4gaGFsdDtcdFxyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7X0hhbHQsIEhhbHRJZn07IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vL0xvYWRzIHRoZSBwbGF5YWJsZXMgdGhhdCB3aWxsIGJlIHVzZWQgYnkgTmFzaC4gVGhpcyBpcyBiYXNpY2FsbHkgdGhlIGNvbnRyb2xsZXIgbGlzdDogaWYgaXQncyBub3QgaW4gdGhlc2UgbGlzdHMsXHJcbi8vIHRoZW4gaXQgd29uJ3QgYmUgYXZhaWxhYmxlIGZvciB1cy5cclxuXHJcbi8vRXh0ZXJuYWwgZGVwZW5kZW5jeVxyXG52YXIgcHJlc2VudCA9IHJlcXVpcmUoXCJwcmVzZW50XCIpO1xyXG5cclxudmFyIGxvZyA9IHJlcXVpcmUoXCIuLi9sb2dnZXJcIik7XHJcblxyXG52YXIgeyBhcHBseUJpbmQgfSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJGdW5jdGlvbnNcIikoXCJnZW5lcmFsXCIpO1xyXG5cclxubG9nKFwiZGVidWdcIiwgXCJMb2FkaW5nIFBsYXlhYmxlIENsYXNzZXM6IFwiKTtcclxuXHJcbi8vUGxheWFibGVzXHJcbnZhciB7IF9QbGF5YWJsZSB9ID0gcmVxdWlyZShcIi4vcGxheWFibGVcIik7XHJcbnZhciB7IF9DaG9pY2UsIENob2ljZSB9ID0gcmVxdWlyZShcIi4vY2hvaWNlXCIpO1xyXG52YXIgeyBfVHVybiwgVHVybiB9ID0gcmVxdWlyZShcIi4vdHVyblwiKTtcclxudmFyIHsgX1NlcXVlbmNlLCBTZXF1ZW5jZSB9ID0gcmVxdWlyZShcIi4vc2VxdWVuY2VcIik7XHJcbnZhciB7IF9Mb29wLCBMb29wIH0gPSByZXF1aXJlKFwiLi9sb29wXCIpO1xyXG52YXIgeyBfU0xvb3AsIFN0b2NoYXN0aWNMb29wIH0gPSByZXF1aXJlKFwiLi9zdG9jaGFzdGljTG9vcFwiKTtcclxudmFyIHsgX0hhbHQsIEhhbHRJZiB9ID0gcmVxdWlyZShcIi4vaGFsdC1pZlwiKTtcclxudmFyIHsgX1NIYWx0LCBTdG9jaGFzdGljSGFsdCB9ID0gcmVxdWlyZShcIi4vc3RvY2hhc3RpYy1oYWx0XCIpO1xyXG52YXIgeyBfTGFtYmRhLCBMYW1iZGEgfSA9IHJlcXVpcmUoXCIuL2xhbWJkYVwiKTtcclxudmFyIHsgX1JQQ2hvaWNlLCBSYW5kb21QbGF5ZXJDaG9pY2UgfSA9IHJlcXVpcmUoXCIuL3JhbmRvbS1wbGF5ZXItY2hvaWNlXCIpO1xyXG52YXIgeyBfUG9wdWxhdGlvbkR5bmFtaWNzLCBQb3B1bGF0aW9uRHluYW1pY3MgfSA9IHJlcXVpcmUoXCIuL3BvcHVsYXRpb24tZHluYW1pY3NcIik7XHJcbnZhciB7IF9TaW11bHRhbmVvdXMsIFNpbXVsdGFuZW91cyB9ID0gcmVxdWlyZShcIi4vc2ltdWx0YW5lb3VzXCIpO1xyXG5cclxuLy9SdW5zIHdoZW4gbG9hZGluZyBQbGF5YWJsZSBjbGFzc2VzLlxyXG5mdW5jdGlvbiBpbml0aWFsaXplUGxheWFibGVDbGFzcyhwbGF5YWJsZUNsYXNzKSB7XHJcblx0Ly9SZXBsYWNlIHRoZSAucGxheSgpIG1ldGhvZCB3aXRoIGEgd3JhcHBlciB3aGljaCBjYWxscyBpdCBhbmQgYSBmZXcgb3RoZXIgZnVuY3Rpb25zXHJcblx0aWYgKHBsYXlhYmxlQ2xhc3MucHJvdG90eXBlLmhhc093blByb3BlcnR5KFwicGxheVwiKSkge1xyXG5cdFx0cGxheWFibGVDbGFzcy5wcm90b3R5cGUucGxheSA9IChmdW5jdGlvbihwbGF5KSB7XHJcblx0XHRcdHJldHVybiBmdW5jdGlvbih7IGhpc3RvcnkgPSBnYW1lSGlzdG9yeSB9ID0ge30pIHtcclxuXHRcdFx0XHR2YXIgcGxheWFibGUgPSB0aGlzO1xyXG5cdFx0XHRcdHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG5cclxuXHRcdFx0XHQvLyBTZXQgb3VyIGhpc3RvcnlcclxuXHRcdFx0XHRhcmdzWzBdLmhpc3RvcnkgPyBudWxsIDogYXJnc1swXS5oaXN0b3J5ID0gdGhpcy5oaXN0b3J5IHx8IGdhbWVIaXN0b3J5XHJcblxyXG5cdFx0XHRcdC8vIGhvdyB0byBoYWx0IHRoZSBnYW1lIHdpdGhvdXQgZXJyb3JzLiBUT0RPIHRoaXMgaXMgcHJvYmFibHkgZnVja2VkXHJcblx0XHRcdFx0aWYgKGhpc3Rvcnkuc3RvcCkgcmV0dXJuIHsgcGxheWFibGUgfTtcclxuXHJcblxyXG5cdFx0XHRcdHJldHVybiBfUGxheWFibGUucHJvdG90eXBlLl9zdGFydFRpbWVyXHJcblx0XHRcdFx0XHQuYXBwbHkocGxheWFibGUsIGFyZ3MpXHJcblx0XHRcdFx0XHQudGhlbihhcHBseUJpbmQocGxheWFibGUuY2hlY2tJbml0LCBwbGF5YWJsZSwgYXJncykpXHJcblx0XHRcdFx0XHQudGhlbihhcHBseUJpbmQocGxheWFibGUucHJlUGxheSwgcGxheWFibGUsIGFyZ3MpKVxyXG5cdFx0XHRcdFx0LnRoZW4oYXBwbHlCaW5kKHBsYXksIHBsYXlhYmxlLCBhcmdzKSlcclxuXHRcdFx0XHRcdC50aGVuKGFwcGx5QmluZChwbGF5YWJsZS5wb3N0UGxheSwgcGxheWFibGUsIGFyZ3MpKVxyXG5cdFx0XHRcdFx0LnRoZW4oYXBwbHlCaW5kKF9QbGF5YWJsZS5wcm90b3R5cGUuX3N0b3BUaW1lciwgcGxheWFibGUsIGFyZ3MpKVxyXG5cdFx0XHRcdFx0LnRoZW4oYXBwbHlCaW5kKHBsYXlhYmxlLmhhbmRsZUhpc3RvcnksIHBsYXlhYmxlLCBhcmdzKSlcclxuXHRcdFx0XHRcdC50aGVuKGFwcGx5QmluZChfUGxheWFibGUucHJvdG90eXBlLnByb2NlZWQsIHBsYXlhYmxlLCBhcmdzKSk7XHJcblx0XHRcdH07XHJcblx0XHR9KShwbGF5YWJsZUNsYXNzLnByb3RvdHlwZS5wbGF5KTtcclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydHMucGxheWFibGVDbGFzc2VzID0ge1xyXG5cdF9QbGF5YWJsZSxcclxuXHRfQ2hvaWNlLFxyXG5cdF9UdXJuLFxyXG5cdF9TZXF1ZW5jZSxcclxuXHRfTG9vcCxcclxuXHRfU0xvb3AsXHJcblx0X0hhbHQsXHJcblx0X1NIYWx0LFxyXG5cdF9MYW1iZGEsXHJcblx0X1JQQ2hvaWNlLFxyXG5cdF9Qb3B1bGF0aW9uRHluYW1pY3MsXHJcblx0X1NpbXVsdGFuZW91c1xyXG59O1xyXG5leHBvcnRzLnBsYXlhYmxlSW50ZXJmYWNlcyA9IHtcclxuXHRDaG9pY2UsXHJcblx0VHVybixcclxuXHRTZXF1ZW5jZSxcclxuXHRMb29wLFxyXG5cdFN0b2NoYXN0aWNMb29wLFxyXG5cdEhhbHRJZixcclxuXHRTdG9jaGFzdGljSGFsdCxcclxuXHRMYW1iZGEsXHJcblx0UmFuZG9tUGxheWVyQ2hvaWNlLFxyXG5cdFBvcHVsYXRpb25EeW5hbWljcyxcclxuXHRTaW11bHRhbmVvdXNcclxufTtcclxuXHJcbmZvciAodmFyIHBsYXlhYmxlQ2xhc3MgaW4gZXhwb3J0cy5wbGF5YWJsZUNsYXNzZXMpIHtcclxuXHRpZiAocGxheWFibGVDbGFzcyAhPSBcIl9QbGF5YWJsZVwiKVxyXG5cdFx0aW5pdGlhbGl6ZVBsYXlhYmxlQ2xhc3MoZXhwb3J0cy5wbGF5YWJsZUNsYXNzZXNbcGxheWFibGVDbGFzc10pO1xyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGxvZyA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xyXG5sb2coXCJkZWJ1Z1wiLCBcIkxvYWRpbmcgQ2xhc3M6IExhbWJkYVwiKVxyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7cmVnaXN0cnksIGdhbWVIaXN0b3J5fSA9IHJlcXVpcmUoJy4uL3N0YXRlJyk7XHJcblxyXG4vL0hlbHBlciBmdW5jdGlvbnNcclxudmFyIHtpc0Z1bmN0aW9ufVx0PSByZXF1aXJlKCcuLi9oZWxwZXJGdW5jdGlvbnMnKShcImdlbmVyYWxcIik7XHJcbnZhciB7aWRIYW5kbGVyfSBcdD0gcmVxdWlyZSgnLi4vaGVscGVyRnVuY3Rpb25zJykoXCJzdGF0ZVwiKTtcclxuXHJcbi8vUGFyZW50IGNsYXNzXHJcbnZhciB7X1BsYXlhYmxlLCBQbGF5YWJsZX0gPSByZXF1aXJlKCcuL3BsYXlhYmxlJyk7XHJcblxyXG5cclxuXHJcbi8vQmFja2VuZCBmdW5jdGlvbiBjbGFzcyBmb3IgR2FtZVxyXG5mdW5jdGlvbiBfTGFtYmRhKGlkLCBhY3Rpb24sIHBhcmFtZXRlcnM9e30pe1xyXG5cdF9QbGF5YWJsZS5jYWxsKHRoaXMsaWQpO1xyXG5cdFxyXG5cdHRoaXMuYWN0aW9uID0gYWN0aW9uO1xyXG5cdFxyXG5cdHJlZ2lzdHJ5LmxhbWJkYXNbaWRdID0gdGhpcztcclxufVxyXG5fTGFtYmRhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX1BsYXlhYmxlLnByb3RvdHlwZSk7XHJcbl9MYW1iZGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gX0xhbWJkYVxyXG5cclxuX0xhbWJkYS5yZWdpc3RyeU5hbWUgPSBcImxhbWJkYXNcIjtcclxuX0xhbWJkYS5jb3VudGVyTmFtZSA9IFwibGFtYmRhXCI7XHJcblxyXG5cclxuX0xhbWJkYS5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uKHtpbml0aWFsaXplUGxheWVycz1mYWxzZSwgc2hvcnRDaXJjdWl0PWZhbHNlLCBoaXN0b3J5PWdhbWVIaXN0b3J5fT17fSl7XHJcblx0XHJcblx0dmFyIGxhbWJkYSA9IHRoaXM7XHJcblx0XHRcclxuXHR2YXIgcmVzdWx0ID0gbGFtYmRhLmFjdGlvbigpXHJcblx0XHRcclxuXHR2YXIgcmVzdWx0T2JqZWN0ID0ge1xyXG5cdFx0cmVzdWx0LFxyXG5cdFx0J3BsYXlhYmxlJzpsYW1iZGEsXHJcblx0XHRoaXN0b3J5RW50cnk6e1xyXG5cdFx0XHRsYW1iZGE6bGFtYmRhLmlkLFxyXG5cdFx0XHRyZXN1bHRcclxuXHRcdH1cclxuXHR9O1xyXG5cdFxyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0T2JqZWN0KVxyXG59O1xyXG5cclxuX0xhbWJkYS5wcm90b3R5cGUuc3VtbWFyeVRoaXMgPSBmdW5jdGlvbihzdW1tYXJ5KXtcclxuXHRzdW1tYXJ5LmFjdGlvbiA9IHRoaXMuYWN0aW9uLnRvU3RyaW5nKCk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBMYW1iZGEoYWN0aW9uPWZ1bmN0aW9uKCl7fSwgcGFyYW1ldGVycz17fSl7XHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKHBhcmFtZXRlcnMuaWQsXCJsYW1iZGFcIilcclxuXHRcclxuXHRpZiAoIWlzRnVuY3Rpb24oYWN0aW9uKSkgbG9nKFwid2FyblwiLGlkICsgXCI6IGFjdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbi5cIilcclxuXHJcblx0Ly9DcmVhdGUgYmFja2VuZCBsYW1iZGEgb2JqZWN0XHJcblx0dmFyIF9sYW1iZGEgPSBuZXcgX0xhbWJkYShpZCwgYWN0aW9uLCBwYXJhbWV0ZXJzKTtcclxuXHRcclxuXHRcclxuXHQvL1JldHVybiB0aGlzIHJlZmVyZW5jZSBvYmplY3QgdG8gdGhlIHVzZXIuIFJ1biB0aGUgZnVuY3Rpb24gdG8gc2VsZWN0IGEgc291cmNlXHJcblx0dmFyIGxhbWJkYSA9IFBsYXlhYmxlKF9sYW1iZGEpO1x0XHJcblx0cmV0dXJuIGxhbWJkYTtcdFxyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7X0xhbWJkYSwgTGFtYmRhfTsiLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKFwiLi4vbG9nZ2VyXCIpO1xyXG5sb2coXCJkZWJ1Z1wiLCBcIkxvYWRpbmcgQ2xhc3M6IExvb3BcIik7XHJcblxyXG4vL0dhbWUgc3RhdGUgY29udHJvbGxlcnNcclxudmFyIHsgcmVnaXN0cnkgfSA9IHJlcXVpcmUoXCIuLi9zdGF0ZVwiKTtcclxudmFyIHsgZ2FtZUhpc3RvcnksIEhpc3RvcnkgfSA9IHJlcXVpcmUoXCIuLi9oaXN0b3J5XCIpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGlkSGFuZGxlciB9ID0gcmVxdWlyZShcIi4uL2hlbHBlckZ1bmN0aW9uc1wiKShcInN0YXRlXCIpO1xyXG52YXIgeyBjaGFpbmVyR2VuZXJhdG9yIH0gPSByZXF1aXJlKFwiLi4vaGVscGVyRnVuY3Rpb25zXCIpKFwicGxheWFibGVcIik7XHJcblxyXG4vLyBJbmZvcm1hdGlvbiBtZWNoYW5pY3NcclxudmFyIHsgSW5mb3JtYXRpb24sIFBlcmZlY3RJbmZvcm1hdGlvbiB9ID0gcmVxdWlyZShcIi4uL2luZm9ybWF0aW9uXCIpO1xyXG52YXIgeyBnYW1lUG9wdWxhdGlvbiB9ID0gcmVxdWlyZShcIi4uL3BvcHVsYXRpb25cIik7XHJcblxyXG4vL1BhcmVudCBjbGFzc1xyXG52YXIgeyBfUGxheWFibGUsIFBsYXlhYmxlIH0gPSByZXF1aXJlKFwiLi9wbGF5YWJsZVwiKTtcclxuXHJcbi8vQmFja2VuZCBmdW5jdGlvbiBjbGFzcyBmb3IgTG9vcFxyXG5cclxuZnVuY3Rpb24gX0xvb3AoaWQsIHBsYXlhYmxlLCBjb3VudCwgcGFyYW1ldGVycykge1xyXG5cdF9QbGF5YWJsZS5jYWxsKHRoaXMsIGlkLCBwYXJhbWV0ZXJzKTtcclxuXHJcblx0dmFyIHsgbG9nQ29udGludWUgPSB0cnVlLCBwbGF5YWJsZVBhcmFtZXRlcnMgPSB7fSB9ID0gcGFyYW1ldGVycztcclxuXHJcblx0dGhpcy5wbGF5YWJsZSA9IHJlZ2lzdHJ5LnBsYXlhYmxlc1twbGF5YWJsZS5pZCgpXTtcclxuXHR0aGlzLmxvZ0NvbnRpbnVlID0gbG9nQ29udGludWU7XHJcblx0dGhpcy5wbGF5YWJsZVBhcmFtZXRlcnMgPSBwbGF5YWJsZVBhcmFtZXRlcnM7XHJcblxyXG5cdHRoaXMuY291bnQgPSBjb3VudDtcclxuXHJcblx0cmVnaXN0cnkubG9vcHNbaWRdID0gdGhpcztcclxufVxyXG5fTG9vcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKF9QbGF5YWJsZS5wcm90b3R5cGUpO1xyXG5fTG9vcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBfTG9vcDtcclxuXHJcbl9Mb29wLnJlZ2lzdHJ5TmFtZSA9IFwibG9vcHNcIjtcclxuX0xvb3AuY291bnRlck5hbWUgPSBcImxvb3BcIjtcclxuXHJcbl9Mb29wLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24oe1xyXG5cdGhpc3RvcnkgPSB0aGlzLmhpc3RvcnkgfHwgZ2FtZUhpc3RvcnksXHJcblx0aW5mb3JtYXRpb24gPSB0aGlzLmluZm9ybWF0aW9uIHx8IFBlcmZlY3RJbmZvcm1hdGlvbixcclxuXHRwbGF5YWJsZVBhcmFtZXRlcnMgPSB0aGlzLnBsYXlhYmxlUGFyYW1ldGVyc1xyXG59ID0ge30pIHtcclxuXHJcblx0dmFyIGxvb3AgPSB0aGlzO1xyXG5cdGxvb3AuY291bnRlciA9IDA7XHJcblxyXG5cdC8vIFNwbGl0IHRoZSBoaXN0b3J5IGVudHJ5XHJcblx0dmFyIGxvb3BIaXN0b3J5ID0gaGlzdG9yeS5jaGlsZCgpO1xyXG5cclxuXHQvLyBpbmZvcm1hdGlvbiBtZWNoYW5pY3MuXHJcblx0Ly9jb21wYXJ0bWVudGFsaXplIElmIHNldFxyXG5cdGlmIChsb29wLmNvbXBhcnRtZW50YWxpemUpIHtcclxuXHRcdGluZm9ybWF0aW9uID0gbmV3IEluZm9ybWF0aW9uKGxvb3AuY29tcGFydG1lbnRhbGl6ZS5oaXN0b3J5IHx8IGxvb3BIaXN0b3J5LFxyXG5cdFx0XHRsb29wLmNvbXBhcnRtZW50YWxpemUucG9wdWxhdGlvbiB8fCBnYW1lUG9wdWxhdGlvbik7XHJcblx0fVxyXG5cdC8vIFBhc3MgYWxvbmdcclxuXHRwbGF5YWJsZVBhcmFtZXRlcnMuaW5mb3JtYXRpb24gPSBpbmZvcm1hdGlvblxyXG5cclxuXHJcblx0dmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcclxuXHJcblx0dmFyIGFjdGlvbiA9IGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0Ly9JZiB0aGUgZ2FtZSBoYXMgYmVlbiBlbmRlZCBlYXJseSwgZG9uJ3QgY29udGludWUuXHJcblx0XHRpZiAoaGlzdG9yeS5zdG9wKSByZXR1cm4geyBwbGF5YWJsZTogbG9vcCB9O1xyXG5cclxuXHRcdGxvb3AuY291bnRlcisrO1xyXG5cdFx0aWYgKCFyZXN1bHQpIHJlc3VsdCA9IHt9O1xyXG5cclxuXHRcdC8vRGVhbCB3aXRoIGhpc3RvcnlcclxuXHRcdGhpc3RvcnkubG9nLmFkZCh7XHJcblx0XHRcdGxvb3A6IGxvb3AuaWQsXHJcblx0XHRcdGxvb3BUbzogbG9vcC5wbGF5YWJsZS5pZCxcclxuXHRcdFx0Y291bnQ6IGxvb3AuY291bnRlclxyXG5cdFx0fSk7XHJcblxyXG5cdFx0cGxheWFibGVQYXJhbWV0ZXJzLnNob3J0Q2lyY3VpdCA9IHRydWU7XHJcblx0XHRwbGF5YWJsZVBhcmFtZXRlcnMuaGlzdG9yeSA9IGxvb3BIaXN0b3J5O1xyXG5cclxuXHRcdHJldHVybiBsb29wLnBsYXlhYmxlLnBsYXkocGxheWFibGVQYXJhbWV0ZXJzKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0XHQvL1JlLWZvcm1hdCByZXN1bHQsIHJlcGxhY2UgcGxheWFibGUgd2l0aCBMb29wIHBsYXlhYmxlXHJcblx0XHRcdHJlc3VsdC5wbGF5YWJsZSA9IGxvb3A7XHJcblxyXG5cdFx0XHQvL1RPRE86IGFkZCBpbmZvcm1hdGlvbiBtZWNoYW5pc21zXHJcblxyXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcblx0XHR9KTtcclxuXHR9O1xyXG5cclxuXHQvL1JlcGVhdCB0aGUgcGxheWFibGUgbG9vcC5jb3VudCB0aW1lcywgYnkgY2hhaW5pbmcgcHJvbWlzZXMuXHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsb29wLmNvdW50OyBpKyspIHtcclxuXHRcdHByb21pc2UgPSBwcm9taXNlLnRoZW4oYWN0aW9uKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRyZXN1bHQuaGlzdG9yeUVudHJ5ID0ge1xyXG5cdFx0XHRsb29wOiBsb29wLmlkLFxyXG5cdFx0XHRjb3VudDogbG9vcC5jb3VudGVyLFxyXG5cdFx0XHRhY3Rpb246IGxvb3BIaXN0b3J5Lm9ycGhhbigpXHJcblx0XHR9O1xyXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuLy9PdmVyd3JpdGUgaGlzdG9yeSBoYW5kbGVyIHRvIHByZXZlbnQgXCJsb29wIGZpbmlzaGVkXCIgZW50cnkgZnJvbSBoaXR0aW5nIHRoZSB0cmVlLlxyXG5fTG9vcC5wcm90b3R5cGUuaGFuZGxlSGlzdG9yeSA9IGZ1bmN0aW9uKHtcclxuXHRcdGhpc3RvcnkgPSB0aGlzLmhpc3RvcnkgfHwgZ2FtZUhpc3RvcnksXHJcblx0XHRpbmZvcm1hdGlvbiA9IHRoaXMuaW5mb3JtYXRpb24gfHwgUGVyZmVjdEluZm9ybWF0aW9uLFxyXG5cdFx0bG9nQ29udGludWUgPSB0aGlzLmxvZ0NvbnRpbnVlXHJcblx0fSA9IHt9LFxyXG5cdHJlc3VsdFxyXG4pIHtcclxuXHR2YXIgbG9vcCA9IHRoaXM7XHJcblxyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0Ly9Xcml0ZSBmaW5hbCBlbnRyeSBpZiBsb2dDb250aW51ZSBpcyBzZXQgdG8gdHJ1ZVxyXG5cdFx0aWYgKGxvZ0NvbnRpbnVlKSB7XHJcblx0XHRcdGhpc3RvcnkubG9nLmFkZCh7XHJcblx0XHRcdFx0bG9vcDogbG9vcC5pZCxcclxuXHRcdFx0XHRsb29wVG86IFwiTG9vcCBmaW5pc2hlZC5cIixcclxuXHRcdFx0XHRjb3VudDogbG9vcC5jb3VudGVyXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGhpc3RvcnkuYWRkTm9Mb2cocmVzdWx0Lmhpc3RvcnlFbnRyeSk7XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9KTtcclxufTtcclxuXHJcbi8vIEFkZCBkZXRhaWwvbmVzdGluZyB0byBzdW1tYXJ5LlxyXG5fTG9vcC5wcm90b3R5cGUuc3VtbWFyeVRoaXMgPSBmdW5jdGlvbihzdW1tYXJ5LCBlbnRyaWVzKSB7XHJcblx0c3VtbWFyeS5jb3VudCA9IHRoaXMuY291bnQ7XHJcblxyXG5cdHN1bW1hcnkuYWN0aW9uID0ge307XHJcblx0dGhpcy5wbGF5YWJsZS5zdW1tYXJpemUoc3VtbWFyeS5hY3Rpb24sIGVudHJpZXMsIHRydWUpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gTG9vcChwbGF5YWJsZSwgY291bnQgPSAxLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHR2YXIgaWQgPSBpZEhhbmRsZXIocGFyYW1ldGVycy5pZCwgXCJsb29wXCIpO1xyXG5cclxuXHQvL0NyZWF0ZSBiYWNrZW5kIGxvb3Agb2JqZWN0XHJcblx0dmFyIF9sb29wID0gbmV3IF9Mb29wKGlkLCBwbGF5YWJsZSwgY291bnQsIHBhcmFtZXRlcnMpO1xyXG5cclxuXHQvL1JldHVybiB0aGlzIHJlZmVyZW5jZSBvYmplY3QgdG8gdGhlIHVzZXIuIFJ1biB0aGUgZnVuY3Rpb24gdG8gc2VsZWN0IGEgc291cmNlXHJcblx0dmFyIGxvb3AgPSBQbGF5YWJsZShfbG9vcCk7XHJcblx0cmV0dXJuIGxvb3A7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0geyBfTG9vcCwgTG9vcCB9O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKFwiLi4vbG9nZ2VyXCIpO1xyXG5sb2coXCJkZWJ1Z1wiLCBcIkxvYWRpbmcgQ2xhc3M6IFBsYXlhYmxlXCIpO1xyXG5cclxudmFyIHsgU3luY2hyb25vdXNQcm9taXNlIH0gPSByZXF1aXJlKFwic3luY2hyb25vdXMtcHJvbWlzZVwiKTtcclxudmFyIHByZXNlbnQgPSByZXF1aXJlKFwicHJlc2VudFwiKTtcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIgeyByZWdpc3RyeSwgaWRDb3VudGVycyB9ID0gcmVxdWlyZShcIi4uL3N0YXRlXCIpO1xyXG52YXIgeyBnYW1lSGlzdG9yeSwgSGlzdG9yeSB9ID0gcmVxdWlyZShcIi4uL2hpc3RvcnlcIik7XHJcblxyXG4vL0hlbHBlciBmdW5jdGlvbnNcclxudmFyIHsgaXNGdW5jdGlvbiB9ID0gcmVxdWlyZShcIi4uL2hlbHBlckZ1bmN0aW9uc1wiKShcImdlbmVyYWxcIik7XHJcbnZhciB7IG91dGNvbWVUcmVlQWRkQWxsLCBvdXRjb21lVHJlZUdldFZhbHVlIH0gPSByZXF1aXJlKFwiLi4vaGVscGVyRnVuY3Rpb25zXCIpKFwicGxheWFibGVcIik7XHJcbnZhciB7IHJlaW5pdGlhbGl6ZVBsYXllcnMgfSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJGdW5jdGlvbnNcIikoXCJwbGF5ZXJcIik7XHJcblxyXG4vL1RvIHJldHVybiB0byB1c2VyXHJcbnZhciB7IFBvcHVsYXRpb24sIFBsYXllckxpc3QgfSA9IHJlcXVpcmUoXCIuLi9wb3B1bGF0aW9uXCIpO1xyXG5cclxuLy9fcGxheWFibGUgY2xhc3MsIHN1cGVyY2xhc3MgZm9yIG9iamVjdHMgd2hpY2ggY2FuIGV4ZWN1dGUgZ2FtZSBzdGVwcyAoY2hvaWNlLCB0dXJuLCBnYW1lKVxyXG5mdW5jdGlvbiBfUGxheWFibGUoaWQsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdHRoaXMuaWQgPSBpZDtcclxuXHR0aGlzLm5leHQgPSBbXTtcclxuXHRyZWdpc3RyeS5wbGF5YWJsZXNbaWRdID0gdGhpcztcclxuXHRpZENvdW50ZXJzLnBsYXlhYmxlKys7XHJcblxyXG5cdHBhcmFtZXRlcnMuY29tcGFydG1lbnRhbGl6ZSA/IHRoaXMuY29tcGFydG1lbnRhbGl6ZSA9IHBhcmFtZXRlcnMuY29tcGFydG1lbnRhbGl6ZSA6IG51bGw7XHJcblx0cGFyYW1ldGVycy5oaXN0b3J5ID8gKHRoaXMuaGlzdG9yeSA9IHBhcmFtZXRlcnMuaGlzdG9yeSkgOiBudWxsO1xyXG5cdHBhcmFtZXRlcnMuaW5mb3JtYXRpb24gPyAodGhpcy5pbmZvcm1hdGlvbiA9IHBhcmFtZXRlcnMuaW5mb3JtYXRpb24pIDogbnVsbDtcclxuXHRwYXJhbWV0ZXJzLmluaXRpYWxpemVQbGF5ZXJzID8gKHRoaXMuaW5pdGlhbGl6ZVBsYXllcnMgPSBwYXJhbWV0ZXJzLmluaXRpYWxpemVQbGF5ZXJzKSA6IG51bGw7XHJcbn1cclxuXHJcbl9QbGF5YWJsZS5yZWdpc3RyeU5hbWUgPSBcInBsYXlhYmxlc1wiO1xyXG5fUGxheWFibGUuY291bnRlck5hbWUgPSBcInBsYXlhYmxlXCI7XHJcblxyXG4vL0FkZCByZWZlcmVuY2UgdG8gbmV4dCBwbGF5YWJsZSBicmFuY2gsIHRvIGNoYWluIHBsYXlhYmxlcyB0b2dldGhlci5cclxuX1BsYXlhYmxlLnByb3RvdHlwZS5hZGROZXh0ID0gZnVuY3Rpb24obmV4dFBsYXlhYmxlKSB7XHJcblx0b3V0Y29tZVRyZWVBZGRBbGwodGhpcy5uZXh0LCBuZXh0UGxheWFibGUpO1xyXG59O1xyXG5cclxuLy9DYWxsZWQgYmVmb3JlIC5wbGF5KCkgdG8gc3RhcnQgdGltaW5nLlxyXG5fUGxheWFibGUucHJvdG90eXBlLl9zdGFydFRpbWVyID0gZnVuY3Rpb24oKSB7XHJcblx0dGhpcy5fdGltZXIgPSBwcmVzZW50KCk7XHJcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG59O1xyXG5cclxuLy9DYWxsZWQgYmVmb3JlIHByZVBsYXksIGluaXRpYWxpemUgcGxheWVycyBpZiB0cnVlLlxyXG5fUGxheWFibGUucHJvdG90eXBlLmNoZWNrSW5pdCA9IGZ1bmN0aW9uKHsgaW5pdGlhbGl6ZVBsYXllcnMgPSB0aGlzLmluaXRpYWxpemVQbGF5ZXJzIH0gPSB7fSwgcmVzdWx0KSB7XHJcblx0Ly8gaWYgd2UgZ2V0IHNvbWV0aGluZ1xyXG5cdGlmIChpbml0aWFsaXplUGxheWVycykge1xyXG5cdFx0Ly8gaWYgaXQncyBqdXN0IHRydWUsIHRoZW4gcmVpbml0aWFsaXplIGV2ZXJ5Ym9keVxyXG5cdFx0aWYgKGluaXRpYWxpemVQbGF5ZXJzID09PSB0cnVlKSByZXR1cm4gcmVpbml0aWFsaXplUGxheWVycyhcImFsbFwiLCByZXN1bHQpXHJcblxyXG5cdFx0Ly8gaWYgaXQncyBhIHBsYXllckxpc3QsIHVzZSB0aGF0XHJcblx0XHRlbHNlIGlmIChpbml0aWFsaXplUGxheWVycyBpbnN0YW5jZW9mIFBsYXllckxpc3QpIHJldHVybiByZWluaXRpYWxpemVQbGF5ZXJzKGluaXRpYWxpemVQbGF5ZXJzKVxyXG5cclxuXHRcdC8vIGlmIHdlIGdldCBhIGZ1bmN0aW9uLCB0aGVuIHJ1biB0aGUgZnVuY3Rpb24gYW5kIGNoZWNrIHRoYXQgaXQncyByZXR1cm5pbmcgYSBwbGF5ZXJMaXN0XHJcblx0XHRlbHNlIGlmIChpc0Z1bmN0aW9uKGluaXRpYWxpemVQbGF5ZXJzKSkge1xyXG5cdFx0XHR2YXIgbGlzdCA9IGluaXRpYWxpemVQbGF5ZXJzKClcclxuXHRcdFx0aWYgKGxpc3QgaW5zdGFuY2VvZiBQbGF5ZXJMaXN0KSByZXR1cm4gcmVpbml0aWFsaXplUGxheWVycyhsaXN0LCByZXN1bHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG90aGVyd2lzZSwgY29udmVydCBpdCB0byBhIHBsYXllckxpc3QgYW5kIGxldCBQbGF5ZXJMaXN0IGRlYWwgd2l0aCBpdC5cclxuXHRcdGVsc2UgcmV0dXJuIHJlaW5pdGlhbGl6ZVBsYXllcnMobmV3IFBsYXllckxpc3QoaW5pdGlhbGl6ZVBsYXllcnMpLCByZXN1bHQpO1xyXG5cdH1cclxuXHJcblx0Ly8gaWYgd2UgZGlkbid0IGdldCBhbnl0aGluZyBvciBnb3QgZmFsc2UsIHdlJ3JlIGRvbmUgaGVyZS5cclxuXHRlbHNlIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxufTtcclxuXHJcblxyXG4vL0NhbGxlZCBiZWZvcmUgLnBsYXkoKSBidXQgYWZ0ZXIgX3N0YXJ0VGltZXJcclxuX1BsYXlhYmxlLnByb3RvdHlwZS5wcmVQbGF5ID0gZnVuY3Rpb24oe30gPSB7fSwgcmVzdWx0KSB7XHJcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG59O1xyXG5cclxuLy9DYWxsZWQgYWZ0ZXIgLnBsYXkoKSwgb3ZlcndyaXRhYmxlLlxyXG5fUGxheWFibGUucHJvdG90eXBlLnBvc3RQbGF5ID0gZnVuY3Rpb24oe30gPSB7fSwgcmVzdWx0KSB7XHJcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG59O1xyXG5cclxuLy9DYWxsZWQgYWZ0ZXIgLnBvc3RQbGF5KCkgdG8gc3RvcCB0aW1lciBhbmQgbG9nLlxyXG5fUGxheWFibGUucHJvdG90eXBlLl9zdG9wVGltZXIgPSBmdW5jdGlvbih7fSA9IHt9LCByZXN1bHQpIHtcclxuXHRpZiAocmVzdWx0Lmhpc3RvcnlFbnRyeSlcclxuXHRcdHJlc3VsdC5oaXN0b3J5RW50cnkuZHVyYXRpb24gPSBwcmVzZW50KCkgLSB0aGlzLl90aW1lcjtcclxuXHRkZWxldGUgdGhpcy5fdGltZXI7XHJcblxyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxufTtcclxuXHJcbi8vQ2FsbGVkIGFmdGVyIHRpbWVyIHN0b3BzLCB0byB3cml0ZSBsb2cuIE92ZXJ3aXRlYWJsZSBpZiBwbGF5YWJsZSBoYXMgc3BlY2lmaWMgbG9nZ2luZyBiZWhhdmlvci5cclxuX1BsYXlhYmxlLnByb3RvdHlwZS5oYW5kbGVIaXN0b3J5ID0gZnVuY3Rpb24oeyBoaXN0b3J5ID0gZ2FtZUhpc3RvcnkgfSA9IHt9LFxyXG5cdHJlc3VsdFxyXG4pIHtcclxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdGlmIChyZXN1bHQuaGlzdG9yeUVudHJ5KSBoaXN0b3J5LmFkZChyZXN1bHQuaGlzdG9yeUVudHJ5KTtcclxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuXHR9KTtcclxufTtcclxuXHJcbi8vRGV0ZXJtaW5lIHdoZXRoZXIgdG8gcGxheSBuZXh0LCBhbmQgaWYgc28sIGRvLlxyXG5fUGxheWFibGUucHJvdG90eXBlLnByb2NlZWQgPSBmdW5jdGlvbih7IHNob3J0Q2lyY3VpdCB9ID0ge30sIHJlc3VsdCkge1xyXG5cdHZhciBwbGF5YWJsZSA9IHRoaXM7XHJcblxyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0Ly9SZXBsYWNlIHJlcG9ydGVkIHBsYXlhYmxlIHdpdGggbGF0ZXN0IHJ1bm5pbmcgcGxheWFibGUgKHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBzaG9ydC1jaXJjdWl0IGxvZ2ljKVxyXG5cdFx0cmVzdWx0LnBsYXlhYmxlID0gcGxheWFibGU7XHJcblxyXG5cdFx0Ly9TaG9ydC1jaXJjdWl0IGxvZ2ljIGFsbG93cyBoaWdoZXItb3JkZXIgcGxheWFibGUgdG8gZmlndXJlIG91dCB3aGF0IHRvIGRvIG5leHQuXHJcblx0XHRpZiAoc2hvcnRDaXJjdWl0KSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcblxyXG5cdFx0cmV0dXJuIHBsYXlhYmxlLnBsYXlOZXh0KHJlc3VsdCk7XHJcblx0fSk7XHJcbn07XHJcblxyXG4vL1BsYXkgbmV4dC5cclxuX1BsYXlhYmxlLnByb3RvdHlwZS5wbGF5TmV4dCA9IGZ1bmN0aW9uKHJlc3VsdCwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0dmFyIHBsYXlhYmxlID0gdGhpcztcclxuXHJcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHQvL0ZpbmQgb3V0IHdoZXJlIHRvIGdvIG5leHRcclxuXHRcdHZhciBuZXh0ID0gcGxheWFibGUuZmluZE5leHQoeyByZXN1bHQgfSk7XHJcblxyXG5cdFx0Ly9JZiB0aGVyZSdzIHNvbWV3aGVyZSB0byBnbywgdGhlbiBnby5cclxuXHRcdGlmIChuZXh0WzBdIGluc3RhbmNlb2YgX1BsYXlhYmxlKVxyXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoXHJcblx0XHRcdFx0bmV4dC5tYXAoZnVuY3Rpb24ocGxheWFibGUpIHtcclxuXHRcdFx0XHRcdHJldHVybiBwbGF5YWJsZS5wbGF5KHBhcmFtZXRlcnMpO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0Ly9PdGhlcndpc2UsIHdlJ3JlIGRvbmUgaGVyZVxyXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuLy8gUmV0dXJuIHRoZSBuZXh0IHBsYXlhYmxlIGluIHRoZSBzZXF1ZW5jZS4gT3ZlcndyaXRlYWJsZSBmb3IgcGxheWFibGVzIHdpdGggbW9yZSBjb21wbGljYXRlZCBicmFuY2hpbmcuXHJcbl9QbGF5YWJsZS5wcm90b3R5cGUuZmluZE5leHQgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5uZXh0O1xyXG59O1xyXG5cclxuX1BsYXlhYmxlLnByb3RvdHlwZS5fc3VtbWFyaXplID0gZnVuY3Rpb24oKSB7fTtcclxuXHJcbi8vIFN1bW1hcml6ZSB0aGUgZ2FtZSBzdHJ1Y3R1cmUuIENhbGxzIHN1bW1hcnlUaGlzIGFuZCBzdW1tYXJ5TmV4dCwgd2hpY2ggYXJlIG92ZXJ3cml0YWJsZS5cclxuX1BsYXlhYmxlLnByb3RvdHlwZS5zdW1tYXJpemUgPSBmdW5jdGlvbihcclxuXHRzdW1tYXJ5ID0ge30sXHJcblx0ZW50cmllcyA9IHt9LFxyXG5cdHNob3J0Q2lyY3VpdCA9IGZhbHNlLFxyXG5cdG1heEVudHJpZXMgPSAxMFxyXG4pIHtcclxuXHQvLyBTdGFydCBzdW1tYXJ5IGZvciB0aGlzIHBsYXlhYmxlXHJcblx0c3VtbWFyeVt0aGlzLmNvbnN0cnVjdG9yLmNvdW50ZXJOYW1lXSA9IHRoaXMuaWQ7XHJcblxyXG5cdC8vIFRyYWNrIGhvdyBtYW55IHRpbWVzIHdlJ3ZlIGJlZW4gaGVyZSBiZWZvcmUsIHRvIGF2b2lkIGNpcmN1bGFyIHJlY3Vyc2lvblxyXG5cdGVudHJpZXNbdGhpcy5pZF0gPyArK2VudHJpZXNbdGhpcy5pZF0gOiAoZW50cmllc1t0aGlzLmlkXSA9IDEpO1xyXG5cdGlmIChlbnRyaWVzW3RoaXMuaWRdID4gbWF4RW50cmllcykgc2hvcnRDaXJjdWl0ID0gdHJ1ZTtcclxuXHJcblx0Ly8gQWRkIHN1bW1hcnlcclxuXHR0aGlzLnN1bW1hcnlUaGlzKHN1bW1hcnksIGVudHJpZXMpO1xyXG5cclxuXHQvLyBQcm9jZWVkIHRvIG5leHQgc3RlcHNcclxuXHRpZiAoIXNob3J0Q2lyY3VpdCB8fCBzaG9ydENpcmN1aXQgIT09IHRoaXMpXHJcblx0XHR0aGlzLnN1bW1hcnlOZXh0KHN1bW1hcnksIGVudHJpZXMpO1xyXG5cclxuXHRyZXR1cm4gc3VtbWFyeTtcclxufTtcclxuXHJcbi8vIEFkZHMgdGhlIHN1bW1hcnkgaW5mb3JtYXRpb24gb24gdGhpcyBwbGF5YWJsZS4gT3ZlcndyaXRlIHRoaXMgaW4gb3JkZXIgdG8gYWRkIHNwZWNpZmljIGluZm9ybWF0aW9uLlxyXG5fUGxheWFibGUucHJvdG90eXBlLnN1bW1hcnlUaGlzID0gZnVuY3Rpb24oc3VtbWFyeSA9IHt9LCBlbnRyaWVzID0ge30pIHtcclxuXHRyZXR1cm4gc3VtbWFyeTtcclxufTtcclxuXHJcbi8vIEFkZHMgc3VtbWFyeSBpbmZvcm1hdGlvbiBkb3duIHRoZSBuZXh0LXBhdGguIE92ZXJ3aXRlIHRoaXMgZm9yIHBsYXlhYmxlcyB3aXRoIG1vcmUgY29tcGxleCBicmFuY2hpbmcuXHJcbl9QbGF5YWJsZS5wcm90b3R5cGUuc3VtbWFyeU5leHQgPSBmdW5jdGlvbihzdW1tYXJ5ID0ge30sIGVudHJpZXMgPSB7fSkge1xyXG5cdC8vIElmIHRoZXJlJ3MgYSBuZXh0LWVudHJ5XHJcblx0aWYgKHRoaXMubmV4dC5sZW5ndGggPiAwKSB7XHJcblx0XHQvLyBMb29wIG92ZXIgZWFjaCBuZXh0LWl0ZW0sIGFuZCBzdW1tYXJpemUgaXQuXHJcblx0XHRzdW1tYXJ5Lm5leHQgPSB0aGlzLm5leHQubWFwKGZ1bmN0aW9uKHBsYXlhYmxlKSB7XHJcblx0XHRcdHJldHVybiBwbGF5YWJsZS5zdW1tYXJpemUoe30sIGVudHJpZXMpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gSWYgdGhlcmUncyBvbmx5IG9uZSBpdGVtLCBubyBuZWVkIGZvciBhbiBhcnJheS5cclxuXHRcdGlmIChzdW1tYXJ5Lm5leHQubGVuZ3RoID09IDEpIHN1bW1hcnkubmV4dCA9IHN1bW1hcnkubmV4dFswXTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuLy9Db252b2x1dGVkIGNvZGUgaGVyZSB0byBwcm9kdWNlIHRoZSBvYmplY3QgdGhhdCB1c2VyIGludGVyYWN0cyB3aXRoIChpZSBjMSBpbiAnYzEgPSBDaG9pY2UoKScpXHJcbi8vVGhpcyBtaW1pY3MgY3JlYXRpbmcgYSBjbGFzcyB0aGF0IGluaGVyaXRzIGZyb20gRnVuY3Rpb24uIEZpcnN0IGRlZmluZSB0aGUgXCJwcm90b3R5cGVcIiwgd2hpY2ggaW5jbHVkZXNcclxuLy9hIFwiY29uc3RydWN0b3JcIiwgYSBcImNhbGxcIiBtZXRob2QgdGhhdCB3aWxsIGdldCBjYWxsZWQsIGFuZCBhbnkgb3RoZXIgcHJvcGVydGllcyBhbmQgbWV0aG9kcy5cclxuLy9UaGVuICdjbGFzc0ZhY3RvcnknIHByb2R1Y2VzIHRoZSBjbGFzcy9jb25zdHJ1Y3Rpbmcgb2JqZWN0IChzZWUgYmVsb3cpLCB3aGljaCB5b3UgY2FuIHVzZSB0b1xyXG4vL3Byb2R1Y2UgdGhlIGFjdHVhbCBvYmplY3RzLlxyXG5cclxudmFyIHBsYXlhYmxlUHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGdW5jdGlvbi5wcm90b3R5cGUpO1xyXG5cclxucGxheWFibGVQcm90b3R5cGUuY29uc3RydWN0b3IgPSBmdW5jdGlvbihfcGxheWFibGUpIHtcclxuXHR2YXIgcGxheWFibGUgPSB0aGlzO1xyXG5cclxuXHQvL1RhZy1iYWNrLiBTdG9yZSB0aGUgZnJvbnQtZW5kIG9iamVjdCBpbiB0aGUgYmFjay1lbmQgb2JqZWN0LCBmb3IgcmV0cmlldmFsXHJcblx0X3BsYXlhYmxlLmludGVyZmFjZSA9IHBsYXlhYmxlO1xyXG5cclxuXHR0aGlzLmNhbGwgPSBmdW5jdGlvbihzb3VyY2UpIHtcclxuXHRcdHZhciBwcmV2aW91c1BsYXlhYmxlLCBwYXRoO1xyXG5cclxuXHRcdC8vVE9ETzogdmVyaWZ5IHRoYXQgc291cmNlIGlzIHRoZSByaWdodCB0eXBlXHJcblxyXG5cdFx0cmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5hbGwoW1xyXG5cdFx0XHQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0aWYgKHNvdXJjZSBpbnN0YW5jZW9mIFByb21pc2UgfHwgc291cmNlIGluc3RhbmNlb2YgU3luY2hyb25vdXNQcm9taXNlKSB7XHJcblx0XHRcdFx0XHRzb3VyY2UudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0XHRcdFx0cHJldmlvdXNQbGF5YWJsZSA9IHJlZ2lzdHJ5LnBsYXlhYmxlc1tyZXN1bHQucGxheWFibGUuaWQoKV07XHJcblx0XHRcdFx0XHRcdHBhdGggPSByZXN1bHQucGF0aDtcclxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2cocGF0aCk7XHJcblx0XHRcdFx0XHRcdHJldHVybiBTeW5jaHJvbm91c1Byb21pc2UucmVzb2x2ZSgpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBTeW5jaHJvbm91c1Byb21pc2UucmVzb2x2ZSgpO1xyXG5cdFx0XHR9KSgpLFxyXG5cdFx0XHQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0aWYgKCEoc291cmNlIGluc3RhbmNlb2YgUHJvbWlzZSB8fCBzb3VyY2UgaW5zdGFuY2VvZiBTeW5jaHJvbm91c1Byb21pc2UpKSB7XHJcblx0XHRcdFx0XHRwcmV2aW91c1BsYXlhYmxlID0gcmVnaXN0cnkucGxheWFibGVzW3NvdXJjZS5pZCgpXTtcclxuXHRcdFx0XHRcdHBhdGggPSBzb3VyY2UucGF0aDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBTeW5jaHJvbm91c1Byb21pc2UucmVzb2x2ZSgpO1xyXG5cdFx0XHR9KSgpXHJcblx0XHRdKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhwYXRoKTtcclxuXHRcdFx0bG9nKFxyXG5cdFx0XHRcdFwiZGVidWdcIixcclxuXHRcdFx0XHRcIkFkZGluZyBuZXh0IHBsYXlhYmxlIHRvIFwiICtcclxuXHRcdFx0XHRwcmV2aW91c1BsYXlhYmxlLmlkICtcclxuXHRcdFx0XHRcIiwgbm9kZSBcIiArXHJcblx0XHRcdFx0X3BsYXlhYmxlLmlkXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHRpZiAocGF0aCA9PSBcImFsbFwiKSBwcmV2aW91c1BsYXlhYmxlLmFkZE5leHQoX3BsYXlhYmxlKTtcclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0b3V0Y29tZVRyZWVHZXRWYWx1ZShwcmV2aW91c1BsYXlhYmxlLm5leHQsIHBhdGgpLnB1c2goX3BsYXlhYmxlKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bG9nKFwic2lsbHlcIiwgcHJldmlvdXNQbGF5YWJsZS5uZXh0KTtcclxuXHRcdFx0Ly9wcmV2aW91c1BsYXlhYmxlLm5leHRbc2VsZWN0ZWRdLnB1c2goX2Nob2ljZSk7XHJcblxyXG5cdFx0XHRyZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUoe1xyXG5cdFx0XHRcdHBsYXlhYmxlOiBwbGF5YWJsZSxcclxuXHRcdFx0XHRwYXRoOiBcImFsbFwiXHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0fTtcclxuXHJcblx0dGhpcy5pZCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIF9wbGF5YWJsZS5pZDtcclxuXHR9O1xyXG5cclxuXHR0aGlzLnBsYXkgPSBmdW5jdGlvbih7XHJcblx0XHRpbml0aWFsaXplUGxheWVycyA9IGZhbHNlLFxyXG5cdFx0dXNlUGF5b2ZmcyA9IHRydWUsXHJcblx0XHRzaG9ydENpcmN1aXQgPSBmYWxzZSxcclxuXHRcdHdyaXRlSGlzdG9yeSA9XHJcblx0XHR0cnVlLFxyXG5cdFx0Y2xlYXJIaXN0b3J5ID0gdHJ1ZSxcclxuXHRcdHJlbGVhc2VQbGF5ZXJzID0gdHJ1ZVxyXG5cdH0gPSB7fSkge1xyXG5cclxuXHRcdGlmIChjbGVhckhpc3RvcnkpIGdhbWVIaXN0b3J5LmNsZWFySGlzdG9yeSgpO1xyXG5cclxuXHRcdHZhciBoaXN0b3J5ID0gd3JpdGVIaXN0b3J5ID9cclxuXHRcdFx0X3BsYXlhYmxlLmhpc3RvcnkgfHwgZ2FtZUhpc3RvcnkgOlxyXG5cdFx0XHRuZXcgSGlzdG9yeSgpO1xyXG5cclxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxyXG5cdFx0XHQudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0XHRyZXR1cm4gX3BsYXlhYmxlLnBsYXkoeyBpbml0aWFsaXplUGxheWVycywgdXNlUGF5b2Zmcywgc2hvcnRDaXJjdWl0LCBoaXN0b3J5LCByZWxlYXNlUGxheWVycyB9KTtcclxuXHRcdFx0fSlcclxuXHRcdFx0LmNhdGNoKGZ1bmN0aW9uKHJlYXNvbikge1xyXG5cdFx0XHRcdGNvbnNvbGUubG9nKHJlYXNvbik7XHJcblxyXG5cdFx0XHRcdC8vSWYgdGhlIGdhbWUgd2FzIHN0b3BwZWQgYnkgYSBIYWx0IHBsYXlhYmxlIG9yIGV2ZXJ5Ym9keSdzIGRlYWQsIHdlJ2xsIGVuZCB1cCBoZXJlLCBhbmQgdGhpbmdzIGFyZSBmaW5lLiBKdXN0IGxvZyBpdC5cclxuXHRcdFx0XHRpZiAocmVhc29uLnJlc3VsdCA9PSBcIkhhbHRcIikge1xyXG5cdFx0XHRcdFx0Z2FtZUhpc3RvcnkuYWRkKHJlYXNvbi5oaXN0b3J5RW50cnkpO1xyXG5cdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFzb24ucmVzdWx0KTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKHJlYXNvbi5yZXN1bHQgPT0gXCJQb3B1bGF0aW9uIENvbGxhcHNlXCIpXHJcblx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYXNvbi5yZXN1bHQpO1xyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0aGlzdG9yeS5sb2cuYWRkKHsgZXJyb3I6IHJlYXNvbiB9KTtcclxuXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSlcclxuXHRcdFx0LnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdFx0Ly9SZXBsYWNlIHJlc3VsdCwgc28gdGhhdCB1c2VyIGNhbid0IGdldCBhY2Nlc3MgdG8gX3BsYXlhYmxlc1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcclxuXHRcdFx0XHRcdFBvcHVsYXRpb246IFBvcHVsYXRpb24oKSxcclxuXHRcdFx0XHRcdGdhbWVIaXN0b3J5XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdHRoaXMuc3VtbWFyaXplID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gX3BsYXlhYmxlLnN1bW1hcml6ZSh7fSk7XHJcblx0fTtcclxufTtcclxuXHJcbnBsYXlhYmxlUHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbigpIHtcclxuXHQvL1RoaXMgd2lsbCBnZXQgb3ZlcndyaXR0ZW4gd2hlbiB0aGUgXCJjb25zdHJ1Y3RvclwiIGlzIGNhbGxlZCwgYnV0IGxlYXZpbmcgaXQgaGVyZSBzbyB5b3UgY2FuIGZpZ3VyZSBvdXQgaG93IHRoZSBoZWxsIHRoaXMgd29ya3MuXHJcbn07XHJcblxyXG5wbGF5YWJsZVByb3RvdHlwZS5wYXRoID0gXCJhbGxcIjtcclxuXHJcbi8vUHJvZHVjZXMgdGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBwcm9kdWNlIHRoZSBlbmQgcmVzdWx0LiBUaGlzIHBhcnQgaXMgcmV1c2FibGUgaWYgeW91IG5lZWQgdG8gZG8gdGhpcyBhZ2Fpbi5cclxudmFyIGNsYXNzRmFjdG9yeSA9IGZ1bmN0aW9uKHByb3RvKSB7XHJcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGYgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIGYuY2FsbC5hcHBseShmLCBhcmd1bWVudHMpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZiwgXCJjb25zdHJ1Y3RvclwiLCB7XHJcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuXHRcdFx0d3JpdGFibGU6IHRydWVcclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIFwiY2FsbFwiLCB7IHdyaXRhYmxlOiB0cnVlIH0pO1xyXG5cclxuXHRcdE9iamVjdC5rZXlzKHByb3RvKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xyXG5cdFx0XHRmW2tleV0gPSBwcm90b1trZXldO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Zi5jb25zdHJ1Y3Rvci5hcHBseShmLCBhcmd1bWVudHMpO1xyXG5cclxuXHRcdGRlbGV0ZSBmLmNvbnN0cnVjdG9yOyAvL0FkZGVkIHRoaXMgYml0IGhlcmUsIHRvIHByZXZlbnQgdGhlIHVzZXIgZnJvbSB0cnlpbmcgdG8gY3JlYXRlIG5ldyBvYmplY3RzLlxyXG5cclxuXHRcdHJldHVybiBmO1xyXG5cdH07XHJcbn07XHJcblxyXG52YXIgUGxheWFibGUgPSBjbGFzc0ZhY3RvcnkocGxheWFibGVQcm90b3R5cGUpO1xyXG4vLyBjYWxsZWQgYXM6IHZhciBpbnN0YW5jZSA9IFBsYXlhYmxlKC8qIHNvbWUgaW50ZXJuYWwgb2JqZWN0IGxpa2UgX2Nob2ljZSAqLyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgX1BsYXlhYmxlLCBQbGF5YWJsZSB9O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcclxuXHJcbi8vRXh0ZXJuYWwgZGVwZW5kZW5jeVxyXG52YXIgcG9pc3NvbiA9IHJlcXVpcmUoJ3JhbmRnZW4nKS5ycG9pc3NvbjtcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIge3JlZ2lzdHJ5LCBnYW1lSGlzdG9yeX0gPSByZXF1aXJlKCcuLi9zdGF0ZScpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7aXNGdW5jdGlvbn1cdD0gcmVxdWlyZSgnLi4vaGVscGVyRnVuY3Rpb25zJykoXCJnZW5lcmFsXCIpO1xyXG52YXIge2lkSGFuZGxlcn0gXHQ9IHJlcXVpcmUoJy4uL2hlbHBlckZ1bmN0aW9ucycpKFwic3RhdGVcIik7XHJcblxyXG4vL1BhcmVudCBjbGFzc1xyXG52YXIge19QbGF5YWJsZSwgUGxheWFibGV9ID0gcmVxdWlyZSgnLi9wbGF5YWJsZScpO1xyXG5cclxuLy9QbGF5ZXIgY29udHJvbGxlcnNcclxudmFyIHtfUGxheWVyLCBQbGF5ZXJ9ID0gcmVxdWlyZSgnLi4vcGxheWVyJyk7XHJcbnZhciB7UGxheWVyTGlzdCwgVXNlclBsYXllckxpc3QsIGdhbWVQb3B1bGF0aW9uLCBQb3B1bGF0aW9ufSA9IHJlcXVpcmUoJy4uL3BvcHVsYXRpb24nKTtcclxuXHJcbi8vVXBkYXRlIHRoaXMgZWFjaCB0aW1lIC5wbGF5IGlzIGNhbGxlZCwgYnV0IGxlYXZlIGl0IGF2YWlsYWJsZSB0byB0aGUgd2hvbGUgc2NvcGUgc28gdGhhdCBcclxuLy9ncm93dGggYW5kIGRlY2F5IGNhbiBhY2Nlc3MgaXRcclxudmFyIHBvcHVsYXRpb247XHJcblxyXG4vL0RlZmF1bHQgZ3Jvd3RoIGZ1bmN0aW9uXHJcbnZhciBncm93dGhEZWZhdWx0ID0gZnVuY3Rpb24gZ3Jvd3RoKHBsYXllciwgcG9wdWxhdGlvbiwgYmlydGhSYXRlLCBzZWxlY3RpdmVNdWx0aXBsaWVyKSB7XHJcblx0dmFyIHNjb3JlID0gcGxheWVyLnNjb3JlO1xyXG5cdHZhciBtZWFuID0gcG9wdWxhdGlvbi5zY29yZXNNZWFuKCk7XHJcblx0dmFyIHN0ZCA9IHBvcHVsYXRpb24uc2NvcmVzU3RkKCk7XHJcblx0XHJcblx0dmFyIFogPSAhKGlzTmFOKHN0ZCkgfHwgc3RkPT0wKSA/IChzY29yZS1tZWFuKS9zdGQgOiAwXHJcblx0XHJcblx0Y29uc29sZS5sb2coc2NvcmUsIG1lYW4sIHN0ZCxaKTtcclxuXHRcclxuXHR2YXIgcmF0ZSA9IGJpcnRoUmF0ZSArIHNlbGVjdGl2ZU11bHRpcGxpZXIqWjtcclxuXHJcblx0dmFyIGdlbmVyYXRlZCA9IHBvaXNzb24ocmF0ZSk7XHJcblx0bG9nKFwic2lsbHlcIixcImdyb3d0aERlZmF1bHQ6IGdlbmVyYXRlZCByYW5kb20gbnVtYmVyIFwiICsgZ2VuZXJhdGVkLnRvU3RyaW5nKCkrIFwiIHVzaW5nIHJhdGUgXCIrIHJhdGUudG9TdHJpbmcoKSk7XHJcblx0XHJcblx0cmV0dXJuIGdlbmVyYXRlZDtcclxufVxyXG5cclxuLy9EZWZhdWx0IGRlY2F5IGZ1bmN0aW9uXHJcbnZhciBkZWNheURlZmF1bHQgPSBmdW5jdGlvbiBkZWNheShwbGF5ZXIsIHBvcHVsYXRpb24sIGRlYXRoUmF0ZSwgc2VsZWN0aXZlTXVsdGlwbGllcikge1xyXG5cdHZhciBzY29yZSA9IHBsYXllci5zY29yZTtcclxuXHR2YXIgbWVhbiA9IHBvcHVsYXRpb24uc2NvcmVzTWVhbigpO1xyXG5cdHZhciBzdGQgPSBwb3B1bGF0aW9uLnNjb3Jlc1N0ZCgpO1xyXG5cdFxyXG5cdGNvbnNvbGUubG9nKHNjb3JlLCBtZWFuLCBzdGQpO1xyXG5cdFxyXG5cdHZhciBaID0gICEoaXNOYU4oc3RkKXx8c3RkPT0wKSA/IChzY29yZS1tZWFuKS9zdGQgOiAwO1xyXG5cdFxyXG5cdGNvbnNvbGUubG9nKFopXHJcblx0dmFyIHJhdGUgPSBkZWF0aFJhdGUgLSBzZWxlY3RpdmVNdWx0aXBsaWVyKlo7XHJcblx0XHJcblx0dmFyIGdlbmVyYXRlZCA9IHBvaXNzb24ocmF0ZSk7XHJcblx0bG9nKFwic2lsbHlcIixcImRlY2F5RGVmYXVsdDogZ2VuZXJhdGVkIHJhbmRvbSBudW1iZXIgXCIgKyBnZW5lcmF0ZWQudG9TdHJpbmcoKSsgXCIgdXNpbmcgcmF0ZSBcIisgcmF0ZS50b1N0cmluZygpKTtcclxuXHRyZXR1cm4gZ2VuZXJhdGVkO1xyXG59XHJcblxyXG5cclxuXHJcbi8vQmFja2VuZCBmdW5jdGlvbiBjbGFzcyBmb3IgUG9wdWxhdGlvbkR5bmFtaWNzXHJcbmZ1bmN0aW9uIF9Qb3B1bGF0aW9uRHluYW1pY3MoaWQsIGJpcnRoUmF0ZSxkZWF0aFJhdGUsIHtncm93dGhGdW5jdGlvbj1ncm93dGhEZWZhdWx0LCBkZWNheUZ1bmN0aW9uPWRlY2F5RGVmYXVsdCwgc2VsZWN0aXZlTXVsdGlwbGllcj0gLjUsIHBsYXllclBhcmFtZXRlcnM9e319PXt9KXtcclxuXHRfUGxheWFibGUuY2FsbCh0aGlzLGlkKTtcclxuXHRcclxuXHR2YXIgcGQgPSB0aGlzO1xyXG5cdFxyXG5cdHRoaXMuYmlydGhSYXRlID0gYmlydGhSYXRlO1xyXG5cdHRoaXMuZGVhdGhSYXRlID0gZGVhdGhSYXRlO1xyXG5cdHRoaXMuc2VsZWN0aXZlTXVsdGlwbGllciA9IHNlbGVjdGl2ZU11bHRpcGxpZXI7XHJcblx0XHJcblx0Ly9XcmFwIHRoZSBncm93dGggYW5kIGRlY2F5IGZ1bmN0aW9ucywgc28gdGhhdCB0aGUgdXNlciBkb2Vzbid0IGhhdmUgdG8gd29ycnkgYWJvdXQgY2FsbGluZyB0aGlzLmJpcnRoUmF0ZSBvciB0aGlzLmRlYXRoUmF0ZVxyXG5cdHRoaXMuZ3Jvd3RoID0gZnVuY3Rpb24ocGxheWVyKXtcclxuXHRcdGxvZyhcInNpbGx5XCIsXCJfcGQuZ3Jvd3RoOiBDaGVja2luZyBncm93IGNvbmRpdGlvblwiKTtcclxuXHRcdHJldHVybiBncm93dGhGdW5jdGlvbihwbGF5ZXIsIHBvcHVsYXRpb24sIHBkLmJpcnRoUmF0ZSwgcGQuc2VsZWN0aXZlTXVsdGlwbGllcilcclxuXHR9O1xyXG5cdHRoaXMuZGVjYXkgPSBmdW5jdGlvbihwbGF5ZXIpe1xyXG5cdFx0bG9nKFwic2lsbHlcIixcIl9wZC5kZWNheTogQ2hlY2tpbmcgZGVjYXkgY29uZGl0aW9uXCIpO1xyXG5cdFx0cmV0dXJuIGRlY2F5RnVuY3Rpb24ocGxheWVyLCBwb3B1bGF0aW9uLCBwZC5kZWF0aFJhdGUsIHBkLnNlbGVjdGl2ZU11bHRpcGxpZXIpO1xyXG5cdH07XHJcblx0XHJcblx0dGhpcy5wbGF5ZXJQYXJhbWV0ZXJzID0gcGxheWVyUGFyYW1ldGVycztcclxuXHRcclxuXHRyZWdpc3RyeS5jb250cm9sbGVyc1tpZF0gPSB0aGlzO1xyXG59XHJcbl9Qb3B1bGF0aW9uRHluYW1pY3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShfUGxheWFibGUucHJvdG90eXBlKTtcclxuX1BvcHVsYXRpb25EeW5hbWljcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBfUG9wdWxhdGlvbkR5bmFtaWNzO1xyXG5cclxuX1BvcHVsYXRpb25EeW5hbWljcy5yZWdpc3RyeU5hbWUgPSBcImNvbnRyb2xsZXJzXCI7XHJcbl9Qb3B1bGF0aW9uRHluYW1pY3MuY291bnRlck5hbWUgPSBcInBvcHVsYXRpb25EeW5hbWljc1wiO1xyXG5cclxuXHJcbl9Qb3B1bGF0aW9uRHluYW1pY3MucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih7aW5pdGlhbGl6ZVBsYXllcnM9ZmFsc2UsIHNob3J0Q2lyY3VpdD1mYWxzZSwgaGlzdG9yeT1nYW1lSGlzdG9yeX09e30pe1xyXG5cdFxyXG5cdHZhciBwZCA9IHRoaXM7XHJcblx0XHJcblx0dmFyIGJpcnRocyA9IDA7XHJcblx0dmFyIGRlYXRocyA9IDA7XHJcblx0XHJcblx0Ly9VcGRhdGUgcG9wdWxhdGlvbiB1c2luZyB3aG9ldmVyJ3MgYWxpdmUgY3VycmVudGx5XHJcblx0cG9wdWxhdGlvbiA9IGdhbWVQb3B1bGF0aW9uKCkub25seUFsaXZlKCk7XHJcblx0XHRcclxuXHRcclxuXHQvL0tpbGwgY3ljbGVcclxuXHR2YXIga2lsbGVkID0gbmV3IFBsYXllckxpc3QoW10pO1xyXG5cdHBvcHVsYXRpb24uZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpe1xyXG5cdFx0Ly8gSWYgdGhlIGRlY2F5IGZ1bmN0aW9uIGlzIHJldHVybnMgdHJ1dGh5LCBraWxsLlxyXG5cdFx0XHJcblx0XHRpZiAocGQuZGVjYXkocGxheWVyKSkge1xyXG5cdFx0XHRsb2coXCJzaWxseVwiLFwibXVzdCBraWxsLi4uXCIpXHJcblx0XHRcdHBsYXllci5raWxsKCk7XHJcblx0XHRcdGRlYXRocysrO1xyXG5cdFx0XHRraWxsZWQucHVzaChwbGF5ZXIpO1xyXG5cdFx0XHRsb2coXCJzaWxseVwiLFwiZGVhZFwiKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0XHJcblx0fSk7XHJcblx0XHJcblx0Ly9VcGRhdGUgdXBkYXRlIGFnYWluIHRvIHByZXZlbnQgdGhlIHJlY2VudGx5IGRlY2Vhc2VkIGZyb20gcmVwcm9kdWNpbmdcclxuXHRwb3B1bGF0aW9uID0gZ2FtZVBvcHVsYXRpb24oKS5vbmx5QWxpdmUoKTtcclxuXHRcclxuXHRpZiAocG9wdWxhdGlvbi5sZW5ndGggPT0gMCkge1xyXG5cdFx0Ly9FdmVyeWJvZHkncyBkZWFkLiBMZXQncyB3cmFwIGl0IHVwLlxyXG5cdFx0dmFyIHJlYXNvbiA9IHtyZXN1bHQ6XCJQb3B1bGF0aW9uIENvbGxhcHNlXCIsIHBsYXlhYmxlOnBkfTtcclxuXHRcdGhpc3RvcnkuZW5kKCk7XHJcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYXNvbik7XHJcblx0fVxyXG5cdFxyXG5cdC8vQmlydGggY3ljbGVcclxuXHR2YXIgYm9ybiA9IG5ldyBVc2VyUGxheWVyTGlzdChbXSk7XHJcblx0cG9wdWxhdGlvbi5mb3JFYWNoKGZ1bmN0aW9uKHBsYXllcil7XHJcblx0XHQvL0JpcnRoIHdoYXRldmVyIG51bWJlciBpcyByZXR1cm5lZFxyXG5cdFx0dmFyIG51bUJpcnRoID0gcGQuZ3Jvd3RoKHBsYXllcilcclxuXHRcdGNvbnNvbGUubG9nKG51bUJpcnRoKTtcclxuXHRcdGZvciAodmFyIGk9MTsgaTw9bnVtQmlydGg7IGkrKyl7XHJcblx0XHRcdGxvZyhcInNpbGx5XCIsIFwiUGxheWVyIFwiICsgcGxheWVyLmlkICtcIiBnaXZpbmcgYmlydGghXCIpO1xyXG5cdFx0XHRcclxuXHRcdFx0dmFyIHBsYXllclBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKHt9LHtcclxuXHRcdFx0XHRcdGFzc2lnbjpwbGF5ZXIuc3RyYXRlZ3kgPyBwbGF5ZXIuc3RyYXRlZ3kuX2lkIDogXCJcIixcclxuXHRcdFx0XHRcdHBhcmVudDpwbGF5ZXIuaWR9XHJcblx0XHRcdFx0LHBkLnBsYXllclBhcmFtZXRlcnMpO1xyXG5cdFx0XHRcclxuXHRcdFx0Ym9ybi5wdXNoKFBsYXllcihwbGF5ZXJQYXJhbWV0ZXJzKSk7XHJcblx0XHR9XHRcclxuXHR9KTtcclxuXHRcclxuXHRcclxuXHR2YXIgcmVzdWx0ID0ge2JpcnRocywgZGVhdGhzfTtcclxuXHRcclxuXHR2YXIgcmVzdWx0T2JqZWN0ID0ge1xyXG5cdFx0cmVzdWx0LFxyXG5cdFx0J3BsYXlhYmxlJzpwZCxcclxuXHRcdGhpc3RvcnlFbnRyeTp7XHJcblx0XHRcdHBvcHVsYXRpb25EeW5hbWljczpwZC5pZCxcclxuXHRcdFx0cmVzdWx0XHJcblx0XHR9XHJcblx0fTtcclxuXHRcclxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdE9iamVjdCk7XHJcbn07XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIFBvcHVsYXRpb25EeW5hbWljcyhiaXJ0aFJhdGU9LjA1LCBkZWF0aFJhdGUgPSAuMDUsIHBhcmFtZXRlcnM9e30pe1xyXG5cdHZhciBpZCA9IGlkSGFuZGxlcihwYXJhbWV0ZXJzLmlkLFwicG9wdWxhdGlvbkR5bmFtaWNzXCIpXHJcblx0XHJcblx0aWYgKHBhcmFtZXRlcnMuZ3Jvd3RoICYmICFpc0Z1bmN0aW9uKGdyb3d0aCkpIGxvZyhcImVycm9yXCIsaWQgKyBcIjogZ3Jvd3RoIHNob3VsZCBiZSBhIGZ1bmN0aW9uLlwiKTtcclxuXHRpZiAocGFyYW1ldGVycy5kZWNheSAmJiAhaXNGdW5jdGlvbihkZWNheSkpICAgbG9nKFwiZXJyb3JcIixpZCArIFwiOiBkZWNheSBzaG91bGQgYmUgYSBmdW5jdGlvbi5cIik7XHJcblx0XHRcclxuXHQvL0NyZWF0ZSBiYWNrZW5kIGxhbWJkYSBvYmplY3RcclxuXHR2YXIgX3BkID0gbmV3IF9Qb3B1bGF0aW9uRHluYW1pY3MoaWQsIGJpcnRoUmF0ZSwgZGVhdGhSYXRlLCBwYXJhbWV0ZXJzKTtcclxuXHRcclxuXHRcclxuXHQvL1JldHVybiB0aGlzIHJlZmVyZW5jZSBvYmplY3QgdG8gdGhlIHVzZXIuIFJ1biB0aGUgZnVuY3Rpb24gdG8gc2VsZWN0IGEgc291cmNlXHJcblx0dmFyIHBkID0gUGxheWFibGUoX3BkKTtcdFxyXG5cdHJldHVybiBwZDtcdFxyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7X1BvcHVsYXRpb25EeW5hbWljcywgUG9wdWxhdGlvbkR5bmFtaWNzfTsiLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcclxubG9nKFwiZGVidWdcIiwgXCJMb2FkaW5nIENsYXNzOiBSYW5kb21QbGF5ZXJDaG9pY2VcIilcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIge3JlZ2lzdHJ5LCBnYW1lSGlzdG9yeSwgb2NjdXBpZWRQbGF5ZXJzfSA9IHJlcXVpcmUoJy4uL3N0YXRlJyk7XHJcblxyXG4vL0hlbHBlciBmdW5jdGlvbnNcclxudmFyIHtpZEhhbmRsZXJ9ID0gcmVxdWlyZSgnLi4vaGVscGVyRnVuY3Rpb25zJykoXCJzdGF0ZVwiKTtcclxudmFyIHtjaGFpbmVyR2VuZXJhdG9yfSA9IHJlcXVpcmUoJy4uL2hlbHBlckZ1bmN0aW9ucycpKFwicGxheWFibGVcIik7XHJcblxyXG4vL1BhcmVudCBjbGFzc1xyXG52YXIge19QbGF5YWJsZSwgUGxheWFibGV9ID0gcmVxdWlyZSgnLi9wbGF5YWJsZScpO1xyXG52YXIge19DaG9pY2UsIENob2ljZX0gPSByZXF1aXJlKCcuL2Nob2ljZScpO1xyXG5cclxuLy9Qb3B1bGF0aW9uIGhlbHBlcnNcclxudmFyIHtQbGF5ZXJMaXN0fSA9IHJlcXVpcmUoJy4uL3BvcHVsYXRpb24nKTtcclxuXHJcblxyXG4vL0JhY2tlbmQgZnVuY3Rpb24gY2xhc3MgZm9yIFJQQ2hvaWNlXHJcbmZ1bmN0aW9uIF9SUENob2ljZShpZCwgb3B0aW9ucywge2luY2x1ZGVQbGF5ZXJzLCBleGNsdWRlUGxheWVycz1uZXcgUGxheWVyTGlzdCgpfSl7XHJcblx0XHJcblx0Ly9JZiB0aGV5IHNwZWNpZnkgcGxheWVycyB0byBkcmF3IGZyb20sIHVzZSBvbmx5IHRoYXQgbGlzdC4gT3RoZXJ3aXNlLCB1c2Ugd2hvZXZlcidzIGFyb3VuZC5cclxuXHR0aGlzLmluY2x1ZGVQbGF5ZXJzID0gaW5jbHVkZVBsYXllcnMgfHwgXCJhbGxcIjtcclxuXHRcclxuXHR0aGlzLmV4Y2x1ZGVQbGF5ZXJzID0gbmV3IFBsYXllckxpc3QoZXhjbHVkZVBsYXllcnMpO1xyXG5cdFxyXG5cdHRoaXMuZ2VuZXJhdG9yID0gTWF0aC5yYW5kb207XHJcblx0XHJcblx0dmFyIHBsYXllciA9IG51bGw7XHJcblx0XHJcblx0XHJcblx0X0Nob2ljZS5jYWxsKHRoaXMsaWQsIHBsYXllciwgb3B0aW9ucywge30pO1xyXG59XHJcblxyXG5fUlBDaG9pY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShfQ2hvaWNlLnByb3RvdHlwZSk7XHJcbl9SUENob2ljZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBfUlBDaG9pY2U7XHJcblxyXG5fUlBDaG9pY2UucmVnaXN0cnlOYW1lID0gXCJjaG9pY2VzXCI7XHJcbl9SUENob2ljZS5jb3VudGVyTmFtZSA9IFwicmFuZG9tUGxheWVyQ2hvaWNlXCI7XHJcblxyXG5cclxuXHJcbi8vU2VsZWN0IHRoZSBwbGF5ZXIgdG8gbWFrZSB0aGUgY2hvaWNlXHJcbl9SUENob2ljZS5wcm90b3R5cGUuY2hvb3NlUGxheWVyID0gZnVuY3Rpb24gY2hvb3NlUGxheWVyKCl7XHJcblx0XHJcblx0dmFyIHJwQ2hvaWNlID0gdGhpcztcclxuXHRcclxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpe1xyXG5cdFx0XHJcblx0XHQvL0ZpbmQgcGxheWVycyB0byBjaG9vc2UgZnJvbVxyXG5cdFx0dmFyIHBvb2wgPSBuZXcgUGxheWVyTGlzdChycENob2ljZS5pbmNsdWRlUGxheWVycykub25seUFsaXZlKCkub25seUF2YWlsYWJsZSgpLmV4Y2x1ZGUocnBDaG9pY2UuZXhjbHVkZVBsYXllcnMpXHJcblx0XHRpZiAocG9vbC5sZW5ndGggPT0gMCkgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiTm8gYXZhaWxhYmxlIHBsYXllcnMuXCIpO1xyXG5cdFxyXG5cdFx0bG9nKFwic2lsbHlcIiwgXCJycENob2ljZS5jaG9vc2VQbGF5ZXI6IGNob29zaW5nIGZyb29tIHBvb2w6IFwiICsgcG9vbC5pZHMoKSk7XHJcblx0XHJcblx0XHR2YXIgcmFuZG9tTnVtYmVyID0gTWF0aC5mbG9vcihycENob2ljZS5nZW5lcmF0b3IoKSpwb29sLmxlbmd0aCk7XHJcblx0XHR2YXIgY2FuZGlkYXRlID0gcG9vbFtyYW5kb21OdW1iZXJdO1xyXG5cdFxyXG5cdFxyXG5cdFx0bG9nKFwic2lsbHlcIiwgXCJycENob2ljZS5jaG9vc2VQbGF5ZXI6IHNlbGVjdGluZyBwbGF5ZXIgXCIsIGNhbmRpZGF0ZS5pZClcclxuXHRcclxuXHRcdHJwQ2hvaWNlLnBsYXllciA9IGNhbmRpZGF0ZTtcclxuXHRcdGNhbmRpZGF0ZS5hdmFpbGFibGUgPSBmYWxzZTtcclxuXHRcclxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoY2FuZGlkYXRlLmlkKTtcclxuXHR9KTtcclxufTtcclxuXHJcbl9SUENob2ljZS5wcm90b3R5cGUucHJlUGxheSA9IGZ1bmN0aW9uKCl7XHJcblx0cmV0dXJuIHRoaXMuY2hvb3NlUGxheWVyKCk7XHJcbn07XHJcblxyXG5cclxuX1JQQ2hvaWNlLnByb3RvdHlwZS5zdW1tYXJ5VGhpcyA9IGZ1bmN0aW9uKHN1bW1hcnkpe1xyXG5cdHN1bW1hcnkub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxufTtcclxuXHJcblxyXG5cclxuZnVuY3Rpb24gUmFuZG9tUGxheWVyQ2hvaWNlKG9wdGlvbnMsIHtpZD1udWxsLCBleGNsdWRlUGxheWVycz1bXSwgcGxheWVyTGlzdD1udWxsfT17fSl7XHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKGlkLFwicmFuZG9tUGxheWVyQ2hvaWNlXCIpXHJcblx0XHJcblx0Ly9DcmVhdGUgYmFja2VuZCBjaG9pY2Ugb2JqZWN0XHJcblx0dmFyIF9ycENob2ljZSA9IG5ldyBfUlBDaG9pY2UoaWQsIG9wdGlvbnMsIHtwbGF5ZXJMaXN0LCBleGNsdWRlUGxheWVyc30pO1xyXG5cdFxyXG5cdC8vUmV0dXJuIHRoaXMgcmVmZXJlbmNlIG9iamVjdCB0byB0aGUgdXNlci4gUnVuIHRoZSBmdW5jdGlvbiB0byBzZWxlY3QgYSBzb3VyY2VcclxuXHR2YXIgcnBDaG9pY2UgPSBQbGF5YWJsZShfcnBDaG9pY2UpXHJcblx0XHJcblx0cnBDaG9pY2UucGxheWVyTGlzdCA9IGZ1bmN0aW9uKHBsYXllckxpc3Qpe1xyXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkocGxheWVyTGlzdCkpIF9ycENob2ljZS5wbGF5ZXJMaXN0ID0gcGxheWVyTGlzdDtcclxuXHRcdHJldHVybiBcdF9ycENob2ljZS5wbGF5ZXJMaXN0IFxyXG5cdH07XHJcblx0XHJcblx0cnBDaG9pY2UuZXhjbHVkZVBsYXllcnMgPSBmdW5jdGlvbihleGNsdWRlUGxheWVycyl7XHJcblx0XHRpZiAoQXJyYXkuaXNBcnJheShleGNsdWRlUGxheWVycykpIHtcclxuXHRcdFx0X3JwQ2hvaWNlLmV4Y2x1ZGVQbGF5ZXJzID0gW107XHJcblx0XHRcdFxyXG5cdFx0XHRleGNsdWRlUGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uKHBsYXllcil7XHJcblx0XHRcdFx0X3JwQ2hvaWNlLmV4Y2x1ZGVQbGF5ZXJzLnB1c2gocGxheWVyLmlkKCkpO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gXHRfcnBDaG9pY2UuZXhjbHVkZVBsYXllcnMgXHJcblx0fTtcclxuXHRcclxuXHQvL0ludGVyZmFjZSB0byBzcGVjaWZ5IHNpbmdsZS1wbGF5ZXIgcGF5b2ZmcyBpbiBzaW5nbGUtcGxheWVyL3NpbmdsZS1jaG9pY2UgZ2FtZXNcclxuXHRfcnBDaG9pY2UuemVyb1BheW9mZnMoKTsgICAgICAgXHJcblx0XHJcblx0X3JwQ2hvaWNlLmdlbmVyYXRlQ2hhaW5pbmdGdW5jdGlvbnMocnBDaG9pY2UpO1xyXG5cdFxyXG5cdC8vRnVuY3Rpb24gdG8gc2V0IGFsbCBwYXlvZmZzIGF0IG9uY2VcclxuXHRycENob2ljZS5zZXRBbGxQYXlvZmZzID0gZnVuY3Rpb24ocGF5b2Zmcyl7XHJcblx0XHQvL1RPRE86IG1ha2UgdGhpcyB3b3JrLiBJbmNsdWRlIGVycm9yIGhhbmRsaW5nIGlmIGFycmF5IGdpdmVuIGlzbid0IGV4cGVjdGVkIGRpbWVuc2lvbnMuXHJcblx0fTtcclxuXHRcclxuXHRcclxuXHQvL1dheSBmb3IgdXNlciB0byBpbnRlcmFjdCB3aXRoIHBheW9mZnNcclxuXHRycENob2ljZS5wYXlvZmZzID0gZnVuY3Rpb24oKXtyZXR1cm4gcmVnaXN0cnkuY2hvaWNlc1tpZF0ucGF5b2Zmczt9O1xyXG5cdFxyXG5cdHJldHVybiBycENob2ljZTtcdFxyXG59XHJcblxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge19SUENob2ljZSwgUmFuZG9tUGxheWVyQ2hvaWNlfTsiLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKFwiLi4vbG9nZ2VyXCIpO1xyXG5sb2coXCJkZWJ1Z1wiLCBcIkxvYWRpbmcgQ2xhc3M6IFNlcXVlbmNlXCIpO1xyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7IHJlZ2lzdHJ5IH0gPSByZXF1aXJlKFwiLi4vc3RhdGVcIik7XHJcbnZhciB7IGdhbWVIaXN0b3J5IH0gPSByZXF1aXJlKFwiLi4vaGlzdG9yeVwiKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpZEhhbmRsZXIgfSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJGdW5jdGlvbnNcIikoXCJzdGF0ZVwiKTtcclxuXHJcbi8vSW5mb3JtYXRpb25cclxudmFyIHsgSW5mb3JtYXRpb24sIFBlcmZlY3RJbmZvcm1hdGlvbiB9ID0gcmVxdWlyZShcIi4uL2luZm9ybWF0aW9uXCIpO1xyXG5cclxuLy9QYXJlbnQgY2xhc3NcclxudmFyIHsgX1BsYXlhYmxlLCBQbGF5YWJsZSB9ID0gcmVxdWlyZShcIi4vcGxheWFibGVcIik7XHJcblxyXG4vL0JhY2tlbmQgZnVuY3Rpb24gY2xhc3MgZm9yIFNlcXVlbmNlXHJcbmZ1bmN0aW9uIF9TZXF1ZW5jZShpZCwgcGxheWFibGVTdGFydCwgcGxheWFibGVGaW5pc2gsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdF9QbGF5YWJsZS5jYWxsKHRoaXMsIGlkLCBwYXJhbWV0ZXJzKTtcclxuXHJcblx0dGhpcy5wbGF5YWJsZVN0YXJ0ID0gcmVnaXN0cnkucGxheWFibGVzW3BsYXlhYmxlU3RhcnQuaWQoKV07XHJcblx0dGhpcy5wbGF5YWJsZUZpbmlzaCA9IHJlZ2lzdHJ5LnBsYXlhYmxlc1twbGF5YWJsZUZpbmlzaC5pZCgpXTtcclxuXHJcblx0cmVnaXN0cnkuc2VxdWVuY2VzW2lkXSA9IHRoaXM7XHJcbn1cclxuX1NlcXVlbmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX1BsYXlhYmxlLnByb3RvdHlwZSk7XHJcbl9TZXF1ZW5jZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBfU2VxdWVuY2U7XHJcblxyXG5fU2VxdWVuY2UucmVnaXN0cnlOYW1lID0gXCJzZXF1ZW5jZXNcIjtcclxuX1NlcXVlbmNlLmNvdW50ZXJOYW1lID0gXCJzZXF1ZW5jZVwiO1xyXG5cclxuX1NlcXVlbmNlLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24oe1xyXG5cdGhpc3RvcnkgPSBnYW1lSGlzdG9yeSxcclxuXHRpbmZvcm1hdGlvbiA9IHRoaXMuaW5mb3JtYXRpb24gfHxcclxuXHRQZXJmZWN0SW5mb3JtYXRpb25cclxufSA9IHt9KSB7XHJcblxyXG5cdHZhciBzZXF1ZW5jZSA9IHRoaXM7XHJcblxyXG5cdC8vTG9nIHRoZSBoaXN0b3J5IGFwcHJvcHJpYXRlbHlcclxuXHR2YXIgc3RhcnRFbnRyeSA9IHtcclxuXHRcdHNlcXVlbmNlOiBzZXF1ZW5jZS5pZCxcclxuXHRcdGFjdGlvbjogXCJzdGFydFwiXHJcblx0fTtcclxuXHRoaXN0b3J5LmxvZy5hZGQoc3RhcnRFbnRyeSk7XHJcblxyXG5cdC8vSGlzdG9yeSBvYmplY3QgdG8gZ2l2ZSB0byBzZXF1ZW5jZWQgcGxheWFibGVzLlxyXG5cdHZhciBzZXF1ZW5jZUhpc3RvcnkgPSBoaXN0b3J5LmNoaWxkKCk7XHJcblxyXG5cdC8vY29tcGFydG1lbnRhbGl6ZSBpZiBzZXQuIFwiY29tcGFydG1lbnRhbGl6ZVwiIG1lYW5zIHBhc3Mgb24gaW5mb3JtYXRpb24gYXMgaWYgdGhpcyBwbGF5YWJsZSBpcyB0aGUgZW50aXJlIGdhbWUuXHJcblx0aWYgKHNlcXVlbmNlLmNvbXBhcnRtZW50YWxpemUpIHtcclxuXHRcdGluZm9ybWF0aW9uID0gbmV3IEluZm9ybWF0aW9uKHNlcXVlbmNlLmNvbXBhcnRtZW50YWxpemUuaGlzdG9yeSB8fCBzZXF1ZW5jZUhpc3RvcnksXHJcblx0XHRcdHNlcXVlbmNlLmNvbXBhcnRtZW50YWxpemUucG9wdWxhdGlvbiB8fCBnYW1lUG9wdWxhdGlvbik7XHJcblx0fVxyXG5cclxuXHQvLyBSZWN1cnNpb24gZG93biB0aGUgY2hhaW4gb2YgcGxheWFibGVzXHJcblx0dmFyIGFjdGlvbiA9IGZ1bmN0aW9uIGFjdGlvbihyZXN1bHQpIHtcclxuXHRcdC8vU3RvcCBpZiB0aGUgZ2FtZSBpcyBvdmVyLlxyXG5cdFx0aWYgKGhpc3Rvcnkuc3RvcCkgcmV0dXJuIHsgcGxheWFibGU6IHNlcXVlbmNlIH07XHJcblxyXG5cdFx0Ly9PdGhlcndpc2UsIHJlY3Vyc2UgdG8gZmlndXJlIG91dCB3aGF0IHRvIGRvIG5leHQuXHJcblx0XHRpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XHJcblx0XHRcdGxvZyhcInNpbGx5XCIsIFwic2VxdWVuY2UucGxheTogTmV4dC1pdGVtIGlzIGFuIGFycmF5LCBzcGxpdHRpbmcgaW50byBwaWVjZXMuXCIpO1xyXG5cclxuXHRcdFx0cmV0dXJuIFByb21pc2UuYWxsKFxyXG5cdFx0XHRcdHJlc3VsdC5tYXAoZnVuY3Rpb24oaXRlbSkge1xyXG5cdFx0XHRcdFx0bG9nKFwic2lsbHlcIiwgXCJzZXF1ZW5jZS5wbGF5OiByZWN1cnNpbmcgb25cIiwgaXRlbSk7XHJcblx0XHRcdFx0XHRyZXR1cm4gYWN0aW9uKGl0ZW0pO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHJlc3VsdC5wbGF5YWJsZSAhPT0gc2VxdWVuY2UucGxheWFibGVGaW5pc2gpIHtcclxuXHRcdFx0bG9nKFwic2lsbHlcIiwgcmVzdWx0KTtcclxuXHJcblx0XHRcdGlmIChyZXN1bHQucGxheWFibGUuZmluZE5leHQoeyByZXN1bHQgfSkubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdGxvZyhcInNpbGx5XCIsIFwiUGxheWFibGUgaGFzIG5leHQtaXRlbSwgY29udGludWluZyBkb3duIGNoYWluLlwiKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHJlc3VsdC5wbGF5YWJsZS5wbGF5TmV4dChyZXN1bHQsIHsgc2hvcnRDaXJjdWl0OiB0cnVlLCBoaXN0b3J5OiBzZXF1ZW5jZUhpc3RvcnksIGluZm9ybWF0aW9uIH0pXHJcblx0XHRcdFx0XHQudGhlbihhY3Rpb24pOyAvL1JlcGVhdCBmb3IgbmV4dCBwbGF5YWJsZSBpbiBjaGFpblxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gc2VxdWVuY2UucGxheWFibGVTdGFydFxyXG5cdFx0LnBsYXkoeyBzaG9ydENpcmN1aXQ6IHRydWUsIGhpc3Rvcnk6IHNlcXVlbmNlSGlzdG9yeSwgaW5mb3JtYXRpb24gfSlcclxuXHRcdC50aGVuKGFjdGlvbilcclxuXHRcdC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0XHRyZXN1bHQuaGlzdG9yeUVudHJ5ID0ge1xyXG5cdFx0XHRcdHNlcXVlbmNlOiBzZXF1ZW5jZS5pZCxcclxuXHRcdFx0XHRhY3Rpb246IHNlcXVlbmNlSGlzdG9yeS5vcnBoYW4oKVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0Ly9UT0RPOiBhZGQgaW5mb3JtYXRpb24gbWVjaGFuaXNtc1xyXG5cclxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG5cdFx0fSk7XHJcbn07XHJcblxyXG4vL092ZXJ3cml0ZSBoaXN0b3J5IGhhbmRsZXIgc28gdGhhdCB0cmVlIGRvZXNuJ3QgaGF2ZSBcInN0YXJ0XCIgYW5kIFwiZmluaXNoXCIgZW50cmllcy5cclxuX1NlcXVlbmNlLnByb3RvdHlwZS5oYW5kbGVIaXN0b3J5ID0gZnVuY3Rpb24oeyBoaXN0b3J5ID0gZ2FtZUhpc3RvcnkgfSA9IHt9LFxyXG5cdHJlc3VsdFxyXG4pIHtcclxuXHR2YXIgc2VxdWVuY2UgPSB0aGlzO1xyXG5cclxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdGhpc3RvcnkubG9nLmFkZCh7XHJcblx0XHRcdHNlcXVlbmNlOiBzZXF1ZW5jZS5pZCxcclxuXHRcdFx0YWN0aW9uOiBcImZpbmlzaFwiLFxyXG5cdFx0XHRkdXJhdGlvbjogcmVzdWx0Lmhpc3RvcnlFbnRyeS5kdXJhdGlvblxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aGlzdG9yeS5hZGROb0xvZyhyZXN1bHQuaGlzdG9yeUVudHJ5KTtcclxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuXHR9KTtcclxufTtcclxuXHJcbi8vVE9ETzogZmluaXNoIHRoaXMhXHJcbl9TZXF1ZW5jZS5wcm90b3R5cGUuc3VtbWFyeVRoaXMgPSBmdW5jdGlvbihzdW1tYXJ5LCBlbnRyaWVzLCBzaG9ydENpcmN1aXQpIHtcclxuXHRzdW1tYXJ5LmFjdGlvbiA9IHt9O1xyXG5cclxuXHR0aGlzLnBsYXlhYmxlU3RhcnQuc3VtbWFyaXplKFxyXG5cdFx0c3VtbWFyeS5hY3Rpb24sXHJcblx0XHRlbnRyaWVzLFxyXG5cdFx0KHNob3J0Q2lyY3VpdCA9IHRoaXMucGxheWFibGVGaW5pc2gpXHJcblx0KTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIFNlcXVlbmNlKHBsYXlhYmxlU3RhcnQsIHBsYXlhYmxlRmluaXNoLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHR2YXIgaWQgPSBpZEhhbmRsZXIocGFyYW1ldGVycy5pZCwgXCJzZXF1ZW5jZVwiKTtcclxuXHJcblx0Ly9DcmVhdGUgYmFja2VuZCBsb29wIG9iamVjdFxyXG5cdHZhciBfc2VxdWVuY2UgPSBuZXcgX1NlcXVlbmNlKGlkLCBwbGF5YWJsZVN0YXJ0LCBwbGF5YWJsZUZpbmlzaCwgcGFyYW1ldGVycyk7XHJcblxyXG5cdC8vUmV0dXJuIHRoaXMgcmVmZXJlbmNlIG9iamVjdCB0byB0aGUgdXNlci4gUnVuIHRoZSBmdW5jdGlvbiB0byBzZWxlY3QgYSBzb3VyY2VcclxuXHR2YXIgc2VxdWVuY2UgPSBQbGF5YWJsZShfc2VxdWVuY2UpO1xyXG5cdHJldHVybiBzZXF1ZW5jZTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7IF9TZXF1ZW5jZSwgU2VxdWVuY2UgfTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XHJcblxyXG4vL0hlbHBlciBmdW5jdGlvbnNcclxudmFyIHsgaXNPYmplY3QgfSA9IHJlcXVpcmUoJy4uL2hlbHBlckZ1bmN0aW9ucycpKFwiZ2VuZXJhbFwiKTtcclxudmFyIHsgaWRIYW5kbGVyIH0gPSByZXF1aXJlKCcuLi9oZWxwZXJGdW5jdGlvbnMnKShcInN0YXRlXCIpO1xyXG5cclxuLy9QYXJlbnQgY2xhc3NcclxudmFyIHsgX1BsYXlhYmxlLCBQbGF5YWJsZSB9ID0gcmVxdWlyZSgnLi9wbGF5YWJsZScpO1xyXG5cclxuLy8gSW5mb3JtYXRpb24gbWVjaGFuaWNzXHJcbnZhciB7IEluZm9ybWF0aW9uLCBQZXJmZWN0SW5mb3JtYXRpb24gfSA9IHJlcXVpcmUoJy4uL2luZm9ybWF0aW9uJyk7XHJcblxyXG5cclxuLy9CYWNrZW5kIGNsYXNzXHJcbmZ1bmN0aW9uIF9TaW11bHRhbmVvdXMoaWQsIHBsYXlhYmxlQXJyYXksIHsgcGxheWFibGVQYXJhbWV0ZXJzID0ge30gfSA9IHt9KSB7XHJcblx0X1BsYXlhYmxlLmNhbGwodGhpcywgaWQpO1xyXG5cclxuXHR0aGlzLnBsYXlhYmxlQXJyYXkgPSBwbGF5YWJsZUFycmF5O1xyXG5cdHRoaXMucGxheWFibGVQYXJhbWV0ZXJzID0gcGxheWFibGVQYXJhbWV0ZXJzO1xyXG5cclxuXHRyZWdpc3RyeS5jb250cm9sbGVyc1tpZF0gPSB0aGlzO1xyXG59XHJcblxyXG5fU2ltdWx0YW5lb3VzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX1BsYXlhYmxlLnByb3RvdHlwZSk7XHJcbl9TaW11bHRhbmVvdXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gX1NpbXVsdGFuZW91cztcclxuXHJcbl9TaW11bHRhbmVvdXMucmVnaXN0cnlOYW1lID0gXCJjb250cm9sbGVyc1wiO1xyXG5fU2ltdWx0YW5lb3VzLmNvdW50ZXJOYW1lID0gXCJzaW11bHRhbmVvdXNcIjtcclxuXHJcblxyXG4vL1NpbXVsdGFuZW91cyBQcm9taXNlLmFsbCdzIHRoZSBwbGF5YWJsZXMsIHdoaWNoIGNhdXNlcyB0aGVtIHRvIHJ1biBtZXNoZWQuXHJcbl9TaW11bHRhbmVvdXMucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih7IGhpc3RvcnkgPSBnYW1lSGlzdG9yeSwgaW5mb3JtYXRpb24gPSBQZXJmZWN0SW5mb3JtYXRpb24gfSA9IHt9KSB7XHJcblxyXG5cdHZhciBzaW11bHRhbmVvdXMgPSB0aGlzO1xyXG5cclxuXHQvLyBEZWFsIHdpdGggaGlzdG9yeS4gTG9nIHN0YXJ0LCB0aGVuIHNwbGl0IGhpc3RvcnkgZm9yIGNoaWxkcmVuIHBsYXlhYmxlcyB0byBmaWxsIGluLlxyXG5cdGhpc3RvcnkubG9nLmFkZCh7XHJcblx0XHRzaW11bHRhbmVvdXM6IHNpbXVsdGFuZW91cy5pZCxcclxuXHRcdGFjdGlvbjogXCJTaW11bHRhbmVvdXMgc3RhcnQuXCJcclxuXHR9KTtcclxuXHR2YXIgc2ltdWx0YW5lb3VzSGlzdG9yeSA9IFtdXHJcblxyXG5cclxuXHJcblx0Ly9UT0RPOiBpcyBpbmZvcm1hdGlvbiBtZWNoYW5pY3MgY29ycmVjdD9cclxuXHJcblx0cmV0dXJuIFByb21pc2UuYWxsKHNpbXVsdGFuZW91cy5wbGF5YWJsZUFycmF5Lm1hcChmdW5jdGlvbihwbGF5YWJsZSkge1xyXG5cdFx0dmFyIGJyYW5jaEhpc3RvcnkgPSBoaXN0b3J5LmNoaWxkV2l0aENvbnRlbnQoKTtcclxuXHRcdHNpbXVsdGFuZW91c0hpc3RvcnkucHVzaChicmFuY2hIaXN0b3J5KVxyXG5cclxuXHRcdC8vIEluZm9ybWF0aW9uIG1lY2hhbmljc1xyXG5cdFx0Ly9jb21wYXJ0bWVudGFsaXplIGlmIHNldC4gXCJjb21wYXJ0bWVudGFsaXplXCIgbWVhbnMgcGFzcyBvbiBpbmZvcm1hdGlvbiBhcyBpZiB0aGlzIHBsYXlhYmxlIGlzIHRoZSBlbnRpcmUgZ2FtZS5cclxuXHRcdGlmIChzaW11bHRhbmVvdXMuY29tcGFydG1lbnRhbGl6ZSkge1xyXG5cdFx0XHRpbmZvcm1hdGlvbiA9IG5ldyBJbmZvcm1hdGlvbihzaW11bHRhbmVvdXMuY29tcGFydG1lbnRhbGl6ZS5oaXN0b3J5IHx8IGJyYW5jaEhpc3RvcnksXHJcblx0XHRcdFx0c2ltdWx0YW5lb3VzLmNvbXBhcnRtZW50YWxpemUucG9wdWxhdGlvbiB8fCBnYW1lUG9wdWxhdGlvbik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHNpbXVsdGFuZW91c0luZm9ybWF0aW9uID0gaW5mb3JtYXRpb24uY2hpbGQoKTtcclxuXHJcblx0XHRyZXR1cm4gcGxheWFibGUucGxheSh7IGhpc3Rvcnk6IHNpbXVsdGFuZW91c0hpc3RvcnksIGluZm9ybWF0aW9uOiBzaW11bHRhbmVvdXNJbmZvcm1hdGlvbiB9KTtcclxuXHR9KSkudGhlbihmdW5jdGlvbihyZXN1bHRBcnJheSkge1xyXG5cclxuXHRcdHZhciByZXN1bHRPYmplY3QgPSB7XHJcblx0XHRcdHJlc3VsdEFycmF5LFxyXG5cdFx0XHRwbGF5YWJsZTogc2ltdWx0YW5lb3VzLFxyXG5cdFx0XHRoaXN0b3J5RW50cnk6IHtcclxuXHRcdFx0XHRzaW11bHRhbmVvdXM6IHNpbXVsdGFuZW91cy5pZCxcclxuXHRcdFx0XHRhY3Rpb246IHNpbXVsdGFuZW91c0hpc3RvcnkubWFwKGZ1bmN0aW9uKGhpc3RvcnkpIHtcclxuXHRcdFx0XHRcdHJldHVybiBoaXN0b3J5Lm9ycGhhbigpO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0XHRyZXR1cm4gcmVzdWx0T2JqZWN0O1xyXG5cdH0pO1xyXG59O1xyXG5cclxuXHJcbl9TaW11bHRhbmVvdXMucHJvdG90eXBlLmhhbmRsZUhpc3RvcnkgPSBmdW5jdGlvbih7IGhpc3RvcnkgPSBnYW1lSGlzdG9yeSB9ID0ge30sIHJlc3VsdCkge1xyXG5cclxuXHRoaXN0b3J5LmxvZy5hZGQoe1xyXG5cdFx0c2ltdWx0YW5lb3VzOiB0aGlzLmlkLFxyXG5cdFx0YWN0aW9uOiBcIlNpbXVsdGFuZW91cyBjb21wbGV0ZS5cIlxyXG5cdH0pO1xyXG5cclxuXHRoaXN0b3J5LmFkZE5vTG9nKHJlc3VsdC5oaXN0b3J5RW50cnkpO1xyXG5cclxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcbn07XHJcblxyXG5fU2ltdWx0YW5lb3VzLnByb3RvdHlwZS5zdW1tYXJ5VGhpcyA9IGZ1bmN0aW9uKHN1bW1hcnksIGVudHJpZXMpIHtcclxuXHRzdW1tYXJ5LmFjdGlvbiA9IFtdO1xyXG5cclxuXHR0aGlzLnBsYXlhYmxlQXJyYXkuZm9yRWFjaChmdW5jdGlvbihwbGF5YWJsZSwgaW5kZXgpIHtcclxuXHRcdHN1bW1hcnkuYWN0aW9uW2luZGV4XSA9IHt9XHJcblx0XHRwbGF5YWJsZS5zdW1tYXJpemUoc3VtbWFyeS5hY3Rpb25baW5kZXhdLCBlbnRyaWVzKTtcclxuXHR9KTtcclxufVxyXG5cclxuXHJcbi8vRnJvbnRlbmQgY2xhc3NcclxuZnVuY3Rpb24gU2ltdWx0YW5lb3VzKHBsYXlhYmxlQXJyYXksIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdHZhciBpZCA9IGlkSGFuZGxlcihwYXJhbWV0ZXJzLmlkLCBcInNpbXVsdGFuZW91c1wiKVxyXG5cclxuXHRwbGF5YWJsZUFycmF5ID0gcGxheWFibGVBcnJheS5tYXAoZnVuY3Rpb24ocGxheWFibGUpIHtcclxuXHRcdHJldHVybiByZWdpc3RyeS5wbGF5YWJsZXNbcGxheWFibGUuaWQoKV07XHJcblx0fSk7XHJcblxyXG5cclxuXHQvL0NyZWF0ZSBiYWNrZW5kIGluc3RhbmNlLlxyXG5cdHZhciBfc2ltdWx0YW5lb3VzID0gbmV3IF9TaW11bHRhbmVvdXMoaWQsIHBsYXlhYmxlQXJyYXksIHBhcmFtZXRlcnMpO1xyXG5cclxuXHQvL1JldHVybiB0aGlzIHJlZmVyZW5jZSBvYmplY3QgdG8gdGhlIHVzZXIuIFJ1biB0aGUgZnVuY3Rpb24gdG8gc2VsZWN0IGEgc291cmNlXHJcblx0dmFyIHNpbXVsdGFuZW91cyA9IFBsYXlhYmxlKF9zaW11bHRhbmVvdXMpO1xyXG5cdHJldHVybiBzaW11bHRhbmVvdXM7XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgX1NpbXVsdGFuZW91cywgU2ltdWx0YW5lb3VzIH07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGxvZyA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xyXG5sb2coXCJkZWJ1Z1wiLCBcIkxvYWRpbmcgQ2xhc3M6IFN0b2NoYXN0aWMtSGFsdFwiKVxyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7cmVnaXN0cnksIGdhbWVIaXN0b3J5fSA9IHJlcXVpcmUoJy4uL3N0YXRlJyk7XHJcblxyXG4vL0hlbHBlciBmdW5jdGlvbnNcclxudmFyIHtpc0Z1bmN0aW9ufVx0PSByZXF1aXJlKCcuLi9oZWxwZXJGdW5jdGlvbnMnKShcImdlbmVyYWxcIik7XHJcbnZhciB7aWRIYW5kbGVyfSBcdD0gcmVxdWlyZSgnLi4vaGVscGVyRnVuY3Rpb25zJykoXCJzdGF0ZVwiKTtcclxuXHJcbi8vUGFyZW50IGNsYXNzXHJcbnZhciB7X1BsYXlhYmxlLCBQbGF5YWJsZX0gXHQ9IHJlcXVpcmUoJy4vcGxheWFibGUnKTtcclxudmFyIHtfSGFsdCwgSGFsdH1cdFx0XHQ9IHJlcXVpcmUoJy4vaGFsdC1pZicpO1xyXG5cclxuXHJcbi8vQmFja2VuZCBmdW5jdGlvbiBjbGFzcyBmb3IgU0hhbHRcclxuZnVuY3Rpb24gX1NIYWx0KGlkLCBwcm9iYWJpbGl0eSwgcGFyYW1ldGVycyl7XHJcblx0X0hhbHQuY2FsbCh0aGlzLGlkLG51bGwscGFyYW1ldGVycyk7XHJcblx0XHJcblx0dmFyIHNIYWx0ID0gdGhpcztcclxuXHRcclxuXHR0aGlzLnByb2JhYmlsaXR5ID0gcHJvYmFiaWxpdHk7XHJcblx0dGhpcy5nZW5lcmF0b3IgPSBNYXRoLnJhbmRvbTtcdFx0XHRcdC8vVE9ETzogYWxsb3cgdXNlciB0byBzcGVjaWZ5IHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXHJcblx0XHJcblx0dGhpcy50ZXN0Q29uZGl0aW9uID0gZnVuY3Rpb24oKXtcclxuXHRcdGlmIChzSGFsdC5nZW5lcmF0b3IoKSA8IHNIYWx0LnByb2JhYmlsaXR5KSByZXR1cm4gdHJ1ZTtcclxuXHR9O1xyXG5cdFxyXG5cdFxyXG5cdHJlZ2lzdHJ5LnNIYWx0c1tpZF0gPSB0aGlzO1xyXG59XHJcbl9TSGFsdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKF9IYWx0LnByb3RvdHlwZSk7XHJcbl9TSGFsdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBfU0hhbHQ7XHJcblxyXG5fU0hhbHQucmVnaXN0cnlOYW1lID0gXCJzSGFsdHNcIjtcclxuX1NIYWx0LmNvdW50ZXJOYW1lID0gXCJzdG9jaGFzdGljSGFsdFwiO1xyXG5cclxuLypcclxuX1NIYWx0LnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24oe2luaXRpYWxpemVQbGF5ZXJzPWZhbHNlLCBzaG9ydENpcmN1aXQ9ZmFsc2V9PXt9KXtcclxuXHRcclxuXHR2YXIgc0hhbHQgPSB0aGlzO1xyXG5cdHZhciB0ZXN0ID0gc0hhbHQudGVzdENvbmRpdGlvbigpO1xyXG5cdFxyXG5cdGlmICh0ZXN0KSB7XHJcblx0XHRsb2coXCJpbmZvXCIsIFwiSGFsdGluZyBhdCBcIiArIHNIYWx0LmlkKVxyXG5cdFx0XHJcblx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3Qoe1xyXG5cdFx0XHRyZXN1bHQ6XCJIYWx0XCIsXHJcblx0XHRcdHBsYXlhYmxlOnNIYWx0XHJcblx0XHR9KTtcclxuXHR9XHJcblx0XHJcblx0dmFyIHJlc3VsdE9iamVjdCA9IHtcclxuXHRcdCdyZXN1bHQnOlwiQ29udGludWVkXCIsXHJcblx0XHQncGxheWFibGUnOnNIYWx0XHJcblx0fTtcclxuXHRcclxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdE9iamVjdClcclxuXHQudGhlbihmdW5jdGlvbihyZXN1bHQpe1x0XHJcblx0XHRcclxuXHRcdC8vVE9ETzogYWRkIGluZm9ybWF0aW9uIG1lY2hhbmlzbXNcclxuXHRcdFxyXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpXHRcdFxyXG5cdH0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcclxuXHRcdFxyXG5cdFx0cmV0dXJuIHNIYWx0LnByb2NlZWQocmVzdWx0LCBzaG9ydENpcmN1aXQpO1xyXG5cdH0pO1xyXG59O1xyXG4qL1xyXG5cclxuX1NIYWx0LnByb3RvdHlwZS5zdW1tYXJ5VGhpcyA9IGZ1bmN0aW9uKHN1bW1hcnksIGVudHJpZXMpe1xyXG5cdHN1bW1hcnkucHJvYmFiaWxpdHkgPSB0aGlzLnByb2JhYmlsaXR5O1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gU3RvY2hhc3RpY0hhbHQocHJvYmFiaWxpdHksIHtpZD1udWxsLCBsb2dDb250aW51ZT1mYWxzZX09e30pe1xyXG5cdHZhciBpZCA9IGlkSGFuZGxlcihpZCxcInN0b2NoYXN0aWNIYWx0XCIpXHJcblx0XHJcblx0aWYgKGlzTmFOKHByb2JhYmlsaXR5KSB8fCBwcm9iYWJpbGl0eSA8IDAgfHwgcHJvYmFiaWxpdHkgPiAxKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJvYmFiaWxpdHknKTtcclxuXHJcblx0Ly9DcmVhdGUgYmFja2VuZCBzSGFsdCBvYmplY3RzXHJcblx0dmFyIF9zSGFsdCA9IG5ldyBfU0hhbHQoaWQsIHByb2JhYmlsaXR5LCB7bG9nQ29udGludWV9KTtcclxuXHRcclxuXHRcclxuXHQvL1JldHVybiB0aGlzIHJlZmVyZW5jZSBvYmplY3QgdG8gdGhlIHVzZXIuIFJ1biB0aGUgZnVuY3Rpb24gdG8gc2VsZWN0IGEgc291cmNlXHJcblx0dmFyIHNIYWx0ID0gUGxheWFibGUoX3NIYWx0KTtcdFxyXG5cdHJldHVybiBzSGFsdDtcdFxyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7X1NIYWx0LCBTdG9jaGFzdGljSGFsdH07IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XHJcbmxvZyhcImRlYnVnXCIsIFwiTG9hZGluZyBDbGFzczogU3RvY2hhc3RpY0xvb3BcIilcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIge3JlZ2lzdHJ5LCBnYW1lSGlzdG9yeX0gPSByZXF1aXJlKCcuLi9zdGF0ZScpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7aWRIYW5kbGVyfSBcdFx0PSByZXF1aXJlKCcuLi9oZWxwZXJGdW5jdGlvbnMnKShcInN0YXRlXCIpO1xyXG52YXIge2NoYWluZXJHZW5lcmF0b3J9IFx0PSByZXF1aXJlKCcuLi9oZWxwZXJGdW5jdGlvbnMnKShcInBsYXlhYmxlXCIpO1xyXG5cclxuLy9QYXJlbnQgY2xhc3Nlc1xyXG52YXIge19QbGF5YWJsZSxQbGF5YWJsZX0gPSByZXF1aXJlKCcuL3BsYXlhYmxlJyk7XHJcbnZhciB7X0xvb3AsIExvb3B9IFx0XHQgPSByZXF1aXJlKCcuL2xvb3AnKTtcclxuXHJcblxyXG4vL0JhY2tlbmQgZnVuY3Rpb24gY2xhc3MgZm9yIFN0b2NoYXN0aWNMb29wXHJcbmZ1bmN0aW9uIF9TTG9vcChpZCwgcGxheWFibGUsIHByb2JhYmlsaXR5LCBwYXJhbWV0ZXJzKXtcclxuXHRfTG9vcC5jYWxsKHRoaXMsaWQsIHBsYXlhYmxlLCBudWxsLCBwYXJhbWV0ZXJzKTtcclxuXHRcclxuXHR0aGlzLnBsYXlhYmxlID0gcmVnaXN0cnkucGxheWFibGVzW3BsYXlhYmxlLmlkKCldO1xyXG5cdFxyXG5cdC8vVGhpcyBpbmhlcml0cyBmcm9tIExvb3Agd2hpY2ggdXNlcyBhIGNvdW50LiBEZWxldGUgdGhhdCBhbmQgcmVwbGFjZSB3aXRoIHByb2JhYmlsaXR5LlxyXG5cdGRlbGV0ZSB0aGlzLmNvdW50O1x0XHRcdFxyXG5cdHRoaXMucHJvYmFiaWxpdHkgPSBwcm9iYWJpbGl0eTtcdFx0XHRcdFx0XHRcclxuXHRcclxuXHR0aGlzLmdlbmVyYXRvciA9IE1hdGgucmFuZG9tO1x0XHRcdFx0Ly9UT0RPOiBhbGxvdyB1c2VyIHRvIHNwZWNpZnkgcmFuZG9tIG51bWJlciBnZW5lcmF0b3JcclxuXHRcclxuXHRyZWdpc3RyeS5zTG9vcHNbaWRdID0gdGhpcztcclxufVxyXG5fU0xvb3AucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShfTG9vcC5wcm90b3R5cGUpO1xyXG5fU0xvb3AucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gX1NMb29wO1xyXG5cclxuX1NMb29wLnJlZ2lzdHJ5TmFtZSA9IFwic0xvb3BzXCI7XHJcbl9TTG9vcC5jb3VudGVyTmFtZSA9IFwic3RvY2hhc3RpY0xvb3BcIjtcclxuXHJcblxyXG5fU0xvb3AucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih7aW5pdGlhbGl6ZVBsYXllcnM9ZmFsc2UsIHNob3J0Q2lyY3VpdD1mYWxzZSwgaGlzdG9yeT1nYW1lSGlzdG9yeX09e30pe1xyXG5cdFxyXG5cdHZhciBzTG9vcCA9IHRoaXM7XHJcblx0c0xvb3AuY291bnRlciA9IDA7XHJcblx0dmFyIGxvb3BIaXN0b3J5ID0gaGlzdG9yeS5jaGlsZCgpO1xyXG5cdFxyXG5cdHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHt9KTtcclxuXHRcclxuXHQvL1NlY3Rpb24gdGhhdCB3aWxsIGJlIGxvb3BlZFxyXG5cdHZhciBhY3Rpb24gPSBmdW5jdGlvbihyZXN1bHQpe1xyXG5cdFx0XHJcblx0XHRzTG9vcC5jb3VudGVyKys7XHJcblx0XHRpZiAoIXJlc3VsdCkgcmVzdWx0ID0ge307XHJcblx0XHRcclxuXHRcdFxyXG5cdFx0Ly9EZWFsIHdpdGggaGlzdG9yeVxyXG5cdFx0aGlzdG9yeS5sb2cuYWRkKHtcclxuXHRcdFx0bG9vcDpzTG9vcC5pZCxcclxuXHRcdFx0bG9vcFRvOnNMb29wLnBsYXlhYmxlLmlkLFxyXG5cdFx0XHRjb3VudDpzTG9vcC5jb3VudGVyXHJcblx0XHR9KTtcclxuXHRcdFxyXG5cdFx0cmV0dXJuIHNMb29wLnBsYXlhYmxlLnBsYXkoe3Nob3J0Q2lyY3VpdDp0cnVlLCBoaXN0b3J5Omxvb3BIaXN0b3J5fSlcclxuXHRcdC50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XHJcblx0XHRcclxuXHRcdFx0cmVzdWx0LnBsYXlhYmxlID0gc0xvb3A7XHJcblx0XHRcdC8vVE9ETzogYWRkIGluZm9ybWF0aW9uIG1lY2hhbmlzbXNcclxuXHRcdFxyXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdClcdFx0XHJcblx0XHR9KTtcclxuXHR9O1xyXG5cdFxyXG5cdFxyXG5cdC8vR2VuZXJhdGUgcmFuZG9tIG51bWJlcnMsIHJlcGVhdCB3aGlsZSBudW1iZXIgaXMgYWJvdmUgaGFsdGluZyBwcm9iYWJpbGl0eVxyXG5cdHdoaWxlIChzTG9vcC5nZW5lcmF0b3IoKSA+IHNMb29wLnByb2JhYmlsaXR5KSB7XHJcblx0XHRwcm9taXNlID0gcHJvbWlzZS50aGVuKGFjdGlvbik7XHJcblx0fVxyXG5cdFxyXG5cdFxyXG5cdHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcclxuXHRcdFxyXG5cdFx0cmVzdWx0Lmhpc3RvcnlFbnRyeSA9IHtcclxuXHRcdFx0bG9vcDpzTG9vcC5pZCxcclxuXHRcdFx0Y291bnQ6c0xvb3AuY291bnRlcixcclxuXHRcdFx0YWN0aW9uOmxvb3BIaXN0b3J5Lm9ycGhhbigpXHJcblx0XHR9O1xyXG5cdFxyXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuX1NMb29wLnByb3RvdHlwZS5zdW1tYXJ5VGhpcyA9IGZ1bmN0aW9uKHN1bW1hcnksIGVudHJpZXMpe1xyXG5cdHN1bW1hcnkucHJvYmFiaWxpdHkgPSB0aGlzLnByb2JhYmlsaXR5O1xyXG5cdFxyXG5cdHN1bW1hcnkuYWN0aW9uID0ge31cclxuXHR0aGlzLnBsYXlhYmxlLnN1bW1hcml6ZShzdW1tYXJ5LmFjdGlvbiwgZW50cmllcywgdHJ1ZSlcclxufVxyXG5cclxuXHJcbi8vVXNlciBpbnRlcmZhY2VcclxuZnVuY3Rpb24gU3RvY2hhc3RpY0xvb3AocGxheWFibGUsIHByb2JhYmlsaXR5PS41LCBwYXJhbWV0ZXJzPXt9KXtcclxuXHR2YXIgaWQgPSBpZEhhbmRsZXIocGFyYW1ldGVycy5pZCxcInN0b2NoYXN0aWNMb29wXCIpXHJcblx0XHJcblx0aWYgKGlzTmFOKHByb2JhYmlsaXR5KSB8fCBwcm9iYWJpbGl0eSA8IDAgfHwgcHJvYmFiaWxpdHkgPiAxKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJvYmFiaWxpdHknKTtcclxuXHRcclxuXHQvL0NyZWF0ZSBiYWNrZW5kIHNMb29wIG9iamVjdFxyXG5cdHZhciBfc0xvb3AgPSBuZXcgX1NMb29wKGlkLCBwbGF5YWJsZSwgcHJvYmFiaWxpdHksIHBhcmFtZXRlcnMpO1xyXG5cdFxyXG5cdFxyXG5cdC8vUmV0dXJuIHRoaXMgcmVmZXJlbmNlIG9iamVjdCB0byB0aGUgdXNlci4gUnVuIHRoZSBmdW5jdGlvbiB0byBzZWxlY3QgYSBzb3VyY2VcclxuXHR2YXIgc0xvb3AgPSBQbGF5YWJsZShfc0xvb3ApO1xyXG5cdHJldHVybiBzTG9vcDtcdFxyXG59XHJcblxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge19TTG9vcCwgU3RvY2hhc3RpY0xvb3B9OyIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGxvZyA9IHJlcXVpcmUoXCIuLi9sb2dnZXJcIik7XHJcbmxvZyhcImRlYnVnXCIsIFwiTG9hZGluZyBDbGFzczogVHVyblwiKTtcclxuXHJcbi8vRXh0ZXJuYWwgZGVwZW5kZW5jeVxyXG52YXIgeyBTeW5jaHJvbm91c1Byb21pc2UgfSA9IHJlcXVpcmUoXCJzeW5jaHJvbm91cy1wcm9taXNlXCIpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGlzT2JqZWN0LCBvbmNlIH0gPSByZXF1aXJlKFwiLi4vaGVscGVyRnVuY3Rpb25zXCIpKFwiZ2VuZXJhbFwiKTtcclxudmFyIHsgY2hhaW5lckdlbmVyYXRvciwgb3V0Y29tZVRyZWVHZXRWYWx1ZSwgb3V0Y29tZVRyZWVTZXRWYWx1ZSB9ID0gcmVxdWlyZShcIi4uL2hlbHBlckZ1bmN0aW9uc1wiKShcInBsYXlhYmxlXCIpO1xyXG52YXIgeyByZWN1cnNlIH0gPSByZXF1aXJlKFwiLi4vaGVscGVyRnVuY3Rpb25zXCIpKFwidHVyblwiKTtcclxudmFyIHsgaWRIYW5kbGVyIH0gPSByZXF1aXJlKFwiLi4vaGVscGVyRnVuY3Rpb25zXCIpKFwic3RhdGVcIik7XHJcblxyXG4vL0dhbWUgc3RhdGUgY29udHJvbGxlcnNcclxudmFyIHsgcmVnaXN0cnkgfSA9IHJlcXVpcmUoXCIuLi9zdGF0ZVwiKTtcclxudmFyIHsgZ2FtZUhpc3RvcnkgfSA9IHJlcXVpcmUoXCIuLi9oaXN0b3J5XCIpO1xyXG52YXIgeyBJbmZvcm1hdGlvbiwgUGVyZmVjdEluZm9ybWF0aW9uIH0gPSByZXF1aXJlKFwiLi4vaW5mb3JtYXRpb25cIik7XHJcblxyXG4vL1BhcmVudCBjbGFzc1xyXG52YXIgeyBfUGxheWFibGUsIFBsYXlhYmxlIH0gPSByZXF1aXJlKFwiLi9wbGF5YWJsZVwiKTtcclxuXHJcbi8vQmFja2VuZCBmdW5jdGlvbiBjbGFzcyBmb3IgVHVyblxyXG5mdW5jdGlvbiBfVHVybihpZCwgY2hvaWNlcywgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0X1BsYXlhYmxlLmNhbGwodGhpcywgaWQpO1xyXG5cclxuXHR0aGlzLnBheW9mZnNJbXBsaWNpdCA9IHt9O1xyXG5cdHRoaXMucGF5b2Zmc0V4cGxpY2l0ID0ge307XHJcblxyXG5cdHRoaXMubmV4dCA9IHt9O1xyXG5cclxuXHR0aGlzLmNob2ljZXMgPSBjaG9pY2VzLm1hcChmdW5jdGlvbihjaG9pY2UpIHtcclxuXHRcdHJldHVybiByZWdpc3RyeS5jaG9pY2VzW2Nob2ljZS5pZCgpXTtcclxuXHR9KTtcclxuXHJcblx0cmVnaXN0cnkudHVybnNbaWRdID0gdGhpcztcclxuXHJcblx0dmFyIHR1cm4gPSB0aGlzO1xyXG5cclxuXHR0aGlzLmNob2ljZU1hcCA9IHRoaXMuY2hvaWNlcy5tYXAoZnVuY3Rpb24oaXRlbSkge1xyXG5cdFx0cmV0dXJuIGl0ZW0ub3B0aW9ucztcclxuXHR9KTtcclxuXHJcblx0cmVjdXJzZSh0dXJuLmNob2ljZU1hcCwgdHVybi5wYXlvZmZzSW1wbGljaXQsIG51bGwsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gQXJyYXkodHVybi5jaG9pY2VNYXAubGVuZ3RoKS5maWxsKDApO1xyXG5cdFx0fSlcclxuXHRcdC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0XHRsb2coXCJzaWxseVwiLCBcIkFkZGVkIGltcGxpY2l0IHBheW9mZnMgbWFwIHRvIHR1cm4uXCIpO1xyXG5cdFx0XHRyZXR1cm4gcmVjdXJzZSh0dXJuLmNob2ljZU1hcCwgdHVybi5wYXlvZmZzRXhwbGljaXQsIHt9KTtcclxuXHRcdH0pXHJcblx0XHQudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0bG9nKFwic2lsbHlcIiwgXCJBZGRlZCBleHBsaWNpdCBwYXlvZmZzIG1hcCB0byB0dXJuLlwiKTtcclxuXHRcdFx0cmV0dXJuIHJlY3Vyc2UodHVybi5jaG9pY2VNYXAsIHR1cm4ubmV4dCwgbnVsbCwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIFtdO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pXHJcblx0XHQudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0bG9nKFwic2lsbHlcIiwgXCJBZGRlZCBibGFuayBuZXh0IG1hcCB0byB0dXJuLlwiKTtcclxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG5cdFx0fSlcclxuXHRcdC5jYXRjaChmdW5jdGlvbihyZWFzb24pIHtcclxuXHRcdFx0bG9nKFwiZXJyb3JcIiwgcmVhc29uKTtcclxuXHRcdH0pOyAvL1RPRE86IGVycm9yIGhhbmRsaW5nIGhlcmVcclxufVxyXG5fVHVybi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKF9QbGF5YWJsZS5wcm90b3R5cGUpO1xyXG5fVHVybi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBfVHVybjtcclxuXHJcbl9UdXJuLnJlZ2lzdHJ5TmFtZSA9IFwidHVybnNcIjtcclxuX1R1cm4uY291bnRlck5hbWUgPSBcInR1cm5cIjtcclxuXHJcblxyXG5fVHVybi5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uKHtcclxuXHR1c2VQYXlvZmZzID0gdHJ1ZSxcclxuXHRoaXN0b3J5ID0gZ2FtZUhpc3RvcnksXHJcblx0aW5mb3JtYXRpb24gPSBQZXJmZWN0SW5mb3JtYXRpb24sXHJcblx0cmVsZWFzZVBsYXllcnMgPSB0cnVlXHJcbn0gPSB7fSkge1xyXG5cclxuXHR2YXIgdHVybiA9IHRoaXM7XHJcblx0dmFyIGNob2ljZUhpc3RvcnkgPSBoaXN0b3J5LmNoaWxkKCk7XHJcblx0dmFyIGNob2ljZUluZm9ybWF0aW9uID0gaW5mb3JtYXRpb24uY2hpbGQoKTtcclxuXHJcblx0aGlzdG9yeS5sb2cuYWRkKHtcclxuXHRcdHR1cm46IHR1cm4uaWQsXHJcblx0XHRjaG9pY2VzOiB0dXJuLmNob2ljZXMubWFwKGZ1bmN0aW9uKGNob2ljZSkge1xyXG5cdFx0XHRyZXR1cm4gY2hvaWNlLmlkO1xyXG5cdFx0fSlcclxuXHR9KTtcclxuXHJcblx0dmFyIGNvbXBpbGVJbmZvcm1hdGlvbiA9IGZ1bmN0aW9uKHJpKSB7XHJcblx0XHQvL0lmIHRoZXJlJ3Mgbm8gdHVybiBlbnRyeSwgY3JlYXRlIG9uZS5cclxuXHRcdGlmICghY2hvaWNlSW5mb3JtYXRpb24uYWRkaXRpb25hbFswXS50dXJuKSB7XHJcblx0XHRcdHZhciB0dXJuSW5mbyA9IHtcclxuXHRcdFx0XHR0dXJuOiB7XHJcblx0XHRcdFx0XHRpZDogdHVybi5pZCxcclxuXHRcdFx0XHRcdGNob2ljZXM6IFtdLFxyXG5cdFx0XHRcdFx0ZXhjbHVkZTogZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmNob2ljZXMuZmlsdGVyKGZ1bmN0aW9uKGNob2ljZSkge1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybiBjaG9pY2UucGxheWVyID09IHBsYXllcjtcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cdFx0XHRjaG9pY2VJbmZvcm1hdGlvbi5hZGRpdGlvbmFsLnVuc2hpZnQodHVybkluZm8pO1xyXG5cdFx0fVxyXG5cdFx0Y2hvaWNlSW5mb3JtYXRpb24uYWRkaXRpb25hbFswXS50dXJuLmNob2ljZXMucHVzaChcclxuXHRcdFx0Y2hvaWNlSW5mb3JtYXRpb24uYWRkaXRpb25hbC5wb3AoKVxyXG5cdFx0KTtcclxuXHJcblx0XHRpbmZvcm1hdGlvbi5hZGRpdGlvbmFsLmZvckVhY2goXHJcblx0XHRcdGNob2ljZUluZm9ybWF0aW9uLmFkZEFkZGl0aW9uYWwuYmluZChjaG9pY2VJbmZvcm1hdGlvbilcclxuXHRcdCk7XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIFByb21pc2UuYWxsKFxyXG5cdFx0XHR0dXJuLmNob2ljZXMubWFwKGZ1bmN0aW9uKGNob2ljZSkge1xyXG5cdFx0XHRcdHJldHVybiBjaG9pY2UucGxheSh7XHJcblx0XHRcdFx0XHRzaG9ydENpcmN1aXQ6IHRydWUsXHJcblx0XHRcdFx0XHRoaXN0b3J5OiBjaG9pY2VIaXN0b3J5LFxyXG5cdFx0XHRcdFx0aW5mb3JtYXRpb246IGNob2ljZUluZm9ybWF0aW9uLFxyXG5cdFx0XHRcdFx0X2NvbXBpbGVJbmZvcm1hdGlvbjogY29tcGlsZUluZm9ybWF0aW9uLFxyXG5cdFx0XHRcdFx0cmVsZWFzZVBsYXllcnM6IGZhbHNlXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pXHJcblx0XHQpXHJcblx0XHQudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0Ly9SZS1mb3JtYXQgb3V0cHV0IGZyb20gYXJyYXkgb2YgQ2hvaWNlIHJlc3VsdHMgdG8gc2luZ2xlIFR1cm4gcmVzdWx0XHJcblx0XHRcdC8vQW5kIHJlbGVhc2UgcGxheWVyc1xyXG5cdFx0XHR2YXIgcmVzdWx0UGF0aCA9IHJlc3VsdC5tYXAoZnVuY3Rpb24oY2hvaWNlLCBpbmRleCkge1xyXG5cdFx0XHRcdGlmIChyZWxlYXNlUGxheWVycykgdHVybi5jaG9pY2VzW2luZGV4XS5yZWxlYXNlUGxheWVyKCk7XHJcblx0XHRcdFx0cmV0dXJuIGNob2ljZS5yZXN1bHQ7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Ly9QYXNzIGFsb25nIHJlc3VsdHMgYW5kIHJlY29yZCBoaXN0b3J5XHJcblx0XHRcdHZhciByZXN1bHRPYmplY3QgPSB7XHJcblx0XHRcdFx0cmVzdWx0OiByZXN1bHRQYXRoLFxyXG5cdFx0XHRcdHBsYXlhYmxlOiB0dXJuLFxyXG5cdFx0XHRcdGhpc3RvcnlFbnRyeToge1xyXG5cdFx0XHRcdFx0dHVybjogdHVybi5pZCxcclxuXHRcdFx0XHRcdHJlc3VsdHM6IGNob2ljZUhpc3Rvcnkub3JwaGFuKCksXHJcblx0XHRcdFx0XHRwYXlvdXRzOiB7fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0T2JqZWN0KTtcclxuXHRcdH0pXHJcblx0XHQudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0Ly9JbXBsZW1lbnQgcGF5b2Zmc1xyXG5cdFx0XHRpZiAodXNlUGF5b2Zmcykge1xyXG5cdFx0XHRcdHZhciBpbXBsaWNpdFBheW9mZnMgPSBvdXRjb21lVHJlZUdldFZhbHVlKFxyXG5cdFx0XHRcdFx0dHVybi5wYXlvZmZzSW1wbGljaXQsXHJcblx0XHRcdFx0XHRyZXN1bHQucmVzdWx0XHJcblx0XHRcdFx0KTtcclxuXHRcdFx0XHR2YXIgZXhwbGljaXRQYXlvZmZzID0gb3V0Y29tZVRyZWVHZXRWYWx1ZShcclxuXHRcdFx0XHRcdHR1cm4ucGF5b2Zmc0V4cGxpY2l0LFxyXG5cdFx0XHRcdFx0cmVzdWx0LnJlc3VsdFxyXG5cdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdC8vIEZvciB0aGUgbG9nXHJcblx0XHRcdFx0dmFyIHBheW91dHMgPSB7fTtcclxuXHJcblx0XHRcdFx0aW1wbGljaXRQYXlvZmZzLmZvckVhY2goZnVuY3Rpb24ocGF5b2ZmLCBpbmRleCkge1xyXG5cdFx0XHRcdFx0Ly8gRG8gbm90aGluZyBpZiBwYXlvZmYgaXMgemVyby5cclxuXHRcdFx0XHRcdGlmIChwYXlvZmYgPT0gMCkgcmV0dXJuO1xyXG5cclxuXHRcdFx0XHRcdC8vIGZldGNoIHBsYXllciBhbmQgaW5jcmVtZW50IHNjb3JlXHJcblx0XHRcdFx0XHR2YXIgcGxheWVyID0gdHVybi5jaG9pY2VzW2luZGV4XS5wbGF5ZXI7XHJcblx0XHRcdFx0XHRwbGF5ZXIuc2NvcmUgKz0gcGF5b2ZmO1xyXG5cclxuXHRcdFx0XHRcdC8vQW5kIGluY2x1ZGUgaXQgaW4gdGhlIGxvZyBlbnRyeVxyXG5cdFx0XHRcdFx0cGF5b3V0c1twbGF5ZXIuaWRdID0gTnVtYmVyKHBheW9mZik7XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdGZvciAodmFyIHBsYXllciBpbiBleHBsaWNpdFBheW9mZnMpIHtcclxuXHRcdFx0XHRcdHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyXS5zY29yZSArPSBleHBsaWNpdFBheW9mZnNbcGxheWVyXTtcclxuXHJcblx0XHRcdFx0XHQvL0FuZCBpbmNsdWRlIGl0IGluIHRoZSBsb2cgZW50cnlcclxuXHRcdFx0XHRcdHBheW91dHNbcGxheWVyXSA9IE51bWJlcihleHBsaWNpdFBheW9mZnNbcGxheWVyXSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvL0xvZyBmb3IgdGhlIHNjb3JlcyBsb2dcclxuXHRcdFx0XHR2YXIgc2NvcmVFbnRyeSA9IHtcclxuXHRcdFx0XHRcdHR1cm46IHR1cm4uaWQsXHJcblx0XHRcdFx0XHRyZXN1bHQ6IHJlc3VsdC5yZXN1bHQsXHJcblx0XHRcdFx0XHRwYXlvdXRzOiBwYXlvdXRzXHJcblx0XHRcdFx0fTtcclxuXHRcdFx0XHRoaXN0b3J5LmFkZFNjb3JlcyhzY29yZUVudHJ5KTtcclxuXHJcblxyXG5cdFx0XHRcdC8vIExvZyBmb3IgdGhlIGdhbWUgaGlzdG9yeVxyXG5cdFx0XHRcdHJlc3VsdC5oaXN0b3J5RW50cnkucGF5b3V0cyA9IHBheW91dHM7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTsgLy9UT0RPOiBhZGQgaW5mb3JtYXRpb24gbWVjaGFuaXNtc1xyXG5cdFx0fSk7XHJcbn07XHJcblxyXG4vL092ZXJ3cml0ZSBkZWZhdWx0IGhpc3RvcnkgaGFuZGxlciwgYmVjYXVzZSB3ZSBkb24ndCB3YW50IGEgc2Vjb25kIGVudHJ5IGluIHRoZSB0cmVlXHJcbl9UdXJuLnByb3RvdHlwZS5oYW5kbGVIaXN0b3J5ID0gZnVuY3Rpb24oeyBoaXN0b3J5ID0gZ2FtZUhpc3RvcnkgfSA9IHt9LFxyXG5cdHJlc3VsdFxyXG4pIHtcclxuXHRoaXN0b3J5LmFkZE5vTG9nKHJlc3VsdC5oaXN0b3J5RW50cnkpO1xyXG5cclxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcbn07XHJcblxyXG5fVHVybi5wcm90b3R5cGUuZmluZE5leHQgPSBmdW5jdGlvbih7IHJlc3VsdCB9ID0ge30pIHtcclxuXHRyZXR1cm4gb3V0Y29tZVRyZWVHZXRWYWx1ZSh0aGlzLm5leHQsIHJlc3VsdC5yZXN1bHQpO1xyXG59O1xyXG5cclxuX1R1cm4ucHJvdG90eXBlLmdlbmVyYXRlQ2hhaW5pbmdGdW5jdGlvbnMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgX3R1cm4gPSB0aGlzO1xyXG5cdHZhciB0dXJuID0gX3R1cm4uaW50ZXJmYWNlO1xyXG5cclxuXHQvL0NyZWF0ZSBwYXlvZmYgc2V0dGVyL2JyYW5jaCByb3V0ZXIgZnVuY3Rpb25zLlxyXG5cdC8vcmVjdXJzZSBhZGRzIGEgd3JhcHBlciBhcm91bmQgdGhpcyBmdW5jdGlvbiB3aGljaCBzdXBwbGllcyB0aGUgcGF0aC5cclxuXHRyZWN1cnNlKF90dXJuLmNob2ljZU1hcCwgdHVybiwgZnVuY3Rpb24ocGF0aCwgcGF5b2Zmcykge1xyXG5cdFx0Ly9JZiB1c2VyIHN1cHBsaWVkIHBheW9mZnMgaW4gYXJyYXkgZm9ybSwgdGhlbiB0cmFuc2xhdGUgdG8gb2JqZWN0IGJhc2VkIG9uIHdoaWNoIHBsYXllcnMgYXJlIGludm9sdmVkIGluIHRoZSBjaG9pY2VzXHJcblx0XHRpZiAoQXJyYXkuaXNBcnJheShwYXlvZmZzKSkge1xyXG5cdFx0XHRpZiAocGF5b2Zmcy5sZW5ndGggIT09IF90dXJuLmNob2ljZXMubGVuZ3RoKSB7XHJcblx0XHRcdFx0Ly9JZiBhcnJheSBpc24ndCByaWdodCBsZW5ndGgsIHRoZW4gdGhpcyBpcyB1bmludGVsbGlnaWJsZS5cclxuXHRcdFx0XHRsb2coXHJcblx0XHRcdFx0XHRcImVycm9yXCIsXHJcblx0XHRcdFx0XHRcIlBheW9mZiBhcnJheSBkb2VzIG5vdCBtYXRjaCBUdXJuIGRpbWVuc2lvbnMsIGNhbm5vdCBhc3NpZ24gcGF5b2Zmcy5cIlxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlBheW9mZiBhcnJheSBpcyBub3QgY29ycmVjdCBsZW5ndGhcIikpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgb3JpZ2luYWxQYXlvZmZzID0gcGF5b2Zmcy5zbGljZSgpO1xyXG5cdFx0XHRwYXlvZmZzID0ge307XHJcblxyXG5cdFx0XHRvdXRjb21lVHJlZVNldFZhbHVlKF90dXJuLnBheW9mZnNJbXBsaWNpdCwgcGF0aCwgb3JpZ2luYWxQYXlvZmZzKTtcclxuXHRcdH0gZWxzZSBpZiAoaXNPYmplY3QocGF5b2ZmcykpIHtcclxuXHRcdFx0cGF5b2ZmcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocGF5b2ZmcykpO1xyXG5cdFx0XHRvdXRjb21lVHJlZVNldFZhbHVlKF90dXJuLnBheW9mZnNFeHBsaWNpdCwgcGF0aCwgcGF5b2Zmcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlKHtcclxuXHRcdFx0cGxheWFibGU6IHR1cm4sXHJcblx0XHRcdHBhdGg6IHBhdGhcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuX1R1cm4ucHJvdG90eXBlLnNldEFsbFBheW9mZnMgPSBmdW5jdGlvbihwYXlvZmZBcnJheSkge1xyXG5cdHZhciB0dXJuID0gdGhpcztcclxuXHJcblx0Ly9SZWN1cnNlIHRocm91Z2ggdGhlIG9wdGlvbnMgaW4gaW5wdXQsIHRvIGNvbWUgdXAgd2l0aCBhIHBhdGggdG8gZXZlcnkgY29tYmluYXRpb24gb2Ygb3B0aW9ucyBpbiB0aGUgYXJyYXkgb2YgYXJyYXlzLlxyXG5cdGZ1bmN0aW9uIHJlY3Vyc2UoaW5wdXQsIG51bVBsYXllcnMsIHBheW9mZnMsIHBhdGggPSBbXSwgY29vcmRpbmF0ZXMgPSBbXSkge1xyXG5cdFx0cmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlKHBhdGgpLnRoZW4oZnVuY3Rpb24ocGF0aCkge1xyXG5cdFx0XHQvL1NpbmNlIHdlIHNsaWNlIHRoZSBhcnJheSBlYWNoIHRpbWUsIGlmIHRoZXJlIGFyZSBubyBtb3JlIGVudHJpZXMgbGVmdCB0aGVuIHdlJ3JlIGRvbmUgd2l0aCB0aGlzIGJyYW5jaC5cclxuXHRcdFx0aWYgKGlucHV0Lmxlbmd0aCA9PSAwKSByZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUocGF0aCk7XHJcblxyXG5cdFx0XHQvL0Ftb25nIGFsbCB2YWx1ZXMgZnJvbSB0aGUgYXJyYXlcclxuXHRcdFx0cmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5hbGwoXHJcblx0XHRcdFx0aW5wdXRbMF0ubWFwKGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XHJcblx0XHRcdFx0XHR2YXIgc3BsaXRQYXRoID0gcGF0aC5zbGljZSgwKS5jb25jYXQoaXRlbSk7XHJcblx0XHRcdFx0XHR2YXIgc3BsaXRDb29yZGluYXRlcyA9IGNvb3JkaW5hdGVzLnNsaWNlKDApLmNvbmNhdChpbmRleCk7XHJcblx0XHRcdFx0XHR2YXIgc3BsaXRQYXlvZmZzID0gcGF5b2Zmc1tpbmRleF07XHJcblxyXG5cdFx0XHRcdFx0Ly9JZiB3ZSdyZSBhdCB0aGUgbGFzdCBwb3NpdGlvbiBpbiB0aGUgYXJyYXkgb2Ygb3B0aW9ucywgdGhlbiB3ZSBoYXZlIGEgY29tcGxldGUgcGF0aC5cclxuXHRcdFx0XHRcdGlmIChpbnB1dC5sZW5ndGggPT0gMSkge1xyXG5cdFx0XHRcdFx0XHQvKiB5b3UgbWlnaHQgbmVlZCB0aGVzZSBsYXRlclxyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJwYXRoIFwiLCBzcGxpdFBhdGgpO1xyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJjb29yZGluYXRlcyBcIiwgc3BsaXRDb29yZGluYXRlcylcclxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwicGF5b2ZmIFwiLHNwbGl0UGF5b2ZmcylcclxuXHRcdFx0XHRcdCovXHJcblxyXG5cdFx0XHRcdFx0XHRzcGxpdFBheW9mZnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHNwbGl0UGF5b2ZmcykpO1xyXG5cclxuXHRcdFx0XHRcdFx0Ly9BbGxvdyB0aGUgZmlyc3QgZmV3IGFycmF5IGVsZW1lbnRzIHRvIGJlIGltcGxpY2l0IHBheW9mZnMuIENoZWNrIHRoYXQgdGhleSBhcmUgYWN0dWFsbHkgdGhlcmUgYW5kIGFyZSBudW1iZXJzXHJcblx0XHRcdFx0XHRcdHZhciBpbXBsaWNpdCA9IHNwbGl0UGF5b2Zmcy5zbGljZSgwLCBudW1QbGF5ZXJzKTtcclxuXHRcdFx0XHRcdFx0aWYgKFxyXG5cdFx0XHRcdFx0XHRcdGltcGxpY2l0Lmxlbmd0aCA9PSBudW1QbGF5ZXJzICYmXHJcblx0XHRcdFx0XHRcdFx0aW1wbGljaXQuZXZlcnkoZnVuY3Rpb24ocGF5b2ZmKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gIWlzTmFOKHBheW9mZik7XHJcblx0XHRcdFx0XHRcdFx0fSlcclxuXHRcdFx0XHRcdFx0KSB7XHJcblx0XHRcdFx0XHRcdFx0b3V0Y29tZVRyZWVTZXRWYWx1ZSh0dXJuLnBheW9mZnNJbXBsaWNpdCwgc3BsaXRQYXRoLCBpbXBsaWNpdCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdC8vQW55IHJlbWFpbmluZyBzaG91bGQgYmUgYXNzaWduZWQgYXMgZXhwbGljaXQgcGF5b2ZmcywgaWYgdGhleSdyZSBvYmplY3RzLlxyXG5cdFx0XHRcdFx0XHRzcGxpdFBheW9mZnMuc2xpY2UobnVtUGxheWVycykuZm9yRWFjaChmdW5jdGlvbihleHBsaWNpdCkge1xyXG5cdFx0XHRcdFx0XHRcdGlmIChpc09iamVjdChleHBsaWNpdCkpXHJcblx0XHRcdFx0XHRcdFx0XHRvdXRjb21lVHJlZVNldFZhbHVlKHR1cm4ucGF5b2Zmc0V4cGxpY2l0LCBzcGxpdFBhdGgsIGV4cGxpY2l0KTtcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly9JZiB0aGVyZSBhcmUgbW9yZSBpdGVtcyB0byBpdGVyYXRlIG92ZXIsIGluY2x1ZGUgdGhlbSBpbiB0aGUgb3V0cHV0IHRoZW4gcmVjdXJzZS5cclxuXHRcdFx0XHRcdHJldHVybiByZWN1cnNlKFxyXG5cdFx0XHRcdFx0XHRpbnB1dC5zbGljZSgxKSxcclxuXHRcdFx0XHRcdFx0bnVtUGxheWVycyxcclxuXHRcdFx0XHRcdFx0c3BsaXRQYXlvZmZzLFxyXG5cdFx0XHRcdFx0XHRzcGxpdFBhdGgsXHJcblx0XHRcdFx0XHRcdHNwbGl0Q29vcmRpbmF0ZXNcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0KTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHJlY3Vyc2UodHVybi5jaG9pY2VNYXAsIHR1cm4uY2hvaWNlcy5sZW5ndGgsIHBheW9mZkFycmF5KS5jYXRjaChcclxuXHRcdGZ1bmN0aW9uKHJlYXNvbikge1xyXG5cdFx0XHRsb2coXCJlcnJvclwiLCByZWFzb24pO1xyXG5cdFx0fVxyXG5cdCk7XHJcbn07XHJcblxyXG4vLyBBZGRpbmcgbW9yZSBjb21wbGljYXRlZCBzdW1tYXJ5IGVudHJ5XHJcbl9UdXJuLnByb3RvdHlwZS5zdW1tYXJ5VGhpcyA9IGZ1bmN0aW9uKHN1bW1hcnksIGVudHJpZXMsIHNob3J0Q2lyY3VpdCA9IGZhbHNlKSB7XHJcblx0Ly8gRmV0Y2ggc3VtbWFyaWVzIGZvciBlYWNoIGNob2ljZS5cclxuXHRzdW1tYXJ5LmNob2ljZXMgPSBbXTtcclxuXHR0aGlzLmNob2ljZXMuZm9yRWFjaChmdW5jdGlvbihjaG9pY2UsIGluZGV4KSB7XHJcblx0XHRzdW1tYXJ5LmNob2ljZXNbaW5kZXhdID0gY2hvaWNlLnN1bW1hcml6ZShcclxuXHRcdFx0c3VtbWFyeS5jaG9pY2VzW2luZGV4XSxcclxuXHRcdFx0ZW50cmllcyxcclxuXHRcdFx0dHJ1ZVxyXG5cdFx0KTtcclxuXHR9KTtcclxuXHJcblx0Ly8gSW5jbHVkZSBwYXlvZmZzXHJcblx0c3VtbWFyeS5wYXlvZmZzID0gSlNPTi5wYXJzZShcclxuXHRcdEpTT04uc3RyaW5naWZ5KHtcclxuXHRcdFx0aW1wbGljaXQ6IHRoaXMucGF5b2Zmc0ltcGxpY2l0LFxyXG5cdFx0XHRleHBsaWNpdDogdGhpcy5wYXlvZmZzRXhwbGljaXRcclxuXHRcdH0pXHJcblx0KTtcclxuXHJcblx0cmV0dXJuIHN1bW1hcnk7XHJcbn07XHJcblxyXG4vL1xyXG5fVHVybi5wcm90b3R5cGUuc3VtbWFyeU5leHQgPSBmdW5jdGlvbihzdW1tYXJ5LCBlbnRyaWVzKSB7XHJcblx0dmFyIHR1cm4gPSB0aGlzO1xyXG5cclxuXHQvLyBDcmVhdGUgbWFwXHJcblx0c3VtbWFyeS5uZXh0ID0ge307XHJcblx0dmFyIGNvdW50ID0gMDtcclxuXHRyZWN1cnNlKHRoaXMuY2hvaWNlTWFwLCBzdW1tYXJ5Lm5leHQsIG51bGwsIGZ1bmN0aW9uKHBhdGgpIHtcclxuXHRcdHJldHVybiBvdXRjb21lVHJlZUdldFZhbHVlKHR1cm4ubmV4dCwgcGF0aCkubWFwKGZ1bmN0aW9uKHBsYXlhYmxlKSB7XHJcblx0XHRcdCsrY291bnQ7XHJcblx0XHRcdHJldHVybiBwbGF5YWJsZS5zdW1tYXJpemUoKTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG5cclxuXHQvLyBJZiB0aGVyZSBpcyBubyBuZXh0LCBkZWxldGUgdGhlIGtleS5cclxuXHRpZiAoY291bnQgPT0gMCkgZGVsZXRlIHN1bW1hcnkubmV4dDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIFR1cm4oY2hvaWNlcywgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKHBhcmFtZXRlcnMuaWQsIFwidHVyblwiKTtcclxuXHJcblx0Ly9DcmVhdGUgYmFja2VuZCBjaG9pY2Ugb2JqZWN0XHJcblx0dmFyIF90dXJuID0gbmV3IF9UdXJuKGlkLCBjaG9pY2VzLCBwYXJhbWV0ZXJzKTtcclxuXHJcblx0Ly9SZXR1cm4gdGhpcyByZWZlcmVuY2Ugb2JqZWN0IHRvIHRoZSB1c2VyLiBSdW4gdGhlIGZ1bmN0aW9uIHRvIHNlbGVjdCBhIHNvdXJjZVxyXG5cdHZhciB0dXJuID0gUGxheWFibGUoX3R1cm4pO1xyXG5cclxuXHRfdHVybi5nZW5lcmF0ZUNoYWluaW5nRnVuY3Rpb25zKCk7XHJcblxyXG5cdC8vRnVuY3Rpb24gdG8gc2V0IGFsbCBwYXlvZmZzIGF0IG9uY2VcclxuXHR0dXJuLnNldEFsbFBheW9mZnMgPSBmdW5jdGlvbihwYXlvZmZzKSB7XHJcblx0XHQvL1RPRE86IEluY2x1ZGUgZXJyb3IgaGFuZGxpbmcgaWYgYXJyYXkgZ2l2ZW4gaXNuJ3QgZXhwZWN0ZWQgZGltZW5zaW9ucy5cclxuXHRcdF90dXJuLnNldEFsbFBheW9mZnMocGF5b2Zmcyk7XHJcblx0fTtcclxuXHJcblx0Ly9XYXkgZm9yIHVzZXIgdG8gaW50ZXJhY3Qgd2l0aCBwYXlvZmZzXHJcblx0dHVybi5wYXlvZmZzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gSlNPTi5wYXJzZShcclxuXHRcdFx0SlNPTi5zdHJpbmdpZnkoe1xyXG5cdFx0XHRcdGltcGxpY2l0OiBfdHVybi5wYXlvZmZzSW1wbGljaXQsXHJcblx0XHRcdFx0ZXhwbGljaXQ6IF90dXJuLnBheW9mZnNFeHBsaWNpdFxyXG5cdFx0XHR9KVxyXG5cdFx0KTtcclxuXHR9O1xyXG5cclxuXHQvLyBSZXR1cm5zIHRoZSBwYXlvZmZzIGluIG5lc3RlZCBhcnJheSBmb3JtLCB0byBtYWtlIGNsb25pbmcgZWFzaWVyLCBpZS4gdDIuc2V0QWxsUGF5b2Zmcyh0MS5wYXlvZmZzTWF0cml4KCkpXHJcblx0dHVybi5wYXlvZmZzTWF0cml4ID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0Ly8gcmVjdXJzaW9uIHRvIGNvbnN0cnVjdCBwYXlvZmYgbWF0cml4XHJcblx0XHR2YXIgbWFwcGVyID0gZnVuY3Rpb24ob2JqLCBwYXRoID0gW10pIHtcclxuXHRcdFx0Ly9JZiBpdCdzIGFuIGFycmF5LCB0aGVuIHdlJ3ZlIHJlYWNoZWQgdGhlIHBheW9mZnNcclxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xyXG5cdFx0XHRcdHZhciBwYXlvZmYgPSBvYmouc2xpY2UoMClcclxuXHRcdFx0XHQvLyBBZGQgZXhwbGljaXQgcGF5b2ZmcyB0b29cclxuXHRcdFx0XHR2YXIgZXhwbGljaXQgPSBvdXRjb21lVHJlZUdldFZhbHVlKF90dXJuLnBheW9mZnNFeHBsaWNpdCwgcGF0aCk7XHJcblxyXG5cdFx0XHRcdC8vIE9ubHkgYWRkIGFuIGVudHJ5IGlmIHRoZSBleHBsaWNpdCBwYXlvZmZzIG9iamVjdCBpcyBub3QgZW1wdHlcclxuXHRcdFx0XHRyZXR1cm4gT2JqZWN0LmtleXMoZXhwbGljaXQpLmxlbmd0aCA+IDAgPyBwYXlvZmYuY29uY2F0KFtvdXRjb21lVHJlZUdldFZhbHVlKF90dXJuLnBheW9mZnNFeHBsaWNpdCxcclxuXHRcdFx0XHRcdHBhdGgpXSkgOiBwYXlvZmZcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBkaWcgaW4gZGVlcGVyXHJcblx0XHRcdGVsc2UgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gbWFwcGVyKG9ialtrZXldLCBwYXRoLnNsaWNlKDApLmNvbmNhdChba2V5XSkpIH0pXHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbWFwcGVyKF90dXJuLnBheW9mZnNJbXBsaWNpdClcclxuXHR9XHJcblxyXG5cdHJldHVybiB0dXJuO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgX1R1cm4sIFR1cm4gfTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZSgnLi9sb2dnZXInKTtcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIgeyByZWdpc3RyeSB9ID0gcmVxdWlyZSgnLi9zdGF0ZScpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGlkSGFuZGxlciB9ID0gcmVxdWlyZSgnLi9oZWxwZXJGdW5jdGlvbnMnKShcInN0YXRlXCIpO1xyXG52YXIgeyBjaGFpbmVyR2VuZXJhdG9yIH0gPSByZXF1aXJlKCcuL2hlbHBlckZ1bmN0aW9ucycpKFwicGxheWFibGVcIik7XHJcblxyXG52YXIgeyBVc2VySGlzdG9yeSB9ID0gcmVxdWlyZSgnLi9oaXN0b3J5Jyk7XHJcblxyXG4vL0JhY2tlbmQgZm9yIFBsYXllclxyXG5mdW5jdGlvbiBfUGxheWVyKGlkLCB7IG5hbWUgPSBcIlwiLCBhc3NpZ24gPSBudWxsIH0gPSB7fSkge1xyXG5cdGxvZygnc2lsbHknLCAnQ3JlYXRpbmcgaW50ZXJhbCBwbGF5ZXIgb2JqZWN0LicpO1xyXG5cclxuXHR0aGlzLmlkID0gaWRcclxuXHR0aGlzLnNjb3JlID0gMFxyXG5cdHRoaXMubmFtZSA9IG5hbWU7XHJcblxyXG5cdHRoaXMuaGlzdG9yeSA9IFtdO1xyXG5cclxuXHRpZiAoYXNzaWduKSB0aGlzLmFzc2lnbihhc3NpZ24pO1xyXG5cclxuXHR0aGlzLmFsaXZlID0gdHJ1ZTtcclxuXHR0aGlzLmF2YWlsYWJsZSA9IHRydWU7XHJcblxyXG5cdHJlZ2lzdHJ5LnBsYXllcnNbaWRdID0gdGhpcztcclxufVxyXG5cclxuXHJcbi8vTWFrZSBhIGNvcHkgb2YgdGhlIHBsYXllciwgaW4gb3JkZXIgdG8gdGFrZSBhIHNuYXBzaG90LiAvLy8vVE9ETyB0cnkgdGhpcyBhZ2FpbiBzb21ldGltZS5cclxuLypcclxuX1BsYXllci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpe1xyXG5cdC8vTWFrZSBuZXcgY29weS4gRG9uJ3Qga2VlcCBtb3JlIHRoYW4gb25lLlxyXG5cdGRlbGV0ZSB0aGlzLmNvcHlcclxuXHJcblx0dmFyIGNsb25lID0gbmV3IF9QbGF5ZXIodGhpcy5pZCk7XHJcblxyXG5cdC8vTG9vcCB0aHJvdWdoIHByb3BlcnRpZXMgYW5kIGFzc2lnbiB0aGVtLlxyXG5cdGZvciAodmFyIGtleSBpbiB0aGlzKXtcclxuXHRcdGNsb25lW2tleV0gPSB0aGlzW2tleV07XHJcblx0fVxyXG5cdC8vRG8gbm90IGFkZCB0byByZWdpc3RyeS4gVGhpcyB3aWxsIGtlZXAgZHVwbGljYXRlcyBvdXQgb2YgcG9wdWxhdGlvbi5cclxuXHJcblx0Ly9EbyBhZGQgcmVmZXJlbmNlIHNvIHdlIGNhbiBmaW5kIGl0IGFnYWluLlxyXG5cdHRoaXMuY29weSA9IGNsb25lO1xyXG5cclxuXHRyZXR1cm4gY2xvbmU7XHJcbn07XHJcbiovXHJcblxyXG5cclxuLy9Bc3NpZ24gc3RyYXRlZ3kgdG8gcGxheWVyXHJcbl9QbGF5ZXIucHJvdG90eXBlLmFzc2lnbiA9IGZ1bmN0aW9uKHN0cmF0ZWd5KSB7XHJcblxyXG5cdC8vVE9ETzogdmVyaWZ5IHN0cmF0ZWd5IHR5cGVcclxuXHRpZiAocmVnaXN0cnkuc3RyYXRlZ2llc1tzdHJhdGVneV0pIHtcclxuXHRcdHRoaXMuc3RyYXRlZ3kgPSBuZXcgcmVnaXN0cnkuc3RyYXRlZ2llc1tzdHJhdGVneV07XHJcblx0XHR0aGlzLnN0cmF0ZWd5Ll9pZCA9IHN0cmF0ZWd5XHJcblx0fSBlbHNlIHRocm93IG5ldyBFcnJvcihcIlN0cmF0ZWd5ICdcIiArIHN0cmF0ZWd5ICsgXCInIGlzIG5vdCBkZWZpbmVkXCIpO1xyXG59O1xyXG5cclxuXHJcbi8vQ2FsbCBzdHJhdGVneSB0byBtYWtlIGEgY2hvaWNlXHJcbl9QbGF5ZXIucHJvdG90eXBlLmNob29zZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIGluZm9ybWF0aW9uID0ge30pIHsgLy9UT0RPOiBjaGVjayB0aGF0IHRoZXJlJ3MgYSBzdHJhdGVneSBhc3NpZ25lZCBiZWZvcmUgdHJ5aW5nIHRvIHBsYXlcclxuXHR2YXIgcGxheWVyID0gdGhpcztcclxuXHRpZiAocGxheWVyLnN0cmF0ZWd5KVxyXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShwbGF5ZXIuc3RyYXRlZ3kuY2hvb3NlKG9wdGlvbnMsIGluZm9ybWF0aW9uKS50b1N0cmluZygpKTtcclxuXHRlbHNlXHJcblx0XHRsb2coXCJ3YXJuaW5nXCIsIFwiTm8gc3RyYXRlZ3kgYXNzaWduZWQgdG8gcGxheWVyIFwiICsgcGxheWVyLmlkICsgXCIuIFVzaW5nIGRlZmF1bHQgb3B0aW9uLlwiKTtcclxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xyXG59O1xyXG5cclxuXHJcbi8vVGFrZXMgYSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KCkpIGNvcHkgb2YgX3BsYXllci4gUmV0dXJucyBhIGNsZWFuZWQgdXAgdmVyc2lvblxyXG5fUGxheWVyLnByb3RvdHlwZS5pbmZvQ2xlYW4gPSBmdW5jdGlvbihpbmZvT2JqZWN0KSB7XHJcblx0ZGVsZXRlIGluZm9PYmplY3QuaW50ZXJmYWNlO1xyXG5cdGluZm9PYmplY3Quc3RyYXRlZ3kgPSBpbmZvT2JqZWN0LnN0cmF0ZWd5Ll9pZDtcclxuXHJcblx0cmV0dXJuIGluZm9PYmplY3Q7XHJcbn07XHJcblxyXG5cclxuLy9LaWxsIHBsYXllci4gVE9ETzogYWRkIHBsYXllciB0byBzb21lIHNvcnQgb2YgXCJkZWFkXCIgbGlzdCB0byBhdm9pZCBiZWluZyBwaWNrZWQgdG8gZG8gdGhpbmdzLlxyXG5fUGxheWVyLnByb3RvdHlwZS5raWxsID0gZnVuY3Rpb24oKSB7XHJcblx0dGhpcy5hbGl2ZSA9IGZhbHNlO1xyXG59O1xyXG5cclxuXHJcblxyXG4vL0NsYXNzIHRoYXQgaXMgdGhlIHJlZmVyZW5jZSBmb3IgdGhlIHVzZXIgdG8gaG9sZCBvbnRvXHJcbmZ1bmN0aW9uIHBsYXllcigpIHt9XHJcblxyXG5cclxuLy9Gcm9udGVuZCBmb3IgUGxheWVyXHJcbmZ1bmN0aW9uIFBsYXllcihwYXJhbWV0ZXJzID0ge30pIHtcclxuXHR2YXIgaWQgPSBpZEhhbmRsZXIocGFyYW1ldGVycy5pZCwgXCJwbGF5ZXJcIik7XHJcblxyXG5cdC8vQ3JlYXRlIGJhY2tlbmQgcGxheWVyIG9iamVjdFxyXG5cdHZhciBfcGxheWVyID0gbmV3IF9QbGF5ZXIoaWQsIHBhcmFtZXRlcnMpO1xyXG5cclxuXHJcblx0Ly9SZXR1cm4gdGhpcyByZWZlcmVuY2Ugb2JqZWN0IHRvIHRoZSB1c2VyXHJcblx0dmFyIHBsYXllckludGVyZmFjZSA9IG5ldyBwbGF5ZXIoKTsgLy9Qcm9iYWJseSBhZGQgZnVuY3Rpb25hbGl0eSBoZXJlXHJcblxyXG5cdC8vVGFnLWJhY2suIFN0b3JlIHRoZSBmcm9udC1lbmQgb2JqZWN0IGluIHRoZSBiYWNrLWVuZCBvYmplY3QsIGZvciByZXRyaWV2YWxcclxuXHRfcGxheWVyLmludGVyZmFjZSA9IHBsYXllckludGVyZmFjZTtcclxuXHJcblx0cGxheWVySW50ZXJmYWNlLmFsaXZlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gX3BsYXllci5hbGl2ZTtcclxuXHR9XHJcblxyXG5cdHBsYXllckludGVyZmFjZS5hc3NpZ24gPSBmdW5jdGlvbihzdHJhdGVneSkge1xyXG5cdFx0X3BsYXllci5hc3NpZ24oc3RyYXRlZ3kpO1xyXG5cdH07XHJcblxyXG5cdHBsYXllckludGVyZmFjZS5hdmFpbGFibGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBfcGxheWVyLmF2YWlsYWJsZVxyXG5cdH07XHJcblxyXG5cdHBsYXllckludGVyZmFjZS5idXN5ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRfcGxheWVyLmF2YWlsYWJsZSA9IGZhbHNlO1xyXG5cdH07XHJcblxyXG5cdHBsYXllckludGVyZmFjZS5oaXN0b3J5ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gbmV3IFVzZXJIaXN0b3J5KF9wbGF5ZXIuaGlzdG9yeSk7XHJcblx0fTtcclxuXHJcblx0cGxheWVySW50ZXJmYWNlLmlkID0gZnVuY3Rpb24oKSB7IHJldHVybiBpZDsgfTtcclxuXHJcblx0cGxheWVySW50ZXJmYWNlLmtpbGwgPSBmdW5jdGlvbigpIHtcclxuXHRcdF9wbGF5ZXIua2lsbCgpO1xyXG5cdH1cclxuXHJcblx0cGxheWVySW50ZXJmYWNlLnJlbGVhc2UgPSBmdW5jdGlvbigpIHtcclxuXHRcdF9wbGF5ZXIuYXZhaWxhYmxlID0gdHJ1ZTtcclxuXHR9O1xyXG5cclxuXHRwbGF5ZXJJbnRlcmZhY2UucmVzZXRTY29yZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0X3BsYXllci5zY29yZSA9IDA7XHJcblx0fVxyXG5cclxuXHRwbGF5ZXJJbnRlcmZhY2Uuc2NvcmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiByZWdpc3RyeS5wbGF5ZXJzW2lkXS5zY29yZTtcclxuXHR9O1xyXG5cclxuXHRwbGF5ZXJJbnRlcmZhY2Uuc3RyYXRlZ3kgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBfcGxheWVyLnN0cmF0ZWd5Ll9pZDtcclxuXHR9O1xyXG5cclxuXHJcblx0cmV0dXJuIHBsYXllckludGVyZmFjZVxyXG59XHJcblxyXG5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgX1BsYXllciwgUGxheWVyIH07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGxvZyA9IHJlcXVpcmUoXCIuL2xvZ2dlclwiKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpc0Z1bmN0aW9uLCBpc09iamVjdCB9ID0gcmVxdWlyZShcIi4vaGVscGVyRnVuY3Rpb25zXCIpKFwiZ2VuZXJhbFwiKTtcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIgeyByZWdpc3RyeSB9ID0gcmVxdWlyZShcIi4vc3RhdGVcIik7XHJcblxyXG52YXIgeyBfUGxheWVyIH0gPSByZXF1aXJlKFwiLi9wbGF5ZXJcIik7XHJcblxyXG4vL0NsYXNzIFBsYXllckxpc3QgaXMgYSBsaXN0IG9mIHBsYXllcnMgd2hpY2ggaW5jbHVkZXMgc29tZSBleHRyYSBmdW5jdGlvbmFsaXR5LiBVc2VyUGxheWVyTGlzdCB0YWtlcyBhIHBsYXllckxpc3QgYW5kXHJcbi8vc2FuaXRpemVzIGl0IGZvciB0aGUgdXNlciAoaWUgcmV0dXJucyAuaW50ZXJmYWNlIGZvciBlYWNoIHBsYXllcikuXHJcblxyXG5mdW5jdGlvbiBQbGF5ZXJMaXN0KC4uLmFyZ3MpIHtcclxuXHRpZiAoQXJyYXkuaXNBcnJheShhcmdzWzBdKSkgYXJncyA9IGFyZ3NbMF0uc2xpY2UoMCk7XHJcblx0aWYgKGFyZ3MgPT0gXCJhbGxcIikgcmV0dXJuIGdhbWVQb3B1bGF0aW9uKCk7XHJcblxyXG5cdC8vIFdlJ2xsIG5lZWQgdG8gcmV0YWluIHRoZSBvcmlnaW5hbCBhcmd1bWVudHMgaW4gb3JkZXIgdG8gY3JlYXRlIHRoZSBnZW5lcmF0b3JcclxuXHR2YXIgb3JpZ2luYWxBcmdzID0gW11cclxuXHJcblx0Ly8gTG9vcCBvdmVyIHRoZSBhcmd1bWVudHMsIHNhdmUgdGhlIG9yaWdpbmFscywgcGFyc2UgdGhlbSB0byBfcGxheWVyc1xyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRvcmlnaW5hbEFyZ3MucHVzaChhcmdzW2ldKTtcclxuXHRcdGlmIChpc0Z1bmN0aW9uKGFyZ3NbaV0uaWQpKSBhcmdzW2ldID0gcmVnaXN0cnkucGxheWVyc1thcmdzW2ldLmlkKCldO1xyXG5cdFx0ZWxzZSBpZiAodHlwZW9mIGFyZ3NbaV0gPT09ICdzdHJpbmcnKSBhcmdzW2ldID0gcmVnaXN0cnkucGxheWVyc1thcmdzW2ldXVxyXG5cdH1cclxuXHJcblx0T2JqZWN0LnNldFByb3RvdHlwZU9mKGFyZ3MsIFBsYXllckxpc3QucHJvdG90eXBlKTtcclxuXHJcblx0Ly8gcmV0dXJucyB0aGUgc2FtZSBwbGF5ZXJsaXN0LCBidXQgdXBkYXRlZCwgdXNpbmcgdGhlIG9yaWdpbmFsIGFyZ3MuXHJcblx0YXJncy5nZW5lcmF0b3IgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBuZXcgUGxheWVyTGlzdChvcmlnaW5hbEFyZ3MpO1xyXG5cdH07XHJcblxyXG5cdHJldHVybiBhcmdzO1xyXG59XHJcblxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQXJyYXkucHJvdG90eXBlKTtcclxuUGxheWVyTGlzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQbGF5ZXJMaXN0O1xyXG5cclxuLy9SZXR1cm4gYSBwbGF5ZXJMaXN0IHdpdGggb25seSB0aGUgcGxheWVycyB3aG8gYXJlIGF2YWlsYWJsZVxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5vbmx5QWxpdmUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gbmV3IFBsYXllckxpc3QoXHJcblx0XHR0aGlzLmZpbHRlcihmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0cmV0dXJuIHBsYXllci5hbGl2ZTtcclxuXHRcdH0pXHJcblx0KTtcclxufTtcclxuXHJcbi8vUmV0dXJuIGEgcGxheWVyTGlzdCB3aXRoIG9ubHkgdGhlIHBsYXllcnMgd2hvIGFyZSBhdmFpbGFibGVcclxuUGxheWVyTGlzdC5wcm90b3R5cGUub25seUF2YWlsYWJsZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBuZXcgUGxheWVyTGlzdChcclxuXHRcdHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRyZXR1cm4gcGxheWVyLmF2YWlsYWJsZTtcclxuXHRcdH0pXHJcblx0KTtcclxufTtcclxuXHJcbi8vS2lsbCBhbGwgcGxheWVycyBpbiB0aGUgcGxheWVyTGlzdFxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5raWxsID0gZnVuY3Rpb24oKSB7XHJcblx0dGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0cGxheWVyLmtpbGwoKTtcclxuXHR9KTtcclxufTtcclxuXHJcblBsYXllckxpc3QucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbigpIHtcclxuXHR0aGlzLmZvckVhY2goZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRwbGF5ZXIuYXZhaWxhYmxlID0gdHJ1ZTtcclxuXHR9KTtcclxufTtcclxuXHJcbi8vUmV0dXJuIGFycmF5IG9mIGlkcyBvZiBlYWNoIHBsYXllciBpbiB0aGUgbGlzdFxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5pZHMgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRyZXR1cm4gcGxheWVyLmlkO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuLy9SZXR1cm4gYSBQbGF5ZXJMaXN0IG1pbnVzIHRoZSBzcGVjaWZpZWQgcGxheWVycy5cclxuLy9Bcmd1bWVudCBjYW4gYmUgX3BsYXllciwgaW50ZXJmYWNlLCBvciBhIHBsYXllcidzIGlkLlxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5leGNsdWRlID0gZnVuY3Rpb24ocGxheWVyQXJnKSB7XHJcblx0aWYgKEFycmF5LmlzQXJyYXkocGxheWVyQXJnKSlcclxuXHRcdHJldHVybiBwbGF5ZXJBcmcucmVkdWNlKGZ1bmN0aW9uKHJ1bm5pbmcsIGl0ZW0pIHtcclxuXHRcdFx0cmV0dXJuIHJ1bm5pbmcuZXhjbHVkZShpdGVtKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRyZXR1cm4gbmV3IFBsYXllckxpc3QoXHJcblx0XHR0aGlzLmZpbHRlcihmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0aWYgKFxyXG5cdFx0XHRcdHBsYXllckFyZyA9PT0gcGxheWVyIHx8XHJcblx0XHRcdFx0cGxheWVyQXJnID09IHBsYXllci5pbnRlcmZhY2UgfHxcclxuXHRcdFx0XHRwbGF5ZXJBcmcgPT0gcGxheWVyLmlkIHx8XHJcblx0XHRcdFx0KGlzT2JqZWN0KHBsYXllckFyZykgJiYgcGxheWVyQXJnLmlkID09IHBsYXllci5pZClcclxuXHRcdFx0KVxyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0ZWxzZSByZXR1cm4gdHJ1ZTtcclxuXHRcdH0pXHJcblx0KTtcclxufTtcclxuXHJcbi8vQ3JlYXRlIGFuIEluZm9QbGF5ZXJMaXN0IG91dCBvZiB0aGlzIFBsYXllckxpc3QuIFVzZWZ1bCBmb3IgZ2V0dGluZyBzdW1tYXJ5IHZpZXcuXHJcblBsYXllckxpc3QucHJvdG90eXBlLmluZm8gPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gbmV3IEluZm9QbGF5ZXJMaXN0KHRoaXMpO1xyXG59O1xyXG5cclxuLy8gUGxhY2Vob2xkZXIgZm9yIGdlbmVyYXRvciBtZXRob2QuXHJcblBsYXllckxpc3QucHJvdG90eXBlLmdlbmVyYXRvciA9IGZ1bmN0aW9uKCkge1xyXG5cdC8vIFRoaXMgd2lsbCBnZXQgc2hhZG93ZWQgd2hlbiB0aGUgY29uc3RydWN0b3IgaXMgY2FsbGVkLCBidXQgaXQgbmVlZHMgdG8gYmUgaGVyZSBzbyB0aGF0IHRoZVxyXG5cdC8vIFVzZXJQbGF5ZXJMaXN0IGFuZCBJbmZvUGxheWVyTGlzdCBjb25zdHJ1Y3RvcnMgY2FuIHNlZSBpdC5cclxufVxyXG5cclxuLy9SZXR1cm4gYW4gYXJyYXkgb2YgdGhlIHN0cmF0ZWd5IG9mIGVhY2ggcGxheWVyIGluIHRoZSBsaXN0XHJcblBsYXllckxpc3QucHJvdG90eXBlLnN0cmF0ZWdpZXMgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRyZXR1cm4gcGxheWVyLnN0cmF0ZWd5ID8gcGxheWVyLnN0cmF0ZWd5Ll9pZCA6IFwiXCI7XHJcblx0fSk7XHJcbn07XHJcblxyXG4vL1JldHVybiBhIFBsYXllckxpc3Qgd2l0aCBvbmx5IHBsYXllcnMgdXNpbmcgYSBnaXZlbiBzdHJhdGVneVxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS51c2luZ1N0cmF0ZWd5ID0gZnVuY3Rpb24oc3RyYXRlZ3kpIHtcclxuXHRyZXR1cm4gbmV3IFBsYXllckxpc3QoXHJcblx0XHR0aGlzLmZpbHRlcihmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0aWYgKFxyXG5cdFx0XHRcdHBsYXllci5zdHJhdGVneSA9PSBzdHJhdGVneSB8fFxyXG5cdFx0XHRcdHBsYXllci5zdHJhdGVneS5faWQgPT0gc3RyYXRlZ3kgfHxcclxuXHRcdFx0XHQoaXNGdW5jdGlvbihzdHJhdGVneSkgJiYgcGxheWVyLnN0cmF0ZWd5IGluc3RhbmNlb2Ygc3RyYXRlZ3kpXHJcblx0XHRcdClcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0ZWxzZSByZXR1cm4gZmFsc2U7XHJcblx0XHR9KVxyXG5cdCk7XHJcbn07XHJcblxyXG4vKlxyXG5cclxuVE9ETyBmaWd1cmUgb3V0IGhvdyB0byBtYWtlIHRoaXMgd29ya1xyXG5cclxuLy9SZXR1cm5zIGFuIG9iamVjdCB3aGVyZSB0aGUga2V5cyBhcmUgc3RyYXRlZ3kgbmFtZXMgYW5kIHRoZSB2YWx1ZXMgYXJlIGFycmF5cyBvZiBwbGF5ZXJzLlxyXG4vL1RoaXMgbmVlZHMgdG8gYmUgb3ZlcnJpZGRlbiBvbiB0aGUgVXNlclBsYXllckxpc3QgcHJvdG90eXBlLCBiZWNhdXNlIHRoZSBub3JtYWwgd3JhcHBlciBsb2dpY1xyXG4vL2ZvciBVc2VyUGxheWVyTGlzdCBjYW5ub3Qgc2FuaXRpemUgdGhpcy5cclxuUGxheWVyTGlzdC5wcm90b3R5cGUuYnlTdHJhdGVneSA9IGZ1bmN0aW9uKCl7XHJcblx0dmFyIGxpc3QgPSB0aGlzO1xyXG5cdHZhciBkYXRhID0ge307XHJcblxyXG5cdE9iamVjdC5rZXlzKHJlZ2lzdHJ5LnN0cmF0ZWdpZXMpLmZvckVhY2goZnVuY3Rpb24oc3RyYXRlZ3kpe1xyXG5cdFx0ZGF0YVtzdHJhdGVneV0gPSBsaXN0LnVzaW5nU3RyYXRlZ3koc3RyYXRlZ3kpO1xyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gZGF0YTtcclxufTtcclxuKi9cclxuXHJcbi8vUmV0dXJucyBhbiBvYmplY3Qgd2hlcmUgdGhlIGtleXMgYXJlIGVhY2ggc3RyYXRlZ3kgYW5kIHRoZSB2YWx1ZXNcclxuLy9hcmUgdGhlIG51bWJlciBvZiBwbGF5ZXJzIGluIHRoZSBsaXN0IHdobyBhcmUgdXNpbmcgaXQuXHJcblBsYXllckxpc3QucHJvdG90eXBlLnN0cmF0ZWd5RGlzdHJpYnV0aW9uID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGNvdW50cyA9IHt9O1xyXG5cclxuXHR0aGlzLmZvckVhY2goZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHR2YXIgcyA9IHBsYXllci5zdHJhdGVneS5faWQ7XHJcblx0XHRjb3VudHNbc10gPSAoY291bnRzW3NdIHx8IDApICsgMTtcclxuXHR9KTtcclxuXHJcblx0cmV0dXJuIGNvdW50cztcclxufTtcclxuXHJcbi8vUmV0dXJucyBhbiBhcnJheSBvZiBzY29yZXMgb2YgZWFjaCBwbGF5ZXIgaW4gdGhlIGxpc3RcclxuUGxheWVyTGlzdC5wcm90b3R5cGUuc2NvcmVzID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIHNjb3JlcyA9IFtdO1xyXG5cclxuXHR0aGlzLmZvckVhY2goZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRzY29yZXMucHVzaChwbGF5ZXIuc2NvcmUpOyAvL1VzZSB0aGUgaW50ZXJmYWNlIGZ1bmN0aW9uIHRvIGF2b2lkIHVzZXJzIHJlLWFzc2lnbmluZyB0aGUgcmVmZXJlbmNlXHJcblx0fSk7XHJcblx0cmV0dXJuIHNjb3JlcztcclxufTtcclxuXHJcbi8vIFJldHVybnMgYW4gb2JqZWN0IHdoZXJlIGVhY2gga2V5IGlzIGEgc3RyYXRlZ3kgYW5kIGVhY2ggdmFsdWUgaXMgYW4gYXJyYXkgb2YgdGhlIHNjb3JlcyBvZiBwbGF5ZXJzIHdpdGggdGhhdCBzdHJhdGVneS5cclxuLy8gVE9ETzogZmluaXNoIC50b3RhbCgpIG1ldGhvZCwgd2hpY2ggd2lsbCBzdW0gdGhlIGFycmF5cyAoZHVwbGljYXRpbmcgLnNjb3Jlc0J5U3RyYXRlZ3lUb3RhbHMpXHJcblBsYXllckxpc3QucHJvdG90eXBlLnNjb3Jlc0J5U3RyYXRlZ3kgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgc2NvcmVzID0ge307XHJcblx0dmFyIGxpc3QgPSB0aGlzO1xyXG5cclxuXHRsaXN0LnN0cmF0ZWdpZXMoKS5tYXAoZnVuY3Rpb24oc3RyYXRlZ3kpIHtcclxuXHRcdHNjb3Jlc1tzdHJhdGVneV0gPSBsaXN0LnVzaW5nU3RyYXRlZ3koc3RyYXRlZ3kpLnNjb3JlcygpO1xyXG5cdH0pO1xyXG5cclxuXHRzY29yZXMudG90YWwgPSBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBzY29yZSA9IHt9O1xyXG5cdFx0dmFyIHNjb3JlcyA9IHRoaXM7XHJcblx0XHRPYmplY3Qua2V5cyhzY29yZXMpLmZvckVhY2goZnVuY3Rpb24oc3RyYXRlZ3kpIHtcclxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoc2NvcmVzW3N0cmF0ZWd5XSkpIHNjb3JlW3N0cmF0ZWd5XSA9IHNjb3Jlc1tzdHJhdGVneV0ucmVkdWNlKGZ1bmN0aW9uKGEsIGIpIHtcclxuXHRcdFx0XHRyZXR1cm4gYSArIGI7XHJcblx0XHRcdH0sIDApO1xyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4gc2NvcmU7XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIHNjb3JlcztcclxufTtcclxuXHJcbi8vIFJldHVybnMgYW4gb2JqZWN0IHdoZXJlIGVhY2gga2V5IGlzIGEgc3RyYXRlZ3kgYW5kIGVhY2ggdmFsdWUgaXMgdGhlIHN1bSBvZiBzY29yZXMgb2YgYWxsIHBsYXllcnMgd2l0aCB0aGF0IHZhbHVlXHJcblBsYXllckxpc3QucHJvdG90eXBlLnNjb3Jlc0J5U3RyYXRlZ3lUb3RhbHMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgc2NvcmVzID0ge307XHJcblx0dmFyIGxpc3QgPSB0aGlzO1xyXG5cclxuXHRsaXN0LnN0cmF0ZWdpZXMoKS5tYXAoZnVuY3Rpb24oc3RyYXRlZ3kpIHtcclxuXHRcdHNjb3Jlc1tzdHJhdGVneV0gPSBsaXN0XHJcblx0XHRcdC51c2luZ1N0cmF0ZWd5KHN0cmF0ZWd5KVxyXG5cdFx0XHQuc2NvcmVzKClcclxuXHRcdFx0LnJlZHVjZShmdW5jdGlvbihhLCBiKSB7XHJcblx0XHRcdFx0cmV0dXJuIGEgKyBiO1xyXG5cdFx0XHR9LCAwKTtcclxuXHR9KTtcclxuXHJcblx0cmV0dXJuIHNjb3JlcztcclxufTtcclxuXHJcbi8vUmV0dXJucyBhbiBvYmplY3Qgd2hlcmUgdGhlIGtleXMgYXJlIHRoZSBwbGF5ZXIgaWRzIGFuZCB0aGUgdmFsdWVzXHJcbi8vYXJlIHRoZSBwbGF5ZXJzJyBzY29yZVxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5zY29yZXNPYmplY3QgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgc2NvcmVzID0ge307XHJcblxyXG5cdHRoaXMuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdHNjb3Jlc1twbGF5ZXIuaWRdID0gcGxheWVyLnNjb3JlO1xyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gc2NvcmVzO1xyXG59O1xyXG5cclxuLy9NZWFuIG9mIHRoZSBzY29yZXNcclxuUGxheWVyTGlzdC5wcm90b3R5cGUuc2NvcmVzTWVhbiA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBzY29yZXMgPSB0aGlzLnNjb3JlcygpO1xyXG5cclxuXHR2YXIgbWVhbiA9XHJcblx0XHRzY29yZXMucmVkdWNlKGZ1bmN0aW9uKHN1bSwgdmFsdWUpIHtcclxuXHRcdFx0cmV0dXJuIHN1bSArIHZhbHVlO1xyXG5cdFx0fSwgMCkgLyBzY29yZXMubGVuZ3RoO1xyXG5cclxuXHRyZXR1cm4gbWVhbjtcclxufTtcclxuXHJcbi8vQXJyYXkgd2l0aCAyIGVudHJpZXMsIHRoZSBsb3dlc3QgYW5kIGhpZ2hlc3Qgc2NvcmVcclxuUGxheWVyTGlzdC5wcm90b3R5cGUuc2NvcmVzUmFuZ2UgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgc2NvcmVzID0gdGhpcy5zY29yZXMoKTtcclxuXHJcblx0c2NvcmVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG5cdFx0cmV0dXJuIGEgLSBiO1xyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gW3Njb3Jlc1swXSwgc2NvcmVzW3Njb3Jlcy5sZW5ndGggLSAxXV07XHJcbn07XHJcblxyXG4vL1RoZSBzdGFuZGFyZCBkZXZpYXRpb24gb2YgdGhlIHNjb3Jlc1xyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5zY29yZXNTdGQgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgc2NvcmVzID0gdGhpcy5zY29yZXMoKTtcclxuXHR2YXIgbWVhbiA9IHRoaXMuc2NvcmVzTWVhbigpO1xyXG5cclxuXHR2YXIgdmFyaWFuY2UgPVxyXG5cdFx0c2NvcmVzLnJlZHVjZShmdW5jdGlvbihzdW0sIHZhbHVlKSB7XHJcblx0XHRcdHJldHVybiBzdW0gKyBNYXRoLnBvdyh2YWx1ZSAtIG1lYW4sIDIpO1xyXG5cdFx0fSwgMCkgLyBzY29yZXMubGVuZ3RoO1xyXG5cclxuXHR2YXIgc3RkID0gTWF0aC5zcXJ0KHZhcmlhbmNlKTtcclxuXHJcblx0cmV0dXJuIHN0ZDtcclxufTtcclxuXHJcbi8vUmV0dXJucyB0aGUgc2luZ2xlIHBsYXllciB3aXRoIHRoZSBoaWdoZXN0IHNjb3JlXHJcblBsYXllckxpc3QucHJvdG90eXBlLmxlYWRlciA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBwbGF5ZXJzID0gdGhpcy5zbGljZSgpO1xyXG5cclxuXHRwbGF5ZXJzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG5cdFx0cmV0dXJuIGIuc2NvcmUgLSBhLnNjb3JlO1xyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gcGxheWVyc1swXTtcclxufTtcclxuXHJcblBsYXllckxpc3QucHJvdG90eXBlLnJlc2V0U2NvcmVzID0gZnVuY3Rpb24oKSB7XHJcblx0dGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0cGxheWVyLnNjb3JlID0gMDtcclxuXHR9KTtcclxufTtcclxuXHJcbi8vQWNjZXB0IGEgUGxheWVyTGlzdCBhbmQgcmV0dXJuIG9uZSBzdWl0YWJsZSBmb3IgdGhlIHVzZXIsIG9yIGNyZWF0ZSBhIHBsYXllcmxpc3QgYW5kIHJldHVybiBvbmUgc3VpdGFibGUgZm9yIHRoZSB1c2VyXHJcbmZ1bmN0aW9uIFVzZXJQbGF5ZXJMaXN0KC4uLnBsYXllckxpc3QpIHtcclxuXHRpZiAoQXJyYXkuaXNBcnJheShwbGF5ZXJMaXN0WzBdKSkgcGxheWVyTGlzdCA9IHBsYXllckxpc3RbMF07XHJcblxyXG5cdC8vIElmIHdlJ3ZlIGdvdCBhIHBsYXllckxpc3QsIHJldHVybiB0aGUgaW50ZXJmYWNlIG9mIGVhY2ggcGxheWVyXHJcblx0aWYgKHBsYXllckxpc3QgaW5zdGFuY2VvZiBQbGF5ZXJMaXN0KSB7XHJcblx0XHR2YXIgdXNlclBsYXllckxpc3QgPSBwbGF5ZXJMaXN0Lm1hcChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0cmV0dXJuIHBsYXllci5pbnRlcmZhY2U7XHJcblx0XHR9KTtcclxuXHR9XHJcblx0Ly8gSWYgbm90LCBmaXJzdCBjcmVhdGUgYSBwbGF5ZXJMaXN0LCB0aGVuIGNhbGwgdGhpcyBmdW5jdGlvbiBhZ2FpbiB0byB3cmFwIGl0LlxyXG5cdGVsc2UgcmV0dXJuIG5ldyBVc2VyUGxheWVyTGlzdChuZXcgUGxheWVyTGlzdChwbGF5ZXJMaXN0KSk7XHJcblxyXG5cdE9iamVjdC5zZXRQcm90b3R5cGVPZih1c2VyUGxheWVyTGlzdCwgVXNlclBsYXllckxpc3QucHJvdG90eXBlKTtcclxuXHJcblx0Ly9BdHRhY2ggbWV0aG9kcyBmcm9tIFBsYXllckxpc3QsIHdyYXBwZWQgaW4gYSBmdW5jdGlvbi4gSWYgdGhvc2UgbWV0aG9kcyByZXR1cm4gYSBwbGF5ZXJMaXN0LFxyXG5cdC8vdGhlbiB0aGUgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IHRoYXQgdG8gYSBVc2VyUGxheWVyTGlzdC5cclxuXHRmb3IgKHZhciBtZXRob2QgaW4gUGxheWVyTGlzdC5wcm90b3R5cGUpIHtcclxuXHRcdGlmIChpc0Z1bmN0aW9uKHBsYXllckxpc3RbbWV0aG9kXSkpIHtcclxuXHRcdFx0aWYgKG1ldGhvZCAhPSBcImNvbnN0cnVjdG9yXCIpXHJcblx0XHRcdFx0dXNlclBsYXllckxpc3RbbWV0aG9kXSA9IChmdW5jdGlvbihtZXRob2QpIHtcclxuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0dmFyIHJlc3VsdCA9IHBsYXllckxpc3RbbWV0aG9kXS5hcHBseShwbGF5ZXJMaXN0LCBhcmd1bWVudHMpO1xyXG5cdFx0XHRcdFx0XHRpZiAocmVzdWx0IGluc3RhbmNlb2YgUGxheWVyTGlzdCkgcmV0dXJuIG5ldyBVc2VyUGxheWVyTGlzdChyZXN1bHQpO1xyXG5cdFx0XHRcdFx0XHRlbHNlIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBfUGxheWVyKSByZXR1cm4gcmVzdWx0LmludGVyZmFjZTtcclxuXHRcdFx0XHRcdFx0ZWxzZSByZXR1cm4gcmVzdWx0O1xyXG5cdFx0XHRcdFx0fTtcclxuXHRcdFx0XHR9KShtZXRob2QpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHVzZXJQbGF5ZXJMaXN0O1xyXG59XHJcblxyXG5Vc2VyUGxheWVyTGlzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBsYXllckxpc3QucHJvdG90eXBlKTtcclxuVXNlclBsYXllckxpc3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVXNlclBsYXllckxpc3Q7XHJcblxyXG4vL0FjY2VwdCBhIFBsYXllckxpc3QgYW5kIHJldHVybiBvbmUgc3VpdGFibGUgZm9yIGEgc3RyYXRlZ3kgaW5mb3JtYXRpb24gc2V0LlxyXG5mdW5jdGlvbiBJbmZvUGxheWVyTGlzdChwbGF5ZXJMaXN0KSB7XHJcblx0dmFyIGluZm9QbGF5ZXJMaXN0ID0gcGxheWVyTGlzdC5tYXAoZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRyZXR1cm4gcGxheWVyLmluZm9DbGVhbihKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHBsYXllcikpKTtcclxuXHR9KTtcclxuXHJcblx0T2JqZWN0LnNldFByb3RvdHlwZU9mKGluZm9QbGF5ZXJMaXN0LCBJbmZvUGxheWVyTGlzdC5wcm90b3R5cGUpO1xyXG5cclxuXHQvL0F0dGFjaCBzZWxlY3RlZCBtZXRob2RzIGZyb20gUGxheWVyTGlzdCwgd3JhcHBlZCBpbiBhIGZ1bmN0aW9uLiBJZiB0aG9zZSBtZXRob2RzIHJldHVybiBhIHBsYXllckxpc3QsXHJcblx0Ly90aGVuIHRoZSBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgdGhhdCB0byBhbiBJbmZvUGxheWVyTGlzdC5cclxuXHR2YXIgbWV0aG9kc1RvSW5jbHVkZSA9IFtcclxuXHRcdFwib25seUFsaXZlXCIsXHJcblx0XHRcIm9ubHlBdmFpbGFibGVcIixcclxuXHRcdFwiaWRzXCIsXHJcblx0XHRcImV4Y2x1ZGVcIixcclxuXHRcdFwiZ2VuZXJhdG9yXCIsXHJcblx0XHRcInN0cmF0ZWdpZXNcIixcclxuXHRcdFwidXNpbmdTdHJhdGVneVwiLFxyXG5cdFx0XCJzdHJhdGVneURpc3RyaWJ1dGlvblwiLFxyXG5cdFx0XCJzY29yZXNcIixcclxuXHRcdFwic2NvcmVzT2JqZWN0XCIsXHJcblx0XHRcInNjb3Jlc01lYW5cIixcclxuXHRcdFwic2NvcmVzUmFuZ2VcIixcclxuXHRcdFwic2NvcmVzU3RkXCIsXHJcblx0XHRcImxlYWRlclwiXHJcblx0XTtcclxuXHJcblx0Zm9yICh2YXIgbWV0aG9kIGluIFBsYXllckxpc3QucHJvdG90eXBlKSB7XHJcblx0XHRpZiAoaXNGdW5jdGlvbihwbGF5ZXJMaXN0W21ldGhvZF0pKSB7XHJcblx0XHRcdGlmIChtZXRob2RzVG9JbmNsdWRlLmluZGV4T2YobWV0aG9kKSA+IC0xKVxyXG5cdFx0XHRcdGluZm9QbGF5ZXJMaXN0W21ldGhvZF0gPSAoZnVuY3Rpb24obWV0aG9kKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdHZhciByZXN1bHQgPSBwbGF5ZXJMaXN0W21ldGhvZF0uYXBwbHkocGxheWVyTGlzdCwgYXJndW1lbnRzKTtcclxuXHRcdFx0XHRcdFx0aWYgKHJlc3VsdCBpbnN0YW5jZW9mIFBsYXllckxpc3QpIHJldHVybiBuZXcgSW5mb1BsYXllckxpc3QocmVzdWx0KTtcclxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAocmVzdWx0IGluc3RhbmNlb2YgX1BsYXllcilcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0LmluZm9DbGVhbihKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJlc3VsdCkpKTtcclxuXHRcdFx0XHRcdFx0ZWxzZSByZXR1cm4gcmVzdWx0O1xyXG5cdFx0XHRcdFx0fTtcclxuXHRcdFx0XHR9KShtZXRob2QpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGluZm9QbGF5ZXJMaXN0O1xyXG59XHJcblxyXG5JbmZvUGxheWVyTGlzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEFycmF5LnByb3RvdHlwZSk7XHJcbkluZm9QbGF5ZXJMaXN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEluZm9QbGF5ZXJMaXN0O1xyXG5cclxuLy9FeHRyYSBtZXRob2QgdG8gcmV0dXJuIGEgc2luZ2xlIHBsYXllciBmcm9tIGFuIGluZm9QbGF5ZXJMaXN0XHJcbkluZm9QbGF5ZXJMaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihwbGF5ZXJJRCkge1xyXG5cdHJldHVybiB0aGlzLmZpbmQoZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRyZXR1cm4gcGxheWVyLmlkID09IHBsYXllcklEO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuLy9HZW5lcmF0ZXMgYSBQbGF5ZXJMaXN0IGNvbnRhaW5pbmcgYWxsIHBsYXllcnMuXHJcbnZhciBnYW1lUG9wdWxhdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBwb3B1bGF0aW9uID0gW107XHJcblxyXG5cdGZvciAodmFyIHBsYXllciBpbiByZWdpc3RyeS5wbGF5ZXJzKSB7XHJcblx0XHRwb3B1bGF0aW9uLnB1c2gocmVnaXN0cnkucGxheWVyc1twbGF5ZXJdKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBuZXcgUGxheWVyTGlzdChwb3B1bGF0aW9uKTtcclxufTtcclxuXHJcbi8vRG9lcyB0aGUgc2FtZSwgYnV0IGEgVXNlclBsYXllckxpc3RcclxudmFyIFBvcHVsYXRpb24gPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gbmV3IFVzZXJQbGF5ZXJMaXN0KGdhbWVQb3B1bGF0aW9uKCkpO1xyXG59O1xyXG5cclxuLy9Eb2VzIHRoZSBzYW1lLCBidXQgYW4gSW5mb1BsYXllckxpc3RcclxudmFyIEluZm9Qb3B1bGF0aW9uID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIG5ldyBJbmZvUGxheWVyTGlzdChnYW1lUG9wdWxhdGlvbigpKTtcclxufTtcclxuXHJcbi8vQSBzaG9ydC1oYW5kIHRvIHJldHVybiB0b3RhbCBwb3B1bGF0aW9uIHNpemUgd2l0aG91dCBjcmVhdGluZyBhIFBsYXllckxpc3RcclxuUG9wdWxhdGlvbi5zaXplID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIE9iamVjdC5rZXlzKHJlZ2lzdHJ5LnBsYXllcnMpLmxlbmd0aDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cdFBsYXllckxpc3QsXHJcblx0VXNlclBsYXllckxpc3QsXHJcblx0SW5mb1BsYXllckxpc3QsXHJcblx0Z2FtZVBvcHVsYXRpb24sXHJcblx0UG9wdWxhdGlvbixcclxuXHRJbmZvUG9wdWxhdGlvblxyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xyXG5cclxubG9nKFwiZGVidWdcIiwgXCJzdGF0ZTogQ3JlYXRpbmcgZ2FtZSBzdGF0ZSB2YXJpYWJsZXMuXCIpXHJcblxyXG5cclxudmFyIHJlZ2lzdHJ5ID0ge31cclxucmVnaXN0cnkuX2FkZFR5cGVfID0gZnVuY3Rpb24odHlwZSl7XHRcclxuXHRyZWdpc3RyeVt0eXBlXSA9IHt9O1xyXG5cdGxvZyhcInNpbGx5XCIsIFwic3RhdGU6IGFkZGluZyByZWdpc3RyeSBlbnRyeTogXCIsIHR5cGUpXHJcbn07XHJcblxyXG5cclxudmFyIGlkQ291bnRlcnMgPSB7fVxyXG5pZENvdW50ZXJzLl9hZGRUeXBlXyA9IGZ1bmN0aW9uKHR5cGUpe1xyXG5cdGlkQ291bnRlcnNbdHlwZV0gPSAwXHJcblx0bG9nKFwic2lsbHlcIiwgXCJzdGF0ZTogYWRkaW5nIGNvdW50ZXIgZW50cnk6IFwiLCB0eXBlKVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge3JlZ2lzdHJ5LCBpZENvdW50ZXJzfTsiLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmNvbnN0IG5hc2hOYW1lID0gXCIuL2NvcmVcIjtcdFx0XHRcdFx0XHQvL0NoYW5nZSB0aGlzIHdoZW4gcHVibGlzaGVkLCBwcm9iYWJseSB0byAnbmFzaC1qcydcclxuXHJcbnZhciBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcclxudmFyIGNvbXBpbGVyID0gcmVxdWlyZSgnZXhwcmVzc2lvbi1zYW5kYm94Jyk7XHJcblxyXG52YXIge3JlZ2lzdGVyU3RyYXRlZ3l9ID0gcmVxdWlyZSgnLi9zdHJhdGVneScpO1xyXG5cclxuLy9DaGVjayB0byBzZWUgaWYgcGFyc2VkIGV4cHJlc3Npb24gaXMgY2FsbCB0byByZXF1aXJlIG9yIGV2YWxcclxuZnVuY3Rpb24gaXNCYW5uZWRDYWxsKG5vZGUpIHtcclxuXHRyZXR1cm4gKG5vZGUudHlwZSA9PT0gJ0NhbGxFeHByZXNzaW9uJykgJiZcclxuXHRcdChub2RlLmNhbGxlZS50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicpICYmXHJcblx0XHQobm9kZS5jYWxsZWUub2JqZWN0LnR5cGUgPT09ICdJZGVudGlmaWVyJykgJiZcclxuXHRcdCgobm9kZS5jYWxsZWUub2JqZWN0Lm5hbWUgPT09ICdyZXF1aXJlJykgfHwgKG5vZGUuY2FsbGVlLm9iamVjdC5uYW1lID09PSAnZXZhbCcpKTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZUNhbGxzKHNvdXJjZSkge1xyXG5cdFx0Y29uc3QgZW50cmllcyA9IFtdO1xyXG5cdFx0ZXNwcmltYS5wYXJzZVNjcmlwdChzb3VyY2UsIHt9LCBmdW5jdGlvbiAobm9kZSwgbWV0YSkge1xyXG5cdFx0XHRpZiAoaXNCYW5uZWRDYWxsKG5vZGUpKSB7XHJcblx0XHRcdFx0ZW50cmllcy5wdXNoKHtcclxuXHRcdFx0XHRcdHN0YXJ0OiBtZXRhLnN0YXJ0Lm9mZnNldCxcclxuXHRcdFx0XHRcdGVuZDogbWV0YS5lbmQub2Zmc2V0XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0ZW50cmllcy5zb3J0KChhLCBiKSA9PiB7IHJldHVybiBiLmVuZCAtIGEuZW5kIH0pLmZvckVhY2gobiA9PiB7XHJcblx0XHRcdHNvdXJjZSA9IHNvdXJjZS5zbGljZSgwLCBuLnN0YXJ0KSArXCIgbnVsbDsgXCIgKyBzb3VyY2Uuc2xpY2Uobi5lbmQpO1xyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4gc291cmNlO1xyXG5cdH1cclxuXHJcblxyXG5cdFxyXG52YXIgbG9hZFN0cmF0ZWd5ID0gZnVuY3Rpb24oZmlsZXBhdGgsIHRydXN0ZWQ9ZmFsc2Upe1xyXG5cdHZhciBzb3VyY2UgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZXBhdGgpO1xyXG5cdFxyXG5cdGlmICghdHJ1c3RlZCkge1xyXG5cdFx0dmFyIG9yaWdpbmFsU291cmNlID0gc291cmNlO1xyXG5cdFx0dmFyIHBhcnNlZFNvdXJjZSA9IHJlbW92ZUNhbGxzKHNvdXJjZSk7XHJcblx0XHJcblx0XHRpZiAob3JpZ2luYWxTb3VyY2UgIT0gcGFyc2VkU291cmNlKSB0aHJvdyBuZXcgRXJyb3IoXCJTdHJhdGVneSBcIiArIGZpbGVwYXRoICsgXCIgdXNlcyByZXF1aXJlIG9yIGV2YWwuXCIpO1xyXG5cdH1cclxuXHRcclxuXHRzb3VyY2UgPSBcIlxcXCJ1c2Ugc3RyaWN0XFxcIjsgXFxuIFwiICsgc291cmNlO1xyXG5cdGNvbXBpbGVyKHNvdXJjZSkocmVnaXN0ZXJTdHJhdGVneSk7XHJcbn07XHRcdFx0XHRcdC8vVE9ETzogY2hhbmdlIHRoaXMgc28gdGhhdCBzdHJhdGVnaWVzIGNhbid0IHJlcXVpcmUgYW55IG1vZHVsZXMuXHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIGxvYWRTdHJhdGVneUZvbGRlcihwYXRoPVwiLi9zdHJhdGVnaWVzXCIpe1xyXG5cdHZhciBmaWxlcyA9IGZzLnJlYWRkaXJTeW5jKHBhdGgpO1xyXG5cdHZhciBzdHJhdGVnaWVzID0ge31cclxuXHRmaWxlcy5mb3JFYWNoKGZ1bmN0aW9uKGZpbGUpe1xyXG5cdFx0dmFyIGZpbGVQYXRoID0gcGF0aCArICcvJyArIGZpbGU7XHJcblx0XHRyZXF1aXJlRnVuY3Rpb24oZmlsZXBhdGgpO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge2xvYWRTdHJhdGVneSwgbG9hZFN0cmF0ZWd5Rm9sZGVyfTsiLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xyXG5cclxuLy9KYXZhc2NyaXB0IGNvZGUgcGFyc2VyXHJcbnZhciBlc3ByaW1hID0gcmVxdWlyZSgnZXNwcmltYScpO1xyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7cmVnaXN0cnl9ID0gcmVxdWlyZSgnLi9zdGF0ZScpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7aWRIYW5kbGVyfSA9IHJlcXVpcmUoJy4vaGVscGVyRnVuY3Rpb25zJykoXCJzdGF0ZVwiKTtcclxuXHJcblxyXG5cclxuLy9Vc2VyIGludGVyZmFjZSB0byBkZWNsYXJlIHN0cmF0ZWd5IHR5cGUuXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyU3RyYXRlZ3koc3RyYXRlZ3ksIG5hbWUsIHBsYXllcm5hbWUgPSBcIlwiKXtcclxuXHR2YXIgaWQgPSBpZEhhbmRsZXIobmFtZSxcInN0cmF0ZWd5XCIpO1xyXG5cdFxyXG5cdGxvZyhcImRlYnVnXCIsIFwiTG9hZGluZyBzdHJhdGVneSAnXCIgKyBpZCArIFwiJ1wiKVxyXG5cdHJlZ2lzdHJ5LnN0cmF0ZWdpZXNbaWRdID0gc3RyYXRlZ3k7XHJcbn1cclxuXHJcbi8vU3RyaXAgb3V0IHJlcXVpcmVzIGFuZCBzdWNoXHJcbmZ1bmN0aW9uIHNhbml0aXplU3RyYXRlZ3koc3RyYXRlZ3kpe1xyXG5cdC8vIGNvbnNvbGUubG9nKHgpIG9yIGNvbnNvbGVbJ2Vycm9yJ10oeSlcclxuXHRmdW5jdGlvbiBpc1JlcXVpcmVDYWxsKG5vZGUpIHtcclxuXHRcdHJldHVybiAobm9kZS50eXBlID09PSAnQ2FsbEV4cHJlc3Npb24nKSAmJlxyXG5cdFx0XHQobm9kZS5jYWxsZWUudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nKSAmJlxyXG5cdFx0XHQobm9kZS5jYWxsZWUub2JqZWN0LnR5cGUgPT09ICdJZGVudGlmaWVyJykgJiZcclxuXHRcdFx0KG5vZGUuY2FsbGVlLm9iamVjdC5uYW1lID09PSAncmVxdWlyZScpO1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiByZW1vdmVDYWxscyhzb3VyY2UpIHtcclxuXHRcdGNvbnN0IGVudHJpZXMgPSBbXTtcclxuXHRcdGVzcHJpbWEucGFyc2VTY3JpcHQoc291cmNlLCB7fSwgZnVuY3Rpb24gKG5vZGUsIG1ldGEpIHtcclxuXHRcdFx0aWYgKGlzUmVxdWlyZUNhbGwobm9kZSkpIHtcclxuXHRcdFx0XHRlbnRyaWVzLnB1c2goe1xyXG5cdFx0XHRcdFx0c3RhcnQ6IG1ldGEuc3RhcnQub2Zmc2V0LFxyXG5cdFx0XHRcdFx0ZW5kOiBtZXRhLmVuZC5vZmZzZXRcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRlbnRyaWVzLnNvcnQoKGEsIGIpID0+IHsgcmV0dXJuIGIuZW5kIC0gYS5lbmQgfSkuZm9yRWFjaChuID0+IHtcclxuXHRcdFx0c291cmNlID0gc291cmNlLnNsaWNlKDAsIG4uc3RhcnQpICsgc291cmNlLnNsaWNlKG4uZW5kKTtcclxuXHRcdH0pO1xyXG5cdFx0cmV0dXJuIHNvdXJjZTtcclxuXHR9XHJcblx0XHJcblx0cmVtb3ZlQ2FsbHMoc3RyYXRlZ3kudG9TdHJpbmcoKSk7XHJcblxyXG59XHJcblxyXG4vL1JldHVybnMgdG8gdGhlIHVzZXIgYW4gYXJyYXkgb2YgYWxsIHJlZ2lzdGVyZWQgc3RyYXRlZ2llcy4gVE9ETzogaGF2ZSB0aGlzIG1pcnJvciBQbGF5ZXJMaXN0LCB0byBwcm92aWRlIGZ1bmN0aW9uYWxpdHkgbGlrZSBvbmx5QWxpdmUgYW5kIHNjb3Jlc09iamVjdC5cclxuZnVuY3Rpb24gU3RyYXRlZ2llcygpe1xyXG5cdHZhciBzdHJhdGVnaWVzID0gW107XHJcblx0Zm9yICh2YXIgc3RyYXRlZ3kgaW4gcmVnaXN0cnkuc3RyYXRlZ2llcykgc3RyYXRlZ2llcy5wdXNoKHN0cmF0ZWd5KTtcclxuXHRyZXR1cm4gc3RyYXRlZ2llcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge3JlZ2lzdGVyU3RyYXRlZ3ksIFN0cmF0ZWdpZXN9OyIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gL1tcXHUwMDFiXFx1MDA5Yl1bWygpIzs/XSooPzpbMC05XXsxLDR9KD86O1swLTldezAsNH0pKik/WzAtOUEtUFJaY2YtbnFyeT0+PF0vZztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGFzc2VtYmxlU3R5bGVzICgpIHtcblx0dmFyIHN0eWxlcyA9IHtcblx0XHRtb2RpZmllcnM6IHtcblx0XHRcdHJlc2V0OiBbMCwgMF0sXG5cdFx0XHRib2xkOiBbMSwgMjJdLCAvLyAyMSBpc24ndCB3aWRlbHkgc3VwcG9ydGVkIGFuZCAyMiBkb2VzIHRoZSBzYW1lIHRoaW5nXG5cdFx0XHRkaW06IFsyLCAyMl0sXG5cdFx0XHRpdGFsaWM6IFszLCAyM10sXG5cdFx0XHR1bmRlcmxpbmU6IFs0LCAyNF0sXG5cdFx0XHRpbnZlcnNlOiBbNywgMjddLFxuXHRcdFx0aGlkZGVuOiBbOCwgMjhdLFxuXHRcdFx0c3RyaWtldGhyb3VnaDogWzksIDI5XVxuXHRcdH0sXG5cdFx0Y29sb3JzOiB7XG5cdFx0XHRibGFjazogWzMwLCAzOV0sXG5cdFx0XHRyZWQ6IFszMSwgMzldLFxuXHRcdFx0Z3JlZW46IFszMiwgMzldLFxuXHRcdFx0eWVsbG93OiBbMzMsIDM5XSxcblx0XHRcdGJsdWU6IFszNCwgMzldLFxuXHRcdFx0bWFnZW50YTogWzM1LCAzOV0sXG5cdFx0XHRjeWFuOiBbMzYsIDM5XSxcblx0XHRcdHdoaXRlOiBbMzcsIDM5XSxcblx0XHRcdGdyYXk6IFs5MCwgMzldXG5cdFx0fSxcblx0XHRiZ0NvbG9yczoge1xuXHRcdFx0YmdCbGFjazogWzQwLCA0OV0sXG5cdFx0XHRiZ1JlZDogWzQxLCA0OV0sXG5cdFx0XHRiZ0dyZWVuOiBbNDIsIDQ5XSxcblx0XHRcdGJnWWVsbG93OiBbNDMsIDQ5XSxcblx0XHRcdGJnQmx1ZTogWzQ0LCA0OV0sXG5cdFx0XHRiZ01hZ2VudGE6IFs0NSwgNDldLFxuXHRcdFx0YmdDeWFuOiBbNDYsIDQ5XSxcblx0XHRcdGJnV2hpdGU6IFs0NywgNDldXG5cdFx0fVxuXHR9O1xuXG5cdC8vIGZpeCBodW1hbnNcblx0c3R5bGVzLmNvbG9ycy5ncmV5ID0gc3R5bGVzLmNvbG9ycy5ncmF5O1xuXG5cdE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXBOYW1lKSB7XG5cdFx0dmFyIGdyb3VwID0gc3R5bGVzW2dyb3VwTmFtZV07XG5cblx0XHRPYmplY3Qua2V5cyhncm91cCkuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVOYW1lKSB7XG5cdFx0XHR2YXIgc3R5bGUgPSBncm91cFtzdHlsZU5hbWVdO1xuXG5cdFx0XHRzdHlsZXNbc3R5bGVOYW1lXSA9IGdyb3VwW3N0eWxlTmFtZV0gPSB7XG5cdFx0XHRcdG9wZW46ICdcXHUwMDFiWycgKyBzdHlsZVswXSArICdtJyxcblx0XHRcdFx0Y2xvc2U6ICdcXHUwMDFiWycgKyBzdHlsZVsxXSArICdtJ1xuXHRcdFx0fTtcblx0XHR9KTtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdHlsZXMsIGdyb3VwTmFtZSwge1xuXHRcdFx0dmFsdWU6IGdyb3VwLFxuXHRcdFx0ZW51bWVyYWJsZTogZmFsc2Vcblx0XHR9KTtcblx0fSk7XG5cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgJ2V4cG9ydHMnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogYXNzZW1ibGVTdHlsZXNcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGVzY2FwZVN0cmluZ1JlZ2V4cCA9IHJlcXVpcmUoJ2VzY2FwZS1zdHJpbmctcmVnZXhwJyk7XG52YXIgYW5zaVN0eWxlcyA9IHJlcXVpcmUoJ2Fuc2ktc3R5bGVzJyk7XG52YXIgc3RyaXBBbnNpID0gcmVxdWlyZSgnc3RyaXAtYW5zaScpO1xudmFyIGhhc0Fuc2kgPSByZXF1aXJlKCdoYXMtYW5zaScpO1xudmFyIHN1cHBvcnRzQ29sb3IgPSByZXF1aXJlKCdzdXBwb3J0cy1jb2xvcicpO1xudmFyIGRlZmluZVByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgaXNTaW1wbGVXaW5kb3dzVGVybSA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgJiYgIS9eeHRlcm0vaS50ZXN0KHByb2Nlc3MuZW52LlRFUk0pO1xuXG5mdW5jdGlvbiBDaGFsayhvcHRpb25zKSB7XG5cdC8vIGRldGVjdCBtb2RlIGlmIG5vdCBzZXQgbWFudWFsbHlcblx0dGhpcy5lbmFibGVkID0gIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmFibGVkID09PSB1bmRlZmluZWQgPyBzdXBwb3J0c0NvbG9yIDogb3B0aW9ucy5lbmFibGVkO1xufVxuXG4vLyB1c2UgYnJpZ2h0IGJsdWUgb24gV2luZG93cyBhcyB0aGUgbm9ybWFsIGJsdWUgY29sb3IgaXMgaWxsZWdpYmxlXG5pZiAoaXNTaW1wbGVXaW5kb3dzVGVybSkge1xuXHRhbnNpU3R5bGVzLmJsdWUub3BlbiA9ICdcXHUwMDFiWzk0bSc7XG59XG5cbnZhciBzdHlsZXMgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgcmV0ID0ge307XG5cblx0T2JqZWN0LmtleXMoYW5zaVN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0YW5zaVN0eWxlc1trZXldLmNsb3NlUmUgPSBuZXcgUmVnRXhwKGVzY2FwZVN0cmluZ1JlZ2V4cChhbnNpU3R5bGVzW2tleV0uY2xvc2UpLCAnZycpO1xuXG5cdFx0cmV0W2tleV0gPSB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIGJ1aWxkLmNhbGwodGhpcywgdGhpcy5fc3R5bGVzLmNvbmNhdChrZXkpKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KTtcblxuXHRyZXR1cm4gcmV0O1xufSkoKTtcblxudmFyIHByb3RvID0gZGVmaW5lUHJvcHMoZnVuY3Rpb24gY2hhbGsoKSB7fSwgc3R5bGVzKTtcblxuZnVuY3Rpb24gYnVpbGQoX3N0eWxlcykge1xuXHR2YXIgYnVpbGRlciA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gYXBwbHlTdHlsZS5hcHBseShidWlsZGVyLCBhcmd1bWVudHMpO1xuXHR9O1xuXG5cdGJ1aWxkZXIuX3N0eWxlcyA9IF9zdHlsZXM7XG5cdGJ1aWxkZXIuZW5hYmxlZCA9IHRoaXMuZW5hYmxlZDtcblx0Ly8gX19wcm90b19fIGlzIHVzZWQgYmVjYXVzZSB3ZSBtdXN0IHJldHVybiBhIGZ1bmN0aW9uLCBidXQgdGhlcmUgaXNcblx0Ly8gbm8gd2F5IHRvIGNyZWF0ZSBhIGZ1bmN0aW9uIHdpdGggYSBkaWZmZXJlbnQgcHJvdG90eXBlLlxuXHQvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXHRidWlsZGVyLl9fcHJvdG9fXyA9IHByb3RvO1xuXG5cdHJldHVybiBidWlsZGVyO1xufVxuXG5mdW5jdGlvbiBhcHBseVN0eWxlKCkge1xuXHQvLyBzdXBwb3J0IHZhcmFncywgYnV0IHNpbXBseSBjYXN0IHRvIHN0cmluZyBpbiBjYXNlIHRoZXJlJ3Mgb25seSBvbmUgYXJnXG5cdHZhciBhcmdzID0gYXJndW1lbnRzO1xuXHR2YXIgYXJnc0xlbiA9IGFyZ3MubGVuZ3RoO1xuXHR2YXIgc3RyID0gYXJnc0xlbiAhPT0gMCAmJiBTdHJpbmcoYXJndW1lbnRzWzBdKTtcblxuXHRpZiAoYXJnc0xlbiA+IDEpIHtcblx0XHQvLyBkb24ndCBzbGljZSBgYXJndW1lbnRzYCwgaXQgcHJldmVudHMgdjggb3B0aW1pemF0aW9uc1xuXHRcdGZvciAodmFyIGEgPSAxOyBhIDwgYXJnc0xlbjsgYSsrKSB7XG5cdFx0XHRzdHIgKz0gJyAnICsgYXJnc1thXTtcblx0XHR9XG5cdH1cblxuXHRpZiAoIXRoaXMuZW5hYmxlZCB8fCAhc3RyKSB7XG5cdFx0cmV0dXJuIHN0cjtcblx0fVxuXG5cdHZhciBuZXN0ZWRTdHlsZXMgPSB0aGlzLl9zdHlsZXM7XG5cdHZhciBpID0gbmVzdGVkU3R5bGVzLmxlbmd0aDtcblxuXHQvLyBUdXJucyBvdXQgdGhhdCBvbiBXaW5kb3dzIGRpbW1lZCBncmF5IHRleHQgYmVjb21lcyBpbnZpc2libGUgaW4gY21kLmV4ZSxcblx0Ly8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFsay9jaGFsay9pc3N1ZXMvNThcblx0Ly8gSWYgd2UncmUgb24gV2luZG93cyBhbmQgd2UncmUgZGVhbGluZyB3aXRoIGEgZ3JheSBjb2xvciwgdGVtcG9yYXJpbHkgbWFrZSAnZGltJyBhIG5vb3AuXG5cdHZhciBvcmlnaW5hbERpbSA9IGFuc2lTdHlsZXMuZGltLm9wZW47XG5cdGlmIChpc1NpbXBsZVdpbmRvd3NUZXJtICYmIChuZXN0ZWRTdHlsZXMuaW5kZXhPZignZ3JheScpICE9PSAtMSB8fCBuZXN0ZWRTdHlsZXMuaW5kZXhPZignZ3JleScpICE9PSAtMSkpIHtcblx0XHRhbnNpU3R5bGVzLmRpbS5vcGVuID0gJyc7XG5cdH1cblxuXHR3aGlsZSAoaS0tKSB7XG5cdFx0dmFyIGNvZGUgPSBhbnNpU3R5bGVzW25lc3RlZFN0eWxlc1tpXV07XG5cblx0XHQvLyBSZXBsYWNlIGFueSBpbnN0YW5jZXMgYWxyZWFkeSBwcmVzZW50IHdpdGggYSByZS1vcGVuaW5nIGNvZGVcblx0XHQvLyBvdGhlcndpc2Ugb25seSB0aGUgcGFydCBvZiB0aGUgc3RyaW5nIHVudGlsIHNhaWQgY2xvc2luZyBjb2RlXG5cdFx0Ly8gd2lsbCBiZSBjb2xvcmVkLCBhbmQgdGhlIHJlc3Qgd2lsbCBzaW1wbHkgYmUgJ3BsYWluJy5cblx0XHRzdHIgPSBjb2RlLm9wZW4gKyBzdHIucmVwbGFjZShjb2RlLmNsb3NlUmUsIGNvZGUub3BlbikgKyBjb2RlLmNsb3NlO1xuXHR9XG5cblx0Ly8gUmVzZXQgdGhlIG9yaWdpbmFsICdkaW0nIGlmIHdlIGNoYW5nZWQgaXQgdG8gd29yayBhcm91bmQgdGhlIFdpbmRvd3MgZGltbWVkIGdyYXkgaXNzdWUuXG5cdGFuc2lTdHlsZXMuZGltLm9wZW4gPSBvcmlnaW5hbERpbTtcblxuXHRyZXR1cm4gc3RyO1xufVxuXG5mdW5jdGlvbiBpbml0KCkge1xuXHR2YXIgcmV0ID0ge307XG5cblx0T2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0cmV0W25hbWVdID0ge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBidWlsZC5jYWxsKHRoaXMsIFtuYW1lXSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSk7XG5cblx0cmV0dXJuIHJldDtcbn1cblxuZGVmaW5lUHJvcHMoQ2hhbGsucHJvdG90eXBlLCBpbml0KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBDaGFsaygpO1xubW9kdWxlLmV4cG9ydHMuc3R5bGVzID0gYW5zaVN0eWxlcztcbm1vZHVsZS5leHBvcnRzLmhhc0NvbG9yID0gaGFzQW5zaTtcbm1vZHVsZS5leHBvcnRzLnN0cmlwQ29sb3IgPSBzdHJpcEFuc2k7XG5tb2R1bGUuZXhwb3J0cy5zdXBwb3J0c0NvbG9yID0gc3VwcG9ydHNDb2xvcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhcmd2ID0gcHJvY2Vzcy5hcmd2O1xuXG52YXIgdGVybWluYXRvciA9IGFyZ3YuaW5kZXhPZignLS0nKTtcbnZhciBoYXNGbGFnID0gZnVuY3Rpb24gKGZsYWcpIHtcblx0ZmxhZyA9ICctLScgKyBmbGFnO1xuXHR2YXIgcG9zID0gYXJndi5pbmRleE9mKGZsYWcpO1xuXHRyZXR1cm4gcG9zICE9PSAtMSAmJiAodGVybWluYXRvciAhPT0gLTEgPyBwb3MgPCB0ZXJtaW5hdG9yIDogdHJ1ZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG5cdGlmICgnRk9SQ0VfQ09MT1InIGluIHByb2Nlc3MuZW52KSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoaGFzRmxhZygnbm8tY29sb3InKSB8fFxuXHRcdGhhc0ZsYWcoJ25vLWNvbG9ycycpIHx8XG5cdFx0aGFzRmxhZygnY29sb3I9ZmFsc2UnKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmIChoYXNGbGFnKCdjb2xvcicpIHx8XG5cdFx0aGFzRmxhZygnY29sb3JzJykgfHxcblx0XHRoYXNGbGFnKCdjb2xvcj10cnVlJykgfHxcblx0XHRoYXNGbGFnKCdjb2xvcj1hbHdheXMnKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKHByb2Nlc3Muc3Rkb3V0ICYmICFwcm9jZXNzLnN0ZG91dC5pc1RUWSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoJ0NPTE9SVEVSTScgaW4gcHJvY2Vzcy5lbnYpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmIChwcm9jZXNzLmVudi5URVJNID09PSAnZHVtYicpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAoL15zY3JlZW58Xnh0ZXJtfF52dDEwMHxjb2xvcnxhbnNpfGN5Z3dpbnxsaW51eC9pLnRlc3QocHJvY2Vzcy5lbnYuVEVSTSkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn0pKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBtYXRjaE9wZXJhdG9yc1JlID0gL1t8XFxcXHt9KClbXFxdXiQrKj8uXS9nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0aWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcnKTtcblx0fVxuXG5cdHJldHVybiBzdHIucmVwbGFjZShtYXRjaE9wZXJhdG9yc1JlLCAnXFxcXCQmJyk7XG59O1xuIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJlc3ByaW1hXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImVzcHJpbWFcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG5cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG5cblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHQvKlxyXG5cdCAgQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycywgaHR0cHM6Ly9qcy5mb3VuZGF0aW9uL1xyXG5cclxuXHQgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxyXG5cdCAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcblxyXG5cdCAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XHJcblx0ICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG5cdCAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XHJcblx0ICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxyXG5cdCAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcblxyXG5cdCAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcclxuXHQgIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcclxuXHQgIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXHJcblx0ICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXHJcblx0ICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xyXG5cdCAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xyXG5cdCAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXHJcblx0ICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxyXG5cdCAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXHJcblx0ICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG5cdCovXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdHZhciBjb21tZW50X2hhbmRsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcblx0dmFyIGpzeF9wYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcblx0dmFyIHBhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcclxuXHR2YXIgdG9rZW5pemVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcclxuXHRmdW5jdGlvbiBwYXJzZShjb2RlLCBvcHRpb25zLCBkZWxlZ2F0ZSkge1xyXG5cdCAgICB2YXIgY29tbWVudEhhbmRsZXIgPSBudWxsO1xyXG5cdCAgICB2YXIgcHJveHlEZWxlZ2F0ZSA9IGZ1bmN0aW9uIChub2RlLCBtZXRhZGF0YSkge1xyXG5cdCAgICAgICAgaWYgKGRlbGVnYXRlKSB7XHJcblx0ICAgICAgICAgICAgZGVsZWdhdGUobm9kZSwgbWV0YWRhdGEpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKGNvbW1lbnRIYW5kbGVyKSB7XHJcblx0ICAgICAgICAgICAgY29tbWVudEhhbmRsZXIudmlzaXQobm9kZSwgbWV0YWRhdGEpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICB2YXIgcGFyc2VyRGVsZWdhdGUgPSAodHlwZW9mIGRlbGVnYXRlID09PSAnZnVuY3Rpb24nKSA/IHByb3h5RGVsZWdhdGUgOiBudWxsO1xyXG5cdCAgICB2YXIgY29sbGVjdENvbW1lbnQgPSBmYWxzZTtcclxuXHQgICAgaWYgKG9wdGlvbnMpIHtcclxuXHQgICAgICAgIGNvbGxlY3RDb21tZW50ID0gKHR5cGVvZiBvcHRpb25zLmNvbW1lbnQgPT09ICdib29sZWFuJyAmJiBvcHRpb25zLmNvbW1lbnQpO1xyXG5cdCAgICAgICAgdmFyIGF0dGFjaENvbW1lbnQgPSAodHlwZW9mIG9wdGlvbnMuYXR0YWNoQ29tbWVudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMuYXR0YWNoQ29tbWVudCk7XHJcblx0ICAgICAgICBpZiAoY29sbGVjdENvbW1lbnQgfHwgYXR0YWNoQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgIGNvbW1lbnRIYW5kbGVyID0gbmV3IGNvbW1lbnRfaGFuZGxlcl8xLkNvbW1lbnRIYW5kbGVyKCk7XHJcblx0ICAgICAgICAgICAgY29tbWVudEhhbmRsZXIuYXR0YWNoID0gYXR0YWNoQ29tbWVudDtcclxuXHQgICAgICAgICAgICBvcHRpb25zLmNvbW1lbnQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIHBhcnNlckRlbGVnYXRlID0gcHJveHlEZWxlZ2F0ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgICB2YXIgaXNNb2R1bGUgPSBmYWxzZTtcclxuXHQgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuc291cmNlVHlwZSA9PT0gJ3N0cmluZycpIHtcclxuXHQgICAgICAgIGlzTW9kdWxlID0gKG9wdGlvbnMuc291cmNlVHlwZSA9PT0gJ21vZHVsZScpO1xyXG5cdCAgICB9XHJcblx0ICAgIHZhciBwYXJzZXI7XHJcblx0ICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLmpzeCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMuanN4KSB7XHJcblx0ICAgICAgICBwYXJzZXIgPSBuZXcganN4X3BhcnNlcl8xLkpTWFBhcnNlcihjb2RlLCBvcHRpb25zLCBwYXJzZXJEZWxlZ2F0ZSk7XHJcblx0ICAgIH1cclxuXHQgICAgZWxzZSB7XHJcblx0ICAgICAgICBwYXJzZXIgPSBuZXcgcGFyc2VyXzEuUGFyc2VyKGNvZGUsIG9wdGlvbnMsIHBhcnNlckRlbGVnYXRlKTtcclxuXHQgICAgfVxyXG5cdCAgICB2YXIgcHJvZ3JhbSA9IGlzTW9kdWxlID8gcGFyc2VyLnBhcnNlTW9kdWxlKCkgOiBwYXJzZXIucGFyc2VTY3JpcHQoKTtcclxuXHQgICAgdmFyIGFzdCA9IHByb2dyYW07XHJcblx0ICAgIGlmIChjb2xsZWN0Q29tbWVudCAmJiBjb21tZW50SGFuZGxlcikge1xyXG5cdCAgICAgICAgYXN0LmNvbW1lbnRzID0gY29tbWVudEhhbmRsZXIuY29tbWVudHM7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKHBhcnNlci5jb25maWcudG9rZW5zKSB7XHJcblx0ICAgICAgICBhc3QudG9rZW5zID0gcGFyc2VyLnRva2VucztcclxuXHQgICAgfVxyXG5cdCAgICBpZiAocGFyc2VyLmNvbmZpZy50b2xlcmFudCkge1xyXG5cdCAgICAgICAgYXN0LmVycm9ycyA9IHBhcnNlci5lcnJvckhhbmRsZXIuZXJyb3JzO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBhc3Q7XHJcblx0fVxyXG5cdGV4cG9ydHMucGFyc2UgPSBwYXJzZTtcclxuXHRmdW5jdGlvbiBwYXJzZU1vZHVsZShjb2RlLCBvcHRpb25zLCBkZWxlZ2F0ZSkge1xyXG5cdCAgICB2YXIgcGFyc2luZ09wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdCAgICBwYXJzaW5nT3B0aW9ucy5zb3VyY2VUeXBlID0gJ21vZHVsZSc7XHJcblx0ICAgIHJldHVybiBwYXJzZShjb2RlLCBwYXJzaW5nT3B0aW9ucywgZGVsZWdhdGUpO1xyXG5cdH1cclxuXHRleHBvcnRzLnBhcnNlTW9kdWxlID0gcGFyc2VNb2R1bGU7XHJcblx0ZnVuY3Rpb24gcGFyc2VTY3JpcHQoY29kZSwgb3B0aW9ucywgZGVsZWdhdGUpIHtcclxuXHQgICAgdmFyIHBhcnNpbmdPcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHQgICAgcGFyc2luZ09wdGlvbnMuc291cmNlVHlwZSA9ICdzY3JpcHQnO1xyXG5cdCAgICByZXR1cm4gcGFyc2UoY29kZSwgcGFyc2luZ09wdGlvbnMsIGRlbGVnYXRlKTtcclxuXHR9XHJcblx0ZXhwb3J0cy5wYXJzZVNjcmlwdCA9IHBhcnNlU2NyaXB0O1xyXG5cdGZ1bmN0aW9uIHRva2VuaXplKGNvZGUsIG9wdGlvbnMsIGRlbGVnYXRlKSB7XHJcblx0ICAgIHZhciB0b2tlbml6ZXIgPSBuZXcgdG9rZW5pemVyXzEuVG9rZW5pemVyKGNvZGUsIG9wdGlvbnMpO1xyXG5cdCAgICB2YXIgdG9rZW5zO1xyXG5cdCAgICB0b2tlbnMgPSBbXTtcclxuXHQgICAgdHJ5IHtcclxuXHQgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5pemVyLmdldE5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGlmICghdG9rZW4pIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmIChkZWxlZ2F0ZSkge1xyXG5cdCAgICAgICAgICAgICAgICB0b2tlbiA9IGRlbGVnYXRlKHRva2VuKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICAgIGNhdGNoIChlKSB7XHJcblx0ICAgICAgICB0b2tlbml6ZXIuZXJyb3JIYW5kbGVyLnRvbGVyYXRlKGUpO1xyXG5cdCAgICB9XHJcblx0ICAgIGlmICh0b2tlbml6ZXIuZXJyb3JIYW5kbGVyLnRvbGVyYW50KSB7XHJcblx0ICAgICAgICB0b2tlbnMuZXJyb3JzID0gdG9rZW5pemVyLmVycm9ycygpO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiB0b2tlbnM7XHJcblx0fVxyXG5cdGV4cG9ydHMudG9rZW5pemUgPSB0b2tlbml6ZTtcclxuXHR2YXIgc3ludGF4XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cdGV4cG9ydHMuU3ludGF4ID0gc3ludGF4XzEuU3ludGF4O1xyXG5cdC8vIFN5bmMgd2l0aCAqLmpzb24gbWFuaWZlc3RzLlxyXG5cdGV4cG9ydHMudmVyc2lvbiA9ICc0LjAuMCc7XHJcblxuXG4vKioqLyB9LFxuLyogMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdHZhciBzeW50YXhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblx0dmFyIENvbW1lbnRIYW5kbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQ29tbWVudEhhbmRsZXIoKSB7XHJcblx0ICAgICAgICB0aGlzLmF0dGFjaCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5jb21tZW50cyA9IFtdO1xyXG5cdCAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xyXG5cdCAgICAgICAgdGhpcy5sZWFkaW5nID0gW107XHJcblx0ICAgICAgICB0aGlzLnRyYWlsaW5nID0gW107XHJcblx0ICAgIH1cclxuXHQgICAgQ29tbWVudEhhbmRsZXIucHJvdG90eXBlLmluc2VydElubmVyQ29tbWVudHMgPSBmdW5jdGlvbiAobm9kZSwgbWV0YWRhdGEpIHtcclxuXHQgICAgICAgIC8vICBpbm5uZXJDb21tZW50cyBmb3IgcHJvcGVydGllcyBlbXB0eSBibG9ja1xyXG5cdCAgICAgICAgLy8gIGBmdW5jdGlvbiBhKCkgey8qKiBjb21tZW50cyAqKlxcL31gXHJcblx0ICAgICAgICBpZiAobm9kZS50eXBlID09PSBzeW50YXhfMS5TeW50YXguQmxvY2tTdGF0ZW1lbnQgJiYgbm9kZS5ib2R5Lmxlbmd0aCA9PT0gMCkge1xyXG5cdCAgICAgICAgICAgIHZhciBpbm5lckNvbW1lbnRzID0gW107XHJcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMubGVhZGluZy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmxlYWRpbmdbaV07XHJcblx0ICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YS5lbmQub2Zmc2V0ID49IGVudHJ5LnN0YXJ0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbm5lckNvbW1lbnRzLnVuc2hpZnQoZW50cnkuY29tbWVudCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmxlYWRpbmcuc3BsaWNlKGksIDEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFpbGluZy5zcGxpY2UoaSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKGlubmVyQ29tbWVudHMubGVuZ3RoKSB7XHJcblx0ICAgICAgICAgICAgICAgIG5vZGUuaW5uZXJDb21tZW50cyA9IGlubmVyQ29tbWVudHM7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBDb21tZW50SGFuZGxlci5wcm90b3R5cGUuZmluZFRyYWlsaW5nQ29tbWVudHMgPSBmdW5jdGlvbiAobWV0YWRhdGEpIHtcclxuXHQgICAgICAgIHZhciB0cmFpbGluZ0NvbW1lbnRzID0gW107XHJcblx0ICAgICAgICBpZiAodGhpcy50cmFpbGluZy5sZW5ndGggPiAwKSB7XHJcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJhaWxpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGVudHJ5XzEgPSB0aGlzLnRyYWlsaW5nW2ldO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoZW50cnlfMS5zdGFydCA+PSBtZXRhZGF0YS5lbmQub2Zmc2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ0NvbW1lbnRzLnVuc2hpZnQoZW50cnlfMS5jb21tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLnRyYWlsaW5nLmxlbmd0aCA9IDA7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRyYWlsaW5nQ29tbWVudHM7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XHJcblx0ICAgICAgICBpZiAoZW50cnkgJiYgZW50cnkubm9kZS50cmFpbGluZ0NvbW1lbnRzKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGZpcnN0Q29tbWVudCA9IGVudHJ5Lm5vZGUudHJhaWxpbmdDb21tZW50c1swXTtcclxuXHQgICAgICAgICAgICBpZiAoZmlyc3RDb21tZW50ICYmIGZpcnN0Q29tbWVudC5yYW5nZVswXSA+PSBtZXRhZGF0YS5lbmQub2Zmc2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgIHRyYWlsaW5nQ29tbWVudHMgPSBlbnRyeS5ub2RlLnRyYWlsaW5nQ29tbWVudHM7XHJcblx0ICAgICAgICAgICAgICAgIGRlbGV0ZSBlbnRyeS5ub2RlLnRyYWlsaW5nQ29tbWVudHM7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRyYWlsaW5nQ29tbWVudHM7XHJcblx0ICAgIH07XHJcblx0ICAgIENvbW1lbnRIYW5kbGVyLnByb3RvdHlwZS5maW5kTGVhZGluZ0NvbW1lbnRzID0gZnVuY3Rpb24gKG1ldGFkYXRhKSB7XHJcblx0ICAgICAgICB2YXIgbGVhZGluZ0NvbW1lbnRzID0gW107XHJcblx0ICAgICAgICB2YXIgdGFyZ2V0O1xyXG5cdCAgICAgICAgd2hpbGUgKHRoaXMuc3RhY2subGVuZ3RoID4gMCkge1xyXG5cdCAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcclxuXHQgICAgICAgICAgICBpZiAoZW50cnkgJiYgZW50cnkuc3RhcnQgPj0gbWV0YWRhdGEuc3RhcnQub2Zmc2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgIHRhcmdldCA9IGVudHJ5Lm5vZGU7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGFyZ2V0KSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNvdW50ID0gdGFyZ2V0LmxlYWRpbmdDb21tZW50cyA/IHRhcmdldC5sZWFkaW5nQ29tbWVudHMubGVuZ3RoIDogMDtcclxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gY291bnQgLSAxOyBpID49IDA7IC0taSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IHRhcmdldC5sZWFkaW5nQ29tbWVudHNbaV07XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjb21tZW50LnJhbmdlWzFdIDw9IG1ldGFkYXRhLnN0YXJ0Lm9mZnNldCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGVhZGluZ0NvbW1lbnRzLnVuc2hpZnQoY29tbWVudCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0YXJnZXQubGVhZGluZ0NvbW1lbnRzLnNwbGljZShpLCAxKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAodGFyZ2V0LmxlYWRpbmdDb21tZW50cyAmJiB0YXJnZXQubGVhZGluZ0NvbW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG5cdCAgICAgICAgICAgICAgICBkZWxldGUgdGFyZ2V0LmxlYWRpbmdDb21tZW50cztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgcmV0dXJuIGxlYWRpbmdDb21tZW50cztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmxlYWRpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuXHQgICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmxlYWRpbmdbaV07XHJcblx0ICAgICAgICAgICAgaWYgKGVudHJ5LnN0YXJ0IDw9IG1ldGFkYXRhLnN0YXJ0Lm9mZnNldCkge1xyXG5cdCAgICAgICAgICAgICAgICBsZWFkaW5nQ29tbWVudHMudW5zaGlmdChlbnRyeS5jb21tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5sZWFkaW5nLnNwbGljZShpLCAxKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gbGVhZGluZ0NvbW1lbnRzO1xyXG5cdCAgICB9O1xyXG5cdCAgICBDb21tZW50SGFuZGxlci5wcm90b3R5cGUudmlzaXROb2RlID0gZnVuY3Rpb24gKG5vZGUsIG1ldGFkYXRhKSB7XHJcblx0ICAgICAgICBpZiAobm9kZS50eXBlID09PSBzeW50YXhfMS5TeW50YXguUHJvZ3JhbSAmJiBub2RlLmJvZHkubGVuZ3RoID4gMCkge1xyXG5cdCAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuaW5zZXJ0SW5uZXJDb21tZW50cyhub2RlLCBtZXRhZGF0YSk7XHJcblx0ICAgICAgICB2YXIgdHJhaWxpbmdDb21tZW50cyA9IHRoaXMuZmluZFRyYWlsaW5nQ29tbWVudHMobWV0YWRhdGEpO1xyXG5cdCAgICAgICAgdmFyIGxlYWRpbmdDb21tZW50cyA9IHRoaXMuZmluZExlYWRpbmdDb21tZW50cyhtZXRhZGF0YSk7XHJcblx0ICAgICAgICBpZiAobGVhZGluZ0NvbW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHQgICAgICAgICAgICBub2RlLmxlYWRpbmdDb21tZW50cyA9IGxlYWRpbmdDb21tZW50cztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0cmFpbGluZ0NvbW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHQgICAgICAgICAgICBub2RlLnRyYWlsaW5nQ29tbWVudHMgPSB0cmFpbGluZ0NvbW1lbnRzO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5zdGFjay5wdXNoKHtcclxuXHQgICAgICAgICAgICBub2RlOiBub2RlLFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBtZXRhZGF0YS5zdGFydC5vZmZzZXRcclxuXHQgICAgICAgIH0pO1xyXG5cdCAgICB9O1xyXG5cdCAgICBDb21tZW50SGFuZGxlci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKG5vZGUsIG1ldGFkYXRhKSB7XHJcblx0ICAgICAgICB2YXIgdHlwZSA9IChub2RlLnR5cGVbMF0gPT09ICdMJykgPyAnTGluZScgOiAnQmxvY2snO1xyXG5cdCAgICAgICAgdmFyIGNvbW1lbnQgPSB7XHJcblx0ICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuXHQgICAgICAgICAgICB2YWx1ZTogbm9kZS52YWx1ZVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIGlmIChub2RlLnJhbmdlKSB7XHJcblx0ICAgICAgICAgICAgY29tbWVudC5yYW5nZSA9IG5vZGUucmFuZ2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAobm9kZS5sb2MpIHtcclxuXHQgICAgICAgICAgICBjb21tZW50LmxvYyA9IG5vZGUubG9jO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5jb21tZW50cy5wdXNoKGNvbW1lbnQpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuYXR0YWNoKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGVudHJ5ID0ge1xyXG5cdCAgICAgICAgICAgICAgICBjb21tZW50OiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5vZGUudmFsdWUsXHJcblx0ICAgICAgICAgICAgICAgICAgICByYW5nZTogW21ldGFkYXRhLnN0YXJ0Lm9mZnNldCwgbWV0YWRhdGEuZW5kLm9mZnNldF1cclxuXHQgICAgICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IG1ldGFkYXRhLnN0YXJ0Lm9mZnNldFxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgaWYgKG5vZGUubG9jKSB7XHJcblx0ICAgICAgICAgICAgICAgIGVudHJ5LmNvbW1lbnQubG9jID0gbm9kZS5sb2M7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIG5vZGUudHlwZSA9IHR5cGU7XHJcblx0ICAgICAgICAgICAgdGhpcy5sZWFkaW5nLnB1c2goZW50cnkpO1xyXG5cdCAgICAgICAgICAgIHRoaXMudHJhaWxpbmcucHVzaChlbnRyeSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIENvbW1lbnRIYW5kbGVyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uIChub2RlLCBtZXRhZGF0YSkge1xyXG5cdCAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ0xpbmVDb21tZW50Jykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudmlzaXRDb21tZW50KG5vZGUsIG1ldGFkYXRhKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ0Jsb2NrQ29tbWVudCcpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnZpc2l0Q29tbWVudChub2RlLCBtZXRhZGF0YSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0aGlzLmF0dGFjaCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudmlzaXROb2RlKG5vZGUsIG1ldGFkYXRhKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgcmV0dXJuIENvbW1lbnRIYW5kbGVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Db21tZW50SGFuZGxlciA9IENvbW1lbnRIYW5kbGVyO1xyXG5cblxuLyoqKi8gfSxcbi8qIDIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHRleHBvcnRzLlN5bnRheCA9IHtcclxuXHQgICAgQXNzaWdubWVudEV4cHJlc3Npb246ICdBc3NpZ25tZW50RXhwcmVzc2lvbicsXHJcblx0ICAgIEFzc2lnbm1lbnRQYXR0ZXJuOiAnQXNzaWdubWVudFBhdHRlcm4nLFxyXG5cdCAgICBBcnJheUV4cHJlc3Npb246ICdBcnJheUV4cHJlc3Npb24nLFxyXG5cdCAgICBBcnJheVBhdHRlcm46ICdBcnJheVBhdHRlcm4nLFxyXG5cdCAgICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjogJ0Fycm93RnVuY3Rpb25FeHByZXNzaW9uJyxcclxuXHQgICAgQXdhaXRFeHByZXNzaW9uOiAnQXdhaXRFeHByZXNzaW9uJyxcclxuXHQgICAgQmxvY2tTdGF0ZW1lbnQ6ICdCbG9ja1N0YXRlbWVudCcsXHJcblx0ICAgIEJpbmFyeUV4cHJlc3Npb246ICdCaW5hcnlFeHByZXNzaW9uJyxcclxuXHQgICAgQnJlYWtTdGF0ZW1lbnQ6ICdCcmVha1N0YXRlbWVudCcsXHJcblx0ICAgIENhbGxFeHByZXNzaW9uOiAnQ2FsbEV4cHJlc3Npb24nLFxyXG5cdCAgICBDYXRjaENsYXVzZTogJ0NhdGNoQ2xhdXNlJyxcclxuXHQgICAgQ2xhc3NCb2R5OiAnQ2xhc3NCb2R5JyxcclxuXHQgICAgQ2xhc3NEZWNsYXJhdGlvbjogJ0NsYXNzRGVjbGFyYXRpb24nLFxyXG5cdCAgICBDbGFzc0V4cHJlc3Npb246ICdDbGFzc0V4cHJlc3Npb24nLFxyXG5cdCAgICBDb25kaXRpb25hbEV4cHJlc3Npb246ICdDb25kaXRpb25hbEV4cHJlc3Npb24nLFxyXG5cdCAgICBDb250aW51ZVN0YXRlbWVudDogJ0NvbnRpbnVlU3RhdGVtZW50JyxcclxuXHQgICAgRG9XaGlsZVN0YXRlbWVudDogJ0RvV2hpbGVTdGF0ZW1lbnQnLFxyXG5cdCAgICBEZWJ1Z2dlclN0YXRlbWVudDogJ0RlYnVnZ2VyU3RhdGVtZW50JyxcclxuXHQgICAgRW1wdHlTdGF0ZW1lbnQ6ICdFbXB0eVN0YXRlbWVudCcsXHJcblx0ICAgIEV4cG9ydEFsbERlY2xhcmF0aW9uOiAnRXhwb3J0QWxsRGVjbGFyYXRpb24nLFxyXG5cdCAgICBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb246ICdFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24nLFxyXG5cdCAgICBFeHBvcnROYW1lZERlY2xhcmF0aW9uOiAnRXhwb3J0TmFtZWREZWNsYXJhdGlvbicsXHJcblx0ICAgIEV4cG9ydFNwZWNpZmllcjogJ0V4cG9ydFNwZWNpZmllcicsXHJcblx0ICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQ6ICdFeHByZXNzaW9uU3RhdGVtZW50JyxcclxuXHQgICAgRm9yU3RhdGVtZW50OiAnRm9yU3RhdGVtZW50JyxcclxuXHQgICAgRm9yT2ZTdGF0ZW1lbnQ6ICdGb3JPZlN0YXRlbWVudCcsXHJcblx0ICAgIEZvckluU3RhdGVtZW50OiAnRm9ySW5TdGF0ZW1lbnQnLFxyXG5cdCAgICBGdW5jdGlvbkRlY2xhcmF0aW9uOiAnRnVuY3Rpb25EZWNsYXJhdGlvbicsXHJcblx0ICAgIEZ1bmN0aW9uRXhwcmVzc2lvbjogJ0Z1bmN0aW9uRXhwcmVzc2lvbicsXHJcblx0ICAgIElkZW50aWZpZXI6ICdJZGVudGlmaWVyJyxcclxuXHQgICAgSWZTdGF0ZW1lbnQ6ICdJZlN0YXRlbWVudCcsXHJcblx0ICAgIEltcG9ydERlY2xhcmF0aW9uOiAnSW1wb3J0RGVjbGFyYXRpb24nLFxyXG5cdCAgICBJbXBvcnREZWZhdWx0U3BlY2lmaWVyOiAnSW1wb3J0RGVmYXVsdFNwZWNpZmllcicsXHJcblx0ICAgIEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjogJ0ltcG9ydE5hbWVzcGFjZVNwZWNpZmllcicsXHJcblx0ICAgIEltcG9ydFNwZWNpZmllcjogJ0ltcG9ydFNwZWNpZmllcicsXHJcblx0ICAgIExpdGVyYWw6ICdMaXRlcmFsJyxcclxuXHQgICAgTGFiZWxlZFN0YXRlbWVudDogJ0xhYmVsZWRTdGF0ZW1lbnQnLFxyXG5cdCAgICBMb2dpY2FsRXhwcmVzc2lvbjogJ0xvZ2ljYWxFeHByZXNzaW9uJyxcclxuXHQgICAgTWVtYmVyRXhwcmVzc2lvbjogJ01lbWJlckV4cHJlc3Npb24nLFxyXG5cdCAgICBNZXRhUHJvcGVydHk6ICdNZXRhUHJvcGVydHknLFxyXG5cdCAgICBNZXRob2REZWZpbml0aW9uOiAnTWV0aG9kRGVmaW5pdGlvbicsXHJcblx0ICAgIE5ld0V4cHJlc3Npb246ICdOZXdFeHByZXNzaW9uJyxcclxuXHQgICAgT2JqZWN0RXhwcmVzc2lvbjogJ09iamVjdEV4cHJlc3Npb24nLFxyXG5cdCAgICBPYmplY3RQYXR0ZXJuOiAnT2JqZWN0UGF0dGVybicsXHJcblx0ICAgIFByb2dyYW06ICdQcm9ncmFtJyxcclxuXHQgICAgUHJvcGVydHk6ICdQcm9wZXJ0eScsXHJcblx0ICAgIFJlc3RFbGVtZW50OiAnUmVzdEVsZW1lbnQnLFxyXG5cdCAgICBSZXR1cm5TdGF0ZW1lbnQ6ICdSZXR1cm5TdGF0ZW1lbnQnLFxyXG5cdCAgICBTZXF1ZW5jZUV4cHJlc3Npb246ICdTZXF1ZW5jZUV4cHJlc3Npb24nLFxyXG5cdCAgICBTcHJlYWRFbGVtZW50OiAnU3ByZWFkRWxlbWVudCcsXHJcblx0ICAgIFN1cGVyOiAnU3VwZXInLFxyXG5cdCAgICBTd2l0Y2hDYXNlOiAnU3dpdGNoQ2FzZScsXHJcblx0ICAgIFN3aXRjaFN0YXRlbWVudDogJ1N3aXRjaFN0YXRlbWVudCcsXHJcblx0ICAgIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjogJ1RhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbicsXHJcblx0ICAgIFRlbXBsYXRlRWxlbWVudDogJ1RlbXBsYXRlRWxlbWVudCcsXHJcblx0ICAgIFRlbXBsYXRlTGl0ZXJhbDogJ1RlbXBsYXRlTGl0ZXJhbCcsXHJcblx0ICAgIFRoaXNFeHByZXNzaW9uOiAnVGhpc0V4cHJlc3Npb24nLFxyXG5cdCAgICBUaHJvd1N0YXRlbWVudDogJ1Rocm93U3RhdGVtZW50JyxcclxuXHQgICAgVHJ5U3RhdGVtZW50OiAnVHJ5U3RhdGVtZW50JyxcclxuXHQgICAgVW5hcnlFeHByZXNzaW9uOiAnVW5hcnlFeHByZXNzaW9uJyxcclxuXHQgICAgVXBkYXRlRXhwcmVzc2lvbjogJ1VwZGF0ZUV4cHJlc3Npb24nLFxyXG5cdCAgICBWYXJpYWJsZURlY2xhcmF0aW9uOiAnVmFyaWFibGVEZWNsYXJhdGlvbicsXHJcblx0ICAgIFZhcmlhYmxlRGVjbGFyYXRvcjogJ1ZhcmlhYmxlRGVjbGFyYXRvcicsXHJcblx0ICAgIFdoaWxlU3RhdGVtZW50OiAnV2hpbGVTdGF0ZW1lbnQnLFxyXG5cdCAgICBXaXRoU3RhdGVtZW50OiAnV2l0aFN0YXRlbWVudCcsXHJcblx0ICAgIFlpZWxkRXhwcmVzc2lvbjogJ1lpZWxkRXhwcmVzc2lvbidcclxuXHR9O1xyXG5cblxuLyoqKi8gfSxcbi8qIDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHR2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcblx0ICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcblx0ICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcblx0ICAgIH07XHJcblx0fSkoKTtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0dmFyIGNoYXJhY3Rlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuXHR2YXIgSlNYTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcblx0dmFyIGpzeF9zeW50YXhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblx0dmFyIE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG5cdHZhciBwYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XHJcblx0dmFyIHRva2VuXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxuXHR2YXIgeGh0bWxfZW50aXRpZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xyXG5cdHRva2VuXzEuVG9rZW5OYW1lWzEwMCAvKiBJZGVudGlmaWVyICovXSA9ICdKU1hJZGVudGlmaWVyJztcclxuXHR0b2tlbl8xLlRva2VuTmFtZVsxMDEgLyogVGV4dCAqL10gPSAnSlNYVGV4dCc7XHJcblx0Ly8gRnVsbHkgcXVhbGlmaWVkIGVsZW1lbnQgbmFtZSwgZS5nLiA8c3ZnOnBhdGg+IHJldHVybnMgXCJzdmc6cGF0aFwiXHJcblx0ZnVuY3Rpb24gZ2V0UXVhbGlmaWVkRWxlbWVudE5hbWUoZWxlbWVudE5hbWUpIHtcclxuXHQgICAgdmFyIHF1YWxpZmllZE5hbWU7XHJcblx0ICAgIHN3aXRjaCAoZWxlbWVudE5hbWUudHlwZSkge1xyXG5cdCAgICAgICAgY2FzZSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWElkZW50aWZpZXI6XHJcblx0ICAgICAgICAgICAgdmFyIGlkID0gZWxlbWVudE5hbWU7XHJcblx0ICAgICAgICAgICAgcXVhbGlmaWVkTmFtZSA9IGlkLm5hbWU7XHJcblx0ICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICBjYXNlIGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYTmFtZXNwYWNlZE5hbWU6XHJcblx0ICAgICAgICAgICAgdmFyIG5zID0gZWxlbWVudE5hbWU7XHJcblx0ICAgICAgICAgICAgcXVhbGlmaWVkTmFtZSA9IGdldFF1YWxpZmllZEVsZW1lbnROYW1lKG5zLm5hbWVzcGFjZSkgKyAnOicgK1xyXG5cdCAgICAgICAgICAgICAgICBnZXRRdWFsaWZpZWRFbGVtZW50TmFtZShucy5uYW1lKTtcclxuXHQgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgIGNhc2UganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hNZW1iZXJFeHByZXNzaW9uOlxyXG5cdCAgICAgICAgICAgIHZhciBleHByID0gZWxlbWVudE5hbWU7XHJcblx0ICAgICAgICAgICAgcXVhbGlmaWVkTmFtZSA9IGdldFF1YWxpZmllZEVsZW1lbnROYW1lKGV4cHIub2JqZWN0KSArICcuJyArXHJcblx0ICAgICAgICAgICAgICAgIGdldFF1YWxpZmllZEVsZW1lbnROYW1lKGV4cHIucHJvcGVydHkpO1xyXG5cdCAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuXHQgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIHF1YWxpZmllZE5hbWU7XHJcblx0fVxyXG5cdHZhciBKU1hQYXJzZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG5cdCAgICBfX2V4dGVuZHMoSlNYUGFyc2VyLCBfc3VwZXIpO1xyXG5cdCAgICBmdW5jdGlvbiBKU1hQYXJzZXIoY29kZSwgb3B0aW9ucywgZGVsZWdhdGUpIHtcclxuXHQgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBjb2RlLCBvcHRpb25zLCBkZWxlZ2F0ZSkgfHwgdGhpcztcclxuXHQgICAgfVxyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlUHJpbWFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5tYXRjaCgnPCcpID8gdGhpcy5wYXJzZUpTWFJvb3QoKSA6IF9zdXBlci5wcm90b3R5cGUucGFyc2VQcmltYXJ5RXhwcmVzc2lvbi5jYWxsKHRoaXMpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnN0YXJ0SlNYID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgLy8gVW53aW5kIHRoZSBzY2FubmVyIGJlZm9yZSB0aGUgbG9va2FoZWFkIHRva2VuLlxyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyLmluZGV4ID0gdGhpcy5zdGFydE1hcmtlci5pbmRleDtcclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyID0gdGhpcy5zdGFydE1hcmtlci5saW5lO1xyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyLmxpbmVTdGFydCA9IHRoaXMuc3RhcnRNYXJrZXIuaW5kZXggLSB0aGlzLnN0YXJ0TWFya2VyLmNvbHVtbjtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5maW5pc2hKU1ggPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAvLyBQcmltZSB0aGUgbmV4dCBsb29rYWhlYWQuXHJcblx0ICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnJlZW50ZXJKU1ggPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLnN0YXJ0SlNYKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgnfScpO1xyXG5cdCAgICAgICAgLy8gUG9wIHRoZSBjbG9zaW5nICd9JyBhZGRlZCBmcm9tIHRoZSBsb29rYWhlYWQuXHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcudG9rZW5zKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2tlbnMucG9wKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUuY3JlYXRlSlNYTm9kZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuY29sbGVjdENvbW1lbnRzKCk7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGluZGV4OiB0aGlzLnNjYW5uZXIuaW5kZXgsXHJcblx0ICAgICAgICAgICAgbGluZTogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgY29sdW1uOiB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLmNyZWF0ZUpTWENoaWxkTm9kZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgaW5kZXg6IHRoaXMuc2Nhbm5lci5pbmRleCxcclxuXHQgICAgICAgICAgICBsaW5lOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBjb2x1bW46IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnRcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUuc2NhblhIVE1MRW50aXR5ID0gZnVuY3Rpb24gKHF1b3RlKSB7XHJcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gJyYnO1xyXG5cdCAgICAgICAgdmFyIHZhbGlkID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciB0ZXJtaW5hdGVkID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgbnVtZXJpYyA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIGhleCA9IGZhbHNlO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLnNjYW5uZXIuZW9mKCkgJiYgdmFsaWQgJiYgIXRlcm1pbmF0ZWQpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNjYW5uZXIuc291cmNlW3RoaXMuc2Nhbm5lci5pbmRleF07XHJcblx0ICAgICAgICAgICAgaWYgKGNoID09PSBxdW90ZSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGVybWluYXRlZCA9IChjaCA9PT0gJzsnKTtcclxuXHQgICAgICAgICAgICByZXN1bHQgKz0gY2g7XHJcblx0ICAgICAgICAgICAgKyt0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgaWYgKCF0ZXJtaW5hdGVkKSB7XHJcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAocmVzdWx0Lmxlbmd0aCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGUuZy4gJyYjMTIzOydcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBudW1lcmljID0gKGNoID09PSAnIycpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudW1lcmljKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGUuZy4gJyYjeDQxOydcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGV4ID0gKGNoID09PSAneCcpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IGhleCB8fCBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWVyaWMgPSBudW1lcmljICYmICFoZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IHZhbGlkICYmICEobnVtZXJpYyAmJiAhY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IHZhbGlkICYmICEoaGV4ICYmICFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNIZXhEaWdpdChjaC5jaGFyQ29kZUF0KDApKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodmFsaWQgJiYgdGVybWluYXRlZCAmJiByZXN1bHQubGVuZ3RoID4gMikge1xyXG5cdCAgICAgICAgICAgIC8vIGUuZy4gJyYjeDQxOycgYmVjb21lcyBqdXN0ICcjeDQxJ1xyXG5cdCAgICAgICAgICAgIHZhciBzdHIgPSByZXN1bHQuc3Vic3RyKDEsIHJlc3VsdC5sZW5ndGggLSAyKTtcclxuXHQgICAgICAgICAgICBpZiAobnVtZXJpYyAmJiBzdHIubGVuZ3RoID4gMSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDEwKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGhleCAmJiBzdHIubGVuZ3RoID4gMikge1xyXG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KCcwJyArIHN0ci5zdWJzdHIoMSksIDE2KSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKCFudW1lcmljICYmICFoZXggJiYgeGh0bWxfZW50aXRpZXNfMS5YSFRNTEVudGl0aWVzW3N0cl0pIHtcclxuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0geGh0bWxfZW50aXRpZXNfMS5YSFRNTEVudGl0aWVzW3N0cl07XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gU2NhbiB0aGUgbmV4dCBKU1ggdG9rZW4uIFRoaXMgcmVwbGFjZXMgU2Nhbm5lciNsZXggd2hlbiBpbiBKU1ggbW9kZS5cclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5sZXhKU1ggPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgY3AgPSB0aGlzLnNjYW5uZXIuc291cmNlLmNoYXJDb2RlQXQodGhpcy5zY2FubmVyLmluZGV4KTtcclxuXHQgICAgICAgIC8vIDwgPiAvIDogPSB7IH1cclxuXHQgICAgICAgIGlmIChjcCA9PT0gNjAgfHwgY3AgPT09IDYyIHx8IGNwID09PSA0NyB8fCBjcCA9PT0gNTggfHwgY3AgPT09IDYxIHx8IGNwID09PSAxMjMgfHwgY3AgPT09IDEyNSkge1xyXG5cdCAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuc2Nhbm5lci5zb3VyY2VbdGhpcy5zY2FubmVyLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgIHR5cGU6IDcgLyogUHVuY3R1YXRvciAqLyxcclxuXHQgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLnNjYW5uZXIubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5zY2FubmVyLmluZGV4IC0gMSxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB0aGlzLnNjYW5uZXIuaW5kZXhcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gXCIgJ1xyXG5cdCAgICAgICAgaWYgKGNwID09PSAzNCB8fCBjcCA9PT0gMzkpIHtcclxuXHQgICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgdmFyIHF1b3RlID0gdGhpcy5zY2FubmVyLnNvdXJjZVt0aGlzLnNjYW5uZXIuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgdmFyIHN0ciA9ICcnO1xyXG5cdCAgICAgICAgICAgIHdoaWxlICghdGhpcy5zY2FubmVyLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc2Nhbm5lci5zb3VyY2VbdGhpcy5zY2FubmVyLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09IHF1b3RlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJyYnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdHIgKz0gdGhpcy5zY2FuWEhUTUxFbnRpdHkocXVvdGUpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgIHR5cGU6IDggLyogU3RyaW5nTGl0ZXJhbCAqLyxcclxuXHQgICAgICAgICAgICAgICAgdmFsdWU6IHN0cixcclxuXHQgICAgICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5zY2FubmVyLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHRoaXMuc2Nhbm5lci5pbmRleFxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyAuLi4gb3IgLlxyXG5cdCAgICAgICAgaWYgKGNwID09PSA0Nikge1xyXG5cdCAgICAgICAgICAgIHZhciBuMSA9IHRoaXMuc2Nhbm5lci5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLnNjYW5uZXIuaW5kZXggKyAxKTtcclxuXHQgICAgICAgICAgICB2YXIgbjIgPSB0aGlzLnNjYW5uZXIuc291cmNlLmNoYXJDb2RlQXQodGhpcy5zY2FubmVyLmluZGV4ICsgMik7XHJcblx0ICAgICAgICAgICAgdmFyIHZhbHVlID0gKG4xID09PSA0NiAmJiBuMiA9PT0gNDYpID8gJy4uLicgOiAnLic7XHJcblx0ICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5pbmRleCArPSB2YWx1ZS5sZW5ndGg7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICAgICAgdHlwZTogNyAvKiBQdW5jdHVhdG9yICovLFxyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMuc2Nhbm5lci5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB0aGlzLnNjYW5uZXIuaW5kZXhcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gYFxyXG5cdCAgICAgICAgaWYgKGNwID09PSA5Nikge1xyXG5cdCAgICAgICAgICAgIC8vIE9ubHkgcGxhY2Vob2xkZXIsIHNpbmNlIGl0IHdpbGwgYmUgcmVzY2FubmVkIGFzIGEgcmVhbCBhc3NpZ25tZW50IGV4cHJlc3Npb24uXHJcblx0ICAgICAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICAgICAgdHlwZTogMTAgLyogVGVtcGxhdGUgKi8sXHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlOiAnJyxcclxuXHQgICAgICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5zY2FubmVyLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMuc2Nhbm5lci5pbmRleCxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB0aGlzLnNjYW5uZXIuaW5kZXhcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gSWRlbnRpZmVyIGNhbiBub3QgY29udGFpbiBiYWNrc2xhc2ggKGNoYXIgY29kZSA5MikuXHJcblx0ICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclN0YXJ0KGNwKSAmJiAoY3AgIT09IDkyKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICArK3RoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICB3aGlsZSAoIXRoaXMuc2Nhbm5lci5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNjYW5uZXIuc291cmNlLmNoYXJDb2RlQXQodGhpcy5zY2FubmVyLmluZGV4KTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJQYXJ0KGNoKSAmJiAoY2ggIT09IDkyKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09IDQ1KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBIeXBoZW4gKGNoYXIgY29kZSA0NSkgY2FuIGJlIHBhcnQgb2YgYW4gaWRlbnRpZmllci5cclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5zY2FubmVyLnNvdXJjZS5zbGljZShzdGFydCwgdGhpcy5zY2FubmVyLmluZGV4KTtcclxuXHQgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICB0eXBlOiAxMDAgLyogSWRlbnRpZmllciAqLyxcclxuXHQgICAgICAgICAgICAgICAgdmFsdWU6IGlkLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLnNjYW5uZXIubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgIGVuZDogdGhpcy5zY2FubmVyLmluZGV4XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLnNjYW5uZXIubGV4KCk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUubmV4dEpTWFRva2VuID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5jb2xsZWN0Q29tbWVudHMoKTtcclxuXHQgICAgICAgIHRoaXMuc3RhcnRNYXJrZXIuaW5kZXggPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmxpbmUgPSB0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcclxuXHQgICAgICAgIHRoaXMuc3RhcnRNYXJrZXIuY29sdW1uID0gdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydDtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubGV4SlNYKCk7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIuaW5kZXggPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIubGluZSA9IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmNvbHVtbiA9IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnQ7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcudG9rZW5zKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2tlbnMucHVzaCh0aGlzLmNvbnZlcnRUb2tlbih0b2tlbikpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRva2VuO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLm5leHRKU1hUZXh0ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5zdGFydE1hcmtlci5pbmRleCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgIHRoaXMuc3RhcnRNYXJrZXIubGluZSA9IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgdGhpcy5zdGFydE1hcmtlci5jb2x1bW4gPSB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0O1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgdmFyIHRleHQgPSAnJztcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5zY2FubmVyLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zY2FubmVyLnNvdXJjZVt0aGlzLnNjYW5uZXIuaW5kZXhdO1xyXG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gJ3snIHx8IGNoID09PSAnPCcpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICsrdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgIHRleHQgKz0gY2g7XHJcblx0ICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5zY2FubmVyLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgdGhpcy5zY2FubmVyLnNvdXJjZVt0aGlzLnNjYW5uZXIuaW5kZXhdID09PSAnXFxuJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5zY2FubmVyLmxpbmVTdGFydCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIuaW5kZXggPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIubGluZSA9IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmNvbHVtbiA9IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnQ7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB7XHJcblx0ICAgICAgICAgICAgdHlwZTogMTAxIC8qIFRleHQgKi8sXHJcblx0ICAgICAgICAgICAgdmFsdWU6IHRleHQsXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLnNjYW5uZXIubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuc2Nhbm5lci5pbmRleFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIGlmICgodGV4dC5sZW5ndGggPiAwKSAmJiB0aGlzLmNvbmZpZy50b2tlbnMpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHRoaXMuY29udmVydFRva2VuKHRva2VuKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdG9rZW47XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGVla0pTWFRva2VuID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zY2FubmVyLnNhdmVTdGF0ZSgpO1xyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyLnNjYW5Db21tZW50cygpO1xyXG5cdCAgICAgICAgdmFyIG5leHQgPSB0aGlzLmxleEpTWCgpO1xyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyLnJlc3RvcmVTdGF0ZShzdGF0ZSk7XHJcblx0ICAgICAgICByZXR1cm4gbmV4dDtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gRXhwZWN0IHRoZSBuZXh0IEpTWCB0b2tlbiB0byBtYXRjaCB0aGUgc3BlY2lmaWVkIHB1bmN0dWF0b3IuXHJcblx0ICAgIC8vIElmIG5vdCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLmV4cGVjdEpTWCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0SlNYVG9rZW4oKTtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSA3IC8qIFB1bmN0dWF0b3IgKi8gfHwgdG9rZW4udmFsdWUgIT09IHZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IEpTWCB0b2tlbiBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5tYXRjaEpTWCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdCAgICAgICAgdmFyIG5leHQgPSB0aGlzLnBlZWtKU1hUb2tlbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIG5leHQudHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovICYmIG5leHQudmFsdWUgPT09IHZhbHVlO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYSWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRKU1hUb2tlbigpO1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IDEwMCAvKiBJZGVudGlmaWVyICovKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hJZGVudGlmaWVyKHRva2VuLnZhbHVlKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hFbGVtZW50TmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgZWxlbWVudE5hbWUgPSB0aGlzLnBhcnNlSlNYSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hKU1goJzonKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBuYW1lc3BhY2UgPSBlbGVtZW50TmFtZTtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnOicpO1xyXG5cdCAgICAgICAgICAgIHZhciBuYW1lXzEgPSB0aGlzLnBhcnNlSlNYSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIGVsZW1lbnROYW1lID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hOYW1lc3BhY2VkTmFtZShuYW1lc3BhY2UsIG5hbWVfMSkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaEpTWCgnLicpKSB7XHJcblx0ICAgICAgICAgICAgd2hpbGUgKHRoaXMubWF0Y2hKU1goJy4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgb2JqZWN0ID0gZWxlbWVudE5hbWU7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0SlNYKCcuJyk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMucGFyc2VKU1hJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnROYW1lID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hNZW1iZXJFeHByZXNzaW9uKG9iamVjdCwgcHJvcGVydHkpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZWxlbWVudE5hbWU7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hBdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lO1xyXG5cdCAgICAgICAgdmFyIGlkZW50aWZpZXIgPSB0aGlzLnBhcnNlSlNYSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hKU1goJzonKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBuYW1lc3BhY2UgPSBpZGVudGlmaWVyO1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0SlNYKCc6Jyk7XHJcblx0ICAgICAgICAgICAgdmFyIG5hbWVfMiA9IHRoaXMucGFyc2VKU1hJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgYXR0cmlidXRlTmFtZSA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYTmFtZXNwYWNlZE5hbWUobmFtZXNwYWNlLCBuYW1lXzIpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWUgPSBpZGVudGlmaWVyO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZU5hbWU7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hTdHJpbmdMaXRlcmFsQXR0cmlidXRlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dEpTWFRva2VuKCk7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gOCAvKiBTdHJpbmdMaXRlcmFsICovKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgcmF3ID0gdGhpcy5nZXRUb2tlblJhdyh0b2tlbik7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5MaXRlcmFsKHRva2VuLnZhbHVlLCByYXcpKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEV4cHJlc3Npb25BdHRyaWJ1dGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RKU1goJ3snKTtcclxuXHQgICAgICAgIHRoaXMuZmluaXNoSlNYKCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKCdKU1ggYXR0cmlidXRlcyBtdXN0IG9ubHkgYmUgYXNzaWduZWQgYSBub24tZW1wdHkgZXhwcmVzc2lvbicpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIHRoaXMucmVlbnRlckpTWCgpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYRXhwcmVzc2lvbkNvbnRhaW5lcihleHByZXNzaW9uKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hBdHRyaWJ1dGVWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLm1hdGNoSlNYKCd7JykgPyB0aGlzLnBhcnNlSlNYRXhwcmVzc2lvbkF0dHJpYnV0ZSgpIDpcclxuXHQgICAgICAgICAgICB0aGlzLm1hdGNoSlNYKCc8JykgPyB0aGlzLnBhcnNlSlNYRWxlbWVudCgpIDogdGhpcy5wYXJzZUpTWFN0cmluZ0xpdGVyYWxBdHRyaWJ1dGUoKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWE5hbWVWYWx1ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgbmFtZSA9IHRoaXMucGFyc2VKU1hBdHRyaWJ1dGVOYW1lKCk7XHJcblx0ICAgICAgICB2YXIgdmFsdWUgPSBudWxsO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hKU1goJz0nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0SlNYKCc9Jyk7XHJcblx0ICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlSlNYQXR0cmlidXRlVmFsdWUoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYU3ByZWFkQXR0cmlidXRlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0SlNYKCd7Jyk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgnLi4uJyk7XHJcblx0ICAgICAgICB0aGlzLmZpbmlzaEpTWCgpO1xyXG5cdCAgICAgICAgdmFyIGFyZ3VtZW50ID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB0aGlzLnJlZW50ZXJKU1goKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWFNwcmVhZEF0dHJpYnV0ZShhcmd1bWVudCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gW107XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMubWF0Y2hKU1goJy8nKSAmJiAhdGhpcy5tYXRjaEpTWCgnPicpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IHRoaXMubWF0Y2hKU1goJ3snKSA/IHRoaXMucGFyc2VKU1hTcHJlYWRBdHRyaWJ1dGUoKSA6XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMucGFyc2VKU1hOYW1lVmFsdWVBdHRyaWJ1dGUoKTtcclxuXHQgICAgICAgICAgICBhdHRyaWJ1dGVzLnB1c2goYXR0cmlidXRlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYT3BlbmluZ0VsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RKU1goJzwnKTtcclxuXHQgICAgICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZUpTWEVsZW1lbnROYW1lKCk7XHJcblx0ICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMucGFyc2VKU1hBdHRyaWJ1dGVzKCk7XHJcblx0ICAgICAgICB2YXIgc2VsZkNsb3NpbmcgPSB0aGlzLm1hdGNoSlNYKCcvJyk7XHJcblx0ICAgICAgICBpZiAoc2VsZkNsb3NpbmcpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnLycpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3RKU1goJz4nKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWE9wZW5pbmdFbGVtZW50KG5hbWUsIHNlbGZDbG9zaW5nLCBhdHRyaWJ1dGVzKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hCb3VuZGFyeUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RKU1goJzwnKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoSlNYKCcvJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnLycpO1xyXG5cdCAgICAgICAgICAgIHZhciBuYW1lXzMgPSB0aGlzLnBhcnNlSlNYRWxlbWVudE5hbWUoKTtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnPicpO1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWENsb3NpbmdFbGVtZW50KG5hbWVfMykpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlSlNYRWxlbWVudE5hbWUoKTtcclxuXHQgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5wYXJzZUpTWEF0dHJpYnV0ZXMoKTtcclxuXHQgICAgICAgIHZhciBzZWxmQ2xvc2luZyA9IHRoaXMubWF0Y2hKU1goJy8nKTtcclxuXHQgICAgICAgIGlmIChzZWxmQ2xvc2luZykge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0SlNYKCcvJyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgnPicpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYT3BlbmluZ0VsZW1lbnQobmFtZSwgc2VsZkNsb3NpbmcsIGF0dHJpYnV0ZXMpKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEVtcHR5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hDaGlsZE5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuY29sbGVjdENvbW1lbnRzKCk7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIuaW5kZXggPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIubGluZSA9IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmNvbHVtbiA9IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnQ7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hFbXB0eUV4cHJlc3Npb24oKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hFeHByZXNzaW9uQ29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0SlNYKCd7Jyk7XHJcblx0ICAgICAgICB2YXIgZXhwcmVzc2lvbjtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoSlNYKCd9JykpIHtcclxuXHQgICAgICAgICAgICBleHByZXNzaW9uID0gdGhpcy5wYXJzZUpTWEVtcHR5RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0SlNYKCd9Jyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aGlzLmZpbmlzaEpTWCgpO1xyXG5cdCAgICAgICAgICAgIGV4cHJlc3Npb24gPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICB0aGlzLnJlZW50ZXJKU1goKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWEV4cHJlc3Npb25Db250YWluZXIoZXhwcmVzc2lvbikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5zY2FubmVyLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWENoaWxkTm9kZSgpO1xyXG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dEpTWFRleHQoKTtcclxuXHQgICAgICAgICAgICBpZiAodG9rZW4uc3RhcnQgPCB0b2tlbi5lbmQpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHJhdyA9IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWFRleHQodG9rZW4udmFsdWUsIHJhdykpO1xyXG5cdCAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5zb3VyY2VbdGhpcy5zY2FubmVyLmluZGV4XSA9PT0gJ3snKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLnBhcnNlSlNYRXhwcmVzc2lvbkNvbnRhaW5lcigpO1xyXG5cdCAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNvbnRhaW5lcik7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gY2hpbGRyZW47XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VDb21wbGV4SlNYRWxlbWVudCA9IGZ1bmN0aW9uIChlbCkge1xyXG5cdCAgICAgICAgdmFyIHN0YWNrID0gW107XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuc2Nhbm5lci5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIGVsLmNoaWxkcmVuID0gZWwuY2hpbGRyZW4uY29uY2F0KHRoaXMucGFyc2VKU1hDaGlsZHJlbigpKTtcclxuXHQgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYQ2hpbGROb2RlKCk7XHJcblx0ICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnBhcnNlSlNYQm91bmRhcnlFbGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hPcGVuaW5nRWxlbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgb3BlbmluZyA9IGVsZW1lbnQ7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChvcGVuaW5nLnNlbGZDbG9zaW5nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWEVsZW1lbnQob3BlbmluZywgW10sIG51bGwpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGVsLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChlbCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbCA9IHsgbm9kZTogbm9kZSwgb3BlbmluZzogb3BlbmluZywgY2xvc2luZzogbnVsbCwgY2hpbGRyZW46IFtdIH07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hDbG9zaW5nRWxlbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICBlbC5jbG9zaW5nID0gZWxlbWVudDtcclxuXHQgICAgICAgICAgICAgICAgdmFyIG9wZW5fMSA9IGdldFF1YWxpZmllZEVsZW1lbnROYW1lKGVsLm9wZW5pbmcubmFtZSk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBjbG9zZV8xID0gZ2V0UXVhbGlmaWVkRWxlbWVudE5hbWUoZWwuY2xvc2luZy5uYW1lKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKG9wZW5fMSAhPT0gY2xvc2VfMSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKCdFeHBlY3RlZCBjb3JyZXNwb25kaW5nIEpTWCBjbG9zaW5nIHRhZyBmb3IgJTAnLCBvcGVuXzEpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmZpbmFsaXplKGVsLm5vZGUsIG5ldyBKU1hOb2RlLkpTWEVsZW1lbnQoZWwub3BlbmluZywgZWwuY2hpbGRyZW4sIGVsLmNsb3NpbmcpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGVsID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZWw7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHZhciBvcGVuaW5nID0gdGhpcy5wYXJzZUpTWE9wZW5pbmdFbGVtZW50KCk7XHJcblx0ICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcclxuXHQgICAgICAgIHZhciBjbG9zaW5nID0gbnVsbDtcclxuXHQgICAgICAgIGlmICghb3BlbmluZy5zZWxmQ2xvc2luZykge1xyXG5cdCAgICAgICAgICAgIHZhciBlbCA9IHRoaXMucGFyc2VDb21wbGV4SlNYRWxlbWVudCh7IG5vZGU6IG5vZGUsIG9wZW5pbmc6IG9wZW5pbmcsIGNsb3Npbmc6IGNsb3NpbmcsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KTtcclxuXHQgICAgICAgICAgICBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xyXG5cdCAgICAgICAgICAgIGNsb3NpbmcgPSBlbC5jbG9zaW5nO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYRWxlbWVudChvcGVuaW5nLCBjaGlsZHJlbiwgY2xvc2luZykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYUm9vdCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIC8vIFBvcCB0aGUgb3BlbmluZyAnPCcgYWRkZWQgZnJvbSB0aGUgbG9va2FoZWFkLlxyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRva2Vucykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9rZW5zLnBvcCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5zdGFydEpTWCgpO1xyXG5cdCAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnBhcnNlSlNYRWxlbWVudCgpO1xyXG5cdCAgICAgICAgdGhpcy5maW5pc2hKU1goKTtcclxuXHQgICAgICAgIHJldHVybiBlbGVtZW50O1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLmlzU3RhcnRPZkV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5pc1N0YXJ0T2ZFeHByZXNzaW9uLmNhbGwodGhpcykgfHwgdGhpcy5tYXRjaCgnPCcpO1xyXG5cdCAgICB9O1xyXG5cdCAgICByZXR1cm4gSlNYUGFyc2VyO1xyXG5cdH0ocGFyc2VyXzEuUGFyc2VyKSk7XHJcblx0ZXhwb3J0cy5KU1hQYXJzZXIgPSBKU1hQYXJzZXI7XHJcblxuXG4vKioqLyB9LFxuLyogNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdC8vIFNlZSBhbHNvIHRvb2xzL2dlbmVyYXRlLXVuaWNvZGUtcmVnZXguanMuXHJcblx0dmFyIFJlZ2V4ID0ge1xyXG5cdCAgICAvLyBVbmljb2RlIHY4LjAuMCBOb25Bc2NpaUlkZW50aWZpZXJTdGFydDpcclxuXHQgICAgTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQ6IC9bXFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MjAtXFx1MDY0QVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RTVcXHUwNkU2XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MTVcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOEEwLVxcdTA4QjRcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBBRjlcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzRFxcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYxXFx1MEI3MVxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJEMFxcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0RcXHUwQzU4LVxcdTBDNUFcXHUwQzYwXFx1MEM2MVxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ1Ri1cXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5Qi1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkQ1XFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjQwLVxcdUE2NkVcXHVBNjdGLVxcdUE2OURcXHVBNkEwLVxcdUE2RUZcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3QURcXHVBN0IwLVxcdUE3QjdcXHVBN0Y3LVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0ZcXHVBOUUwLVxcdUE5RTRcXHVBOUU2LVxcdUE5RUZcXHVBOUZBLVxcdUE5RkVcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE3RS1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUFcXHVBQUYyLVxcdUFBRjRcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNjVcXHVBQjcwLVxcdUFCRTJcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjIxLVxcdUZGM0FcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdfFxcdUQ4MDBbXFx1REMwMC1cXHVEQzBCXFx1REMwRC1cXHVEQzI2XFx1REMyOC1cXHVEQzNBXFx1REMzQ1xcdURDM0RcXHVEQzNGLVxcdURDNERcXHVEQzUwLVxcdURDNURcXHVEQzgwLVxcdURDRkFcXHVERDQwLVxcdURENzRcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERjAwLVxcdURGMUZcXHVERjMwLVxcdURGNEFcXHVERjUwLVxcdURGNzVcXHVERjgwLVxcdURGOURcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGQ0ZcXHVERkQxLVxcdURGRDVdfFxcdUQ4MDFbXFx1REMwMC1cXHVEQzlEXFx1REQwMC1cXHVERDI3XFx1REQzMC1cXHVERDYzXFx1REUwMC1cXHVERjM2XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjY3XXxcXHVEODAyW1xcdURDMDAtXFx1REMwNVxcdURDMDhcXHVEQzBBLVxcdURDMzVcXHVEQzM3XFx1REMzOFxcdURDM0NcXHVEQzNGLVxcdURDNTVcXHVEQzYwLVxcdURDNzZcXHVEQzgwLVxcdURDOUVcXHVEQ0UwLVxcdURDRjJcXHVEQ0Y0XFx1RENGNVxcdUREMDAtXFx1REQxNVxcdUREMjAtXFx1REQzOVxcdUREODAtXFx1RERCN1xcdUREQkVcXHVEREJGXFx1REUwMFxcdURFMTAtXFx1REUxM1xcdURFMTUtXFx1REUxN1xcdURFMTktXFx1REUzM1xcdURFNjAtXFx1REU3Q1xcdURFODAtXFx1REU5Q1xcdURFQzAtXFx1REVDN1xcdURFQzktXFx1REVFNFxcdURGMDAtXFx1REYzNVxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY3MlxcdURGODAtXFx1REY5MV18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhcXHVEQzgwLVxcdURDQjJcXHVEQ0MwLVxcdURDRjJdfFxcdUQ4MDRbXFx1REMwMy1cXHVEQzM3XFx1REM4My1cXHVEQ0FGXFx1RENEMC1cXHVEQ0U4XFx1REQwMy1cXHVERDI2XFx1REQ1MC1cXHVERDcyXFx1REQ3NlxcdUREODMtXFx1RERCMlxcdUREQzEtXFx1RERDNFxcdUREREFcXHVERERDXFx1REUwMC1cXHVERTExXFx1REUxMy1cXHVERTJCXFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOFxcdURFQjAtXFx1REVERVxcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNEXFx1REY1MFxcdURGNUQtXFx1REY2MV18XFx1RDgwNVtcXHVEQzgwLVxcdURDQUZcXHVEQ0M0XFx1RENDNVxcdURDQzdcXHVERDgwLVxcdUREQUVcXHVEREQ4LVxcdUREREJcXHVERTAwLVxcdURFMkZcXHVERTQ0XFx1REU4MC1cXHVERUFBXFx1REYwMC1cXHVERjE5XXxcXHVEODA2W1xcdURDQTAtXFx1RENERlxcdURDRkZcXHVERUMwLVxcdURFRjhdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk5XXxcXHVEODA5W1xcdURDMDAtXFx1REM2RVxcdURDODAtXFx1REQ0M118W1xcdUQ4MENcXHVEODQwLVxcdUQ4NjhcXHVEODZBLVxcdUQ4NkNcXHVEODZGLVxcdUQ4NzJdW1xcdURDMDAtXFx1REZGRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4MTFbXFx1REMwMC1cXHVERTQ2XXxcXHVEODFBW1xcdURDMDAtXFx1REUzOFxcdURFNDAtXFx1REU1RVxcdURFRDAtXFx1REVFRFxcdURGMDAtXFx1REYyRlxcdURGNDAtXFx1REY0M1xcdURGNjMtXFx1REY3N1xcdURGN0QtXFx1REY4Rl18XFx1RDgxQltcXHVERjAwLVxcdURGNDRcXHVERjUwXFx1REY5My1cXHVERjlGXXxcXHVEODJDW1xcdURDMDBcXHVEQzAxXXxcXHVEODJGW1xcdURDMDAtXFx1REM2QVxcdURDNzAtXFx1REM3Q1xcdURDODAtXFx1REM4OFxcdURDOTAtXFx1REM5OV18XFx1RDgzNVtcXHVEQzAwLVxcdURDNTRcXHVEQzU2LVxcdURDOUNcXHVEQzlFXFx1REM5RlxcdURDQTJcXHVEQ0E1XFx1RENBNlxcdURDQTktXFx1RENBQ1xcdURDQUUtXFx1RENCOVxcdURDQkJcXHVEQ0JELVxcdURDQzNcXHVEQ0M1LVxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDFFLVxcdUREMzlcXHVERDNCLVxcdUREM0VcXHVERDQwLVxcdURENDRcXHVERDQ2XFx1REQ0QS1cXHVERDUwXFx1REQ1Mi1cXHVERUE1XFx1REVBOC1cXHVERUMwXFx1REVDMi1cXHVERURBXFx1REVEQy1cXHVERUZBXFx1REVGQy1cXHVERjE0XFx1REYxNi1cXHVERjM0XFx1REYzNi1cXHVERjRFXFx1REY1MC1cXHVERjZFXFx1REY3MC1cXHVERjg4XFx1REY4QS1cXHVERkE4XFx1REZBQS1cXHVERkMyXFx1REZDNC1cXHVERkNCXXxcXHVEODNBW1xcdURDMDAtXFx1RENDNF18XFx1RDgzQltcXHVERTAwLVxcdURFMDNcXHVERTA1LVxcdURFMUZcXHVERTIxXFx1REUyMlxcdURFMjRcXHVERTI3XFx1REUyOS1cXHVERTMyXFx1REUzNC1cXHVERTM3XFx1REUzOVxcdURFM0JcXHVERTQyXFx1REU0N1xcdURFNDlcXHVERTRCXFx1REU0RC1cXHVERTRGXFx1REU1MVxcdURFNTJcXHVERTU0XFx1REU1N1xcdURFNTlcXHVERTVCXFx1REU1RFxcdURFNUZcXHVERTYxXFx1REU2MlxcdURFNjRcXHVERTY3LVxcdURFNkFcXHVERTZDLVxcdURFNzJcXHVERTc0LVxcdURFNzdcXHVERTc5LVxcdURFN0NcXHVERTdFXFx1REU4MC1cXHVERTg5XFx1REU4Qi1cXHVERTlCXFx1REVBMS1cXHVERUEzXFx1REVBNS1cXHVERUE5XFx1REVBQi1cXHVERUJCXXxcXHVEODY5W1xcdURDMDAtXFx1REVENlxcdURGMDAtXFx1REZGRl18XFx1RDg2RFtcXHVEQzAwLVxcdURGMzRcXHVERjQwLVxcdURGRkZdfFxcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXFx1REMyMC1cXHVERkZGXXxcXHVEODczW1xcdURDMDAtXFx1REVBMV18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdLyxcclxuXHQgICAgLy8gVW5pY29kZSB2OC4wLjAgTm9uQXNjaWlJZGVudGlmaWVyUGFydDpcclxuXHQgICAgTm9uQXNjaWlJZGVudGlmaWVyUGFydDogL1tcXHhBQVxceEI1XFx4QjdcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzAwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4My1cXHUwNDg3XFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MTAtXFx1MDYxQVxcdTA2MjAtXFx1MDY2OVxcdTA2NkUtXFx1MDZEM1xcdTA2RDUtXFx1MDZEQ1xcdTA2REYtXFx1MDZFOFxcdTA2RUEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwLVxcdTA3NEFcXHUwNzRELVxcdTA3QjFcXHUwN0MwLVxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODJEXFx1MDg0MC1cXHUwODVCXFx1MDhBMC1cXHUwOEI0XFx1MDhFMy1cXHUwOTYzXFx1MDk2Ni1cXHUwOTZGXFx1MDk3MS1cXHUwOTgzXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCQy1cXHUwOUM0XFx1MDlDN1xcdTA5QzhcXHUwOUNCLVxcdTA5Q0VcXHUwOUQ3XFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTNcXHUwOUU2LVxcdTA5RjFcXHUwQTAxLVxcdTBBMDNcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBM0NcXHUwQTNFLVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE2Ni1cXHUwQTc1XFx1MEE4MS1cXHUwQTgzXFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJDLVxcdTBBQzVcXHUwQUM3LVxcdTBBQzlcXHUwQUNCLVxcdTBBQ0RcXHUwQUQwXFx1MEFFMC1cXHUwQUUzXFx1MEFFNi1cXHUwQUVGXFx1MEFGOVxcdTBCMDEtXFx1MEIwM1xcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNDLVxcdTBCNDRcXHUwQjQ3XFx1MEI0OFxcdTBCNEItXFx1MEI0RFxcdTBCNTZcXHUwQjU3XFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjNcXHUwQjY2LVxcdTBCNkZcXHUwQjcxXFx1MEI4MlxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJCRS1cXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNEXFx1MEJEMFxcdTBCRDdcXHUwQkU2LVxcdTBCRUZcXHUwQzAwLVxcdTBDMDNcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNELVxcdTBDNDRcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNTgtXFx1MEM1QVxcdTBDNjAtXFx1MEM2M1xcdTBDNjYtXFx1MEM2RlxcdTBDODEtXFx1MEM4M1xcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkMtXFx1MENDNFxcdTBDQzYtXFx1MENDOFxcdTBDQ0EtXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENERVxcdTBDRTAtXFx1MENFM1xcdTBDRTYtXFx1MENFRlxcdTBDRjFcXHUwQ0YyXFx1MEQwMS1cXHUwRDAzXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRC1cXHUwRDQ0XFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRFXFx1MEQ1N1xcdTBENUYtXFx1MEQ2M1xcdTBENjYtXFx1MEQ2RlxcdTBEN0EtXFx1MEQ3RlxcdTBEODJcXHUwRDgzXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBEQ0FcXHUwRENGLVxcdTBERDRcXHUwREQ2XFx1MEREOC1cXHUwRERGXFx1MERFNi1cXHUwREVGXFx1MERGMlxcdTBERjNcXHUwRTAxLVxcdTBFM0FcXHUwRTQwLVxcdTBFNEVcXHUwRTUwLVxcdTBFNTlcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCOVxcdTBFQkItXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRUM4LVxcdTBFQ0RcXHUwRUQwLVxcdTBFRDlcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEYxOFxcdTBGMTlcXHUwRjIwLVxcdTBGMjlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjNFLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjcxLVxcdTBGODRcXHUwRjg2LVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAwMC1cXHUxMDQ5XFx1MTA1MC1cXHUxMDlEXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzNUQtXFx1MTM1RlxcdTEzNjktXFx1MTM3MVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxNFxcdTE3MjAtXFx1MTczNFxcdTE3NDAtXFx1MTc1M1xcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN0QzXFx1MTdEN1xcdTE3RENcXHUxN0REXFx1MTdFMC1cXHUxN0U5XFx1MTgwQi1cXHUxODBEXFx1MTgxMC1cXHUxODE5XFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTNCXFx1MTk0Ni1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MTlEMC1cXHUxOURBXFx1MUEwMC1cXHUxQTFCXFx1MUEyMC1cXHUxQTVFXFx1MUE2MC1cXHUxQTdDXFx1MUE3Ri1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUFBN1xcdTFBQjAtXFx1MUFCRFxcdTFCMDAtXFx1MUI0QlxcdTFCNTAtXFx1MUI1OVxcdTFCNkItXFx1MUI3M1xcdTFCODAtXFx1MUJGM1xcdTFDMDAtXFx1MUMzN1xcdTFDNDAtXFx1MUM0OVxcdTFDNEQtXFx1MUM3RFxcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNGNlxcdTFDRjhcXHUxQ0Y5XFx1MUQwMC1cXHUxREY1XFx1MURGQy1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwMENcXHUyMDBEXFx1MjAzRlxcdTIwNDBcXHUyMDU0XFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMEQwLVxcdTIwRENcXHUyMEUxXFx1MjBFNS1cXHUyMEYwXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEN0YtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJERTAtXFx1MkRGRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyRlxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOTktXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZENVxcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYyQlxcdUE2NDAtXFx1QTY2RlxcdUE2NzQtXFx1QTY3RFxcdUE2N0YtXFx1QTZGMVxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTdBRFxcdUE3QjAtXFx1QTdCN1xcdUE3RjctXFx1QTgyN1xcdUE4NDAtXFx1QTg3M1xcdUE4ODAtXFx1QThDNFxcdUE4RDAtXFx1QThEOVxcdUE4RTAtXFx1QThGN1xcdUE4RkJcXHVBOEZEXFx1QTkwMC1cXHVBOTJEXFx1QTkzMC1cXHVBOTUzXFx1QTk2MC1cXHVBOTdDXFx1QTk4MC1cXHVBOUMwXFx1QTlDRi1cXHVBOUQ5XFx1QTlFMC1cXHVBOUZFXFx1QUEwMC1cXHVBQTM2XFx1QUE0MC1cXHVBQTREXFx1QUE1MC1cXHVBQTU5XFx1QUE2MC1cXHVBQTc2XFx1QUE3QS1cXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVGXFx1QUFGMi1cXHVBQUY2XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY1XFx1QUI3MC1cXHVBQkVBXFx1QUJFQ1xcdUFCRURcXHVBQkYwLVxcdUFCRjlcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFELVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRlxcdUZFMzNcXHVGRTM0XFx1RkU0RC1cXHVGRTRGXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYxMC1cXHVGRjE5XFx1RkYyMS1cXHVGRjNBXFx1RkYzRlxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURENDAtXFx1REQ3NFxcdURERkRcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERUUwXFx1REYwMC1cXHVERjFGXFx1REYzMC1cXHVERjRBXFx1REY1MC1cXHVERjdBXFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXFx1REZEMS1cXHVERkQ1XXxcXHVEODAxW1xcdURDMDAtXFx1REM5RFxcdURDQTAtXFx1RENBOVxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1RENFMC1cXHVEQ0YyXFx1RENGNFxcdURDRjVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDAtXFx1REUwM1xcdURFMDVcXHVERTA2XFx1REUwQy1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTMzXFx1REUzOC1cXHVERTNBXFx1REUzRlxcdURFNjAtXFx1REU3Q1xcdURFODAtXFx1REU5Q1xcdURFQzAtXFx1REVDN1xcdURFQzktXFx1REVFNlxcdURGMDAtXFx1REYzNVxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY3MlxcdURGODAtXFx1REY5MV18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhcXHVEQzgwLVxcdURDQjJcXHVEQ0MwLVxcdURDRjJdfFxcdUQ4MDRbXFx1REMwMC1cXHVEQzQ2XFx1REM2Ni1cXHVEQzZGXFx1REM3Ri1cXHVEQ0JBXFx1RENEMC1cXHVEQ0U4XFx1RENGMC1cXHVEQ0Y5XFx1REQwMC1cXHVERDM0XFx1REQzNi1cXHVERDNGXFx1REQ1MC1cXHVERDczXFx1REQ3NlxcdUREODAtXFx1RERDNFxcdUREQ0EtXFx1RERDQ1xcdURERDAtXFx1REREQVxcdURERENcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMzdcXHVERTgwLVxcdURFODZcXHVERTg4XFx1REU4QS1cXHVERThEXFx1REU4Ri1cXHVERTlEXFx1REU5Ri1cXHVERUE4XFx1REVCMC1cXHVERUVBXFx1REVGMC1cXHVERUY5XFx1REYwMC1cXHVERjAzXFx1REYwNS1cXHVERjBDXFx1REYwRlxcdURGMTBcXHVERjEzLVxcdURGMjhcXHVERjJBLVxcdURGMzBcXHVERjMyXFx1REYzM1xcdURGMzUtXFx1REYzOVxcdURGM0MtXFx1REY0NFxcdURGNDdcXHVERjQ4XFx1REY0Qi1cXHVERjREXFx1REY1MFxcdURGNTdcXHVERjVELVxcdURGNjNcXHVERjY2LVxcdURGNkNcXHVERjcwLVxcdURGNzRdfFxcdUQ4MDVbXFx1REM4MC1cXHVEQ0M1XFx1RENDN1xcdURDRDAtXFx1RENEOVxcdUREODAtXFx1RERCNVxcdUREQjgtXFx1RERDMFxcdURERDgtXFx1RERERFxcdURFMDAtXFx1REU0MFxcdURFNDRcXHVERTUwLVxcdURFNTlcXHVERTgwLVxcdURFQjdcXHVERUMwLVxcdURFQzlcXHVERjAwLVxcdURGMTlcXHVERjFELVxcdURGMkJcXHVERjMwLVxcdURGMzldfFxcdUQ4MDZbXFx1RENBMC1cXHVEQ0U5XFx1RENGRlxcdURFQzAtXFx1REVGOF18XFx1RDgwOFtcXHVEQzAwLVxcdURGOTldfFxcdUQ4MDlbXFx1REMwMC1cXHVEQzZFXFx1REM4MC1cXHVERDQzXXxbXFx1RDgwQ1xcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q1xcdUQ4NkYtXFx1RDg3Ml1bXFx1REMwMC1cXHVERkZGXXxcXHVEODBEW1xcdURDMDAtXFx1REMyRV18XFx1RDgxMVtcXHVEQzAwLVxcdURFNDZdfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REU2MC1cXHVERTY5XFx1REVEMC1cXHVERUVEXFx1REVGMC1cXHVERUY0XFx1REYwMC1cXHVERjM2XFx1REY0MC1cXHVERjQzXFx1REY1MC1cXHVERjU5XFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODFCW1xcdURGMDAtXFx1REY0NFxcdURGNTAtXFx1REY3RVxcdURGOEYtXFx1REY5Rl18XFx1RDgyQ1tcXHVEQzAwXFx1REMwMV18XFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTlcXHVEQzlEXFx1REM5RV18XFx1RDgzNFtcXHVERDY1LVxcdURENjlcXHVERDZELVxcdURENzJcXHVERDdCLVxcdUREODJcXHVERDg1LVxcdUREOEJcXHVEREFBLVxcdUREQURcXHVERTQyLVxcdURFNDRdfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzU0XFx1REM1Ni1cXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REVBNVxcdURFQTgtXFx1REVDMFxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVGQVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYzNFxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY2RVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REZBOFxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDQlxcdURGQ0UtXFx1REZGRl18XFx1RDgzNltcXHVERTAwLVxcdURFMzZcXHVERTNCLVxcdURFNkNcXHVERTc1XFx1REU4NFxcdURFOUItXFx1REU5RlxcdURFQTEtXFx1REVBRl18XFx1RDgzQVtcXHVEQzAwLVxcdURDQzRcXHVEQ0QwLVxcdURDRDZdfFxcdUQ4M0JbXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQl18XFx1RDg2OVtcXHVEQzAwLVxcdURFRDZcXHVERjAwLVxcdURGRkZdfFxcdUQ4NkRbXFx1REMwMC1cXHVERjM0XFx1REY0MC1cXHVERkZGXXxcXHVEODZFW1xcdURDMDAtXFx1REMxRFxcdURDMjAtXFx1REZGRl18XFx1RDg3M1tcXHVEQzAwLVxcdURFQTFdfFxcdUQ4N0VbXFx1REMwMC1cXHVERTFEXXxcXHVEQjQwW1xcdUREMDAtXFx1RERFRl0vXHJcblx0fTtcclxuXHRleHBvcnRzLkNoYXJhY3RlciA9IHtcclxuXHQgICAgLyogdHNsaW50OmRpc2FibGU6bm8tYml0d2lzZSAqL1xyXG5cdCAgICBmcm9tQ29kZVBvaW50OiBmdW5jdGlvbiAoY3ApIHtcclxuXHQgICAgICAgIHJldHVybiAoY3AgPCAweDEwMDAwKSA/IFN0cmluZy5mcm9tQ2hhckNvZGUoY3ApIDpcclxuXHQgICAgICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgwMCArICgoY3AgLSAweDEwMDAwKSA+PiAxMCkpICtcclxuXHQgICAgICAgICAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgweERDMDAgKyAoKGNwIC0gMHgxMDAwMCkgJiAxMDIzKSk7XHJcblx0ICAgIH0sXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXdoaXRlLXNwYWNlXHJcblx0ICAgIGlzV2hpdGVTcGFjZTogZnVuY3Rpb24gKGNwKSB7XHJcblx0ICAgICAgICByZXR1cm4gKGNwID09PSAweDIwKSB8fCAoY3AgPT09IDB4MDkpIHx8IChjcCA9PT0gMHgwQikgfHwgKGNwID09PSAweDBDKSB8fCAoY3AgPT09IDB4QTApIHx8XHJcblx0ICAgICAgICAgICAgKGNwID49IDB4MTY4MCAmJiBbMHgxNjgwLCAweDIwMDAsIDB4MjAwMSwgMHgyMDAyLCAweDIwMDMsIDB4MjAwNCwgMHgyMDA1LCAweDIwMDYsIDB4MjAwNywgMHgyMDA4LCAweDIwMDksIDB4MjAwQSwgMHgyMDJGLCAweDIwNUYsIDB4MzAwMCwgMHhGRUZGXS5pbmRleE9mKGNwKSA+PSAwKTtcclxuXHQgICAgfSxcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGluZS10ZXJtaW5hdG9yc1xyXG5cdCAgICBpc0xpbmVUZXJtaW5hdG9yOiBmdW5jdGlvbiAoY3ApIHtcclxuXHQgICAgICAgIHJldHVybiAoY3AgPT09IDB4MEEpIHx8IChjcCA9PT0gMHgwRCkgfHwgKGNwID09PSAweDIwMjgpIHx8IChjcCA9PT0gMHgyMDI5KTtcclxuXHQgICAgfSxcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbmFtZXMtYW5kLWtleXdvcmRzXHJcblx0ICAgIGlzSWRlbnRpZmllclN0YXJ0OiBmdW5jdGlvbiAoY3ApIHtcclxuXHQgICAgICAgIHJldHVybiAoY3AgPT09IDB4MjQpIHx8IChjcCA9PT0gMHg1RikgfHxcclxuXHQgICAgICAgICAgICAoY3AgPj0gMHg0MSAmJiBjcCA8PSAweDVBKSB8fFxyXG5cdCAgICAgICAgICAgIChjcCA+PSAweDYxICYmIGNwIDw9IDB4N0EpIHx8XHJcblx0ICAgICAgICAgICAgKGNwID09PSAweDVDKSB8fFxyXG5cdCAgICAgICAgICAgICgoY3AgPj0gMHg4MCkgJiYgUmVnZXguTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQudGVzdChleHBvcnRzLkNoYXJhY3Rlci5mcm9tQ29kZVBvaW50KGNwKSkpO1xyXG5cdCAgICB9LFxyXG5cdCAgICBpc0lkZW50aWZpZXJQYXJ0OiBmdW5jdGlvbiAoY3ApIHtcclxuXHQgICAgICAgIHJldHVybiAoY3AgPT09IDB4MjQpIHx8IChjcCA9PT0gMHg1RikgfHxcclxuXHQgICAgICAgICAgICAoY3AgPj0gMHg0MSAmJiBjcCA8PSAweDVBKSB8fFxyXG5cdCAgICAgICAgICAgIChjcCA+PSAweDYxICYmIGNwIDw9IDB4N0EpIHx8XHJcblx0ICAgICAgICAgICAgKGNwID49IDB4MzAgJiYgY3AgPD0gMHgzOSkgfHxcclxuXHQgICAgICAgICAgICAoY3AgPT09IDB4NUMpIHx8XHJcblx0ICAgICAgICAgICAgKChjcCA+PSAweDgwKSAmJiBSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJQYXJ0LnRlc3QoZXhwb3J0cy5DaGFyYWN0ZXIuZnJvbUNvZGVQb2ludChjcCkpKTtcclxuXHQgICAgfSxcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGl0ZXJhbHMtbnVtZXJpYy1saXRlcmFsc1xyXG5cdCAgICBpc0RlY2ltYWxEaWdpdDogZnVuY3Rpb24gKGNwKSB7XHJcblx0ICAgICAgICByZXR1cm4gKGNwID49IDB4MzAgJiYgY3AgPD0gMHgzOSk7IC8vIDAuLjlcclxuXHQgICAgfSxcclxuXHQgICAgaXNIZXhEaWdpdDogZnVuY3Rpb24gKGNwKSB7XHJcblx0ICAgICAgICByZXR1cm4gKGNwID49IDB4MzAgJiYgY3AgPD0gMHgzOSkgfHxcclxuXHQgICAgICAgICAgICAoY3AgPj0gMHg0MSAmJiBjcCA8PSAweDQ2KSB8fFxyXG5cdCAgICAgICAgICAgIChjcCA+PSAweDYxICYmIGNwIDw9IDB4NjYpOyAvLyBhLi5mXHJcblx0ICAgIH0sXHJcblx0ICAgIGlzT2N0YWxEaWdpdDogZnVuY3Rpb24gKGNwKSB7XHJcblx0ICAgICAgICByZXR1cm4gKGNwID49IDB4MzAgJiYgY3AgPD0gMHgzNyk7IC8vIDAuLjdcclxuXHQgICAgfVxyXG5cdH07XHJcblxuXG4vKioqLyB9LFxuLyogNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdHZhciBqc3hfc3ludGF4XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cdC8qIHRzbGludDpkaXNhYmxlOm1heC1jbGFzc2VzLXBlci1maWxlICovXHJcblx0dmFyIEpTWENsb3NpbmdFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYQ2xvc2luZ0VsZW1lbnQobmFtZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hDbG9zaW5nRWxlbWVudDtcclxuXHQgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWENsb3NpbmdFbGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hDbG9zaW5nRWxlbWVudCA9IEpTWENsb3NpbmdFbGVtZW50O1xyXG5cdHZhciBKU1hFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYRWxlbWVudChvcGVuaW5nRWxlbWVudCwgY2hpbGRyZW4sIGNsb3NpbmdFbGVtZW50KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWEVsZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLm9wZW5pbmdFbGVtZW50ID0gb3BlbmluZ0VsZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XHJcblx0ICAgICAgICB0aGlzLmNsb3NpbmdFbGVtZW50ID0gY2xvc2luZ0VsZW1lbnQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWEVsZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWEVsZW1lbnQgPSBKU1hFbGVtZW50O1xyXG5cdHZhciBKU1hFbXB0eUV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hFbXB0eUV4cHJlc3Npb24oKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWEVtcHR5RXhwcmVzc2lvbjtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYRW1wdHlFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hFbXB0eUV4cHJlc3Npb24gPSBKU1hFbXB0eUV4cHJlc3Npb247XHJcblx0dmFyIEpTWEV4cHJlc3Npb25Db250YWluZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hFeHByZXNzaW9uQ29udGFpbmVyKGV4cHJlc3Npb24pIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYRXhwcmVzc2lvbkNvbnRhaW5lcjtcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWEV4cHJlc3Npb25Db250YWluZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWEV4cHJlc3Npb25Db250YWluZXIgPSBKU1hFeHByZXNzaW9uQ29udGFpbmVyO1xyXG5cdHZhciBKU1hJZGVudGlmaWVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYSWRlbnRpZmllcihuYW1lKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWElkZW50aWZpZXI7XHJcblx0ICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hJZGVudGlmaWVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hJZGVudGlmaWVyID0gSlNYSWRlbnRpZmllcjtcclxuXHR2YXIgSlNYTWVtYmVyRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWE1lbWJlckV4cHJlc3Npb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hNZW1iZXJFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcblx0ICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWE1lbWJlckV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWE1lbWJlckV4cHJlc3Npb24gPSBKU1hNZW1iZXJFeHByZXNzaW9uO1xyXG5cdHZhciBKU1hBdHRyaWJ1dGUgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYQXR0cmlidXRlO1xyXG5cdCAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuXHQgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYQXR0cmlidXRlO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hBdHRyaWJ1dGUgPSBKU1hBdHRyaWJ1dGU7XHJcblx0dmFyIEpTWE5hbWVzcGFjZWROYW1lID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYTmFtZXNwYWNlZE5hbWUobmFtZXNwYWNlLCBuYW1lKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWE5hbWVzcGFjZWROYW1lO1xyXG5cdCAgICAgICAgdGhpcy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XHJcblx0ICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hOYW1lc3BhY2VkTmFtZTtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYTmFtZXNwYWNlZE5hbWUgPSBKU1hOYW1lc3BhY2VkTmFtZTtcclxuXHR2YXIgSlNYT3BlbmluZ0VsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hPcGVuaW5nRWxlbWVudChuYW1lLCBzZWxmQ2xvc2luZywgYXR0cmlidXRlcykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hPcGVuaW5nRWxlbWVudDtcclxuXHQgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcblx0ICAgICAgICB0aGlzLnNlbGZDbG9zaW5nID0gc2VsZkNsb3Npbmc7XHJcblx0ICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hPcGVuaW5nRWxlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYT3BlbmluZ0VsZW1lbnQgPSBKU1hPcGVuaW5nRWxlbWVudDtcclxuXHR2YXIgSlNYU3ByZWFkQXR0cmlidXRlID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYU3ByZWFkQXR0cmlidXRlKGFyZ3VtZW50KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWFNwcmVhZEF0dHJpYnV0ZTtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYU3ByZWFkQXR0cmlidXRlO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hTcHJlYWRBdHRyaWJ1dGUgPSBKU1hTcHJlYWRBdHRyaWJ1dGU7XHJcblx0dmFyIEpTWFRleHQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hUZXh0KHZhbHVlLCByYXcpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYVGV4dDtcclxuXHQgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHQgICAgICAgIHRoaXMucmF3ID0gcmF3O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hUZXh0O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hUZXh0ID0gSlNYVGV4dDtcclxuXG5cbi8qKiovIH0sXG4vKiA2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0ZXhwb3J0cy5KU1hTeW50YXggPSB7XHJcblx0ICAgIEpTWEF0dHJpYnV0ZTogJ0pTWEF0dHJpYnV0ZScsXHJcblx0ICAgIEpTWENsb3NpbmdFbGVtZW50OiAnSlNYQ2xvc2luZ0VsZW1lbnQnLFxyXG5cdCAgICBKU1hFbGVtZW50OiAnSlNYRWxlbWVudCcsXHJcblx0ICAgIEpTWEVtcHR5RXhwcmVzc2lvbjogJ0pTWEVtcHR5RXhwcmVzc2lvbicsXHJcblx0ICAgIEpTWEV4cHJlc3Npb25Db250YWluZXI6ICdKU1hFeHByZXNzaW9uQ29udGFpbmVyJyxcclxuXHQgICAgSlNYSWRlbnRpZmllcjogJ0pTWElkZW50aWZpZXInLFxyXG5cdCAgICBKU1hNZW1iZXJFeHByZXNzaW9uOiAnSlNYTWVtYmVyRXhwcmVzc2lvbicsXHJcblx0ICAgIEpTWE5hbWVzcGFjZWROYW1lOiAnSlNYTmFtZXNwYWNlZE5hbWUnLFxyXG5cdCAgICBKU1hPcGVuaW5nRWxlbWVudDogJ0pTWE9wZW5pbmdFbGVtZW50JyxcclxuXHQgICAgSlNYU3ByZWFkQXR0cmlidXRlOiAnSlNYU3ByZWFkQXR0cmlidXRlJyxcclxuXHQgICAgSlNYVGV4dDogJ0pTWFRleHQnXHJcblx0fTtcclxuXG5cbi8qKiovIH0sXG4vKiA3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0dmFyIHN5bnRheF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHQvKiB0c2xpbnQ6ZGlzYWJsZTptYXgtY2xhc3Nlcy1wZXItZmlsZSAqL1xyXG5cdHZhciBBcnJheUV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBBcnJheUV4cHJlc3Npb24oZWxlbWVudHMpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5BcnJheUV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEFycmF5RXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQXJyYXlFeHByZXNzaW9uID0gQXJyYXlFeHByZXNzaW9uO1xyXG5cdHZhciBBcnJheVBhdHRlcm4gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBBcnJheVBhdHRlcm4oZWxlbWVudHMpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5BcnJheVBhdHRlcm47XHJcblx0ICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEFycmF5UGF0dGVybjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQXJyYXlQYXR0ZXJuID0gQXJyYXlQYXR0ZXJuO1xyXG5cdHZhciBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEFycm93RnVuY3Rpb25FeHByZXNzaW9uKHBhcmFtcywgYm9keSwgZXhwcmVzc2lvbikge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkFycm93RnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5pZCA9IG51bGw7XHJcblx0ICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgICAgICB0aGlzLmdlbmVyYXRvciA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuYXN5bmMgPSBmYWxzZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkFycm93RnVuY3Rpb25FeHByZXNzaW9uID0gQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XHJcblx0dmFyIEFzc2lnbm1lbnRFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQXNzaWdubWVudEV4cHJlc3Npb24ob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudEV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XHJcblx0ICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xyXG5cdCAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBBc3NpZ25tZW50RXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQXNzaWdubWVudEV4cHJlc3Npb24gPSBBc3NpZ25tZW50RXhwcmVzc2lvbjtcclxuXHR2YXIgQXNzaWdubWVudFBhdHRlcm4gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBBc3NpZ25tZW50UGF0dGVybihsZWZ0LCByaWdodCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkFzc2lnbm1lbnRQYXR0ZXJuO1xyXG5cdCAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcclxuXHQgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQXNzaWdubWVudFBhdHRlcm47XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkFzc2lnbm1lbnRQYXR0ZXJuID0gQXNzaWdubWVudFBhdHRlcm47XHJcblx0dmFyIEFzeW5jQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBBc3luY0Fycm93RnVuY3Rpb25FeHByZXNzaW9uKHBhcmFtcywgYm9keSwgZXhwcmVzc2lvbikge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkFycm93RnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5pZCA9IG51bGw7XHJcblx0ICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgICAgICB0aGlzLmdlbmVyYXRvciA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuYXN5bmMgPSB0cnVlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBBc3luY0Fycm93RnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Bc3luY0Fycm93RnVuY3Rpb25FeHByZXNzaW9uID0gQXN5bmNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHR2YXIgQXN5bmNGdW5jdGlvbkRlY2xhcmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQXN5bmNGdW5jdGlvbkRlY2xhcmF0aW9uKGlkLCBwYXJhbXMsIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG5cdCAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5hc3luYyA9IHRydWU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEFzeW5jRnVuY3Rpb25EZWNsYXJhdGlvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQXN5bmNGdW5jdGlvbkRlY2xhcmF0aW9uID0gQXN5bmNGdW5jdGlvbkRlY2xhcmF0aW9uO1xyXG5cdHZhciBBc3luY0Z1bmN0aW9uRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEFzeW5jRnVuY3Rpb25FeHByZXNzaW9uKGlkLCBwYXJhbXMsIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5GdW5jdGlvbkV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmlkID0gaWQ7XHJcblx0ICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgICAgICB0aGlzLmdlbmVyYXRvciA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmFzeW5jID0gdHJ1ZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQXN5bmNGdW5jdGlvbkV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkFzeW5jRnVuY3Rpb25FeHByZXNzaW9uID0gQXN5bmNGdW5jdGlvbkV4cHJlc3Npb247XHJcblx0dmFyIEF3YWl0RXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEF3YWl0RXhwcmVzc2lvbihhcmd1bWVudCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkF3YWl0RXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQXdhaXRFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Bd2FpdEV4cHJlc3Npb24gPSBBd2FpdEV4cHJlc3Npb247XHJcblx0dmFyIEJpbmFyeUV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBCaW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xyXG5cdCAgICAgICAgdmFyIGxvZ2ljYWwgPSAob3BlcmF0b3IgPT09ICd8fCcgfHwgb3BlcmF0b3IgPT09ICcmJicpO1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gbG9naWNhbCA/IHN5bnRheF8xLlN5bnRheC5Mb2dpY2FsRXhwcmVzc2lvbiA6IHN5bnRheF8xLlN5bnRheC5CaW5hcnlFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xyXG5cdCAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcclxuXHQgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQmluYXJ5RXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQmluYXJ5RXhwcmVzc2lvbiA9IEJpbmFyeUV4cHJlc3Npb247XHJcblx0dmFyIEJsb2NrU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQmxvY2tTdGF0ZW1lbnQoYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkJsb2NrU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQmxvY2tTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkJsb2NrU3RhdGVtZW50ID0gQmxvY2tTdGF0ZW1lbnQ7XHJcblx0dmFyIEJyZWFrU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQnJlYWtTdGF0ZW1lbnQobGFiZWwpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5CcmVha1N0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQnJlYWtTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkJyZWFrU3RhdGVtZW50ID0gQnJlYWtTdGF0ZW1lbnQ7XHJcblx0dmFyIENhbGxFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQ2FsbEV4cHJlc3Npb24oY2FsbGVlLCBhcmdzKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQ2FsbEV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmNhbGxlZSA9IGNhbGxlZTtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnRzID0gYXJncztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQ2FsbEV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkNhbGxFeHByZXNzaW9uID0gQ2FsbEV4cHJlc3Npb247XHJcblx0dmFyIENhdGNoQ2xhdXNlID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQ2F0Y2hDbGF1c2UocGFyYW0sIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5DYXRjaENsYXVzZTtcclxuXHQgICAgICAgIHRoaXMucGFyYW0gPSBwYXJhbTtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIENhdGNoQ2xhdXNlO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5DYXRjaENsYXVzZSA9IENhdGNoQ2xhdXNlO1xyXG5cdHZhciBDbGFzc0JvZHkgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBDbGFzc0JvZHkoYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkNsYXNzQm9keTtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIENsYXNzQm9keTtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQ2xhc3NCb2R5ID0gQ2xhc3NCb2R5O1xyXG5cdHZhciBDbGFzc0RlY2xhcmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQ2xhc3NEZWNsYXJhdGlvbihpZCwgc3VwZXJDbGFzcywgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkNsYXNzRGVjbGFyYXRpb247XHJcblx0ICAgICAgICB0aGlzLmlkID0gaWQ7XHJcblx0ICAgICAgICB0aGlzLnN1cGVyQ2xhc3MgPSBzdXBlckNsYXNzO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQ2xhc3NEZWNsYXJhdGlvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQ2xhc3NEZWNsYXJhdGlvbiA9IENsYXNzRGVjbGFyYXRpb247XHJcblx0dmFyIENsYXNzRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIENsYXNzRXhwcmVzc2lvbihpZCwgc3VwZXJDbGFzcywgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkNsYXNzRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuaWQgPSBpZDtcclxuXHQgICAgICAgIHRoaXMuc3VwZXJDbGFzcyA9IHN1cGVyQ2xhc3M7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBDbGFzc0V4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkNsYXNzRXhwcmVzc2lvbiA9IENsYXNzRXhwcmVzc2lvbjtcclxuXHR2YXIgQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uKG9iamVjdCwgcHJvcGVydHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5NZW1iZXJFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5jb21wdXRlZCA9IHRydWU7XHJcblx0ICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuXHQgICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Db21wdXRlZE1lbWJlckV4cHJlc3Npb24gPSBDb21wdXRlZE1lbWJlckV4cHJlc3Npb247XHJcblx0dmFyIENvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIENvbmRpdGlvbmFsRXhwcmVzc2lvbih0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Db25kaXRpb25hbEV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xyXG5cdCAgICAgICAgdGhpcy5jb25zZXF1ZW50ID0gY29uc2VxdWVudDtcclxuXHQgICAgICAgIHRoaXMuYWx0ZXJuYXRlID0gYWx0ZXJuYXRlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBDb25kaXRpb25hbEV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkNvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IENvbmRpdGlvbmFsRXhwcmVzc2lvbjtcclxuXHR2YXIgQ29udGludWVTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBDb250aW51ZVN0YXRlbWVudChsYWJlbCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkNvbnRpbnVlU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBDb250aW51ZVN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQ29udGludWVTdGF0ZW1lbnQgPSBDb250aW51ZVN0YXRlbWVudDtcclxuXHR2YXIgRGVidWdnZXJTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBEZWJ1Z2dlclN0YXRlbWVudCgpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5EZWJ1Z2dlclN0YXRlbWVudDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRGVidWdnZXJTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkRlYnVnZ2VyU3RhdGVtZW50ID0gRGVidWdnZXJTdGF0ZW1lbnQ7XHJcblx0dmFyIERpcmVjdGl2ZSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIERpcmVjdGl2ZShleHByZXNzaW9uLCBkaXJlY3RpdmUpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuZGlyZWN0aXZlID0gZGlyZWN0aXZlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBEaXJlY3RpdmU7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkRpcmVjdGl2ZSA9IERpcmVjdGl2ZTtcclxuXHR2YXIgRG9XaGlsZVN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIERvV2hpbGVTdGF0ZW1lbnQoYm9keSwgdGVzdCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkRvV2hpbGVTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRG9XaGlsZVN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRG9XaGlsZVN0YXRlbWVudCA9IERvV2hpbGVTdGF0ZW1lbnQ7XHJcblx0dmFyIEVtcHR5U3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRW1wdHlTdGF0ZW1lbnQoKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRW1wdHlTdGF0ZW1lbnQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEVtcHR5U3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5FbXB0eVN0YXRlbWVudCA9IEVtcHR5U3RhdGVtZW50O1xyXG5cdHZhciBFeHBvcnRBbGxEZWNsYXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEV4cG9ydEFsbERlY2xhcmF0aW9uKHNvdXJjZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkV4cG9ydEFsbERlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEV4cG9ydEFsbERlY2xhcmF0aW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5FeHBvcnRBbGxEZWNsYXJhdGlvbiA9IEV4cG9ydEFsbERlY2xhcmF0aW9uO1xyXG5cdHZhciBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24oZGVjbGFyYXRpb24pIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5FeHBvcnREZWZhdWx0RGVjbGFyYXRpb247XHJcblx0ICAgICAgICB0aGlzLmRlY2xhcmF0aW9uID0gZGVjbGFyYXRpb247XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uID0gRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uO1xyXG5cdHZhciBFeHBvcnROYW1lZERlY2xhcmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRXhwb3J0TmFtZWREZWNsYXJhdGlvbihkZWNsYXJhdGlvbiwgc3BlY2lmaWVycywgc291cmNlKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRXhwb3J0TmFtZWREZWNsYXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuZGVjbGFyYXRpb24gPSBkZWNsYXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuc3BlY2lmaWVycyA9IHNwZWNpZmllcnM7XHJcblx0ICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRXhwb3J0TmFtZWREZWNsYXJhdGlvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRXhwb3J0TmFtZWREZWNsYXJhdGlvbiA9IEV4cG9ydE5hbWVkRGVjbGFyYXRpb247XHJcblx0dmFyIEV4cG9ydFNwZWNpZmllciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEV4cG9ydFNwZWNpZmllcihsb2NhbCwgZXhwb3J0ZWQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5FeHBvcnRTcGVjaWZpZXI7XHJcblx0ICAgICAgICB0aGlzLmV4cG9ydGVkID0gZXhwb3J0ZWQ7XHJcblx0ICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWw7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEV4cG9ydFNwZWNpZmllcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRXhwb3J0U3BlY2lmaWVyID0gRXhwb3J0U3BlY2lmaWVyO1xyXG5cdHZhciBFeHByZXNzaW9uU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRXhwcmVzc2lvblN0YXRlbWVudChleHByZXNzaW9uKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRXhwcmVzc2lvblN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEV4cHJlc3Npb25TdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkV4cHJlc3Npb25TdGF0ZW1lbnQgPSBFeHByZXNzaW9uU3RhdGVtZW50O1xyXG5cdHZhciBGb3JJblN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEZvckluU3RhdGVtZW50KGxlZnQsIHJpZ2h0LCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRm9ySW5TdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xyXG5cdCAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgICAgIHRoaXMuZWFjaCA9IGZhbHNlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBGb3JJblN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRm9ySW5TdGF0ZW1lbnQgPSBGb3JJblN0YXRlbWVudDtcclxuXHR2YXIgRm9yT2ZTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBGb3JPZlN0YXRlbWVudChsZWZ0LCByaWdodCwgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkZvck9mU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcclxuXHQgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEZvck9mU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Gb3JPZlN0YXRlbWVudCA9IEZvck9mU3RhdGVtZW50O1xyXG5cdHZhciBGb3JTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBGb3JTdGF0ZW1lbnQoaW5pdCwgdGVzdCwgdXBkYXRlLCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRm9yU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5pbml0ID0gaW5pdDtcclxuXHQgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XHJcblx0ICAgICAgICB0aGlzLnVwZGF0ZSA9IHVwZGF0ZTtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEZvclN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRm9yU3RhdGVtZW50ID0gRm9yU3RhdGVtZW50O1xyXG5cdHZhciBGdW5jdGlvbkRlY2xhcmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRnVuY3Rpb25EZWNsYXJhdGlvbihpZCwgcGFyYW1zLCBib2R5LCBnZW5lcmF0b3IpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG5cdCAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuYXN5bmMgPSBmYWxzZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRnVuY3Rpb25EZWNsYXJhdGlvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRnVuY3Rpb25EZWNsYXJhdGlvbiA9IEZ1bmN0aW9uRGVjbGFyYXRpb247XHJcblx0dmFyIEZ1bmN0aW9uRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEZ1bmN0aW9uRXhwcmVzc2lvbihpZCwgcGFyYW1zLCBib2R5LCBnZW5lcmF0b3IpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5GdW5jdGlvbkV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmlkID0gaWQ7XHJcblx0ICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgICAgICB0aGlzLmdlbmVyYXRvciA9IGdlbmVyYXRvcjtcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5hc3luYyA9IGZhbHNlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBGdW5jdGlvbkV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkZ1bmN0aW9uRXhwcmVzc2lvbiA9IEZ1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHR2YXIgSWRlbnRpZmllciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIElkZW50aWZpZXIobmFtZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXI7XHJcblx0ICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBJZGVudGlmaWVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5JZGVudGlmaWVyID0gSWRlbnRpZmllcjtcclxuXHR2YXIgSWZTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBJZlN0YXRlbWVudCh0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5JZlN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XHJcblx0ICAgICAgICB0aGlzLmNvbnNlcXVlbnQgPSBjb25zZXF1ZW50O1xyXG5cdCAgICAgICAgdGhpcy5hbHRlcm5hdGUgPSBhbHRlcm5hdGU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIElmU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5JZlN0YXRlbWVudCA9IElmU3RhdGVtZW50O1xyXG5cdHZhciBJbXBvcnREZWNsYXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEltcG9ydERlY2xhcmF0aW9uKHNwZWNpZmllcnMsIHNvdXJjZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkltcG9ydERlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5zcGVjaWZpZXJzID0gc3BlY2lmaWVycztcclxuXHQgICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBJbXBvcnREZWNsYXJhdGlvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSW1wb3J0RGVjbGFyYXRpb24gPSBJbXBvcnREZWNsYXJhdGlvbjtcclxuXHR2YXIgSW1wb3J0RGVmYXVsdFNwZWNpZmllciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEltcG9ydERlZmF1bHRTcGVjaWZpZXIobG9jYWwpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5JbXBvcnREZWZhdWx0U3BlY2lmaWVyO1xyXG5cdCAgICAgICAgdGhpcy5sb2NhbCA9IGxvY2FsO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBJbXBvcnREZWZhdWx0U3BlY2lmaWVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5JbXBvcnREZWZhdWx0U3BlY2lmaWVyID0gSW1wb3J0RGVmYXVsdFNwZWNpZmllcjtcclxuXHR2YXIgSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKGxvY2FsKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyO1xyXG5cdCAgICAgICAgdGhpcy5sb2NhbCA9IGxvY2FsO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkltcG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcclxuXHR2YXIgSW1wb3J0U3BlY2lmaWVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSW1wb3J0U3BlY2lmaWVyKGxvY2FsLCBpbXBvcnRlZCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkltcG9ydFNwZWNpZmllcjtcclxuXHQgICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbDtcclxuXHQgICAgICAgIHRoaXMuaW1wb3J0ZWQgPSBpbXBvcnRlZDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSW1wb3J0U3BlY2lmaWVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5JbXBvcnRTcGVjaWZpZXIgPSBJbXBvcnRTcGVjaWZpZXI7XHJcblx0dmFyIExhYmVsZWRTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBMYWJlbGVkU3RhdGVtZW50KGxhYmVsLCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguTGFiZWxlZFN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIExhYmVsZWRTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkxhYmVsZWRTdGF0ZW1lbnQgPSBMYWJlbGVkU3RhdGVtZW50O1xyXG5cdHZhciBMaXRlcmFsID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gTGl0ZXJhbCh2YWx1ZSwgcmF3KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguTGl0ZXJhbDtcclxuXHQgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHQgICAgICAgIHRoaXMucmF3ID0gcmF3O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBMaXRlcmFsO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5MaXRlcmFsID0gTGl0ZXJhbDtcclxuXHR2YXIgTWV0YVByb3BlcnR5ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gTWV0YVByb3BlcnR5KG1ldGEsIHByb3BlcnR5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguTWV0YVByb3BlcnR5O1xyXG5cdCAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcclxuXHQgICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gTWV0YVByb3BlcnR5O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5NZXRhUHJvcGVydHkgPSBNZXRhUHJvcGVydHk7XHJcblx0dmFyIE1ldGhvZERlZmluaXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBNZXRob2REZWZpbml0aW9uKGtleSwgY29tcHV0ZWQsIHZhbHVlLCBraW5kLCBpc1N0YXRpYykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4Lk1ldGhvZERlZmluaXRpb247XHJcblx0ICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuXHQgICAgICAgIHRoaXMuY29tcHV0ZWQgPSBjb21wdXRlZDtcclxuXHQgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHQgICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XHJcblx0ICAgICAgICB0aGlzLnN0YXRpYyA9IGlzU3RhdGljO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBNZXRob2REZWZpbml0aW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5NZXRob2REZWZpbml0aW9uID0gTWV0aG9kRGVmaW5pdGlvbjtcclxuXHR2YXIgTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gTW9kdWxlKGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Qcm9ncmFtO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgICAgIHRoaXMuc291cmNlVHlwZSA9ICdtb2R1bGUnO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBNb2R1bGU7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLk1vZHVsZSA9IE1vZHVsZTtcclxuXHR2YXIgTmV3RXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIE5ld0V4cHJlc3Npb24oY2FsbGVlLCBhcmdzKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguTmV3RXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuY2FsbGVlID0gY2FsbGVlO1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudHMgPSBhcmdzO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBOZXdFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5OZXdFeHByZXNzaW9uID0gTmV3RXhwcmVzc2lvbjtcclxuXHR2YXIgT2JqZWN0RXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIE9iamVjdEV4cHJlc3Npb24ocHJvcGVydGllcykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4Lk9iamVjdEV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBPYmplY3RFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5PYmplY3RFeHByZXNzaW9uID0gT2JqZWN0RXhwcmVzc2lvbjtcclxuXHR2YXIgT2JqZWN0UGF0dGVybiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIE9iamVjdFBhdHRlcm4ocHJvcGVydGllcykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4Lk9iamVjdFBhdHRlcm47XHJcblx0ICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBPYmplY3RQYXR0ZXJuO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5PYmplY3RQYXR0ZXJuID0gT2JqZWN0UGF0dGVybjtcclxuXHR2YXIgUHJvcGVydHkgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBQcm9wZXJ0eShraW5kLCBrZXksIGNvbXB1dGVkLCB2YWx1ZSwgbWV0aG9kLCBzaG9ydGhhbmQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Qcm9wZXJ0eTtcclxuXHQgICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG5cdCAgICAgICAgdGhpcy5jb21wdXRlZCA9IGNvbXB1dGVkO1xyXG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG5cdCAgICAgICAgdGhpcy5raW5kID0ga2luZDtcclxuXHQgICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xyXG5cdCAgICAgICAgdGhpcy5zaG9ydGhhbmQgPSBzaG9ydGhhbmQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFByb3BlcnR5O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Qcm9wZXJ0eSA9IFByb3BlcnR5O1xyXG5cdHZhciBSZWdleExpdGVyYWwgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBSZWdleExpdGVyYWwodmFsdWUsIHJhdywgcGF0dGVybiwgZmxhZ3MpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5MaXRlcmFsO1xyXG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG5cdCAgICAgICAgdGhpcy5yYXcgPSByYXc7XHJcblx0ICAgICAgICB0aGlzLnJlZ2V4ID0geyBwYXR0ZXJuOiBwYXR0ZXJuLCBmbGFnczogZmxhZ3MgfTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gUmVnZXhMaXRlcmFsO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5SZWdleExpdGVyYWwgPSBSZWdleExpdGVyYWw7XHJcblx0dmFyIFJlc3RFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gUmVzdEVsZW1lbnQoYXJndW1lbnQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5SZXN0RWxlbWVudDtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gUmVzdEVsZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlJlc3RFbGVtZW50ID0gUmVzdEVsZW1lbnQ7XHJcblx0dmFyIFJldHVyblN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFJldHVyblN0YXRlbWVudChhcmd1bWVudCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlJldHVyblN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gUmV0dXJuU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5SZXR1cm5TdGF0ZW1lbnQgPSBSZXR1cm5TdGF0ZW1lbnQ7XHJcblx0dmFyIFNjcmlwdCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFNjcmlwdChib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguUHJvZ3JhbTtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgICAgICB0aGlzLnNvdXJjZVR5cGUgPSAnc2NyaXB0JztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gU2NyaXB0O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5TY3JpcHQgPSBTY3JpcHQ7XHJcblx0dmFyIFNlcXVlbmNlRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFNlcXVlbmNlRXhwcmVzc2lvbihleHByZXNzaW9ucykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlNlcXVlbmNlRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gU2VxdWVuY2VFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5TZXF1ZW5jZUV4cHJlc3Npb24gPSBTZXF1ZW5jZUV4cHJlc3Npb247XHJcblx0dmFyIFNwcmVhZEVsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBTcHJlYWRFbGVtZW50KGFyZ3VtZW50KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguU3ByZWFkRWxlbWVudDtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gU3ByZWFkRWxlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuU3ByZWFkRWxlbWVudCA9IFNwcmVhZEVsZW1lbnQ7XHJcblx0dmFyIFN0YXRpY01lbWJlckV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBTdGF0aWNNZW1iZXJFeHByZXNzaW9uKG9iamVjdCwgcHJvcGVydHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5NZW1iZXJFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5jb21wdXRlZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcblx0ICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFN0YXRpY01lbWJlckV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlN0YXRpY01lbWJlckV4cHJlc3Npb24gPSBTdGF0aWNNZW1iZXJFeHByZXNzaW9uO1xyXG5cdHZhciBTdXBlciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFN1cGVyKCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlN1cGVyO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBTdXBlcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuU3VwZXIgPSBTdXBlcjtcclxuXHR2YXIgU3dpdGNoQ2FzZSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFN3aXRjaENhc2UodGVzdCwgY29uc2VxdWVudCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlN3aXRjaENhc2U7XHJcblx0ICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xyXG5cdCAgICAgICAgdGhpcy5jb25zZXF1ZW50ID0gY29uc2VxdWVudDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gU3dpdGNoQ2FzZTtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuU3dpdGNoQ2FzZSA9IFN3aXRjaENhc2U7XHJcblx0dmFyIFN3aXRjaFN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFN3aXRjaFN0YXRlbWVudChkaXNjcmltaW5hbnQsIGNhc2VzKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguU3dpdGNoU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5kaXNjcmltaW5hbnQgPSBkaXNjcmltaW5hbnQ7XHJcblx0ICAgICAgICB0aGlzLmNhc2VzID0gY2FzZXM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFN3aXRjaFN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuU3dpdGNoU3RhdGVtZW50ID0gU3dpdGNoU3RhdGVtZW50O1xyXG5cdHZhciBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24odGFnLCBxdWFzaSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMudGFnID0gdGFnO1xyXG5cdCAgICAgICAgdGhpcy5xdWFzaSA9IHF1YXNpO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbiA9IFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjtcclxuXHR2YXIgVGVtcGxhdGVFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVGVtcGxhdGVFbGVtZW50KHZhbHVlLCB0YWlsKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVGVtcGxhdGVFbGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG5cdCAgICAgICAgdGhpcy50YWlsID0gdGFpbDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gVGVtcGxhdGVFbGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5UZW1wbGF0ZUVsZW1lbnQgPSBUZW1wbGF0ZUVsZW1lbnQ7XHJcblx0dmFyIFRlbXBsYXRlTGl0ZXJhbCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFRlbXBsYXRlTGl0ZXJhbChxdWFzaXMsIGV4cHJlc3Npb25zKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVGVtcGxhdGVMaXRlcmFsO1xyXG5cdCAgICAgICAgdGhpcy5xdWFzaXMgPSBxdWFzaXM7XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFRlbXBsYXRlTGl0ZXJhbDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVGVtcGxhdGVMaXRlcmFsID0gVGVtcGxhdGVMaXRlcmFsO1xyXG5cdHZhciBUaGlzRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFRoaXNFeHByZXNzaW9uKCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlRoaXNFeHByZXNzaW9uO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBUaGlzRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVGhpc0V4cHJlc3Npb24gPSBUaGlzRXhwcmVzc2lvbjtcclxuXHR2YXIgVGhyb3dTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBUaHJvd1N0YXRlbWVudChhcmd1bWVudCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlRocm93U3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBUaHJvd1N0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVGhyb3dTdGF0ZW1lbnQgPSBUaHJvd1N0YXRlbWVudDtcclxuXHR2YXIgVHJ5U3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVHJ5U3RhdGVtZW50KGJsb2NrLCBoYW5kbGVyLCBmaW5hbGl6ZXIpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5UcnlTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmJsb2NrID0gYmxvY2s7XHJcblx0ICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xyXG5cdCAgICAgICAgdGhpcy5maW5hbGl6ZXIgPSBmaW5hbGl6ZXI7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFRyeVN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVHJ5U3RhdGVtZW50ID0gVHJ5U3RhdGVtZW50O1xyXG5cdHZhciBVbmFyeUV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBVbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGFyZ3VtZW50KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVW5hcnlFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xyXG5cdCAgICAgICAgdGhpcy5wcmVmaXggPSB0cnVlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBVbmFyeUV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlVuYXJ5RXhwcmVzc2lvbiA9IFVuYXJ5RXhwcmVzc2lvbjtcclxuXHR2YXIgVXBkYXRlRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFVwZGF0ZUV4cHJlc3Npb24ob3BlcmF0b3IsIGFyZ3VtZW50LCBwcmVmaXgpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5VcGRhdGVFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xyXG5cdCAgICAgICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFVwZGF0ZUV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlVwZGF0ZUV4cHJlc3Npb24gPSBVcGRhdGVFeHByZXNzaW9uO1xyXG5cdHZhciBWYXJpYWJsZURlY2xhcmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsIGtpbmQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5kZWNsYXJhdGlvbnMgPSBkZWNsYXJhdGlvbnM7XHJcblx0ICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBWYXJpYWJsZURlY2xhcmF0aW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5WYXJpYWJsZURlY2xhcmF0aW9uID0gVmFyaWFibGVEZWNsYXJhdGlvbjtcclxuXHR2YXIgVmFyaWFibGVEZWNsYXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVmFyaWFibGVEZWNsYXJhdG9yKGlkLCBpbml0KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVmFyaWFibGVEZWNsYXJhdG9yO1xyXG5cdCAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG5cdCAgICAgICAgdGhpcy5pbml0ID0gaW5pdDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gVmFyaWFibGVEZWNsYXJhdG9yO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5WYXJpYWJsZURlY2xhcmF0b3IgPSBWYXJpYWJsZURlY2xhcmF0b3I7XHJcblx0dmFyIFdoaWxlU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gV2hpbGVTdGF0ZW1lbnQodGVzdCwgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LldoaWxlU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFdoaWxlU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5XaGlsZVN0YXRlbWVudCA9IFdoaWxlU3RhdGVtZW50O1xyXG5cdHZhciBXaXRoU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gV2l0aFN0YXRlbWVudChvYmplY3QsIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5XaXRoU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBXaXRoU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5XaXRoU3RhdGVtZW50ID0gV2l0aFN0YXRlbWVudDtcclxuXHR2YXIgWWllbGRFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gWWllbGRFeHByZXNzaW9uKGFyZ3VtZW50LCBkZWxlZ2F0ZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LllpZWxkRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcclxuXHQgICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gWWllbGRFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5ZaWVsZEV4cHJlc3Npb24gPSBZaWVsZEV4cHJlc3Npb247XHJcblxuXG4vKioqLyB9LFxuLyogOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdHZhciBhc3NlcnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XHJcblx0dmFyIGVycm9yX2hhbmRsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG5cdHZhciBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XHJcblx0dmFyIE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG5cdHZhciBzY2FubmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcclxuXHR2YXIgc3ludGF4XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cdHZhciB0b2tlbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcblx0dmFyIEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIgPSAnQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcic7XHJcblx0dmFyIFBhcnNlciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFBhcnNlcihjb2RlLCBvcHRpb25zLCBkZWxlZ2F0ZSkge1xyXG5cdCAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuXHQgICAgICAgIHRoaXMuY29uZmlnID0ge1xyXG5cdCAgICAgICAgICAgIHJhbmdlOiAodHlwZW9mIG9wdGlvbnMucmFuZ2UgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5yYW5nZSxcclxuXHQgICAgICAgICAgICBsb2M6ICh0eXBlb2Ygb3B0aW9ucy5sb2MgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5sb2MsXHJcblx0ICAgICAgICAgICAgc291cmNlOiBudWxsLFxyXG5cdCAgICAgICAgICAgIHRva2VuczogKHR5cGVvZiBvcHRpb25zLnRva2VucyA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLnRva2VucyxcclxuXHQgICAgICAgICAgICBjb21tZW50OiAodHlwZW9mIG9wdGlvbnMuY29tbWVudCA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLmNvbW1lbnQsXHJcblx0ICAgICAgICAgICAgdG9sZXJhbnQ6ICh0eXBlb2Ygb3B0aW9ucy50b2xlcmFudCA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLnRvbGVyYW50XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxvYyAmJiBvcHRpb25zLnNvdXJjZSAmJiBvcHRpb25zLnNvdXJjZSAhPT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29uZmlnLnNvdXJjZSA9IFN0cmluZyhvcHRpb25zLnNvdXJjZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XHJcblx0ICAgICAgICB0aGlzLmVycm9ySGFuZGxlciA9IG5ldyBlcnJvcl9oYW5kbGVyXzEuRXJyb3JIYW5kbGVyKCk7XHJcblx0ICAgICAgICB0aGlzLmVycm9ySGFuZGxlci50b2xlcmFudCA9IHRoaXMuY29uZmlnLnRvbGVyYW50O1xyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyID0gbmV3IHNjYW5uZXJfMS5TY2FubmVyKGNvZGUsIHRoaXMuZXJyb3JIYW5kbGVyKTtcclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lci50cmFja0NvbW1lbnQgPSB0aGlzLmNvbmZpZy5jb21tZW50O1xyXG5cdCAgICAgICAgdGhpcy5vcGVyYXRvclByZWNlZGVuY2UgPSB7XHJcblx0ICAgICAgICAgICAgJyknOiAwLFxyXG5cdCAgICAgICAgICAgICc7JzogMCxcclxuXHQgICAgICAgICAgICAnLCc6IDAsXHJcblx0ICAgICAgICAgICAgJz0nOiAwLFxyXG5cdCAgICAgICAgICAgICddJzogMCxcclxuXHQgICAgICAgICAgICAnfHwnOiAxLFxyXG5cdCAgICAgICAgICAgICcmJic6IDIsXHJcblx0ICAgICAgICAgICAgJ3wnOiAzLFxyXG5cdCAgICAgICAgICAgICdeJzogNCxcclxuXHQgICAgICAgICAgICAnJic6IDUsXHJcblx0ICAgICAgICAgICAgJz09JzogNixcclxuXHQgICAgICAgICAgICAnIT0nOiA2LFxyXG5cdCAgICAgICAgICAgICc9PT0nOiA2LFxyXG5cdCAgICAgICAgICAgICchPT0nOiA2LFxyXG5cdCAgICAgICAgICAgICc8JzogNyxcclxuXHQgICAgICAgICAgICAnPic6IDcsXHJcblx0ICAgICAgICAgICAgJzw9JzogNyxcclxuXHQgICAgICAgICAgICAnPj0nOiA3LFxyXG5cdCAgICAgICAgICAgICc8PCc6IDgsXHJcblx0ICAgICAgICAgICAgJz4+JzogOCxcclxuXHQgICAgICAgICAgICAnPj4+JzogOCxcclxuXHQgICAgICAgICAgICAnKyc6IDksXHJcblx0ICAgICAgICAgICAgJy0nOiA5LFxyXG5cdCAgICAgICAgICAgICcqJzogMTEsXHJcblx0ICAgICAgICAgICAgJy8nOiAxMSxcclxuXHQgICAgICAgICAgICAnJSc6IDExXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgdGhpcy5sb29rYWhlYWQgPSB7XHJcblx0ICAgICAgICAgICAgdHlwZTogMiAvKiBFT0YgKi8sXHJcblx0ICAgICAgICAgICAgdmFsdWU6ICcnLFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogMCxcclxuXHQgICAgICAgICAgICBzdGFydDogMCxcclxuXHQgICAgICAgICAgICBlbmQ6IDBcclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICB0aGlzLmhhc0xpbmVUZXJtaW5hdG9yID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQgPSB7XHJcblx0ICAgICAgICAgICAgaXNNb2R1bGU6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGF3YWl0OiBmYWxzZSxcclxuXHQgICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxyXG5cdCAgICAgICAgICAgIGFsbG93U3RyaWN0RGlyZWN0aXZlOiB0cnVlLFxyXG5cdCAgICAgICAgICAgIGFsbG93WWllbGQ6IHRydWUsXHJcblx0ICAgICAgICAgICAgZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yOiBudWxsLFxyXG5cdCAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldDogZmFsc2UsXHJcblx0ICAgICAgICAgICAgaXNCaW5kaW5nRWxlbWVudDogZmFsc2UsXHJcblx0ICAgICAgICAgICAgaW5GdW5jdGlvbkJvZHk6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGluSXRlcmF0aW9uOiBmYWxzZSxcclxuXHQgICAgICAgICAgICBpblN3aXRjaDogZmFsc2UsXHJcblx0ICAgICAgICAgICAgbGFiZWxTZXQ6IHt9LFxyXG5cdCAgICAgICAgICAgIHN0cmljdDogZmFsc2VcclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICB0aGlzLnRva2VucyA9IFtdO1xyXG5cdCAgICAgICAgdGhpcy5zdGFydE1hcmtlciA9IHtcclxuXHQgICAgICAgICAgICBpbmRleDogMCxcclxuXHQgICAgICAgICAgICBsaW5lOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBjb2x1bW46IDBcclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIgPSB7XHJcblx0ICAgICAgICAgICAgaW5kZXg6IDAsXHJcblx0ICAgICAgICAgICAgbGluZTogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgY29sdW1uOiAwXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlciA9IHtcclxuXHQgICAgICAgICAgICBpbmRleDogdGhpcy5zY2FubmVyLmluZGV4LFxyXG5cdCAgICAgICAgICAgIGxpbmU6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfVxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnRocm93RXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZUZvcm1hdCkge1xyXG5cdCAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xyXG5cdCAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuXHQgICAgICAgICAgICB2YWx1ZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcblx0ICAgICAgICB2YXIgbXNnID0gbWVzc2FnZUZvcm1hdC5yZXBsYWNlKC8lKFxcZCkvZywgZnVuY3Rpb24gKHdob2xlLCBpZHgpIHtcclxuXHQgICAgICAgICAgICBhc3NlcnRfMS5hc3NlcnQoaWR4IDwgYXJncy5sZW5ndGgsICdNZXNzYWdlIHJlZmVyZW5jZSBtdXN0IGJlIGluIHJhbmdlJyk7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIGFyZ3NbaWR4XTtcclxuXHQgICAgICAgIH0pO1xyXG5cdCAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5sYXN0TWFya2VyLmluZGV4O1xyXG5cdCAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmxhc3RNYXJrZXIubGluZTtcclxuXHQgICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmxhc3RNYXJrZXIuY29sdW1uICsgMTtcclxuXHQgICAgICAgIHRocm93IHRoaXMuZXJyb3JIYW5kbGVyLmNyZWF0ZUVycm9yKGluZGV4LCBsaW5lLCBjb2x1bW4sIG1zZyk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUudG9sZXJhdGVFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlRm9ybWF0KSB7XHJcblx0ICAgICAgICB2YXIgdmFsdWVzID0gW107XHJcblx0ICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG5cdCAgICAgICAgICAgIHZhbHVlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHQgICAgICAgIHZhciBtc2cgPSBtZXNzYWdlRm9ybWF0LnJlcGxhY2UoLyUoXFxkKS9nLCBmdW5jdGlvbiAod2hvbGUsIGlkeCkge1xyXG5cdCAgICAgICAgICAgIGFzc2VydF8xLmFzc2VydChpZHggPCBhcmdzLmxlbmd0aCwgJ01lc3NhZ2UgcmVmZXJlbmNlIG11c3QgYmUgaW4gcmFuZ2UnKTtcclxuXHQgICAgICAgICAgICByZXR1cm4gYXJnc1tpZHhdO1xyXG5cdCAgICAgICAgfSk7XHJcblx0ICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmxhc3RNYXJrZXIuaW5kZXg7XHJcblx0ICAgICAgICB2YXIgbGluZSA9IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMubGFzdE1hcmtlci5jb2x1bW4gKyAxO1xyXG5cdCAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIudG9sZXJhdGVFcnJvcihpbmRleCwgbGluZSwgY29sdW1uLCBtc2cpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBUaHJvdyBhbiBleGNlcHRpb24gYmVjYXVzZSBvZiB0aGUgdG9rZW4uXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUudW5leHBlY3RlZFRva2VuRXJyb3IgPSBmdW5jdGlvbiAodG9rZW4sIG1lc3NhZ2UpIHtcclxuXHQgICAgICAgIHZhciBtc2cgPSBtZXNzYWdlIHx8IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuO1xyXG5cdCAgICAgICAgdmFyIHZhbHVlO1xyXG5cdCAgICAgICAgaWYgKHRva2VuKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCFtZXNzYWdlKSB7XHJcblx0ICAgICAgICAgICAgICAgIG1zZyA9ICh0b2tlbi50eXBlID09PSAyIC8qIEVPRiAqLykgPyBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRFT1MgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykgPyBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRJZGVudGlmaWVyIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAodG9rZW4udHlwZSA9PT0gNiAvKiBOdW1lcmljTGl0ZXJhbCAqLykgPyBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWROdW1iZXIgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAodG9rZW4udHlwZSA9PT0gOCAvKiBTdHJpbmdMaXRlcmFsICovKSA/IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFN0cmluZyA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodG9rZW4udHlwZSA9PT0gMTAgLyogVGVtcGxhdGUgKi8pID8gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVGVtcGxhdGUgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gNCAvKiBLZXl3b3JkICovKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzRnV0dXJlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1zZyA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFJlc2VydmVkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiB0aGlzLnNjYW5uZXIuaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1zZyA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHZhbHVlID0gdG9rZW4udmFsdWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB2YWx1ZSA9ICdJTExFR0FMJztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIG1zZyA9IG1zZy5yZXBsYWNlKCclMCcsIHZhbHVlKTtcclxuXHQgICAgICAgIGlmICh0b2tlbiAmJiB0eXBlb2YgdG9rZW4ubGluZU51bWJlciA9PT0gJ251bWJlcicpIHtcclxuXHQgICAgICAgICAgICB2YXIgaW5kZXggPSB0b2tlbi5zdGFydDtcclxuXHQgICAgICAgICAgICB2YXIgbGluZSA9IHRva2VuLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICAgICAgdmFyIGxhc3RNYXJrZXJMaW5lU3RhcnQgPSB0aGlzLmxhc3RNYXJrZXIuaW5kZXggLSB0aGlzLmxhc3RNYXJrZXIuY29sdW1uO1xyXG5cdCAgICAgICAgICAgIHZhciBjb2x1bW4gPSB0b2tlbi5zdGFydCAtIGxhc3RNYXJrZXJMaW5lU3RhcnQgKyAxO1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9ySGFuZGxlci5jcmVhdGVFcnJvcihpbmRleCwgbGluZSwgY29sdW1uLCBtc2cpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5sYXN0TWFya2VyLmluZGV4O1xyXG5cdCAgICAgICAgICAgIHZhciBsaW5lID0gdGhpcy5sYXN0TWFya2VyLmxpbmU7XHJcblx0ICAgICAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMubGFzdE1hcmtlci5jb2x1bW4gKyAxO1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9ySGFuZGxlci5jcmVhdGVFcnJvcihpbmRleCwgbGluZSwgY29sdW1uLCBtc2cpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnRocm93VW5leHBlY3RlZFRva2VuID0gZnVuY3Rpb24gKHRva2VuLCBtZXNzYWdlKSB7XHJcblx0ICAgICAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWRUb2tlbkVycm9yKHRva2VuLCBtZXNzYWdlKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbiwgbWVzc2FnZSkge1xyXG5cdCAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIudG9sZXJhdGUodGhpcy51bmV4cGVjdGVkVG9rZW5FcnJvcih0b2tlbiwgbWVzc2FnZSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmNvbGxlY3RDb21tZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICghdGhpcy5jb25maWcuY29tbWVudCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5zY2FuQ29tbWVudHMoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHZhciBjb21tZW50cyA9IHRoaXMuc2Nhbm5lci5zY2FuQ29tbWVudHMoKTtcclxuXHQgICAgICAgICAgICBpZiAoY29tbWVudHMubGVuZ3RoID4gMCAmJiB0aGlzLmRlbGVnYXRlKSB7XHJcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tbWVudHMubGVuZ3RoOyArK2kpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBlID0gY29tbWVudHNbaV07XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHZvaWQgMDtcclxuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZS5tdWx0aUxpbmUgPyAnQmxvY2tDb21tZW50JyA6ICdMaW5lQ29tbWVudCcsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuc2Nhbm5lci5zb3VyY2Uuc2xpY2UoZS5zbGljZVswXSwgZS5zbGljZVsxXSlcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcucmFuZ2UpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJhbmdlID0gZS5yYW5nZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5sb2MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmxvYyA9IGUubG9jO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGFkYXRhID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGUubG9jLnN0YXJ0LmxpbmUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogZS5sb2Muc3RhcnQuY29sdW1uLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGUucmFuZ2VbMF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVuZDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBlLmxvYy5lbmQubGluZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBlLmxvYy5lbmQuY29sdW1uLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGUucmFuZ2VbMV1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZShub2RlLCBtZXRhZGF0YSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIEZyb20gaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gdG8gYW4gZXh0ZXJuYWwgc3RydWN0dXJlXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuZ2V0VG9rZW5SYXcgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLnNjYW5uZXIuc291cmNlLnNsaWNlKHRva2VuLnN0YXJ0LCB0b2tlbi5lbmQpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmNvbnZlcnRUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG5cdCAgICAgICAgdmFyIHQgPSB7XHJcblx0ICAgICAgICAgICAgdHlwZTogdG9rZW5fMS5Ub2tlbk5hbWVbdG9rZW4udHlwZV0sXHJcblx0ICAgICAgICAgICAgdmFsdWU6IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLnJhbmdlKSB7XHJcblx0ICAgICAgICAgICAgdC5yYW5nZSA9IFt0b2tlbi5zdGFydCwgdG9rZW4uZW5kXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy5sb2MpIHtcclxuXHQgICAgICAgICAgICB0LmxvYyA9IHtcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMuc3RhcnRNYXJrZXIubGluZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zdGFydE1hcmtlci5jb2x1bW5cclxuXHQgICAgICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydFxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlID09PSA5IC8qIFJlZ3VsYXJFeHByZXNzaW9uICovKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSB0b2tlbi5wYXR0ZXJuO1xyXG5cdCAgICAgICAgICAgIHZhciBmbGFncyA9IHRva2VuLmZsYWdzO1xyXG5cdCAgICAgICAgICAgIHQucmVnZXggPSB7IHBhdHRlcm46IHBhdHRlcm4sIGZsYWdzOiBmbGFncyB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHQ7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUubmV4dFRva2VuID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIuaW5kZXggPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIubGluZSA9IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmNvbHVtbiA9IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnQ7XHJcblx0ICAgICAgICB0aGlzLmNvbGxlY3RDb21tZW50cygpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pbmRleCAhPT0gdGhpcy5zdGFydE1hcmtlci5pbmRleCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuc3RhcnRNYXJrZXIuaW5kZXggPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgdGhpcy5zdGFydE1hcmtlci5saW5lID0gdGhpcy5zY2FubmVyLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICAgICAgdGhpcy5zdGFydE1hcmtlci5jb2x1bW4gPSB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG5leHQgPSB0aGlzLnNjYW5uZXIubGV4KCk7XHJcblx0ICAgICAgICB0aGlzLmhhc0xpbmVUZXJtaW5hdG9yID0gKHRva2VuLmxpbmVOdW1iZXIgIT09IG5leHQubGluZU51bWJlcik7XHJcblx0ICAgICAgICBpZiAobmV4dCAmJiB0aGlzLmNvbnRleHQuc3RyaWN0ICYmIG5leHQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQobmV4dC52YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgbmV4dC50eXBlID0gNCAvKiBLZXl3b3JkICovO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMubG9va2FoZWFkID0gbmV4dDtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy50b2tlbnMgJiYgbmV4dC50eXBlICE9PSAyIC8qIEVPRiAqLykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9rZW5zLnB1c2godGhpcy5jb252ZXJ0VG9rZW4obmV4dCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRva2VuO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLm5leHRSZWdleFRva2VuID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5jb2xsZWN0Q29tbWVudHMoKTtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMuc2Nhbm5lci5zY2FuUmVnRXhwKCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcudG9rZW5zKSB7XHJcblx0ICAgICAgICAgICAgLy8gUG9wIHRoZSBwcmV2aW91cyB0b2tlbiwgJy8nIG9yICcvPSdcclxuXHQgICAgICAgICAgICAvLyBUaGlzIGlzIGFkZGVkIGZyb20gdGhlIGxvb2thaGVhZCB0b2tlbi5cclxuXHQgICAgICAgICAgICB0aGlzLnRva2Vucy5wb3AoKTtcclxuXHQgICAgICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHRoaXMuY29udmVydFRva2VuKHRva2VuKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBQcmltZSB0aGUgbmV4dCBsb29rYWhlYWQuXHJcblx0ICAgICAgICB0aGlzLmxvb2thaGVhZCA9IHRva2VuO1xyXG5cdCAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIHJldHVybiB0b2tlbjtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5jcmVhdGVOb2RlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBpbmRleDogdGhpcy5zdGFydE1hcmtlci5pbmRleCxcclxuXHQgICAgICAgICAgICBsaW5lOiB0aGlzLnN0YXJ0TWFya2VyLmxpbmUsXHJcblx0ICAgICAgICAgICAgY29sdW1uOiB0aGlzLnN0YXJ0TWFya2VyLmNvbHVtblxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5zdGFydE5vZGUgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgaW5kZXg6IHRva2VuLnN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGxpbmU6IHRva2VuLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgY29sdW1uOiB0b2tlbi5zdGFydCAtIHRva2VuLmxpbmVTdGFydFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uIChtYXJrZXIsIG5vZGUpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy5yYW5nZSkge1xyXG5cdCAgICAgICAgICAgIG5vZGUucmFuZ2UgPSBbbWFya2VyLmluZGV4LCB0aGlzLmxhc3RNYXJrZXIuaW5kZXhdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxvYykge1xyXG5cdCAgICAgICAgICAgIG5vZGUubG9jID0ge1xyXG5cdCAgICAgICAgICAgICAgICBzdGFydDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGluZTogbWFya2VyLmxpbmUsXHJcblx0ICAgICAgICAgICAgICAgICAgICBjb2x1bW46IG1hcmtlci5jb2x1bW4sXHJcblx0ICAgICAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgIGVuZDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5sYXN0TWFya2VyLmxpbmUsXHJcblx0ICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMubGFzdE1hcmtlci5jb2x1bW5cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLnNvdXJjZSkge1xyXG5cdCAgICAgICAgICAgICAgICBub2RlLmxvYy5zb3VyY2UgPSB0aGlzLmNvbmZpZy5zb3VyY2U7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUpIHtcclxuXHQgICAgICAgICAgICB2YXIgbWV0YWRhdGEgPSB7XHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsaW5lOiBtYXJrZXIubGluZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogbWFya2VyLmNvbHVtbixcclxuXHQgICAgICAgICAgICAgICAgICAgIG9mZnNldDogbWFya2VyLmluZGV4XHJcblx0ICAgICAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgIGVuZDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5sYXN0TWFya2VyLmxpbmUsXHJcblx0ICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMubGFzdE1hcmtlci5jb2x1bW4sXHJcblx0ICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMubGFzdE1hcmtlci5pbmRleFxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICB0aGlzLmRlbGVnYXRlKG5vZGUsIG1ldGFkYXRhKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBub2RlO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBFeHBlY3QgdGhlIG5leHQgdG9rZW4gdG8gbWF0Y2ggdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxyXG5cdCAgICAvLyBJZiBub3QsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5leHBlY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gNyAvKiBQdW5jdHVhdG9yICovIHx8IHRva2VuLnZhbHVlICE9PSB2YWx1ZSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBRdWlldGx5IGV4cGVjdCBhIGNvbW1hIHdoZW4gaW4gdG9sZXJhbnQgbW9kZSwgb3RoZXJ3aXNlIGRlbGVnYXRlcyB0byBleHBlY3QoKS5cclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5leHBlY3RDb21tYVNlcGFyYXRvciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy50b2xlcmFudCkge1xyXG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8gJiYgdG9rZW4udmFsdWUgPT09ICcsJykge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8gJiYgdG9rZW4udmFsdWUgPT09ICc7Jykge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLCcpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBFeHBlY3QgdGhlIG5leHQgdG9rZW4gdG8gbWF0Y2ggdGhlIHNwZWNpZmllZCBrZXl3b3JkLlxyXG5cdCAgICAvLyBJZiBub3QsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5leHBlY3RLZXl3b3JkID0gZnVuY3Rpb24gKGtleXdvcmQpIHtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gNCAvKiBLZXl3b3JkICovIHx8IHRva2VuLnZhbHVlICE9PSBrZXl3b3JkKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5sb29rYWhlYWQudHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovICYmIHRoaXMubG9va2FoZWFkLnZhbHVlID09PSB2YWx1ZTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGtleXdvcmRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5tYXRjaEtleXdvcmQgPSBmdW5jdGlvbiAoa2V5d29yZCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDQgLyogS2V5d29yZCAqLyAmJiB0aGlzLmxvb2thaGVhZC52YWx1ZSA9PT0ga2V5d29yZDtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGNvbnRleHR1YWwga2V5d29yZFxyXG5cdCAgICAvLyAod2hlcmUgYW4gaWRlbnRpZmllciBpcyBzb21ldGltZXMgYSBrZXl3b3JkIGRlcGVuZGluZyBvbiB0aGUgY29udGV4dClcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5tYXRjaENvbnRleHR1YWxLZXl3b3JkID0gZnVuY3Rpb24gKGtleXdvcmQpIHtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmxvb2thaGVhZC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgdGhpcy5sb29rYWhlYWQudmFsdWUgPT09IGtleXdvcmQ7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIGlzIGFuIGFzc2lnbm1lbnQgb3BlcmF0b3JcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5tYXRjaEFzc2lnbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSA3IC8qIFB1bmN0dWF0b3IgKi8pIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgb3AgPSB0aGlzLmxvb2thaGVhZC52YWx1ZTtcclxuXHQgICAgICAgIHJldHVybiBvcCA9PT0gJz0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICcqPScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJyoqPScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJy89JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnJT0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICcrPScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJy09JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnPDw9JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnPj49JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnPj4+PScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJyY9JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnXj0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICd8PSc7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIENvdmVyIGdyYW1tYXIgc3VwcG9ydC5cclxuXHQgICAgLy9cclxuXHQgICAgLy8gV2hlbiBhbiBhc3NpZ25tZW50IGV4cHJlc3Npb24gcG9zaXRpb24gc3RhcnRzIHdpdGggYW4gbGVmdCBwYXJlbnRoZXNpcywgdGhlIGRldGVybWluYXRpb24gb2YgdGhlIHR5cGVcclxuXHQgICAgLy8gb2YgdGhlIHN5bnRheCBpcyB0byBiZSBkZWZlcnJlZCBhcmJpdHJhcmlseSBsb25nIHVudGlsIHRoZSBlbmQgb2YgdGhlIHBhcmVudGhlc2VzIHBhaXIgKHBsdXMgYSBsb29rYWhlYWQpXHJcblx0ICAgIC8vIG9yIHRoZSBmaXJzdCBjb21tYS4gVGhpcyBzaXR1YXRpb24gYWxzbyBkZWZlcnMgdGhlIGRldGVybWluYXRpb24gb2YgYWxsIHRoZSBleHByZXNzaW9ucyBuZXN0ZWQgaW4gdGhlIHBhaXIuXHJcblx0ICAgIC8vXHJcblx0ICAgIC8vIFRoZXJlIGFyZSB0aHJlZSBwcm9kdWN0aW9ucyB0aGF0IGNhbiBiZSBwYXJzZWQgaW4gYSBwYXJlbnRoZXNlcyBwYWlyIHRoYXQgbmVlZHMgdG8gYmUgZGV0ZXJtaW5lZFxyXG5cdCAgICAvLyBhZnRlciB0aGUgb3V0ZXJtb3N0IHBhaXIgaXMgY2xvc2VkLiBUaGV5IGFyZTpcclxuXHQgICAgLy9cclxuXHQgICAgLy8gICAxLiBBc3NpZ25tZW50RXhwcmVzc2lvblxyXG5cdCAgICAvLyAgIDIuIEJpbmRpbmdFbGVtZW50c1xyXG5cdCAgICAvLyAgIDMuIEFzc2lnbm1lbnRUYXJnZXRzXHJcblx0ICAgIC8vXHJcblx0ICAgIC8vIEluIG9yZGVyIHRvIGF2b2lkIGV4cG9uZW50aWFsIGJhY2t0cmFja2luZywgd2UgdXNlIHR3byBmbGFncyB0byBkZW5vdGUgaWYgdGhlIHByb2R1Y3Rpb24gY2FuIGJlXHJcblx0ICAgIC8vIGJpbmRpbmcgZWxlbWVudCBvciBhc3NpZ25tZW50IHRhcmdldC5cclxuXHQgICAgLy9cclxuXHQgICAgLy8gVGhlIHRocmVlIHByb2R1Y3Rpb25zIGhhdmUgdGhlIHJlbGF0aW9uc2hpcDpcclxuXHQgICAgLy9cclxuXHQgICAgLy8gICBCaW5kaW5nRWxlbWVudHMg4oqGIEFzc2lnbm1lbnRUYXJnZXRzIOKKhiBBc3NpZ25tZW50RXhwcmVzc2lvblxyXG5cdCAgICAvL1xyXG5cdCAgICAvLyB3aXRoIGEgc2luZ2xlIGV4Y2VwdGlvbiB0aGF0IENvdmVySW5pdGlhbGl6ZWROYW1lIHdoZW4gdXNlZCBkaXJlY3RseSBpbiBhbiBFeHByZXNzaW9uLCBnZW5lcmF0ZXNcclxuXHQgICAgLy8gYW4gZWFybHkgZXJyb3IuIFRoZXJlZm9yZSwgd2UgbmVlZCB0aGUgdGhpcmQgc3RhdGUsIGZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciwgdG8gdHJhY2sgdGhlXHJcblx0ICAgIC8vIGZpcnN0IHVzYWdlIG9mIENvdmVySW5pdGlhbGl6ZWROYW1lIGFuZCByZXBvcnQgaXQgd2hlbiB3ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHBhcmVudGhlc2VzIHBhaXIuXHJcblx0ICAgIC8vXHJcblx0ICAgIC8vIGlzb2xhdGVDb3ZlckdyYW1tYXIgZnVuY3Rpb24gcnVucyB0aGUgZ2l2ZW4gcGFyc2VyIGZ1bmN0aW9uIHdpdGggYSBuZXcgY292ZXIgZ3JhbW1hciBjb250ZXh0LCBhbmQgaXQgZG9lcyBub3RcclxuXHQgICAgLy8gZWZmZWN0IHRoZSBjdXJyZW50IGZsYWdzLiBUaGlzIG1lYW5zIHRoZSBwcm9kdWN0aW9uIHRoZSBwYXJzZXIgcGFyc2VzIGlzIG9ubHkgdXNlZCBhcyBhbiBleHByZXNzaW9uLiBUaGVyZWZvcmVcclxuXHQgICAgLy8gdGhlIENvdmVySW5pdGlhbGl6ZWROYW1lIGNoZWNrIGlzIGNvbmR1Y3RlZC5cclxuXHQgICAgLy9cclxuXHQgICAgLy8gaW5oZXJpdENvdmVyR3JhbW1hciBmdW5jdGlvbiBydW5zIHRoZSBnaXZlbiBwYXJzZSBmdW5jdGlvbiB3aXRoIGEgbmV3IGNvdmVyIGdyYW1tYXIgY29udGV4dCwgYW5kIGl0IHByb3BhZ2F0ZXNcclxuXHQgICAgLy8gdGhlIGZsYWdzIG91dHNpZGUgb2YgdGhlIHBhcnNlci4gVGhpcyBtZWFucyB0aGUgcHJvZHVjdGlvbiB0aGUgcGFyc2VyIHBhcnNlcyBpcyB1c2VkIGFzIGEgcGFydCBvZiBhIHBvdGVudGlhbFxyXG5cdCAgICAvLyBwYXR0ZXJuLiBUaGUgQ292ZXJJbml0aWFsaXplZE5hbWUgY2hlY2sgaXMgZGVmZXJyZWQuXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuaXNvbGF0ZUNvdmVyR3JhbW1hciA9IGZ1bmN0aW9uIChwYXJzZUZ1bmN0aW9uKSB7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNJc0JpbmRpbmdFbGVtZW50ID0gdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQ7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNJc0Fzc2lnbm1lbnRUYXJnZXQgPSB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0O1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzRmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcjtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gdHJ1ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VGdW5jdGlvbi5jYWxsKHRoaXMpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBwcmV2aW91c0lzQmluZGluZ0VsZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gcHJldmlvdXNJc0Fzc2lnbm1lbnRUYXJnZXQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gcHJldmlvdXNGaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3I7XHJcblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmluaGVyaXRDb3ZlckdyYW1tYXIgPSBmdW5jdGlvbiAocGFyc2VGdW5jdGlvbikge1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzSXNCaW5kaW5nRWxlbWVudCA9IHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50O1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzSXNBc3NpZ25tZW50VGFyZ2V0ID0gdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0ZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3I7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IHRydWU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlRnVuY3Rpb24uY2FsbCh0aGlzKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgJiYgcHJldmlvdXNJc0JpbmRpbmdFbGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgJiYgcHJldmlvdXNJc0Fzc2lnbm1lbnRUYXJnZXQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gcHJldmlvdXNGaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgfHwgdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcjtcclxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuY29uc3VtZVNlbWljb2xvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCc7JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAoIXRoaXMuaGFzTGluZVRlcm1pbmF0b3IpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMiAvKiBFT0YgKi8gJiYgIXRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy5sYXN0TWFya2VyLmluZGV4ID0gdGhpcy5zdGFydE1hcmtlci5pbmRleDtcclxuXHQgICAgICAgICAgICB0aGlzLmxhc3RNYXJrZXIubGluZSA9IHRoaXMuc3RhcnRNYXJrZXIubGluZTtcclxuXHQgICAgICAgICAgICB0aGlzLmxhc3RNYXJrZXIuY29sdW1uID0gdGhpcy5zdGFydE1hcmtlci5jb2x1bW47XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXByaW1hcnktZXhwcmVzc2lvblxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUHJpbWFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGV4cHI7XHJcblx0ICAgICAgICB2YXIgdG9rZW4sIHJhdztcclxuXHQgICAgICAgIHN3aXRjaCAodGhpcy5sb29rYWhlYWQudHlwZSkge1xyXG5cdCAgICAgICAgICAgIGNhc2UgMyAvKiBJZGVudGlmaWVyICovOlxyXG5cdCAgICAgICAgICAgICAgICBpZiAoKHRoaXMuY29udGV4dC5pc01vZHVsZSB8fCB0aGlzLmNvbnRleHQuYXdhaXQpICYmIHRoaXMubG9va2FoZWFkLnZhbHVlID09PSAnYXdhaXQnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5tYXRjaEFzeW5jRnVuY3Rpb24oKSA/IHRoaXMucGFyc2VGdW5jdGlvbkV4cHJlc3Npb24oKSA6IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWRlbnRpZmllcih0aGlzLm5leHRUb2tlbigpLnZhbHVlKSk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNiAvKiBOdW1lcmljTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDggLyogU3RyaW5nTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgdGhpcy5sb29rYWhlYWQub2N0YWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQsIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgcmF3ID0gdGhpcy5nZXRUb2tlblJhdyh0b2tlbik7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkxpdGVyYWwodG9rZW4udmFsdWUsIHJhdykpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDEgLyogQm9vbGVhbkxpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICByYXcgPSB0aGlzLmdldFRva2VuUmF3KHRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuTGl0ZXJhbCh0b2tlbi52YWx1ZSA9PT0gJ3RydWUnLCByYXcpKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSA1IC8qIE51bGxMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgcmF3ID0gdGhpcy5nZXRUb2tlblJhdyh0b2tlbik7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkxpdGVyYWwobnVsbCwgcmF3KSk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgMTAgLyogVGVtcGxhdGUgKi86XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlVGVtcGxhdGVMaXRlcmFsKCk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNyAvKiBQdW5jdHVhdG9yICovOlxyXG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMubG9va2FoZWFkLnZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICcoJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUdyb3VwRXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdbJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VBcnJheUluaXRpYWxpemVyKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3snOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZU9iamVjdEluaXRpYWxpemVyKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJy8nOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnLz0nOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5pbmRleCA9IHRoaXMuc3RhcnRNYXJrZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLm5leHRSZWdleFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmF3ID0gdGhpcy5nZXRUb2tlblJhdyh0b2tlbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuUmVnZXhMaXRlcmFsKHRva2VuLnJlZ2V4LCByYXcsIHRva2VuLnBhdHRlcm4sIHRva2VuLmZsYWdzKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNCAvKiBLZXl3b3JkICovOlxyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5zdHJpY3QgJiYgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgJiYgdGhpcy5tYXRjaEtleXdvcmQoJ3lpZWxkJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5jb250ZXh0LnN0cmljdCAmJiB0aGlzLm1hdGNoS2V5d29yZCgnbGV0JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLklkZW50aWZpZXIodGhpcy5uZXh0VG9rZW4oKS52YWx1ZSkpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnZnVuY3Rpb24nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlRnVuY3Rpb25FeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoS2V5d29yZCgndGhpcycpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5UaGlzRXhwcmVzc2lvbigpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdjbGFzcycpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMucGFyc2VDbGFzc0V4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LWluaXRpYWxpemVyXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTcHJlYWRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcuLi4nKTtcclxuXHQgICAgICAgIHZhciBhcmcgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlNwcmVhZEVsZW1lbnQoYXJnKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBcnJheUluaXRpYWxpemVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ1snKTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5tYXRjaCgnXScpKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKG51bGwpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCcuLi4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VTcHJlYWRFbGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnXScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJywnKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaCh0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKSk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnXScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLCcpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ10nKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkFycmF5RXhwcmVzc2lvbihlbGVtZW50cykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QtaW5pdGlhbGl6ZXJcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVByb3BlcnR5TWV0aG9kID0gZnVuY3Rpb24gKHBhcmFtcykge1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c1N0cmljdCA9IHRoaXMuY29udGV4dC5zdHJpY3Q7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1N0cmljdERpcmVjdGl2ZSA9IHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZSA9IHBhcmFtcy5zaW1wbGU7XHJcblx0ICAgICAgICB2YXIgYm9keSA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cyk7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBwYXJhbXMuZmlyc3RSZXN0cmljdGVkKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihwYXJhbXMuZmlyc3RSZXN0cmljdGVkLCBwYXJhbXMubWVzc2FnZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBwYXJhbXMuc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHBhcmFtcy5zdHJpY3RlZCwgcGFyYW1zLm1lc3NhZ2UpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlID0gcHJldmlvdXNBbGxvd1N0cmljdERpcmVjdGl2ZTtcclxuXHQgICAgICAgIHJldHVybiBib2R5O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUHJvcGVydHlNZXRob2RGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBpc0dlbmVyYXRvciA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcnMoKTtcclxuXHQgICAgICAgIHZhciBtZXRob2QgPSB0aGlzLnBhcnNlUHJvcGVydHlNZXRob2QocGFyYW1zKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRnVuY3Rpb25FeHByZXNzaW9uKG51bGwsIHBhcmFtcy5wYXJhbXMsIG1ldGhvZCwgaXNHZW5lcmF0b3IpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVByb3BlcnR5TWV0aG9kQXN5bmNGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBd2FpdCA9IHRoaXMuY29udGV4dC5hd2FpdDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYXdhaXQgPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucGFyc2VGb3JtYWxQYXJhbWV0ZXJzKCk7XHJcblx0ICAgICAgICB2YXIgbWV0aG9kID0gdGhpcy5wYXJzZVByb3BlcnR5TWV0aG9kKHBhcmFtcyk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hd2FpdCA9IHByZXZpb3VzQXdhaXQ7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Bc3luY0Z1bmN0aW9uRXhwcmVzc2lvbihudWxsLCBwYXJhbXMucGFyYW1zLCBtZXRob2QpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZU9iamVjdFByb3BlcnR5S2V5ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB2YXIga2V5O1xyXG5cdCAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSA4IC8qIFN0cmluZ0xpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA2IC8qIE51bWVyaWNMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiB0b2tlbi5vY3RhbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHZhciByYXcgPSB0aGlzLmdldFRva2VuUmF3KHRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5MaXRlcmFsKHRva2VuLnZhbHVlLCByYXcpKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSAzIC8qIElkZW50aWZpZXIgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSAxIC8qIEJvb2xlYW5MaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgNSAvKiBOdWxsTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDQgLyogS2V5d29yZCAqLzpcclxuXHQgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JZGVudGlmaWVyKHRva2VuLnZhbHVlKSk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNyAvKiBQdW5jdHVhdG9yICovOlxyXG5cdCAgICAgICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICdbJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnXScpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAga2V5ID0gdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAga2V5ID0gdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ga2V5O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmlzUHJvcGVydHlLZXkgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG5cdCAgICAgICAgcmV0dXJuIChrZXkudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIgJiYga2V5Lm5hbWUgPT09IHZhbHVlKSB8fFxyXG5cdCAgICAgICAgICAgIChrZXkudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LkxpdGVyYWwgJiYga2V5LnZhbHVlID09PSB2YWx1ZSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VPYmplY3RQcm9wZXJ0eSA9IGZ1bmN0aW9uIChoYXNQcm90bykge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdmFyIGtpbmQ7XHJcblx0ICAgICAgICB2YXIga2V5ID0gbnVsbDtcclxuXHQgICAgICAgIHZhciB2YWx1ZSA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgY29tcHV0ZWQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBtZXRob2QgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBzaG9ydGhhbmQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBpc0FzeW5jID0gZmFsc2U7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGlkID0gdG9rZW4udmFsdWU7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICBpc0FzeW5jID0gIXRoaXMuaGFzTGluZVRlcm1pbmF0b3IgJiYgKGlkID09PSAnYXN5bmMnKSAmJlxyXG5cdCAgICAgICAgICAgICAgICAhdGhpcy5tYXRjaCgnOicpICYmICF0aGlzLm1hdGNoKCcoJykgJiYgIXRoaXMubWF0Y2goJyonKTtcclxuXHQgICAgICAgICAgICBrZXkgPSBpc0FzeW5jID8gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCkgOiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLklkZW50aWZpZXIoaWQpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJyonKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBsb29rYWhlYWRQcm9wZXJ0eUtleSA9IHRoaXMucXVhbGlmaWVkUHJvcGVydHlOYW1lKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgIWlzQXN5bmMgJiYgdG9rZW4udmFsdWUgPT09ICdnZXQnICYmIGxvb2thaGVhZFByb3BlcnR5S2V5KSB7XHJcblx0ICAgICAgICAgICAga2luZCA9ICdnZXQnO1xyXG5cdCAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlR2V0dGVyTWV0aG9kKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgIWlzQXN5bmMgJiYgdG9rZW4udmFsdWUgPT09ICdzZXQnICYmIGxvb2thaGVhZFByb3BlcnR5S2V5KSB7XHJcblx0ICAgICAgICAgICAga2luZCA9ICdzZXQnO1xyXG5cdCAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZVNldHRlck1ldGhvZCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovICYmIHRva2VuLnZhbHVlID09PSAnKicgJiYgbG9va2FoZWFkUHJvcGVydHlLZXkpIHtcclxuXHQgICAgICAgICAgICBraW5kID0gJ2luaXQnO1xyXG5cdCAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZUdlbmVyYXRvck1ldGhvZCgpO1xyXG5cdCAgICAgICAgICAgIG1ldGhvZCA9IHRydWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBpZiAoIWtleSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAga2luZCA9ICdpbml0JztcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnOicpICYmICFpc0FzeW5jKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICghY29tcHV0ZWQgJiYgdGhpcy5pc1Byb3BlcnR5S2V5KGtleSwgJ19fcHJvdG9fXycpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaGFzUHJvdG8udmFsdWUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5EdXBsaWNhdGVQcm90b1Byb3BlcnR5KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGhhc1Byb3RvLnZhbHVlID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCcoJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSBpc0FzeW5jID8gdGhpcy5wYXJzZVByb3BlcnR5TWV0aG9kQXN5bmNGdW5jdGlvbigpIDogdGhpcy5wYXJzZVByb3BlcnR5TWV0aG9kRnVuY3Rpb24oKTtcclxuXHQgICAgICAgICAgICAgICAgbWV0aG9kID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBpZCA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWRlbnRpZmllcih0b2tlbi52YWx1ZSkpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnPScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc2hvcnRoYW5kID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpbml0ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXNzaWdubWVudFBhdHRlcm4oaWQsIGluaXQpKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHNob3J0aGFuZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGlkO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlByb3BlcnR5KGtpbmQsIGtleSwgY29tcHV0ZWQsIHZhbHVlLCBtZXRob2QsIHNob3J0aGFuZCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlT2JqZWN0SW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ3snKTtcclxuXHQgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gW107XHJcblx0ICAgICAgICB2YXIgaGFzUHJvdG8gPSB7IHZhbHVlOiBmYWxzZSB9O1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2godGhpcy5wYXJzZU9iamVjdFByb3BlcnR5KGhhc1Byb3RvKSk7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3RDb21tYVNlcGFyYXRvcigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd9Jyk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5PYmplY3RFeHByZXNzaW9uKHByb3BlcnRpZXMpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdGVtcGxhdGUtbGl0ZXJhbHNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRlbXBsYXRlSGVhZCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGFzc2VydF8xLmFzc2VydCh0aGlzLmxvb2thaGVhZC5oZWFkLCAnVGVtcGxhdGUgbGl0ZXJhbCBtdXN0IHN0YXJ0IHdpdGggYSB0ZW1wbGF0ZSBoZWFkJyk7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIHZhciByYXcgPSB0b2tlbi52YWx1ZTtcclxuXHQgICAgICAgIHZhciBjb29rZWQgPSB0b2tlbi5jb29rZWQ7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5UZW1wbGF0ZUVsZW1lbnQoeyByYXc6IHJhdywgY29va2VkOiBjb29rZWQgfSwgdG9rZW4udGFpbCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVGVtcGxhdGVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDEwIC8qIFRlbXBsYXRlICovKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB2YXIgcmF3ID0gdG9rZW4udmFsdWU7XHJcblx0ICAgICAgICB2YXIgY29va2VkID0gdG9rZW4uY29va2VkO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVGVtcGxhdGVFbGVtZW50KHsgcmF3OiByYXcsIGNvb2tlZDogY29va2VkIH0sIHRva2VuLnRhaWwpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRlbXBsYXRlTGl0ZXJhbCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcclxuXHQgICAgICAgIHZhciBxdWFzaXMgPSBbXTtcclxuXHQgICAgICAgIHZhciBxdWFzaSA9IHRoaXMucGFyc2VUZW1wbGF0ZUhlYWQoKTtcclxuXHQgICAgICAgIHF1YXNpcy5wdXNoKHF1YXNpKTtcclxuXHQgICAgICAgIHdoaWxlICghcXVhc2kudGFpbCkge1xyXG5cdCAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZUV4cHJlc3Npb24oKSk7XHJcblx0ICAgICAgICAgICAgcXVhc2kgPSB0aGlzLnBhcnNlVGVtcGxhdGVFbGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgcXVhc2lzLnB1c2gocXVhc2kpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVGVtcGxhdGVMaXRlcmFsKHF1YXNpcywgZXhwcmVzc2lvbnMpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZ3JvdXBpbmctb3BlcmF0b3JcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4gPSBmdW5jdGlvbiAoZXhwcikge1xyXG5cdCAgICAgICAgc3dpdGNoIChleHByLnR5cGUpIHtcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyOlxyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4Lk1lbWJlckV4cHJlc3Npb246XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguUmVzdEVsZW1lbnQ6XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudFBhdHRlcm46XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LlNwcmVhZEVsZW1lbnQ6XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIudHlwZSA9IHN5bnRheF8xLlN5bnRheC5SZXN0RWxlbWVudDtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwci5hcmd1bWVudCk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LkFycmF5RXhwcmVzc2lvbjpcclxuXHQgICAgICAgICAgICAgICAgZXhwci50eXBlID0gc3ludGF4XzEuU3ludGF4LkFycmF5UGF0dGVybjtcclxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZXhwci5lbGVtZW50c1tpXSAhPT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIuZWxlbWVudHNbaV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4Lk9iamVjdEV4cHJlc3Npb246XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIudHlwZSA9IHN5bnRheF8xLlN5bnRheC5PYmplY3RQYXR0ZXJuO1xyXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHIucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwci5wcm9wZXJ0aWVzW2ldLnZhbHVlKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbjpcclxuXHQgICAgICAgICAgICAgICAgZXhwci50eXBlID0gc3ludGF4XzEuU3ludGF4LkFzc2lnbm1lbnRQYXR0ZXJuO1xyXG5cdCAgICAgICAgICAgICAgICBkZWxldGUgZXhwci5vcGVyYXRvcjtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwci5sZWZ0KTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgLy8gQWxsb3cgb3RoZXIgbm9kZSB0eXBlIGZvciB0b2xlcmFudCBwYXJzaW5nLlxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUdyb3VwRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBleHByO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnPT4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnPT4nKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZXhwciA9IHtcclxuXHQgICAgICAgICAgICAgICAgdHlwZTogQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcclxuXHQgICAgICAgICAgICAgICAgcGFyYW1zOiBbXSxcclxuXHQgICAgICAgICAgICAgICAgYXN5bmM6IGZhbHNlXHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHZhciBzdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcuLi4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZVJlc3RFbGVtZW50KHBhcmFtcyk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnPT4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJz0+Jyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHR5cGU6IEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFtleHByXSxcclxuXHQgICAgICAgICAgICAgICAgICAgIGFzeW5jOiBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGFycm93ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goZXhwcik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMiAvKiBFT0YgKi8pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbnMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHJlc3Npb25zW2ldKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJvdyA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBleHByZXNzaW9ucyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jOiBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCcuLi4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHRoaXMucGFyc2VSZXN0RWxlbWVudChwYXJhbXMpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCc9PicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnPT4nKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHJlc3Npb25zLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByZXNzaW9uc1tpXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyb3cgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogZXhwcmVzc2lvbnMsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luYzogZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2godGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbikpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJyb3cpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFhcnJvdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5TZXF1ZW5jZUV4cHJlc3Npb24oZXhwcmVzc2lvbnMpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoIWFycm93KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJz0+JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwci50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllciAmJiBleHByLm5hbWUgPT09ICd5aWVsZCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyb3cgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogW2V4cHJdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmM6IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXJyb3cpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHIudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LlNlcXVlbmNlRXhwcmVzc2lvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByLmV4cHJlc3Npb25zLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwci5leHByZXNzaW9uc1tpXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1ldGVycyA9IChleHByLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5TZXF1ZW5jZUV4cHJlc3Npb24gPyBleHByLmV4cHJlc3Npb25zIDogW2V4cHJdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtZXRlcnMsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luYzogZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWxlZnQtaGFuZC1zaWRlLWV4cHJlc3Npb25zXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBcmd1bWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGV4cHIgPSB0aGlzLm1hdGNoKCcuLi4nKSA/IHRoaXMucGFyc2VTcHJlYWRFbGVtZW50KCkgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgIGFyZ3MucHVzaChleHByKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3RDb21tYVNlcGFyYXRvcigpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICByZXR1cm4gYXJncztcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5pc0lkZW50aWZpZXJOYW1lID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcblx0ICAgICAgICByZXR1cm4gdG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovIHx8XHJcblx0ICAgICAgICAgICAgdG9rZW4udHlwZSA9PT0gNCAvKiBLZXl3b3JkICovIHx8XHJcblx0ICAgICAgICAgICAgdG9rZW4udHlwZSA9PT0gMSAvKiBCb29sZWFuTGl0ZXJhbCAqLyB8fFxyXG5cdCAgICAgICAgICAgIHRva2VuLnR5cGUgPT09IDUgLyogTnVsbExpdGVyYWwgKi87XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VJZGVudGlmaWVyTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLmlzSWRlbnRpZmllck5hbWUodG9rZW4pKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JZGVudGlmaWVyKHRva2VuLnZhbHVlKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VOZXdFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBpZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xyXG5cdCAgICAgICAgYXNzZXJ0XzEuYXNzZXJ0KGlkLm5hbWUgPT09ICduZXcnLCAnTmV3IGV4cHJlc3Npb24gbXVzdCBzdGFydCB3aXRoIGBuZXdgJyk7XHJcblx0ICAgICAgICB2YXIgZXhwcjtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCcuJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgdGhpcy5jb250ZXh0LmluRnVuY3Rpb25Cb2R5ICYmIHRoaXMubG9va2FoZWFkLnZhbHVlID09PSAndGFyZ2V0Jykge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IG5ldyBOb2RlLk1ldGFQcm9wZXJ0eShpZCwgcHJvcGVydHkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNhbGxlZSA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLm1hdGNoKCcoJykgPyB0aGlzLnBhcnNlQXJndW1lbnRzKCkgOiBbXTtcclxuXHQgICAgICAgICAgICBleHByID0gbmV3IE5vZGUuTmV3RXhwcmVzc2lvbihjYWxsZWUsIGFyZ3MpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgZXhwcik7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBc3luY0FyZ3VtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGFyZyA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IG51bGw7XHJcblx0ICAgICAgICByZXR1cm4gYXJnO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQXN5bmNBcmd1bWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGV4cHIgPSB0aGlzLm1hdGNoKCcuLi4nKSA/IHRoaXMucGFyc2VTcHJlYWRFbGVtZW50KCkgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3luY0FyZ3VtZW50KTtcclxuXHQgICAgICAgICAgICAgICAgYXJncy5wdXNoKGV4cHIpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdENvbW1hU2VwYXJhdG9yKCk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgIHJldHVybiBhcmdzO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB2YXIgbWF5YmVBc3luYyA9IHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXN5bmMnKTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93SW4gPSB0aGlzLmNvbnRleHQuYWxsb3dJbjtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciBleHByO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdzdXBlcicpICYmIHRoaXMuY29udGV4dC5pbkZ1bmN0aW9uQm9keSkge1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKGV4cHIsIG5ldyBOb2RlLlN1cGVyKCkpO1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKCcpICYmICF0aGlzLm1hdGNoKCcuJykgJiYgIXRoaXMubWF0Y2goJ1snKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMubWF0Y2hLZXl3b3JkKCduZXcnKSA/IHRoaXMucGFyc2VOZXdFeHByZXNzaW9uIDogdGhpcy5wYXJzZVByaW1hcnlFeHByZXNzaW9uKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJy4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJy4nKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5TdGF0aWNNZW1iZXJFeHByZXNzaW9uKGV4cHIsIHByb3BlcnR5KSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJygnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgYXN5bmNBcnJvdyA9IG1heWJlQXN5bmMgJiYgKHN0YXJ0VG9rZW4ubGluZU51bWJlciA9PT0gdGhpcy5sb29rYWhlYWQubGluZU51bWJlcik7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhc3luY0Fycm93ID8gdGhpcy5wYXJzZUFzeW5jQXJndW1lbnRzKCkgOiB0aGlzLnBhcnNlQXJndW1lbnRzKCk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5DYWxsRXhwcmVzc2lvbihleHByLCBhcmdzKSk7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChhc3luY0Fycm93ICYmIHRoaXMubWF0Y2goJz0+JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGFyZ3NbaV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwciA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogYXJncyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhc3luYzogdHJ1ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCdbJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCdbJyk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlRXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCddJyk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5Db21wdXRlZE1lbWJlckV4cHJlc3Npb24oZXhwciwgcHJvcGVydHkpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMTAgLyogVGVtcGxhdGUgKi8gJiYgdGhpcy5sb29rYWhlYWQuaGVhZCkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcXVhc2kgPSB0aGlzLnBhcnNlVGVtcGxhdGVMaXRlcmFsKCk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5UYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24oZXhwciwgcXVhc2kpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTdXBlciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3N1cGVyJyk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJ1snKSAmJiAhdGhpcy5tYXRjaCgnLicpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5TdXBlcigpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBhc3NlcnRfMS5hc3NlcnQodGhpcy5jb250ZXh0LmFsbG93SW4sICdjYWxsZWUgb2YgbmV3IGV4cHJlc3Npb24gYWx3YXlzIGFsbG93IGluIGtleXdvcmQuJyk7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgIHZhciBleHByID0gKHRoaXMubWF0Y2hLZXl3b3JkKCdzdXBlcicpICYmIHRoaXMuY29udGV4dC5pbkZ1bmN0aW9uQm9keSkgPyB0aGlzLnBhcnNlU3VwZXIoKSA6XHJcblx0ICAgICAgICAgICAgdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMubWF0Y2hLZXl3b3JkKCduZXcnKSA/IHRoaXMucGFyc2VOZXdFeHByZXNzaW9uIDogdGhpcy5wYXJzZVByaW1hcnlFeHByZXNzaW9uKTtcclxuXHQgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJ1snKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJ1snKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJ10nKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uKGV4cHIsIHByb3BlcnR5KSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJy4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJy4nKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlN0YXRpY01lbWJlckV4cHJlc3Npb24oZXhwciwgcHJvcGVydHkpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMTAgLyogVGVtcGxhdGUgKi8gJiYgdGhpcy5sb29rYWhlYWQuaGVhZCkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcXVhc2kgPSB0aGlzLnBhcnNlVGVtcGxhdGVMaXRlcmFsKCk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihleHByLCBxdWFzaSkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXVwZGF0ZS1leHByZXNzaW9uc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVXBkYXRlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBleHByO1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCcrKycpIHx8IHRoaXMubWF0Y2goJy0tJykpIHtcclxuXHQgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pO1xyXG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlVW5hcnlFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBleHByLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyICYmIHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKGV4cHIubmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0TEhTUHJlZml4KTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRMSFNJbkFzc2lnbm1lbnQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB2YXIgcHJlZml4ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5VcGRhdGVFeHByZXNzaW9uKHRva2VuLnZhbHVlLCBleHByLCBwcmVmaXgpKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwpO1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5oYXNMaW5lVGVybWluYXRvciAmJiB0aGlzLmxvb2thaGVhZC50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8pIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJysrJykgfHwgdGhpcy5tYXRjaCgnLS0nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgZXhwci50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllciAmJiB0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZChleHByLm5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0TEhTUG9zdGZpeCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkTEhTSW5Bc3NpZ25tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSB0aGlzLm5leHRUb2tlbigpLnZhbHVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByZWZpeCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLlVwZGF0ZUV4cHJlc3Npb24ob3BlcmF0b3IsIGV4cHIsIHByZWZpeCkpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXVuYXJ5LW9wZXJhdG9yc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQXdhaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB2YXIgYXJndW1lbnQgPSB0aGlzLnBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Bd2FpdEV4cHJlc3Npb24oYXJndW1lbnQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVuYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBleHByO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJysnKSB8fCB0aGlzLm1hdGNoKCctJykgfHwgdGhpcy5tYXRjaCgnficpIHx8IHRoaXMubWF0Y2goJyEnKSB8fFxyXG5cdCAgICAgICAgICAgIHRoaXMubWF0Y2hLZXl3b3JkKCdkZWxldGUnKSB8fCB0aGlzLm1hdGNoS2V5d29yZCgndm9pZCcpIHx8IHRoaXMubWF0Y2hLZXl3b3JkKCd0eXBlb2YnKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUodGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlVW5hcnlFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5VbmFyeUV4cHJlc3Npb24odG9rZW4udmFsdWUsIGV4cHIpKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBleHByLm9wZXJhdG9yID09PSAnZGVsZXRlJyAmJiBleHByLmFyZ3VtZW50LnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdERlbGV0ZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5jb250ZXh0LmF3YWl0ICYmIHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXdhaXQnKSkge1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlQXdhaXRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZVVwZGF0ZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRXhwb25lbnRpYXRpb25FeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHZhciBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VVbmFyeUV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgaWYgKGV4cHIudHlwZSAhPT0gc3ludGF4XzEuU3ludGF4LlVuYXJ5RXhwcmVzc2lvbiAmJiB0aGlzLm1hdGNoKCcqKicpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB2YXIgbGVmdCA9IGV4cHI7XHJcblx0ICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VFeHBvbmVudGlhdGlvbkV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5CaW5hcnlFeHByZXNzaW9uKCcqKicsIGxlZnQsIHJpZ2h0KSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZXhwLW9wZXJhdG9yXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW11bHRpcGxpY2F0aXZlLW9wZXJhdG9yc1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hZGRpdGl2ZS1vcGVyYXRvcnNcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYml0d2lzZS1zaGlmdC1vcGVyYXRvcnNcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVsYXRpb25hbC1vcGVyYXRvcnNcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZXF1YWxpdHktb3BlcmF0b3JzXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWJpbmFyeS1iaXR3aXNlLW9wZXJhdG9yc1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1iaW5hcnktbG9naWNhbC1vcGVyYXRvcnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5iaW5hcnlQcmVjZWRlbmNlID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcblx0ICAgICAgICB2YXIgb3AgPSB0b2tlbi52YWx1ZTtcclxuXHQgICAgICAgIHZhciBwcmVjZWRlbmNlO1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLykge1xyXG5cdCAgICAgICAgICAgIHByZWNlZGVuY2UgPSB0aGlzLm9wZXJhdG9yUHJlY2VkZW5jZVtvcF0gfHwgMDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IDQgLyogS2V5d29yZCAqLykge1xyXG5cdCAgICAgICAgICAgIHByZWNlZGVuY2UgPSAob3AgPT09ICdpbnN0YW5jZW9mJyB8fCAodGhpcy5jb250ZXh0LmFsbG93SW4gJiYgb3AgPT09ICdpbicpKSA/IDcgOiAwO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgcHJlY2VkZW5jZSA9IDA7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gcHJlY2VkZW5jZTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJpbmFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdmFyIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUV4cG9uZW50aWF0aW9uRXhwcmVzc2lvbik7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHZhciBwcmVjID0gdGhpcy5iaW5hcnlQcmVjZWRlbmNlKHRva2VuKTtcclxuXHQgICAgICAgIGlmIChwcmVjID4gMCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdmFyIG1hcmtlcnMgPSBbc3RhcnRUb2tlbiwgdGhpcy5sb29rYWhlYWRdO1xyXG5cdCAgICAgICAgICAgIHZhciBsZWZ0ID0gZXhwcjtcclxuXHQgICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUV4cG9uZW50aWF0aW9uRXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgdmFyIHN0YWNrID0gW2xlZnQsIHRva2VuLnZhbHVlLCByaWdodF07XHJcblx0ICAgICAgICAgICAgdmFyIHByZWNlZGVuY2VzID0gW3ByZWNdO1xyXG5cdCAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHByZWMgPSB0aGlzLmJpbmFyeVByZWNlZGVuY2UodGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAocHJlYyA8PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAvLyBSZWR1Y2U6IG1ha2UgYSBiaW5hcnkgZXhwcmVzc2lvbiBmcm9tIHRoZSB0aHJlZSB0b3Btb3N0IGVudHJpZXMuXHJcblx0ICAgICAgICAgICAgICAgIHdoaWxlICgoc3RhY2subGVuZ3RoID4gMikgJiYgKHByZWMgPD0gcHJlY2VkZW5jZXNbcHJlY2VkZW5jZXMubGVuZ3RoIC0gMV0pKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByaWdodCA9IHN0YWNrLnBvcCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gc3RhY2sucG9wKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlcy5wb3AoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBzdGFjay5wb3AoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIG1hcmtlcnMucG9wKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKG1hcmtlcnNbbWFya2Vycy5sZW5ndGggLSAxXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQmluYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgbGVmdCwgcmlnaHQpKSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgLy8gU2hpZnQuXHJcblx0ICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godGhpcy5uZXh0VG9rZW4oKS52YWx1ZSk7XHJcblx0ICAgICAgICAgICAgICAgIHByZWNlZGVuY2VzLnB1c2gocHJlYyk7XHJcblx0ICAgICAgICAgICAgICAgIG1hcmtlcnMucHVzaCh0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VFeHBvbmVudGlhdGlvbkV4cHJlc3Npb24pKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgLy8gRmluYWwgcmVkdWNlIHRvIGNsZWFuLXVwIHRoZSBzdGFjay5cclxuXHQgICAgICAgICAgICB2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHN0YWNrW2ldO1xyXG5cdCAgICAgICAgICAgIG1hcmtlcnMucG9wKCk7XHJcblx0ICAgICAgICAgICAgd2hpbGUgKGkgPiAxKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUobWFya2Vycy5wb3AoKSk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IHN0YWNrW2kgLSAxXTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQmluYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgc3RhY2tbaSAtIDJdLCBleHByKSk7XHJcblx0ICAgICAgICAgICAgICAgIGkgLT0gMjtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY29uZGl0aW9uYWwtb3BlcmF0b3JcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB2YXIgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlQmluYXJ5RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnPycpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICB2YXIgcHJldmlvdXNBbGxvd0luID0gdGhpcy5jb250ZXh0LmFsbG93SW47XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIHZhciBjb25zZXF1ZW50ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJzonKTtcclxuXHQgICAgICAgICAgICB2YXIgYWx0ZXJuYXRlID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLkNvbmRpdGlvbmFsRXhwcmVzc2lvbihleHByLCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hc3NpZ25tZW50LW9wZXJhdG9yc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmNoZWNrUGF0dGVyblBhcmFtID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmFtKSB7XHJcblx0ICAgICAgICBzd2l0Y2ggKHBhcmFtLnR5cGUpIHtcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyOlxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlUGFyYW0ob3B0aW9ucywgcGFyYW0sIHBhcmFtLm5hbWUpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5SZXN0RWxlbWVudDpcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5QYXJhbShvcHRpb25zLCBwYXJhbS5hcmd1bWVudCk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LkFzc2lnbm1lbnRQYXR0ZXJuOlxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUGF0dGVyblBhcmFtKG9wdGlvbnMsIHBhcmFtLmxlZnQpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5BcnJheVBhdHRlcm46XHJcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW0uZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbS5lbGVtZW50c1tpXSAhPT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuUGFyYW0ob3B0aW9ucywgcGFyYW0uZWxlbWVudHNbaV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4Lk9iamVjdFBhdHRlcm46XHJcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW0ucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5QYXJhbShvcHRpb25zLCBwYXJhbS5wcm9wZXJ0aWVzW2ldLnZhbHVlKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIG9wdGlvbnMuc2ltcGxlID0gb3B0aW9ucy5zaW1wbGUgJiYgKHBhcmFtIGluc3RhbmNlb2YgTm9kZS5JZGVudGlmaWVyKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5yZWludGVycHJldEFzQ292ZXJGb3JtYWxzTGlzdCA9IGZ1bmN0aW9uIChleHByKSB7XHJcblx0ICAgICAgICB2YXIgcGFyYW1zID0gW2V4cHJdO1xyXG5cdCAgICAgICAgdmFyIG9wdGlvbnM7XHJcblx0ICAgICAgICB2YXIgYXN5bmNBcnJvdyA9IGZhbHNlO1xyXG5cdCAgICAgICAgc3dpdGNoIChleHByLnR5cGUpIHtcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyOlxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXI6XHJcblx0ICAgICAgICAgICAgICAgIHBhcmFtcyA9IGV4cHIucGFyYW1zO1xyXG5cdCAgICAgICAgICAgICAgICBhc3luY0Fycm93ID0gZXhwci5hc3luYztcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBvcHRpb25zID0ge1xyXG5cdCAgICAgICAgICAgIHNpbXBsZTogdHJ1ZSxcclxuXHQgICAgICAgICAgICBwYXJhbVNldDoge31cclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7ICsraSkge1xyXG5cdCAgICAgICAgICAgIHZhciBwYXJhbSA9IHBhcmFtc1tpXTtcclxuXHQgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LkFzc2lnbm1lbnRQYXR0ZXJuKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChwYXJhbS5yaWdodC50eXBlID09PSBzeW50YXhfMS5TeW50YXguWWllbGRFeHByZXNzaW9uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW0ucmlnaHQuYXJndW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHBhcmFtLnJpZ2h0LnR5cGUgPSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcjtcclxuXHQgICAgICAgICAgICAgICAgICAgIHBhcmFtLnJpZ2h0Lm5hbWUgPSAneWllbGQnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtLnJpZ2h0LmFyZ3VtZW50O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtLnJpZ2h0LmRlbGVnYXRlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGFzeW5jQXJyb3cgJiYgcGFyYW0udHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIgJiYgcGFyYW0ubmFtZSA9PT0gJ2F3YWl0Jykge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5QYXJhbShvcHRpb25zLCBwYXJhbSk7XHJcblx0ICAgICAgICAgICAgcGFyYW1zW2ldID0gcGFyYW07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCB8fCAhdGhpcy5jb250ZXh0LmFsbG93WWllbGQpIHtcclxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7ICsraSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcGFyYW0gPSBwYXJhbXNbaV07XHJcblx0ICAgICAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBzeW50YXhfMS5TeW50YXguWWllbGRFeHByZXNzaW9uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChvcHRpb25zLm1lc3NhZ2UgPT09IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UGFyYW1EdXBlKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5jb250ZXh0LnN0cmljdCA/IG9wdGlvbnMuc3RyaWN0ZWQgOiBvcHRpb25zLmZpcnN0UmVzdHJpY3RlZDtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuLCBvcHRpb25zLm1lc3NhZ2UpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBzaW1wbGU6IG9wdGlvbnMuc2ltcGxlLFxyXG5cdCAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxyXG5cdCAgICAgICAgICAgIHN0cmljdGVkOiBvcHRpb25zLnN0cmljdGVkLFxyXG5cdCAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZDogb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQsXHJcblx0ICAgICAgICAgICAgbWVzc2FnZTogb3B0aW9ucy5tZXNzYWdlXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgZXhwcjtcclxuXHQgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmFsbG93WWllbGQgJiYgdGhpcy5tYXRjaEtleXdvcmQoJ3lpZWxkJykpIHtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZVlpZWxkRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSBzdGFydFRva2VuO1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyAmJiAodG9rZW4ubGluZU51bWJlciA9PT0gdGhpcy5sb29rYWhlYWQubGluZU51bWJlcikgJiYgdG9rZW4udmFsdWUgPT09ICdhc3luYycpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyB8fCB0aGlzLm1hdGNoS2V5d29yZCgneWllbGQnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IHRoaXMucGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oYXJnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFthcmddLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlXHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmIChleHByLnR5cGUgPT09IEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIgfHwgdGhpcy5tYXRjaCgnPT4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJvdy1mdW5jdGlvbi1kZWZpbml0aW9uc1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBpc0FzeW5jID0gZXhwci5hc3luYztcclxuXHQgICAgICAgICAgICAgICAgdmFyIGxpc3QgPSB0aGlzLnJlaW50ZXJwcmV0QXNDb3ZlckZvcm1hbHNMaXN0KGV4cHIpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAobGlzdCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzTGluZVRlcm1pbmF0b3IpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzU3RyaWN0ID0gdGhpcy5jb250ZXh0LnN0cmljdDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0FsbG93U3RyaWN0RGlyZWN0aXZlID0gdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlID0gbGlzdC5zaW1wbGU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNBd2FpdCA9IHRoaXMuY29udGV4dC5hd2FpdDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hd2FpdCA9IGlzQXN5bmM7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJz0+Jyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYm9keSA9IHZvaWQgMDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCd7JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNBbGxvd0luID0gdGhpcy5jb250ZXh0LmFsbG93SW47XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSB0aGlzLnBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBib2R5LnR5cGUgIT09IHN5bnRheF8xLlN5bnRheC5CbG9ja1N0YXRlbWVudDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGxpc3QuZmlyc3RSZXN0cmljdGVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihsaXN0LmZpcnN0UmVzdHJpY3RlZCwgbGlzdC5tZXNzYWdlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGxpc3Quc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKGxpc3Quc3RyaWN0ZWQsIGxpc3QubWVzc2FnZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBleHByID0gaXNBc3luYyA/IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXN5bmNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihsaXN0LnBhcmFtcywgYm9keSwgZXhwcmVzc2lvbikpIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkFycm93RnVuY3Rpb25FeHByZXNzaW9uKGxpc3QucGFyYW1zLCBib2R5LCBleHByZXNzaW9uKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmUgPSBwcmV2aW91c0FsbG93U3RyaWN0RGlyZWN0aXZlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYXdhaXQgPSBwcmV2aW91c0F3YWl0O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaEFzc2lnbigpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkTEhTSW5Bc3NpZ25tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGV4cHIudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBleHByO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZChpZC5uYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdExIU0Fzc2lnbm1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChpZC5uYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCc9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gdG9rZW4udmFsdWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5Bc3NpZ25tZW50RXhwcmVzc2lvbihvcGVyYXRvciwgZXhwciwgcmlnaHQpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNvbW1hLW9wZXJhdG9yXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHZhciBleHByID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW107XHJcblx0ICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChleHByKTtcclxuXHQgICAgICAgICAgICB3aGlsZSAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMiAvKiBFT0YgKi8pIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2godGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbikpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuU2VxdWVuY2VFeHByZXNzaW9uKGV4cHJlc3Npb25zKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYmxvY2tcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN0YXRlbWVudExpc3RJdGVtID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSB0cnVlO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDQgLyogS2V5d29yZCAqLykge1xyXG5cdCAgICAgICAgICAgIHN3aXRjaCAodGhpcy5sb29rYWhlYWQudmFsdWUpIHtcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAnZXhwb3J0JzpcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmlzTW9kdWxlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCwgbWVzc2FnZXNfMS5NZXNzYWdlcy5JbGxlZ2FsRXhwb3J0RGVjbGFyYXRpb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUV4cG9ydERlY2xhcmF0aW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAnaW1wb3J0JzpcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmlzTW9kdWxlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCwgbWVzc2FnZXNfMS5NZXNzYWdlcy5JbGxlZ2FsSW1wb3J0RGVjbGFyYXRpb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUltcG9ydERlY2xhcmF0aW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAnY29uc3QnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUxleGljYWxEZWNsYXJhdGlvbih7IGluRm9yOiBmYWxzZSB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2NsYXNzJzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VDbGFzc0RlY2xhcmF0aW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAnbGV0JzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMuaXNMZXhpY2FsRGVjbGFyYXRpb24oKSA/IHRoaXMucGFyc2VMZXhpY2FsRGVjbGFyYXRpb24oeyBpbkZvcjogZmFsc2UgfSkgOiB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBzdGF0ZW1lbnQ7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VCbG9jayA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgneycpO1xyXG5cdCAgICAgICAgdmFyIGJsb2NrID0gW107XHJcblx0ICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGJsb2NrLnB1c2godGhpcy5wYXJzZVN0YXRlbWVudExpc3RJdGVtKCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ30nKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkJsb2NrU3RhdGVtZW50KGJsb2NrKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWxldC1hbmQtY29uc3QtZGVjbGFyYXRpb25zXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VMZXhpY2FsQmluZGluZyA9IGZ1bmN0aW9uIChraW5kLCBvcHRpb25zKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIGlkID0gdGhpcy5wYXJzZVBhdHRlcm4ocGFyYW1zLCBraW5kKTtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGlkLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKGlkLm5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFZhck5hbWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBpbml0ID0gbnVsbDtcclxuXHQgICAgICAgIGlmIChraW5kID09PSAnY29uc3QnKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoS2V5d29yZCgnaW4nKSAmJiAhdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdvZicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCc9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5EZWNsYXJhdGlvbk1pc3NpbmdJbml0aWFsaXplciwgJ2NvbnN0Jyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICgoIW9wdGlvbnMuaW5Gb3IgJiYgaWQudHlwZSAhPT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIpIHx8IHRoaXMubWF0Y2goJz0nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc9Jyk7XHJcblx0ICAgICAgICAgICAgaW5pdCA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdG9yKGlkLCBpbml0KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VCaW5kaW5nTGlzdCA9IGZ1bmN0aW9uIChraW5kLCBvcHRpb25zKSB7XHJcblx0ICAgICAgICB2YXIgbGlzdCA9IFt0aGlzLnBhcnNlTGV4aWNhbEJpbmRpbmcoa2luZCwgb3B0aW9ucyldO1xyXG5cdCAgICAgICAgd2hpbGUgKHRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgbGlzdC5wdXNoKHRoaXMucGFyc2VMZXhpY2FsQmluZGluZyhraW5kLCBvcHRpb25zKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gbGlzdDtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5pc0xleGljYWxEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc2Nhbm5lci5zYXZlU3RhdGUoKTtcclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lci5zY2FuQ29tbWVudHMoKTtcclxuXHQgICAgICAgIHZhciBuZXh0ID0gdGhpcy5zY2FubmVyLmxleCgpO1xyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyLnJlc3RvcmVTdGF0ZShzdGF0ZSk7XHJcblx0ICAgICAgICByZXR1cm4gKG5leHQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSB8fFxyXG5cdCAgICAgICAgICAgIChuZXh0LnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyAmJiBuZXh0LnZhbHVlID09PSAnWycpIHx8XHJcblx0ICAgICAgICAgICAgKG5leHQudHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovICYmIG5leHQudmFsdWUgPT09ICd7JykgfHxcclxuXHQgICAgICAgICAgICAobmV4dC50eXBlID09PSA0IC8qIEtleXdvcmQgKi8gJiYgbmV4dC52YWx1ZSA9PT0gJ2xldCcpIHx8XHJcblx0ICAgICAgICAgICAgKG5leHQudHlwZSA9PT0gNCAvKiBLZXl3b3JkICovICYmIG5leHQudmFsdWUgPT09ICd5aWVsZCcpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlTGV4aWNhbERlY2xhcmF0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIga2luZCA9IHRoaXMubmV4dFRva2VuKCkudmFsdWU7XHJcblx0ICAgICAgICBhc3NlcnRfMS5hc3NlcnQoa2luZCA9PT0gJ2xldCcgfHwga2luZCA9PT0gJ2NvbnN0JywgJ0xleGljYWwgZGVjbGFyYXRpb24gbXVzdCBiZSBlaXRoZXIgbGV0IG9yIGNvbnN0Jyk7XHJcblx0ICAgICAgICB2YXIgZGVjbGFyYXRpb25zID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KGtpbmQsIG9wdGlvbnMpO1xyXG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywga2luZCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1kZXN0cnVjdHVyaW5nLWJpbmRpbmctcGF0dGVybnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJpbmRpbmdSZXN0RWxlbWVudCA9IGZ1bmN0aW9uIChwYXJhbXMsIGtpbmQpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnLi4uJyk7XHJcblx0ICAgICAgICB2YXIgYXJnID0gdGhpcy5wYXJzZVBhdHRlcm4ocGFyYW1zLCBraW5kKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlJlc3RFbGVtZW50KGFyZykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQXJyYXlQYXR0ZXJuID0gZnVuY3Rpb24gKHBhcmFtcywga2luZCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCdbJyk7XHJcblx0ICAgICAgICB2YXIgZWxlbWVudHMgPSBbXTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5tYXRjaCgnXScpKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKG51bGwpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJy4uLicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKHRoaXMucGFyc2VCaW5kaW5nUmVzdEVsZW1lbnQocGFyYW1zLCBraW5kKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2godGhpcy5wYXJzZVBhdHRlcm5XaXRoRGVmYXVsdChwYXJhbXMsIGtpbmQpKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJ10nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJywnKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCddJyk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5BcnJheVBhdHRlcm4oZWxlbWVudHMpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVByb3BlcnR5UGF0dGVybiA9IGZ1bmN0aW9uIChwYXJhbXMsIGtpbmQpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgY29tcHV0ZWQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBzaG9ydGhhbmQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBtZXRob2QgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBrZXk7XHJcblx0ICAgICAgICB2YXIgdmFsdWU7XHJcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGtleVRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIHZhciBpbml0ID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JZGVudGlmaWVyKGtleVRva2VuLnZhbHVlKSk7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJz0nKSkge1xyXG5cdCAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChrZXlUb2tlbik7XHJcblx0ICAgICAgICAgICAgICAgIHNob3J0aGFuZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBleHByID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShrZXlUb2tlbiksIG5ldyBOb2RlLkFzc2lnbm1lbnRQYXR0ZXJuKGluaXQsIGV4cHIpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMubWF0Y2goJzonKSkge1xyXG5cdCAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChrZXlUb2tlbik7XHJcblx0ICAgICAgICAgICAgICAgIHNob3J0aGFuZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gaW5pdDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc6Jyk7XHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZVBhdHRlcm5XaXRoRGVmYXVsdChwYXJhbXMsIGtpbmQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc6Jyk7XHJcblx0ICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlUGF0dGVybldpdGhEZWZhdWx0KHBhcmFtcywga2luZCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Qcm9wZXJ0eSgnaW5pdCcsIGtleSwgY29tcHV0ZWQsIHZhbHVlLCBtZXRob2QsIHNob3J0aGFuZCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlT2JqZWN0UGF0dGVybiA9IGZ1bmN0aW9uIChwYXJhbXMsIGtpbmQpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgcHJvcGVydGllcyA9IFtdO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ3snKTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKHRoaXMucGFyc2VQcm9wZXJ0eVBhdHRlcm4ocGFyYW1zLCBraW5kKSk7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJywnKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnfScpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuT2JqZWN0UGF0dGVybihwcm9wZXJ0aWVzKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VQYXR0ZXJuID0gZnVuY3Rpb24gKHBhcmFtcywga2luZCkge1xyXG5cdCAgICAgICAgdmFyIHBhdHRlcm47XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnWycpKSB7XHJcblx0ICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMucGFyc2VBcnJheVBhdHRlcm4ocGFyYW1zLCBraW5kKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJ3snKSkge1xyXG5cdCAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLnBhcnNlT2JqZWN0UGF0dGVybihwYXJhbXMsIGtpbmQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdsZXQnKSAmJiAoa2luZCA9PT0gJ2NvbnN0JyB8fCBraW5kID09PSAnbGV0JykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCwgbWVzc2FnZXNfMS5NZXNzYWdlcy5MZXRJbkxleGljYWxCaW5kaW5nKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgcGFyYW1zLnB1c2godGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKGtpbmQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHBhdHRlcm47XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VQYXR0ZXJuV2l0aERlZmF1bHQgPSBmdW5jdGlvbiAocGFyYW1zLCBraW5kKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdmFyIHBhdHRlcm4gPSB0aGlzLnBhcnNlUGF0dGVybihwYXJhbXMsIGtpbmQpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJz0nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcclxuXHQgICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuQXNzaWdubWVudFBhdHRlcm4ocGF0dGVybiwgcmlnaHQpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBwYXR0ZXJuO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy12YXJpYWJsZS1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVZhcmlhYmxlSWRlbnRpZmllciA9IGZ1bmN0aW9uIChraW5kKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlID09PSA0IC8qIEtleXdvcmQgKi8gJiYgdG9rZW4udmFsdWUgPT09ICd5aWVsZCcpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlICE9PSAzIC8qIElkZW50aWZpZXIgKi8pIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiB0b2tlbi50eXBlID09PSA0IC8qIEtleXdvcmQgKi8gJiYgdGhpcy5zY2FubmVyLmlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgfHwgdG9rZW4udmFsdWUgIT09ICdsZXQnIHx8IGtpbmQgIT09ICd2YXInKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKCh0aGlzLmNvbnRleHQuaXNNb2R1bGUgfHwgdGhpcy5jb250ZXh0LmF3YWl0KSAmJiB0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgdG9rZW4udmFsdWUgPT09ICdhd2FpdCcpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLklkZW50aWZpZXIodG9rZW4udmFsdWUpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBwYXJhbXMgPSBbXTtcclxuXHQgICAgICAgIHZhciBpZCA9IHRoaXMucGFyc2VQYXR0ZXJuKHBhcmFtcywgJ3ZhcicpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgaWQudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQoaWQubmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0VmFyTmFtZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGluaXQgPSBudWxsO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJz0nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgaW5pdCA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAoaWQudHlwZSAhPT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIgJiYgIW9wdGlvbnMuaW5Gb3IpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnPScpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdG9yKGlkLCBpbml0KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uTGlzdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0ICAgICAgICB2YXIgb3B0ID0geyBpbkZvcjogb3B0aW9ucy5pbkZvciB9O1xyXG5cdCAgICAgICAgdmFyIGxpc3QgPSBbXTtcclxuXHQgICAgICAgIGxpc3QucHVzaCh0aGlzLnBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbihvcHQpKTtcclxuXHQgICAgICAgIHdoaWxlICh0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGxpc3QucHVzaCh0aGlzLnBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbihvcHQpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBsaXN0O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVmFyaWFibGVTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCd2YXInKTtcclxuXHQgICAgICAgIHZhciBkZWNsYXJhdGlvbnMgPSB0aGlzLnBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QoeyBpbkZvcjogZmFsc2UgfSk7XHJcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCAndmFyJykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lbXB0eS1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUVtcHR5U3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCc7Jyk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FbXB0eVN0YXRlbWVudCgpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZXhwcmVzc2lvbi1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHByZXNzaW9uU3RhdGVtZW50KGV4cHIpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaWYtc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VJZkNsYXVzZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHRoaXMubWF0Y2hLZXl3b3JkKCdmdW5jdGlvbicpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb24pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUlmU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBjb25zZXF1ZW50O1xyXG5cdCAgICAgICAgdmFyIGFsdGVybmF0ZSA9IG51bGw7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2lmJyk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgdmFyIHRlc3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykgJiYgdGhpcy5jb25maWcudG9sZXJhbnQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgICAgIGNvbnNlcXVlbnQgPSB0aGlzLmZpbmFsaXplKHRoaXMuY3JlYXRlTm9kZSgpLCBuZXcgTm9kZS5FbXB0eVN0YXRlbWVudCgpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICAgICAgY29uc2VxdWVudCA9IHRoaXMucGFyc2VJZkNsYXVzZSgpO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnZWxzZScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIGFsdGVybmF0ZSA9IHRoaXMucGFyc2VJZkNsYXVzZSgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLklmU3RhdGVtZW50KHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1kby13aGlsZS1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZURvV2hpbGVTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdkbycpO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzSW5JdGVyYXRpb24gPSB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb247XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24gPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24gPSBwcmV2aW91c0luSXRlcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCd3aGlsZScpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIHZhciB0ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpICYmIHRoaXMuY29uZmlnLnRvbGVyYW50KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJzsnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkRvV2hpbGVTdGF0ZW1lbnQoYm9keSwgdGVzdCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy13aGlsZS1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVdoaWxlU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCd3aGlsZScpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIHZhciB0ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpICYmIHRoaXMuY29uZmlnLnRvbGVyYW50KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgICAgICBib2R5ID0gdGhpcy5maW5hbGl6ZSh0aGlzLmNyZWF0ZU5vZGUoKSwgbmV3IE5vZGUuRW1wdHlTdGF0ZW1lbnQoKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgICAgIHZhciBwcmV2aW91c0luSXRlcmF0aW9uID0gdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiA9IHRydWU7XHJcblx0ICAgICAgICAgICAgYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24gPSBwcmV2aW91c0luSXRlcmF0aW9uO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuV2hpbGVTdGF0ZW1lbnQodGVzdCwgYm9keSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1mb3Itc3RhdGVtZW50XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWZvci1pbi1hbmQtZm9yLW9mLXN0YXRlbWVudHNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZvclN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBpbml0ID0gbnVsbDtcclxuXHQgICAgICAgIHZhciB0ZXN0ID0gbnVsbDtcclxuXHQgICAgICAgIHZhciB1cGRhdGUgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIGZvckluID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciBsZWZ0LCByaWdodDtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2ZvcicpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCc7JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCd2YXInKSkge1xyXG5cdCAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0FsbG93SW4gPSB0aGlzLmNvbnRleHQuYWxsb3dJbjtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IHRoaXMucGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uTGlzdCh7IGluRm9yOiB0cnVlIH0pO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEgJiYgdGhpcy5tYXRjaEtleXdvcmQoJ2luJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkZWNsID0gZGVjbGFyYXRpb25zWzBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGRlY2wuaW5pdCAmJiAoZGVjbC5pZC50eXBlID09PSBzeW50YXhfMS5TeW50YXguQXJyYXlQYXR0ZXJuIHx8IGRlY2wuaWQudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4Lk9iamVjdFBhdHRlcm4gfHwgdGhpcy5jb250ZXh0LnN0cmljdCkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5Gb3JJbk9mTG9vcEluaXRpYWxpemVyLCAnZm9yLWluJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5maW5hbGl6ZShpbml0LCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywgJ3ZhcicpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEgJiYgZGVjbGFyYXRpb25zWzBdLmluaXQgPT09IG51bGwgJiYgdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdvZicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5maW5hbGl6ZShpbml0LCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywgJ3ZhcicpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGZvckluID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5maW5hbGl6ZShpbml0LCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywgJ3ZhcicpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc7Jyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2NvbnN0JykgfHwgdGhpcy5tYXRjaEtleXdvcmQoJ2xldCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGtpbmQgPSB0aGlzLm5leHRUb2tlbigpLnZhbHVlO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5zdHJpY3QgJiYgdGhpcy5sb29rYWhlYWQudmFsdWUgPT09ICdpbicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmZpbmFsaXplKGluaXQsIG5ldyBOb2RlLklkZW50aWZpZXIoa2luZCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNBbGxvd0luID0gdGhpcy5jb250ZXh0LmFsbG93SW47XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdChraW5kLCB7IGluRm9yOiB0cnVlIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSAmJiBkZWNsYXJhdGlvbnNbMF0uaW5pdCA9PT0gbnVsbCAmJiB0aGlzLm1hdGNoS2V5d29yZCgnaW4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmZpbmFsaXplKGluaXQsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCBraW5kKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmIGRlY2xhcmF0aW9uc1swXS5pbml0ID09PSBudWxsICYmIHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnb2YnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmZpbmFsaXplKGluaXQsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCBraW5kKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvckluID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5maW5hbGl6ZShpbml0LCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywga2luZCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgaW5pdFN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dJbiA9IHRoaXMuY29udGV4dC5hbGxvd0luO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2luJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCB8fCBpbml0LnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRMSFNJbkZvckluKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihpbml0KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdvZicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgfHwgaW5pdC50eXBlID09PSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkTEhTSW5Gb3JMb29wKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihpbml0KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9ySW4gPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdFNlcSA9IFtpbml0XTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRTZXEucHVzaCh0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKGluaXRTdGFydFRva2VuKSwgbmV3IE5vZGUuU2VxdWVuY2VFeHByZXNzaW9uKGluaXRTZXEpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc7Jyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodHlwZW9mIGxlZnQgPT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCc7JykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGVzdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc7Jyk7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdXBkYXRlID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgYm9keTtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpICYmIHRoaXMuY29uZmlnLnRvbGVyYW50KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgICAgICBib2R5ID0gdGhpcy5maW5hbGl6ZSh0aGlzLmNyZWF0ZU5vZGUoKSwgbmV3IE5vZGUuRW1wdHlTdGF0ZW1lbnQoKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgICAgIHZhciBwcmV2aW91c0luSXRlcmF0aW9uID0gdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiA9IHRydWU7XHJcblx0ICAgICAgICAgICAgYm9keSA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlU3RhdGVtZW50KTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24gPSBwcmV2aW91c0luSXRlcmF0aW9uO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuICh0eXBlb2YgbGVmdCA9PT0gJ3VuZGVmaW5lZCcpID9cclxuXHQgICAgICAgICAgICB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZvclN0YXRlbWVudChpbml0LCB0ZXN0LCB1cGRhdGUsIGJvZHkpKSA6XHJcblx0ICAgICAgICAgICAgZm9ySW4gPyB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZvckluU3RhdGVtZW50KGxlZnQsIHJpZ2h0LCBib2R5KSkgOlxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZvck9mU3RhdGVtZW50KGxlZnQsIHJpZ2h0LCBib2R5KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNvbnRpbnVlLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ29udGludWVTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdjb250aW51ZScpO1xyXG5cdCAgICAgICAgdmFyIGxhYmVsID0gbnVsbDtcclxuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgIXRoaXMuaGFzTGluZVRlcm1pbmF0b3IpIHtcclxuXHQgICAgICAgICAgICB2YXIgaWQgPSB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgbGFiZWwgPSBpZDtcclxuXHQgICAgICAgICAgICB2YXIga2V5ID0gJyQnICsgaWQubmFtZTtcclxuXHQgICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmNvbnRleHQubGFiZWxTZXQsIGtleSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5rbm93bkxhYmVsLCBpZC5uYW1lKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgIGlmIChsYWJlbCA9PT0gbnVsbCAmJiAhdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSWxsZWdhbENvbnRpbnVlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkNvbnRpbnVlU3RhdGVtZW50KGxhYmVsKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWJyZWFrLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQnJlYWtTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdicmVhaycpO1xyXG5cdCAgICAgICAgdmFyIGxhYmVsID0gbnVsbDtcclxuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgIXRoaXMuaGFzTGluZVRlcm1pbmF0b3IpIHtcclxuXHQgICAgICAgICAgICB2YXIgaWQgPSB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgdmFyIGtleSA9ICckJyArIGlkLm5hbWU7XHJcblx0ICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jb250ZXh0LmxhYmVsU2V0LCBrZXkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlVua25vd25MYWJlbCwgaWQubmFtZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGxhYmVsID0gaWQ7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgIGlmIChsYWJlbCA9PT0gbnVsbCAmJiAhdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uICYmICF0aGlzLmNvbnRleHQuaW5Td2l0Y2gpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbGxlZ2FsQnJlYWspO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQnJlYWtTdGF0ZW1lbnQobGFiZWwpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmV0dXJuLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUmV0dXJuU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHkpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbGxlZ2FsUmV0dXJuKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3JldHVybicpO1xyXG5cdCAgICAgICAgdmFyIGhhc0FyZ3VtZW50ID0gIXRoaXMubWF0Y2goJzsnKSAmJiAhdGhpcy5tYXRjaCgnfScpICYmXHJcblx0ICAgICAgICAgICAgIXRoaXMuaGFzTGluZVRlcm1pbmF0b3IgJiYgdGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMiAvKiBFT0YgKi87XHJcblx0ICAgICAgICB2YXIgYXJndW1lbnQgPSBoYXNBcmd1bWVudCA/IHRoaXMucGFyc2VFeHByZXNzaW9uKCkgOiBudWxsO1xyXG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5SZXR1cm5TdGF0ZW1lbnQoYXJndW1lbnQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtd2l0aC1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVdpdGhTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdE1vZGVXaXRoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgYm9keTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnd2l0aCcpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIHZhciBvYmplY3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykgJiYgdGhpcy5jb25maWcudG9sZXJhbnQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgICAgIGJvZHkgPSB0aGlzLmZpbmFsaXplKHRoaXMuY3JlYXRlTm9kZSgpLCBuZXcgTm9kZS5FbXB0eVN0YXRlbWVudCgpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICAgICAgYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLldpdGhTdGF0ZW1lbnQob2JqZWN0LCBib2R5KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN3aXRjaC1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN3aXRjaENhc2UgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHRlc3Q7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2RlZmF1bHQnKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgdGVzdCA9IG51bGw7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2Nhc2UnKTtcclxuXHQgICAgICAgICAgICB0ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCc6Jyk7XHJcblx0ICAgICAgICB2YXIgY29uc2VxdWVudCA9IFtdO1xyXG5cdCAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnfScpIHx8IHRoaXMubWF0Y2hLZXl3b3JkKCdkZWZhdWx0JykgfHwgdGhpcy5tYXRjaEtleXdvcmQoJ2Nhc2UnKSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgY29uc2VxdWVudC5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlN3aXRjaENhc2UodGVzdCwgY29uc2VxdWVudCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU3dpdGNoU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnc3dpdGNoJyk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgdmFyIGRpc2NyaW1pbmFudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzSW5Td2l0Y2ggPSB0aGlzLmNvbnRleHQuaW5Td2l0Y2g7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5Td2l0Y2ggPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIGNhc2VzID0gW107XHJcblx0ICAgICAgICB2YXIgZGVmYXVsdEZvdW5kID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgneycpO1xyXG5cdCAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB2YXIgY2xhdXNlID0gdGhpcy5wYXJzZVN3aXRjaENhc2UoKTtcclxuXHQgICAgICAgICAgICBpZiAoY2xhdXNlLnRlc3QgPT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRGb3VuZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuTXVsdGlwbGVEZWZhdWx0c0luU3dpdGNoKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0Rm91bmQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBjYXNlcy5wdXNoKGNsYXVzZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnfScpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluU3dpdGNoID0gcHJldmlvdXNJblN3aXRjaDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlN3aXRjaFN0YXRlbWVudChkaXNjcmltaW5hbnQsIGNhc2VzKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWxhYmVsbGVkLXN0YXRlbWVudHNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxhYmVsbGVkU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBleHByID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIHZhciBzdGF0ZW1lbnQ7XHJcblx0ICAgICAgICBpZiAoKGV4cHIudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIpICYmIHRoaXMubWF0Y2goJzonKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgdmFyIGlkID0gZXhwcjtcclxuXHQgICAgICAgICAgICB2YXIga2V5ID0gJyQnICsgaWQubmFtZTtcclxuXHQgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY29udGV4dC5sYWJlbFNldCwga2V5KSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5SZWRlY2xhcmF0aW9uLCAnTGFiZWwnLCBpZC5uYW1lKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmxhYmVsU2V0W2tleV0gPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIHZhciBib2R5ID0gdm9pZCAwO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnY2xhc3MnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgYm9keSA9IHRoaXMucGFyc2VDbGFzc0RlY2xhcmF0aW9uKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdmdW5jdGlvbicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbigpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RGdW5jdGlvbik7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGVjbGFyYXRpb24uZ2VuZXJhdG9yKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLkdlbmVyYXRvckluTGVnYWN5Q29udGV4dCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYm9keSA9IGRlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29udGV4dC5sYWJlbFNldFtrZXldO1xyXG5cdCAgICAgICAgICAgIHN0YXRlbWVudCA9IG5ldyBOb2RlLkxhYmVsZWRTdGF0ZW1lbnQoaWQsIGJvZHkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICAgICAgc3RhdGVtZW50ID0gbmV3IE5vZGUuRXhwcmVzc2lvblN0YXRlbWVudChleHByKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIHN0YXRlbWVudCk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRocm93LXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVGhyb3dTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCd0aHJvdycpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuaGFzTGluZVRlcm1pbmF0b3IpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5OZXdsaW5lQWZ0ZXJUaHJvdyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5UaHJvd1N0YXRlbWVudChhcmd1bWVudCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10cnktc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VDYXRjaENsYXVzZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2NhdGNoJyk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIHBhcmFtID0gdGhpcy5wYXJzZVBhdHRlcm4ocGFyYW1zKTtcclxuXHQgICAgICAgIHZhciBwYXJhbU1hcCA9IHt9O1xyXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICB2YXIga2V5ID0gJyQnICsgcGFyYW1zW2ldLnZhbHVlO1xyXG5cdCAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFyYW1NYXAsIGtleSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuRHVwbGljYXRlQmluZGluZywgcGFyYW1zW2ldLnZhbHVlKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgcGFyYW1NYXBba2V5XSA9IHRydWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBwYXJhbS50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcikge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZChwYXJhbS5uYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RDYXRjaFZhcmlhYmxlKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlQmxvY2soKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkNhdGNoQ2xhdXNlKHBhcmFtLCBib2R5KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VGaW5hbGx5Q2xhdXNlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdmaW5hbGx5Jyk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJsb2NrKCk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VUcnlTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCd0cnknKTtcclxuXHQgICAgICAgIHZhciBibG9jayA9IHRoaXMucGFyc2VCbG9jaygpO1xyXG5cdCAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLm1hdGNoS2V5d29yZCgnY2F0Y2gnKSA/IHRoaXMucGFyc2VDYXRjaENsYXVzZSgpIDogbnVsbDtcclxuXHQgICAgICAgIHZhciBmaW5hbGl6ZXIgPSB0aGlzLm1hdGNoS2V5d29yZCgnZmluYWxseScpID8gdGhpcy5wYXJzZUZpbmFsbHlDbGF1c2UoKSA6IG51bGw7XHJcblx0ICAgICAgICBpZiAoIWhhbmRsZXIgJiYgIWZpbmFsaXplcikge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLk5vQ2F0Y2hPckZpbmFsbHkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVHJ5U3RhdGVtZW50KGJsb2NrLCBoYW5kbGVyLCBmaW5hbGl6ZXIpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZGVidWdnZXItc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VEZWJ1Z2dlclN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2RlYnVnZ2VyJyk7XHJcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkRlYnVnZ2VyU3RhdGVtZW50KCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXN0YXRlbWVudHMtYW5kLWRlY2xhcmF0aW9uc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXRlbWVudDtcclxuXHQgICAgICAgIHN3aXRjaCAodGhpcy5sb29rYWhlYWQudHlwZSkge1xyXG5cdCAgICAgICAgICAgIGNhc2UgMSAvKiBCb29sZWFuTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDUgLyogTnVsbExpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA2IC8qIE51bWVyaWNMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgOCAvKiBTdHJpbmdMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgMTAgLyogVGVtcGxhdGUgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA5IC8qIFJlZ3VsYXJFeHByZXNzaW9uICovOlxyXG5cdCAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDcgLyogUHVuY3R1YXRvciAqLzpcclxuXHQgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5sb29rYWhlYWQudmFsdWU7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ3snKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlQmxvY2soKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gJygnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSAnOycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VFbXB0eVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDMgLyogSWRlbnRpZmllciAqLzpcclxuXHQgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5tYXRjaEFzeW5jRnVuY3Rpb24oKSA/IHRoaXMucGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKCkgOiB0aGlzLnBhcnNlTGFiZWxsZWRTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSA0IC8qIEtleXdvcmQgKi86XHJcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5sb29rYWhlYWQudmFsdWUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JyZWFrJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlQnJlYWtTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbnRpbnVlJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlQ29udGludWVTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RlYnVnZ2VyJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RvJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRG9XaGlsZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnZm9yJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRm9yU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2lmJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlSWZTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JldHVybic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVJldHVyblN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3dpdGNoJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlU3dpdGNoU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICd0aHJvdyc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVRocm93U3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICd0cnknOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VUcnlTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Zhcic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVZhcmlhYmxlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICd3aGlsZSc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVdoaWxlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICd3aXRoJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlV2l0aFN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHN0YXRlbWVudDtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZnVuY3Rpb24tZGVmaW5pdGlvbnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ3snKTtcclxuXHQgICAgICAgIHZhciBib2R5ID0gdGhpcy5wYXJzZURpcmVjdGl2ZVByb2xvZ3VlcygpO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzTGFiZWxTZXQgPSB0aGlzLmNvbnRleHQubGFiZWxTZXQ7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNJbkl0ZXJhdGlvbiA9IHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbjtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0luU3dpdGNoID0gdGhpcy5jb250ZXh0LmluU3dpdGNoO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzSW5GdW5jdGlvbkJvZHkgPSB0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQubGFiZWxTZXQgPSB7fTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluU3dpdGNoID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHkgPSB0cnVlO1xyXG5cdCAgICAgICAgd2hpbGUgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDIgLyogRU9GICovKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgYm9keS5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd9Jyk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQubGFiZWxTZXQgPSBwcmV2aW91c0xhYmVsU2V0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uID0gcHJldmlvdXNJbkl0ZXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pblN3aXRjaCA9IHByZXZpb3VzSW5Td2l0Y2g7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHkgPSBwcmV2aW91c0luRnVuY3Rpb25Cb2R5O1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQmxvY2tTdGF0ZW1lbnQoYm9keSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnZhbGlkYXRlUGFyYW0gPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyYW0sIG5hbWUpIHtcclxuXHQgICAgICAgIHZhciBrZXkgPSAnJCcgKyBuYW1lO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQobmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5zdHJpY3RlZCA9IHBhcmFtO1xyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFBhcmFtTmFtZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLnBhcmFtU2V0LCBrZXkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RyaWN0ZWQgPSBwYXJhbTtcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RQYXJhbUR1cGU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAoIW9wdGlvbnMuZmlyc3RSZXN0cmljdGVkKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKG5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkID0gcGFyYW07XHJcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMubWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UGFyYW1OYW1lO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnNjYW5uZXIuaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKG5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkID0gcGFyYW07XHJcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMubWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucy5wYXJhbVNldCwga2V5KSkge1xyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLnN0cmljdGVkID0gcGFyYW07XHJcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMubWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UGFyYW1EdXBlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcblx0ICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdCAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRpb25zLnBhcmFtU2V0LCBrZXksIHsgdmFsdWU6IHRydWUsIGVudW1lcmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBvcHRpb25zLnBhcmFtU2V0W2tleV0gPSB0cnVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUmVzdEVsZW1lbnQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJy4uLicpO1xyXG5cdCAgICAgICAgdmFyIGFyZyA9IHRoaXMucGFyc2VQYXR0ZXJuKHBhcmFtcyk7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnPScpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuRGVmYXVsdFJlc3RQYXJhbWV0ZXIpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5QYXJhbWV0ZXJBZnRlclJlc3RQYXJhbWV0ZXIpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuUmVzdEVsZW1lbnQoYXJnKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VGb3JtYWxQYXJhbWV0ZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIHBhcmFtID0gdGhpcy5tYXRjaCgnLi4uJykgPyB0aGlzLnBhcnNlUmVzdEVsZW1lbnQocGFyYW1zKSA6IHRoaXMucGFyc2VQYXR0ZXJuV2l0aERlZmF1bHQocGFyYW1zKTtcclxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVBhcmFtKG9wdGlvbnMsIHBhcmFtc1tpXSwgcGFyYW1zW2ldLnZhbHVlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIG9wdGlvbnMuc2ltcGxlID0gb3B0aW9ucy5zaW1wbGUgJiYgKHBhcmFtIGluc3RhbmNlb2YgTm9kZS5JZGVudGlmaWVyKTtcclxuXHQgICAgICAgIG9wdGlvbnMucGFyYW1zLnB1c2gocGFyYW0pO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRm9ybWFsUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChmaXJzdFJlc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgIHZhciBvcHRpb25zO1xyXG5cdCAgICAgICAgb3B0aW9ucyA9IHtcclxuXHQgICAgICAgICAgICBzaW1wbGU6IHRydWUsXHJcblx0ICAgICAgICAgICAgcGFyYW1zOiBbXSxcclxuXHQgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQ6IGZpcnN0UmVzdHJpY3RlZFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgIG9wdGlvbnMucGFyYW1TZXQgPSB7fTtcclxuXHQgICAgICAgICAgICB3aGlsZSAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMiAvKiBFT0YgKi8pIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcihvcHRpb25zKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJywnKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBzaW1wbGU6IG9wdGlvbnMuc2ltcGxlLFxyXG5cdCAgICAgICAgICAgIHBhcmFtczogb3B0aW9ucy5wYXJhbXMsXHJcblx0ICAgICAgICAgICAgc3RyaWN0ZWQ6IG9wdGlvbnMuc3RyaWN0ZWQsXHJcblx0ICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkOiBvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCxcclxuXHQgICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLm1lc3NhZ2VcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUubWF0Y2hBc3luY0Z1bmN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG1hdGNoID0gdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhc3luYycpO1xyXG5cdCAgICAgICAgaWYgKG1hdGNoKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zY2FubmVyLnNhdmVTdGF0ZSgpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5zY2FuQ29tbWVudHMoKTtcclxuXHQgICAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMuc2Nhbm5lci5sZXgoKTtcclxuXHQgICAgICAgICAgICB0aGlzLnNjYW5uZXIucmVzdG9yZVN0YXRlKHN0YXRlKTtcclxuXHQgICAgICAgICAgICBtYXRjaCA9IChzdGF0ZS5saW5lTnVtYmVyID09PSBuZXh0LmxpbmVOdW1iZXIpICYmIChuZXh0LnR5cGUgPT09IDQgLyogS2V5d29yZCAqLykgJiYgKG5leHQudmFsdWUgPT09ICdmdW5jdGlvbicpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIG1hdGNoO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChpZGVudGlmaWVySXNPcHRpb25hbCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBpc0FzeW5jID0gdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhc3luYycpO1xyXG5cdCAgICAgICAgaWYgKGlzQXN5bmMpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdmdW5jdGlvbicpO1xyXG5cdCAgICAgICAgdmFyIGlzR2VuZXJhdG9yID0gaXNBc3luYyA/IGZhbHNlIDogdGhpcy5tYXRjaCgnKicpO1xyXG5cdCAgICAgICAgaWYgKGlzR2VuZXJhdG9yKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBtZXNzYWdlO1xyXG5cdCAgICAgICAgdmFyIGlkID0gbnVsbDtcclxuXHQgICAgICAgIHZhciBmaXJzdFJlc3RyaWN0ZWQgPSBudWxsO1xyXG5cdCAgICAgICAgaWYgKCFpZGVudGlmaWVySXNPcHRpb25hbCB8fCAhdGhpcy5tYXRjaCgnKCcpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgaWQgPSB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWUpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uTmFtZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnNjYW5uZXIuaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XHJcblx0ICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQ7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd0F3YWl0ID0gdGhpcy5jb250ZXh0LmF3YWl0O1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmF3YWl0ID0gaXNBc3luYztcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gIWlzR2VuZXJhdG9yO1xyXG5cdCAgICAgICAgdmFyIGZvcm1hbFBhcmFtZXRlcnMgPSB0aGlzLnBhcnNlRm9ybWFsUGFyYW1ldGVycyhmaXJzdFJlc3RyaWN0ZWQpO1xyXG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IGZvcm1hbFBhcmFtZXRlcnMucGFyYW1zO1xyXG5cdCAgICAgICAgdmFyIHN0cmljdGVkID0gZm9ybWFsUGFyYW1ldGVycy5zdHJpY3RlZDtcclxuXHQgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IGZvcm1hbFBhcmFtZXRlcnMuZmlyc3RSZXN0cmljdGVkO1xyXG5cdCAgICAgICAgaWYgKGZvcm1hbFBhcmFtZXRlcnMubWVzc2FnZSkge1xyXG5cdCAgICAgICAgICAgIG1lc3NhZ2UgPSBmb3JtYWxQYXJhbWV0ZXJzLm1lc3NhZ2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNTdHJpY3QgPSB0aGlzLmNvbnRleHQuc3RyaWN0O1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dTdHJpY3REaXJlY3RpdmUgPSB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmUgPSBmb3JtYWxQYXJhbWV0ZXJzLnNpbXBsZTtcclxuXHQgICAgICAgIHZhciBib2R5ID0gdGhpcy5wYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMoKTtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGZpcnN0UmVzdHJpY3RlZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oZmlyc3RSZXN0cmljdGVkLCBtZXNzYWdlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHN0cmljdGVkKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihzdHJpY3RlZCwgbWVzc2FnZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmUgPSBwcmV2aW91c0FsbG93U3RyaWN0RGlyZWN0aXZlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmF3YWl0ID0gcHJldmlvdXNBbGxvd0F3YWl0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XHJcblx0ICAgICAgICByZXR1cm4gaXNBc3luYyA/IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXN5bmNGdW5jdGlvbkRlY2xhcmF0aW9uKGlkLCBwYXJhbXMsIGJvZHkpKSA6XHJcblx0ICAgICAgICAgICAgdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5GdW5jdGlvbkRlY2xhcmF0aW9uKGlkLCBwYXJhbXMsIGJvZHksIGlzR2VuZXJhdG9yKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VGdW5jdGlvbkV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGlzQXN5bmMgPSB0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzeW5jJyk7XHJcblx0ICAgICAgICBpZiAoaXNBc3luYykge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2Z1bmN0aW9uJyk7XHJcblx0ICAgICAgICB2YXIgaXNHZW5lcmF0b3IgPSBpc0FzeW5jID8gZmFsc2UgOiB0aGlzLm1hdGNoKCcqJyk7XHJcblx0ICAgICAgICBpZiAoaXNHZW5lcmF0b3IpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG1lc3NhZ2U7XHJcblx0ICAgICAgICB2YXIgaWQgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIGZpcnN0UmVzdHJpY3RlZDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93QXdhaXQgPSB0aGlzLmNvbnRleHQuYXdhaXQ7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYXdhaXQgPSBpc0FzeW5jO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSAhaXNHZW5lcmF0b3I7XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJygnKSkge1xyXG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgIGlkID0gKCF0aGlzLmNvbnRleHQuc3RyaWN0ICYmICFpc0dlbmVyYXRvciAmJiB0aGlzLm1hdGNoS2V5d29yZCgneWllbGQnKSkgPyB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKSA6IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uTmFtZSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb25OYW1lO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc2Nhbm5lci5pc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBmb3JtYWxQYXJhbWV0ZXJzID0gdGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcnMoZmlyc3RSZXN0cmljdGVkKTtcclxuXHQgICAgICAgIHZhciBwYXJhbXMgPSBmb3JtYWxQYXJhbWV0ZXJzLnBhcmFtcztcclxuXHQgICAgICAgIHZhciBzdHJpY3RlZCA9IGZvcm1hbFBhcmFtZXRlcnMuc3RyaWN0ZWQ7XHJcblx0ICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSBmb3JtYWxQYXJhbWV0ZXJzLmZpcnN0UmVzdHJpY3RlZDtcclxuXHQgICAgICAgIGlmIChmb3JtYWxQYXJhbWV0ZXJzLm1lc3NhZ2UpIHtcclxuXHQgICAgICAgICAgICBtZXNzYWdlID0gZm9ybWFsUGFyYW1ldGVycy5tZXNzYWdlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzU3RyaWN0ID0gdGhpcy5jb250ZXh0LnN0cmljdDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93U3RyaWN0RGlyZWN0aXZlID0gdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlID0gZm9ybWFsUGFyYW1ldGVycy5zaW1wbGU7XHJcblx0ICAgICAgICB2YXIgYm9keSA9IHRoaXMucGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzKCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBmaXJzdFJlc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKGZpcnN0UmVzdHJpY3RlZCwgbWVzc2FnZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBzdHJpY3RlZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oc3RyaWN0ZWQsIG1lc3NhZ2UpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlID0gcHJldmlvdXNBbGxvd1N0cmljdERpcmVjdGl2ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hd2FpdCA9IHByZXZpb3VzQWxsb3dBd2FpdDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgcmV0dXJuIGlzQXN5bmMgPyB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkFzeW5jRnVuY3Rpb25FeHByZXNzaW9uKGlkLCBwYXJhbXMsIGJvZHkpKSA6XHJcblx0ICAgICAgICAgICAgdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5GdW5jdGlvbkV4cHJlc3Npb24oaWQsIHBhcmFtcywgYm9keSwgaXNHZW5lcmF0b3IpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZGlyZWN0aXZlLXByb2xvZ3Vlcy1hbmQtdGhlLXVzZS1zdHJpY3QtZGlyZWN0aXZlXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VEaXJlY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB2YXIgZGlyZWN0aXZlID0gKGV4cHIudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LkxpdGVyYWwpID8gdGhpcy5nZXRUb2tlblJhdyh0b2tlbikuc2xpY2UoMSwgLTEpIDogbnVsbDtcclxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgZGlyZWN0aXZlID8gbmV3IE5vZGUuRGlyZWN0aXZlKGV4cHIsIGRpcmVjdGl2ZSkgOiBuZXcgTm9kZS5FeHByZXNzaW9uU3RhdGVtZW50KGV4cHIpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZURpcmVjdGl2ZVByb2xvZ3VlcyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBmaXJzdFJlc3RyaWN0ZWQgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIGJvZHkgPSBbXTtcclxuXHQgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IDggLyogU3RyaW5nTGl0ZXJhbCAqLykge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdmFyIHN0YXRlbWVudCA9IHRoaXMucGFyc2VEaXJlY3RpdmUoKTtcclxuXHQgICAgICAgICAgICBib2R5LnB1c2goc3RhdGVtZW50KTtcclxuXHQgICAgICAgICAgICB2YXIgZGlyZWN0aXZlID0gc3RhdGVtZW50LmRpcmVjdGl2ZTtcclxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGRpcmVjdGl2ZSAhPT0gJ3N0cmluZycpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmIChkaXJlY3RpdmUgPT09ICd1c2Ugc3RyaWN0Jykge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGZpcnN0UmVzdHJpY3RlZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihmaXJzdFJlc3RyaWN0ZWQsIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5JbGxlZ2FsTGFuZ3VhZ2VNb2RlRGlyZWN0aXZlKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKCFmaXJzdFJlc3RyaWN0ZWQgJiYgdG9rZW4ub2N0YWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGJvZHk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW1ldGhvZC1kZWZpbml0aW9uc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnF1YWxpZmllZFByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG5cdCAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSAzIC8qIElkZW50aWZpZXIgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA4IC8qIFN0cmluZ0xpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSAxIC8qIEJvb2xlYW5MaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgNSAvKiBOdWxsTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDYgLyogTnVtZXJpY0xpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA0IC8qIEtleXdvcmQgKi86XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNyAvKiBQdW5jdHVhdG9yICovOlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4udmFsdWUgPT09ICdbJztcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUdldHRlck1ldGhvZCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgaXNHZW5lcmF0b3IgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgZm9ybWFsUGFyYW1ldGVycyA9IHRoaXMucGFyc2VGb3JtYWxQYXJhbWV0ZXJzKCk7XHJcblx0ICAgICAgICBpZiAoZm9ybWFsUGFyYW1ldGVycy5wYXJhbXMubGVuZ3RoID4gMCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkJhZEdldHRlckFyaXR5KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBtZXRob2QgPSB0aGlzLnBhcnNlUHJvcGVydHlNZXRob2QoZm9ybWFsUGFyYW1ldGVycyk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZ1bmN0aW9uRXhwcmVzc2lvbihudWxsLCBmb3JtYWxQYXJhbWV0ZXJzLnBhcmFtcywgbWV0aG9kLCBpc0dlbmVyYXRvcikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU2V0dGVyTWV0aG9kID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBpc0dlbmVyYXRvciA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBmb3JtYWxQYXJhbWV0ZXJzID0gdGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcnMoKTtcclxuXHQgICAgICAgIGlmIChmb3JtYWxQYXJhbWV0ZXJzLnBhcmFtcy5sZW5ndGggIT09IDEpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5CYWRTZXR0ZXJBcml0eSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmIChmb3JtYWxQYXJhbWV0ZXJzLnBhcmFtc1swXSBpbnN0YW5jZW9mIE5vZGUuUmVzdEVsZW1lbnQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5CYWRTZXR0ZXJSZXN0UGFyYW1ldGVyKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBtZXRob2QgPSB0aGlzLnBhcnNlUHJvcGVydHlNZXRob2QoZm9ybWFsUGFyYW1ldGVycyk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZ1bmN0aW9uRXhwcmVzc2lvbihudWxsLCBmb3JtYWxQYXJhbWV0ZXJzLnBhcmFtcywgbWV0aG9kLCBpc0dlbmVyYXRvcikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlR2VuZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBpc0dlbmVyYXRvciA9IHRydWU7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHRydWU7XHJcblx0ICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcnMoKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgbWV0aG9kID0gdGhpcy5wYXJzZVByb3BlcnR5TWV0aG9kKHBhcmFtcyk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZ1bmN0aW9uRXhwcmVzc2lvbihudWxsLCBwYXJhbXMucGFyYW1zLCBtZXRob2QsIGlzR2VuZXJhdG9yKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdlbmVyYXRvci1mdW5jdGlvbi1kZWZpbml0aW9uc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmlzU3RhcnRPZkV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5sb29rYWhlYWQudmFsdWU7XHJcblx0ICAgICAgICBzd2l0Y2ggKHRoaXMubG9va2FoZWFkLnR5cGUpIHtcclxuXHQgICAgICAgICAgICBjYXNlIDcgLyogUHVuY3R1YXRvciAqLzpcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQgPSAodmFsdWUgPT09ICdbJykgfHwgKHZhbHVlID09PSAnKCcpIHx8ICh2YWx1ZSA9PT0gJ3snKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKHZhbHVlID09PSAnKycpIHx8ICh2YWx1ZSA9PT0gJy0nKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKHZhbHVlID09PSAnIScpIHx8ICh2YWx1ZSA9PT0gJ34nKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKHZhbHVlID09PSAnKysnKSB8fCAodmFsdWUgPT09ICctLScpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09ICcvJykgfHwgKHZhbHVlID09PSAnLz0nKTsgLy8gcmVndWxhciBleHByZXNzaW9uIGxpdGVyYWxcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSA0IC8qIEtleXdvcmQgKi86XHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0ID0gKHZhbHVlID09PSAnY2xhc3MnKSB8fCAodmFsdWUgPT09ICdkZWxldGUnKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKHZhbHVlID09PSAnZnVuY3Rpb24nKSB8fCAodmFsdWUgPT09ICdsZXQnKSB8fCAodmFsdWUgPT09ICduZXcnKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKHZhbHVlID09PSAnc3VwZXInKSB8fCAodmFsdWUgPT09ICd0aGlzJykgfHwgKHZhbHVlID09PSAndHlwZW9mJykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJ3ZvaWQnKSB8fCAodmFsdWUgPT09ICd5aWVsZCcpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBzdGFydDtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVlpZWxkRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3lpZWxkJyk7XHJcblx0ICAgICAgICB2YXIgYXJndW1lbnQgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIGRlbGVnYXRlID0gZmFsc2U7XHJcblx0ICAgICAgICBpZiAoIXRoaXMuaGFzTGluZVRlcm1pbmF0b3IpIHtcclxuXHQgICAgICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICBkZWxlZ2F0ZSA9IHRoaXMubWF0Y2goJyonKTtcclxuXHQgICAgICAgICAgICBpZiAoZGVsZWdhdGUpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgYXJndW1lbnQgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc1N0YXJ0T2ZFeHByZXNzaW9uKCkpIHtcclxuXHQgICAgICAgICAgICAgICAgYXJndW1lbnQgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5ZaWVsZEV4cHJlc3Npb24oYXJndW1lbnQsIGRlbGVnYXRlKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNsYXNzLWRlZmluaXRpb25zXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VDbGFzc0VsZW1lbnQgPSBmdW5jdGlvbiAoaGFzQ29uc3RydWN0b3IpIHtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBraW5kID0gJyc7XHJcblx0ICAgICAgICB2YXIga2V5ID0gbnVsbDtcclxuXHQgICAgICAgIHZhciB2YWx1ZSA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgY29tcHV0ZWQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBtZXRob2QgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBpc1N0YXRpYyA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIGlzQXN5bmMgPSBmYWxzZTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCcqJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICAgICAgdmFyIGlkID0ga2V5O1xyXG5cdCAgICAgICAgICAgIGlmIChpZC5uYW1lID09PSAnc3RhdGljJyAmJiAodGhpcy5xdWFsaWZpZWRQcm9wZXJ0eU5hbWUodGhpcy5sb29rYWhlYWQpIHx8IHRoaXMubWF0Y2goJyonKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICAgICAgaXNTdGF0aWMgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJyonKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmICgodG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSAmJiAhdGhpcy5oYXNMaW5lVGVybWluYXRvciAmJiAodG9rZW4udmFsdWUgPT09ICdhc3luYycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwdW5jdHVhdG9yID0gdGhpcy5sb29rYWhlYWQudmFsdWU7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChwdW5jdHVhdG9yICE9PSAnOicgJiYgcHVuY3R1YXRvciAhPT0gJygnICYmIHB1bmN0dWF0b3IgIT09ICcqJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaXNBc3luYyA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnZ2V0JyB8fCB0b2tlbi52YWx1ZSA9PT0gJ3NldCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnZhbHVlID09PSAnY29uc3RydWN0b3InKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuQ29uc3RydWN0b3JJc0FzeW5jKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbG9va2FoZWFkUHJvcGVydHlLZXkgPSB0aGlzLnF1YWxpZmllZFByb3BlcnR5TmFtZSh0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnZ2V0JyAmJiBsb29rYWhlYWRQcm9wZXJ0eUtleSkge1xyXG5cdCAgICAgICAgICAgICAgICBraW5kID0gJ2dldCc7XHJcblx0ICAgICAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlR2V0dGVyTWV0aG9kKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnZhbHVlID09PSAnc2V0JyAmJiBsb29rYWhlYWRQcm9wZXJ0eUtleSkge1xyXG5cdCAgICAgICAgICAgICAgICBraW5kID0gJ3NldCc7XHJcblx0ICAgICAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlU2V0dGVyTWV0aG9kKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovICYmIHRva2VuLnZhbHVlID09PSAnKicgJiYgbG9va2FoZWFkUHJvcGVydHlLZXkpIHtcclxuXHQgICAgICAgICAgICBraW5kID0gJ2luaXQnO1xyXG5cdCAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZUdlbmVyYXRvck1ldGhvZCgpO1xyXG5cdCAgICAgICAgICAgIG1ldGhvZCA9IHRydWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoIWtpbmQgJiYga2V5ICYmIHRoaXMubWF0Y2goJygnKSkge1xyXG5cdCAgICAgICAgICAgIGtpbmQgPSAnaW5pdCc7XHJcblx0ICAgICAgICAgICAgdmFsdWUgPSBpc0FzeW5jID8gdGhpcy5wYXJzZVByb3BlcnR5TWV0aG9kQXN5bmNGdW5jdGlvbigpIDogdGhpcy5wYXJzZVByb3BlcnR5TWV0aG9kRnVuY3Rpb24oKTtcclxuXHQgICAgICAgICAgICBtZXRob2QgPSB0cnVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKCFraW5kKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoa2luZCA9PT0gJ2luaXQnKSB7XHJcblx0ICAgICAgICAgICAga2luZCA9ICdtZXRob2QnO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKCFjb21wdXRlZCkge1xyXG5cdCAgICAgICAgICAgIGlmIChpc1N0YXRpYyAmJiB0aGlzLmlzUHJvcGVydHlLZXkoa2V5LCAncHJvdG90eXBlJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdGF0aWNQcm90b3R5cGUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoIWlzU3RhdGljICYmIHRoaXMuaXNQcm9wZXJ0eUtleShrZXksICdjb25zdHJ1Y3RvcicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChraW5kICE9PSAnbWV0aG9kJyB8fCAhbWV0aG9kIHx8ICh2YWx1ZSAmJiB2YWx1ZS5nZW5lcmF0b3IpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLkNvbnN0cnVjdG9yU3BlY2lhbE1ldGhvZCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKGhhc0NvbnN0cnVjdG9yLnZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLkR1cGxpY2F0ZUNvbnN0cnVjdG9yKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGhhc0NvbnN0cnVjdG9yLnZhbHVlID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBraW5kID0gJ2NvbnN0cnVjdG9yJztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5NZXRob2REZWZpbml0aW9uKGtleSwgY29tcHV0ZWQsIHZhbHVlLCBraW5kLCBpc1N0YXRpYykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ2xhc3NFbGVtZW50TGlzdCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBib2R5ID0gW107XHJcblx0ICAgICAgICB2YXIgaGFzQ29uc3RydWN0b3IgPSB7IHZhbHVlOiBmYWxzZSB9O1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ3snKTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJzsnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgYm9keS5wdXNoKHRoaXMucGFyc2VDbGFzc0VsZW1lbnQoaGFzQ29uc3RydWN0b3IpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnfScpO1xyXG5cdCAgICAgICAgcmV0dXJuIGJvZHk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VDbGFzc0JvZHkgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGVsZW1lbnRMaXN0ID0gdGhpcy5wYXJzZUNsYXNzRWxlbWVudExpc3QoKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkNsYXNzQm9keShlbGVtZW50TGlzdCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ2xhc3NEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChpZGVudGlmaWVySXNPcHRpb25hbCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c1N0cmljdCA9IHRoaXMuY29udGV4dC5zdHJpY3Q7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gdHJ1ZTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnY2xhc3MnKTtcclxuXHQgICAgICAgIHZhciBpZCA9IChpZGVudGlmaWVySXNPcHRpb25hbCAmJiAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMyAvKiBJZGVudGlmaWVyICovKSkgPyBudWxsIDogdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgdmFyIHN1cGVyQ2xhc3MgPSBudWxsO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdleHRlbmRzJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIHN1cGVyQ2xhc3MgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGNsYXNzQm9keSA9IHRoaXMucGFyc2VDbGFzc0JvZHkoKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkNsYXNzRGVjbGFyYXRpb24oaWQsIHN1cGVyQ2xhc3MsIGNsYXNzQm9keSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ2xhc3NFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c1N0cmljdCA9IHRoaXMuY29udGV4dC5zdHJpY3Q7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gdHJ1ZTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnY2xhc3MnKTtcclxuXHQgICAgICAgIHZhciBpZCA9ICh0aGlzLmxvb2thaGVhZC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pID8gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpIDogbnVsbDtcclxuXHQgICAgICAgIHZhciBzdXBlckNsYXNzID0gbnVsbDtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnZXh0ZW5kcycpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBzdXBlckNsYXNzID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBjbGFzc0JvZHkgPSB0aGlzLnBhcnNlQ2xhc3NCb2R5KCk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5DbGFzc0V4cHJlc3Npb24oaWQsIHN1cGVyQ2xhc3MsIGNsYXNzQm9keSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zY3JpcHRzXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW1vZHVsZXNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZU1vZHVsZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSB0cnVlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzTW9kdWxlID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgYm9keSA9IHRoaXMucGFyc2VEaXJlY3RpdmVQcm9sb2d1ZXMoKTtcclxuXHQgICAgICAgIHdoaWxlICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSAyIC8qIEVPRiAqLykge1xyXG5cdCAgICAgICAgICAgIGJvZHkucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Nb2R1bGUoYm9keSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU2NyaXB0ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBib2R5ID0gdGhpcy5wYXJzZURpcmVjdGl2ZVByb2xvZ3VlcygpO1xyXG5cdCAgICAgICAgd2hpbGUgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDIgLyogRU9GICovKSB7XHJcblx0ICAgICAgICAgICAgYm9keS5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlNjcmlwdChib2R5KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWltcG9ydHNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZU1vZHVsZVNwZWNpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gOCAvKiBTdHJpbmdMaXRlcmFsICovKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZE1vZHVsZVNwZWNpZmllcik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgdmFyIHJhdyA9IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuTGl0ZXJhbCh0b2tlbi52YWx1ZSwgcmF3KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGltcG9ydCB7PGZvbyBhcyBiYXI+fSAuLi47XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VJbXBvcnRTcGVjaWZpZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGltcG9ydGVkO1xyXG5cdCAgICAgICAgdmFyIGxvY2FsO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykge1xyXG5cdCAgICAgICAgICAgIGltcG9ydGVkID0gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIGxvY2FsID0gaW1wb3J0ZWQ7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXMnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICBsb2NhbCA9IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBpbXBvcnRlZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xyXG5cdCAgICAgICAgICAgIGxvY2FsID0gaW1wb3J0ZWQ7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXMnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICBsb2NhbCA9IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSW1wb3J0U3BlY2lmaWVyKGxvY2FsLCBpbXBvcnRlZCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyB7Zm9vLCBiYXIgYXMgYmFzfVxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlTmFtZWRJbXBvcnRzID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ3snKTtcclxuXHQgICAgICAgIHZhciBzcGVjaWZpZXJzID0gW107XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaCh0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVyKCkpO1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcsJyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ30nKTtcclxuXHQgICAgICAgIHJldHVybiBzcGVjaWZpZXJzO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBpbXBvcnQgPGZvbz4gLi4uO1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlSW1wb3J0RGVmYXVsdFNwZWNpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgbG9jYWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkltcG9ydERlZmF1bHRTcGVjaWZpZXIobG9jYWwpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaW1wb3J0IDwqIGFzIGZvbz4gLi4uO1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcqJyk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXMnKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLk5vQXNBZnRlckltcG9ydE5hbWVzcGFjZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgdmFyIGxvY2FsID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIobG9jYWwpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUltcG9ydERlY2xhcmF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5pbkZ1bmN0aW9uQm9keSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLklsbGVnYWxJbXBvcnREZWNsYXJhdGlvbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdpbXBvcnQnKTtcclxuXHQgICAgICAgIHZhciBzcmM7XHJcblx0ICAgICAgICB2YXIgc3BlY2lmaWVycyA9IFtdO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDggLyogU3RyaW5nTGl0ZXJhbCAqLykge1xyXG5cdCAgICAgICAgICAgIC8vIGltcG9ydCAnZm9vJztcclxuXHQgICAgICAgICAgICBzcmMgPSB0aGlzLnBhcnNlTW9kdWxlU3BlY2lmaWVyKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgneycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGltcG9ydCB7YmFyfVxyXG5cdCAgICAgICAgICAgICAgICBzcGVjaWZpZXJzID0gc3BlY2lmaWVycy5jb25jYXQodGhpcy5wYXJzZU5hbWVkSW1wb3J0cygpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnKicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGltcG9ydCAqIGFzIGZvb1xyXG5cdCAgICAgICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2godGhpcy5wYXJzZUltcG9ydE5hbWVzcGFjZVNwZWNpZmllcigpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc0lkZW50aWZpZXJOYW1lKHRoaXMubG9va2FoZWFkKSAmJiAhdGhpcy5tYXRjaEtleXdvcmQoJ2RlZmF1bHQnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBpbXBvcnQgZm9vXHJcblx0ICAgICAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaCh0aGlzLnBhcnNlSW1wb3J0RGVmYXVsdFNwZWNpZmllcigpKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcqJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbXBvcnQgZm9vLCAqIGFzIGZvb1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaCh0aGlzLnBhcnNlSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgneycpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW1wb3J0IGZvbywge2Jhcn1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWZpZXJzID0gc3BlY2lmaWVycy5jb25jYXQodGhpcy5wYXJzZU5hbWVkSW1wb3J0cygpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnZnJvbScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5sb29rYWhlYWQudmFsdWUgPyBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiA6IG1lc3NhZ2VzXzEuTWVzc2FnZXMuTWlzc2luZ0Zyb21DbGF1c2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCB0aGlzLmxvb2thaGVhZC52YWx1ZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgc3JjID0gdGhpcy5wYXJzZU1vZHVsZVNwZWNpZmllcigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JbXBvcnREZWNsYXJhdGlvbihzcGVjaWZpZXJzLCBzcmMpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZXhwb3J0c1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRXhwb3J0U3BlY2lmaWVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBsb2NhbCA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xyXG5cdCAgICAgICAgdmFyIGV4cG9ydGVkID0gbG9jYWw7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhcycpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBleHBvcnRlZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0U3BlY2lmaWVyKGxvY2FsLCBleHBvcnRlZCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRXhwb3J0RGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LmluRnVuY3Rpb25Cb2R5KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSWxsZWdhbEV4cG9ydERlY2xhcmF0aW9uKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2V4cG9ydCcpO1xyXG5cdCAgICAgICAgdmFyIGV4cG9ydERlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdkZWZhdWx0JykpIHtcclxuXHQgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCAuLi5cclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnZnVuY3Rpb24nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmb28gKCkge31cclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge31cclxuXHQgICAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24odHJ1ZSk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cG9ydERlY2xhcmF0aW9uID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHBvcnREZWZhdWx0RGVjbGFyYXRpb24oZGVjbGFyYXRpb24pKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2NsYXNzJykpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgY2xhc3MgZm9vIHt9XHJcblx0ICAgICAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VDbGFzc0RlY2xhcmF0aW9uKHRydWUpO1xyXG5cdCAgICAgICAgICAgICAgICBleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXN5bmMnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBmICgpIHt9XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uICgpIHt9XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IGFzeW5jIHggPT4geFxyXG5cdCAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzLm1hdGNoQXN5bmNGdW5jdGlvbigpID8gdGhpcy5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24odHJ1ZSkgOiB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwb3J0RGVjbGFyYXRpb24gPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbihkZWNsYXJhdGlvbikpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnZnJvbScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sIHRoaXMubG9va2FoZWFkLnZhbHVlKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCB7fTtcclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgW107XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0ICgxICsgMik7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IHRoaXMubWF0Y2goJ3snKSA/IHRoaXMucGFyc2VPYmplY3RJbml0aWFsaXplcigpIDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goJ1snKSA/IHRoaXMucGFyc2VBcnJheUluaXRpYWxpemVyKCkgOiB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cG9ydERlY2xhcmF0aW9uID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHBvcnREZWZhdWx0RGVjbGFyYXRpb24oZGVjbGFyYXRpb24pKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCcqJykpIHtcclxuXHQgICAgICAgICAgICAvLyBleHBvcnQgKiBmcm9tICdmb28nO1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2Zyb20nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMubG9va2FoZWFkLnZhbHVlID8gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4gOiBtZXNzYWdlc18xLk1lc3NhZ2VzLk1pc3NpbmdGcm9tQ2xhdXNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgdGhpcy5sb29rYWhlYWQudmFsdWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIHZhciBzcmMgPSB0aGlzLnBhcnNlTW9kdWxlU3BlY2lmaWVyKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICAgICAgZXhwb3J0RGVjbGFyYXRpb24gPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkV4cG9ydEFsbERlY2xhcmF0aW9uKHNyYykpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gNCAvKiBLZXl3b3JkICovKSB7XHJcblx0ICAgICAgICAgICAgLy8gZXhwb3J0IHZhciBmID0gMTtcclxuXHQgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB2b2lkIDA7XHJcblx0ICAgICAgICAgICAgc3dpdGNoICh0aGlzLmxvb2thaGVhZC52YWx1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlICdsZXQnOlxyXG5cdCAgICAgICAgICAgICAgICBjYXNlICdjb25zdCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VMZXhpY2FsRGVjbGFyYXRpb24oeyBpbkZvcjogZmFsc2UgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAndmFyJzpcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAnY2xhc3MnOlxyXG5cdCAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XHJcblx0ICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZXhwb3J0RGVjbGFyYXRpb24gPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkV4cG9ydE5hbWVkRGVjbGFyYXRpb24oZGVjbGFyYXRpb24sIFtdLCBudWxsKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoQXN5bmNGdW5jdGlvbigpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24oKTtcclxuXHQgICAgICAgICAgICBleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0TmFtZWREZWNsYXJhdGlvbihkZWNsYXJhdGlvbiwgW10sIG51bGwpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHZhciBzcGVjaWZpZXJzID0gW107XHJcblx0ICAgICAgICAgICAgdmFyIHNvdXJjZSA9IG51bGw7XHJcblx0ICAgICAgICAgICAgdmFyIGlzRXhwb3J0RnJvbUlkZW50aWZpZXIgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgneycpO1xyXG5cdCAgICAgICAgICAgIHdoaWxlICghdGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlzRXhwb3J0RnJvbUlkZW50aWZpZXIgPSBpc0V4cG9ydEZyb21JZGVudGlmaWVyIHx8IHRoaXMubWF0Y2hLZXl3b3JkKCdkZWZhdWx0Jyk7XHJcblx0ICAgICAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaCh0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVyKCkpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJywnKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnfScpO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2Zyb20nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQge2RlZmF1bHR9IGZyb20gJ2Zvbyc7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCB7Zm9vfSBmcm9tICdmb28nO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICBzb3VyY2UgPSB0aGlzLnBhcnNlTW9kdWxlU3BlY2lmaWVyKCk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChpc0V4cG9ydEZyb21JZGVudGlmaWVyKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCB7ZGVmYXVsdH07IC8vIG1pc3NpbmcgZnJvbUNsYXVzZVxyXG5cdCAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMubG9va2FoZWFkLnZhbHVlID8gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4gOiBtZXNzYWdlc18xLk1lc3NhZ2VzLk1pc3NpbmdGcm9tQ2xhdXNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgdGhpcy5sb29rYWhlYWQudmFsdWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IHtmb299O1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZXhwb3J0RGVjbGFyYXRpb24gPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkV4cG9ydE5hbWVkRGVjbGFyYXRpb24obnVsbCwgc3BlY2lmaWVycywgc291cmNlKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwb3J0RGVjbGFyYXRpb247XHJcblx0ICAgIH07XHJcblx0ICAgIHJldHVybiBQYXJzZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlBhcnNlciA9IFBhcnNlcjtcclxuXG5cbi8qKiovIH0sXG4vKiA5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHQvLyBFbnN1cmUgdGhlIGNvbmRpdGlvbiBpcyB0cnVlLCBvdGhlcndpc2UgdGhyb3cgYW4gZXJyb3IuXHJcblx0Ly8gVGhpcyBpcyBvbmx5IHRvIGhhdmUgYSBiZXR0ZXIgY29udHJhY3Qgc2VtYW50aWMsIGkuZS4gYW5vdGhlciBzYWZldHkgbmV0XHJcblx0Ly8gdG8gY2F0Y2ggYSBsb2dpYyBlcnJvci4gVGhlIGNvbmRpdGlvbiBzaGFsbCBiZSBmdWxmaWxsZWQgaW4gbm9ybWFsIGNhc2UuXHJcblx0Ly8gRG8gTk9UIHVzZSB0aGlzIHRvIGVuZm9yY2UgYSBjZXJ0YWluIGNvbmRpdGlvbiBvbiBhbnkgdXNlciBpbnB1dC5cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0ZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xyXG5cdCAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuXHQgICAgaWYgKCFjb25kaXRpb24pIHtcclxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignQVNTRVJUOiAnICsgbWVzc2FnZSk7XHJcblx0ICAgIH1cclxuXHR9XHJcblx0ZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XHJcblxuXG4vKioqLyB9LFxuLyogMTAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdC8qIHRzbGludDpkaXNhYmxlOm1heC1jbGFzc2VzLXBlci1maWxlICovXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdHZhciBFcnJvckhhbmRsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBFcnJvckhhbmRsZXIoKSB7XHJcblx0ICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xyXG5cdCAgICAgICAgdGhpcy50b2xlcmFudCA9IGZhbHNlO1xyXG5cdCAgICB9XHJcblx0ICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUucmVjb3JkRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcclxuXHQgICAgICAgIHRoaXMuZXJyb3JzLnB1c2goZXJyb3IpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLnRvbGVyYXRlID0gZnVuY3Rpb24gKGVycm9yKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy50b2xlcmFudCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMucmVjb3JkRXJyb3IoZXJyb3IpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUuY29uc3RydWN0RXJyb3IgPSBmdW5jdGlvbiAobXNnLCBjb2x1bW4pIHtcclxuXHQgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihtc2cpO1xyXG5cdCAgICAgICAgdHJ5IHtcclxuXHQgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGNhdGNoIChiYXNlKSB7XHJcblx0ICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuXHQgICAgICAgICAgICBpZiAoT2JqZWN0LmNyZWF0ZSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcclxuXHQgICAgICAgICAgICAgICAgZXJyb3IgPSBPYmplY3QuY3JlYXRlKGJhc2UpO1xyXG5cdCAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3IsICdjb2x1bW4nLCB7IHZhbHVlOiBjb2x1bW4gfSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuXHQgICAgICAgIHJldHVybiBlcnJvcjtcclxuXHQgICAgfTtcclxuXHQgICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVFcnJvciA9IGZ1bmN0aW9uIChpbmRleCwgbGluZSwgY29sLCBkZXNjcmlwdGlvbikge1xyXG5cdCAgICAgICAgdmFyIG1zZyA9ICdMaW5lICcgKyBsaW5lICsgJzogJyArIGRlc2NyaXB0aW9uO1xyXG5cdCAgICAgICAgdmFyIGVycm9yID0gdGhpcy5jb25zdHJ1Y3RFcnJvcihtc2csIGNvbCk7XHJcblx0ICAgICAgICBlcnJvci5pbmRleCA9IGluZGV4O1xyXG5cdCAgICAgICAgZXJyb3IubGluZU51bWJlciA9IGxpbmU7XHJcblx0ICAgICAgICBlcnJvci5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xyXG5cdCAgICAgICAgcmV0dXJuIGVycm9yO1xyXG5cdCAgICB9O1xyXG5cdCAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLnRocm93RXJyb3IgPSBmdW5jdGlvbiAoaW5kZXgsIGxpbmUsIGNvbCwgZGVzY3JpcHRpb24pIHtcclxuXHQgICAgICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IoaW5kZXgsIGxpbmUsIGNvbCwgZGVzY3JpcHRpb24pO1xyXG5cdCAgICB9O1xyXG5cdCAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLnRvbGVyYXRlRXJyb3IgPSBmdW5jdGlvbiAoaW5kZXgsIGxpbmUsIGNvbCwgZGVzY3JpcHRpb24pIHtcclxuXHQgICAgICAgIHZhciBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoaW5kZXgsIGxpbmUsIGNvbCwgZGVzY3JpcHRpb24pO1xyXG5cdCAgICAgICAgaWYgKHRoaXMudG9sZXJhbnQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnJlY29yZEVycm9yKGVycm9yKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICByZXR1cm4gRXJyb3JIYW5kbGVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5FcnJvckhhbmRsZXIgPSBFcnJvckhhbmRsZXI7XHJcblxuXG4vKioqLyB9LFxuLyogMTEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHQvLyBFcnJvciBtZXNzYWdlcyBzaG91bGQgYmUgaWRlbnRpY2FsIHRvIFY4LlxyXG5cdGV4cG9ydHMuTWVzc2FnZXMgPSB7XHJcblx0ICAgIEJhZEdldHRlckFyaXR5OiAnR2V0dGVyIG11c3Qgbm90IGhhdmUgYW55IGZvcm1hbCBwYXJhbWV0ZXJzJyxcclxuXHQgICAgQmFkU2V0dGVyQXJpdHk6ICdTZXR0ZXIgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGZvcm1hbCBwYXJhbWV0ZXInLFxyXG5cdCAgICBCYWRTZXR0ZXJSZXN0UGFyYW1ldGVyOiAnU2V0dGVyIGZ1bmN0aW9uIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgcmVzdCBwYXJhbWV0ZXInLFxyXG5cdCAgICBDb25zdHJ1Y3RvcklzQXN5bmM6ICdDbGFzcyBjb25zdHJ1Y3RvciBtYXkgbm90IGJlIGFuIGFzeW5jIG1ldGhvZCcsXHJcblx0ICAgIENvbnN0cnVjdG9yU3BlY2lhbE1ldGhvZDogJ0NsYXNzIGNvbnN0cnVjdG9yIG1heSBub3QgYmUgYW4gYWNjZXNzb3InLFxyXG5cdCAgICBEZWNsYXJhdGlvbk1pc3NpbmdJbml0aWFsaXplcjogJ01pc3NpbmcgaW5pdGlhbGl6ZXIgaW4gJTAgZGVjbGFyYXRpb24nLFxyXG5cdCAgICBEZWZhdWx0UmVzdFBhcmFtZXRlcjogJ1VuZXhwZWN0ZWQgdG9rZW4gPScsXHJcblx0ICAgIER1cGxpY2F0ZUJpbmRpbmc6ICdEdXBsaWNhdGUgYmluZGluZyAlMCcsXHJcblx0ICAgIER1cGxpY2F0ZUNvbnN0cnVjdG9yOiAnQSBjbGFzcyBtYXkgb25seSBoYXZlIG9uZSBjb25zdHJ1Y3RvcicsXHJcblx0ICAgIER1cGxpY2F0ZVByb3RvUHJvcGVydHk6ICdEdXBsaWNhdGUgX19wcm90b19fIGZpZWxkcyBhcmUgbm90IGFsbG93ZWQgaW4gb2JqZWN0IGxpdGVyYWxzJyxcclxuXHQgICAgRm9ySW5PZkxvb3BJbml0aWFsaXplcjogJyUwIGxvb3AgdmFyaWFibGUgZGVjbGFyYXRpb24gbWF5IG5vdCBoYXZlIGFuIGluaXRpYWxpemVyJyxcclxuXHQgICAgR2VuZXJhdG9ySW5MZWdhY3lDb250ZXh0OiAnR2VuZXJhdG9yIGRlY2xhcmF0aW9ucyBhcmUgbm90IGFsbG93ZWQgaW4gbGVnYWN5IGNvbnRleHRzJyxcclxuXHQgICAgSWxsZWdhbEJyZWFrOiAnSWxsZWdhbCBicmVhayBzdGF0ZW1lbnQnLFxyXG5cdCAgICBJbGxlZ2FsQ29udGludWU6ICdJbGxlZ2FsIGNvbnRpbnVlIHN0YXRlbWVudCcsXHJcblx0ICAgIElsbGVnYWxFeHBvcnREZWNsYXJhdGlvbjogJ1VuZXhwZWN0ZWQgdG9rZW4nLFxyXG5cdCAgICBJbGxlZ2FsSW1wb3J0RGVjbGFyYXRpb246ICdVbmV4cGVjdGVkIHRva2VuJyxcclxuXHQgICAgSWxsZWdhbExhbmd1YWdlTW9kZURpcmVjdGl2ZTogJ0lsbGVnYWwgXFwndXNlIHN0cmljdFxcJyBkaXJlY3RpdmUgaW4gZnVuY3Rpb24gd2l0aCBub24tc2ltcGxlIHBhcmFtZXRlciBsaXN0JyxcclxuXHQgICAgSWxsZWdhbFJldHVybjogJ0lsbGVnYWwgcmV0dXJuIHN0YXRlbWVudCcsXHJcblx0ICAgIEludmFsaWRFc2NhcGVkUmVzZXJ2ZWRXb3JkOiAnS2V5d29yZCBtdXN0IG5vdCBjb250YWluIGVzY2FwZWQgY2hhcmFjdGVycycsXHJcblx0ICAgIEludmFsaWRIZXhFc2NhcGVTZXF1ZW5jZTogJ0ludmFsaWQgaGV4YWRlY2ltYWwgZXNjYXBlIHNlcXVlbmNlJyxcclxuXHQgICAgSW52YWxpZExIU0luQXNzaWdubWVudDogJ0ludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gYXNzaWdubWVudCcsXHJcblx0ICAgIEludmFsaWRMSFNJbkZvckluOiAnSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBmb3ItaW4nLFxyXG5cdCAgICBJbnZhbGlkTEhTSW5Gb3JMb29wOiAnSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBmb3ItbG9vcCcsXHJcblx0ICAgIEludmFsaWRNb2R1bGVTcGVjaWZpZXI6ICdVbmV4cGVjdGVkIHRva2VuJyxcclxuXHQgICAgSW52YWxpZFJlZ0V4cDogJ0ludmFsaWQgcmVndWxhciBleHByZXNzaW9uJyxcclxuXHQgICAgTGV0SW5MZXhpY2FsQmluZGluZzogJ2xldCBpcyBkaXNhbGxvd2VkIGFzIGEgbGV4aWNhbGx5IGJvdW5kIG5hbWUnLFxyXG5cdCAgICBNaXNzaW5nRnJvbUNsYXVzZTogJ1VuZXhwZWN0ZWQgdG9rZW4nLFxyXG5cdCAgICBNdWx0aXBsZURlZmF1bHRzSW5Td2l0Y2g6ICdNb3JlIHRoYW4gb25lIGRlZmF1bHQgY2xhdXNlIGluIHN3aXRjaCBzdGF0ZW1lbnQnLFxyXG5cdCAgICBOZXdsaW5lQWZ0ZXJUaHJvdzogJ0lsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvdycsXHJcblx0ICAgIE5vQXNBZnRlckltcG9ydE5hbWVzcGFjZTogJ1VuZXhwZWN0ZWQgdG9rZW4nLFxyXG5cdCAgICBOb0NhdGNoT3JGaW5hbGx5OiAnTWlzc2luZyBjYXRjaCBvciBmaW5hbGx5IGFmdGVyIHRyeScsXHJcblx0ICAgIFBhcmFtZXRlckFmdGVyUmVzdFBhcmFtZXRlcjogJ1Jlc3QgcGFyYW1ldGVyIG11c3QgYmUgbGFzdCBmb3JtYWwgcGFyYW1ldGVyJyxcclxuXHQgICAgUmVkZWNsYXJhdGlvbjogJyUwIFxcJyUxXFwnIGhhcyBhbHJlYWR5IGJlZW4gZGVjbGFyZWQnLFxyXG5cdCAgICBTdGF0aWNQcm90b3R5cGU6ICdDbGFzc2VzIG1heSBub3QgaGF2ZSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgcHJvdG90eXBlJyxcclxuXHQgICAgU3RyaWN0Q2F0Y2hWYXJpYWJsZTogJ0NhdGNoIHZhcmlhYmxlIG1heSBub3QgYmUgZXZhbCBvciBhcmd1bWVudHMgaW4gc3RyaWN0IG1vZGUnLFxyXG5cdCAgICBTdHJpY3REZWxldGU6ICdEZWxldGUgb2YgYW4gdW5xdWFsaWZpZWQgaWRlbnRpZmllciBpbiBzdHJpY3QgbW9kZS4nLFxyXG5cdCAgICBTdHJpY3RGdW5jdGlvbjogJ0luIHN0cmljdCBtb2RlIGNvZGUsIGZ1bmN0aW9ucyBjYW4gb25seSBiZSBkZWNsYXJlZCBhdCB0b3AgbGV2ZWwgb3IgaW5zaWRlIGEgYmxvY2snLFxyXG5cdCAgICBTdHJpY3RGdW5jdGlvbk5hbWU6ICdGdW5jdGlvbiBuYW1lIG1heSBub3QgYmUgZXZhbCBvciBhcmd1bWVudHMgaW4gc3RyaWN0IG1vZGUnLFxyXG5cdCAgICBTdHJpY3RMSFNBc3NpZ25tZW50OiAnQXNzaWdubWVudCB0byBldmFsIG9yIGFyZ3VtZW50cyBpcyBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZScsXHJcblx0ICAgIFN0cmljdExIU1Bvc3RmaXg6ICdQb3N0Zml4IGluY3JlbWVudC9kZWNyZW1lbnQgbWF5IG5vdCBoYXZlIGV2YWwgb3IgYXJndW1lbnRzIG9wZXJhbmQgaW4gc3RyaWN0IG1vZGUnLFxyXG5cdCAgICBTdHJpY3RMSFNQcmVmaXg6ICdQcmVmaXggaW5jcmVtZW50L2RlY3JlbWVudCBtYXkgbm90IGhhdmUgZXZhbCBvciBhcmd1bWVudHMgb3BlcmFuZCBpbiBzdHJpY3QgbW9kZScsXHJcblx0ICAgIFN0cmljdE1vZGVXaXRoOiAnU3RyaWN0IG1vZGUgY29kZSBtYXkgbm90IGluY2x1ZGUgYSB3aXRoIHN0YXRlbWVudCcsXHJcblx0ICAgIFN0cmljdE9jdGFsTGl0ZXJhbDogJ09jdGFsIGxpdGVyYWxzIGFyZSBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZS4nLFxyXG5cdCAgICBTdHJpY3RQYXJhbUR1cGU6ICdTdHJpY3QgbW9kZSBmdW5jdGlvbiBtYXkgbm90IGhhdmUgZHVwbGljYXRlIHBhcmFtZXRlciBuYW1lcycsXHJcblx0ICAgIFN0cmljdFBhcmFtTmFtZTogJ1BhcmFtZXRlciBuYW1lIGV2YWwgb3IgYXJndW1lbnRzIGlzIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlJyxcclxuXHQgICAgU3RyaWN0UmVzZXJ2ZWRXb3JkOiAnVXNlIG9mIGZ1dHVyZSByZXNlcnZlZCB3b3JkIGluIHN0cmljdCBtb2RlJyxcclxuXHQgICAgU3RyaWN0VmFyTmFtZTogJ1ZhcmlhYmxlIG5hbWUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXHJcblx0ICAgIFRlbXBsYXRlT2N0YWxMaXRlcmFsOiAnT2N0YWwgbGl0ZXJhbHMgYXJlIG5vdCBhbGxvd2VkIGluIHRlbXBsYXRlIHN0cmluZ3MuJyxcclxuXHQgICAgVW5leHBlY3RlZEVPUzogJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0JyxcclxuXHQgICAgVW5leHBlY3RlZElkZW50aWZpZXI6ICdVbmV4cGVjdGVkIGlkZW50aWZpZXInLFxyXG5cdCAgICBVbmV4cGVjdGVkTnVtYmVyOiAnVW5leHBlY3RlZCBudW1iZXInLFxyXG5cdCAgICBVbmV4cGVjdGVkUmVzZXJ2ZWQ6ICdVbmV4cGVjdGVkIHJlc2VydmVkIHdvcmQnLFxyXG5cdCAgICBVbmV4cGVjdGVkU3RyaW5nOiAnVW5leHBlY3RlZCBzdHJpbmcnLFxyXG5cdCAgICBVbmV4cGVjdGVkVGVtcGxhdGU6ICdVbmV4cGVjdGVkIHF1YXNpICUwJyxcclxuXHQgICAgVW5leHBlY3RlZFRva2VuOiAnVW5leHBlY3RlZCB0b2tlbiAlMCcsXHJcblx0ICAgIFVuZXhwZWN0ZWRUb2tlbklsbGVnYWw6ICdVbmV4cGVjdGVkIHRva2VuIElMTEVHQUwnLFxyXG5cdCAgICBVbmtub3duTGFiZWw6ICdVbmRlZmluZWQgbGFiZWwgXFwnJTBcXCcnLFxyXG5cdCAgICBVbnRlcm1pbmF0ZWRSZWdFeHA6ICdJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbjogbWlzc2luZyAvJ1xyXG5cdH07XHJcblxuXG4vKioqLyB9LFxuLyogMTIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHR2YXIgYXNzZXJ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xyXG5cdHZhciBjaGFyYWN0ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcblx0dmFyIG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcclxuXHRmdW5jdGlvbiBoZXhWYWx1ZShjaCkge1xyXG5cdCAgICByZXR1cm4gJzAxMjM0NTY3ODlhYmNkZWYnLmluZGV4T2YoY2gudG9Mb3dlckNhc2UoKSk7XHJcblx0fVxyXG5cdGZ1bmN0aW9uIG9jdGFsVmFsdWUoY2gpIHtcclxuXHQgICAgcmV0dXJuICcwMTIzNDU2NycuaW5kZXhPZihjaCk7XHJcblx0fVxyXG5cdHZhciBTY2FubmVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gU2Nhbm5lcihjb2RlLCBoYW5kbGVyKSB7XHJcblx0ICAgICAgICB0aGlzLnNvdXJjZSA9IGNvZGU7XHJcblx0ICAgICAgICB0aGlzLmVycm9ySGFuZGxlciA9IGhhbmRsZXI7XHJcblx0ICAgICAgICB0aGlzLnRyYWNrQ29tbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5sZW5ndGggPSBjb2RlLmxlbmd0aDtcclxuXHQgICAgICAgIHRoaXMuaW5kZXggPSAwO1xyXG5cdCAgICAgICAgdGhpcy5saW5lTnVtYmVyID0gKGNvZGUubGVuZ3RoID4gMCkgPyAxIDogMDtcclxuXHQgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gMDtcclxuXHQgICAgICAgIHRoaXMuY3VybHlTdGFjayA9IFtdO1xyXG5cdCAgICB9XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNhdmVTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnRcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnJlc3RvcmVTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xyXG5cdCAgICAgICAgdGhpcy5pbmRleCA9IHN0YXRlLmluZGV4O1xyXG5cdCAgICAgICAgdGhpcy5saW5lTnVtYmVyID0gc3RhdGUubGluZU51bWJlcjtcclxuXHQgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gc3RhdGUubGluZVN0YXJ0O1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5lb2YgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5pbmRleCA+PSB0aGlzLmxlbmd0aDtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUudGhyb3dVbmV4cGVjdGVkVG9rZW4gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG5cdCAgICAgICAgaWYgKG1lc3NhZ2UgPT09IHZvaWQgMCkgeyBtZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW5JbGxlZ2FsOyB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5lcnJvckhhbmRsZXIudGhyb3dFcnJvcih0aGlzLmluZGV4LCB0aGlzLmxpbmVOdW1iZXIsIHRoaXMuaW5kZXggLSB0aGlzLmxpbmVTdGFydCArIDEsIG1lc3NhZ2UpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbiA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcblx0ICAgICAgICBpZiAobWVzc2FnZSA9PT0gdm9pZCAwKSB7IG1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbklsbGVnYWw7IH1cclxuXHQgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyLnRvbGVyYXRlRXJyb3IodGhpcy5pbmRleCwgdGhpcy5saW5lTnVtYmVyLCB0aGlzLmluZGV4IC0gdGhpcy5saW5lU3RhcnQgKyAxLCBtZXNzYWdlKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY29tbWVudHNcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2tpcFNpbmdsZUxpbmVDb21tZW50ID0gZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdCAgICAgICAgdmFyIGNvbW1lbnRzID0gW107XHJcblx0ICAgICAgICB2YXIgc3RhcnQsIGxvYztcclxuXHQgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgIGNvbW1lbnRzID0gW107XHJcblx0ICAgICAgICAgICAgc3RhcnQgPSB0aGlzLmluZGV4IC0gb2Zmc2V0O1xyXG5cdCAgICAgICAgICAgIGxvYyA9IHtcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5pbmRleCAtIHRoaXMubGluZVN0YXJ0IC0gb2Zmc2V0XHJcblx0ICAgICAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgIGVuZDoge31cclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KTtcclxuXHQgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxvYy5lbmQgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5pbmRleCAtIHRoaXMubGluZVN0YXJ0IC0gMVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aUxpbmU6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNsaWNlOiBbc3RhcnQgKyBvZmZzZXQsIHRoaXMuaW5kZXggLSAxXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCB0aGlzLmluZGV4IC0gMV0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9jOiBsb2NcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICBjb21tZW50cy5wdXNoKGVudHJ5KTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDEzICYmIHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkgPT09IDEwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1lbnRzO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgIGxvYy5lbmQgPSB7XHJcblx0ICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmluZGV4IC0gdGhpcy5saW5lU3RhcnRcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgIHZhciBlbnRyeSA9IHtcclxuXHQgICAgICAgICAgICAgICAgbXVsdGlMaW5lOiBmYWxzZSxcclxuXHQgICAgICAgICAgICAgICAgc2xpY2U6IFtzdGFydCArIG9mZnNldCwgdGhpcy5pbmRleF0sXHJcblx0ICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIHRoaXMuaW5kZXhdLFxyXG5cdCAgICAgICAgICAgICAgICBsb2M6IGxvY1xyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgY29tbWVudHMucHVzaChlbnRyeSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gY29tbWVudHM7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNraXBNdWx0aUxpbmVDb21tZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGNvbW1lbnRzID0gW107XHJcblx0ICAgICAgICB2YXIgc3RhcnQsIGxvYztcclxuXHQgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgIGNvbW1lbnRzID0gW107XHJcblx0ICAgICAgICAgICAgc3RhcnQgPSB0aGlzLmluZGV4IC0gMjtcclxuXHQgICAgICAgICAgICBsb2MgPSB7XHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuaW5kZXggLSB0aGlzLmxpbmVTdGFydCAtIDJcclxuXHQgICAgICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB7fVxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpO1xyXG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaCkpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAweDBEICYmIHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCArIDEpID09PSAweDBBKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gMHgyQSkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBCbG9jayBjb21tZW50IGVuZHMgd2l0aCAnKi8nLlxyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4ICsgMSkgPT09IDB4MkYpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gMjtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvYy5lbmQgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmluZGV4IC0gdGhpcy5saW5lU3RhcnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlMaW5lOiB0cnVlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGljZTogW3N0YXJ0ICsgMiwgdGhpcy5pbmRleCAtIDJdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCB0aGlzLmluZGV4XSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jOiBsb2NcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzLnB1c2goZW50cnkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1lbnRzO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBSYW4gb2ZmIHRoZSBlbmQgb2YgdGhlIGZpbGUgLSB0aGUgd2hvbGUgdGhpbmcgaXMgYSBjb21tZW50XHJcblx0ICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICBsb2MuZW5kID0ge1xyXG5cdCAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5pbmRleCAtIHRoaXMubGluZVN0YXJ0XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICB2YXIgZW50cnkgPSB7XHJcblx0ICAgICAgICAgICAgICAgIG11bHRpTGluZTogdHJ1ZSxcclxuXHQgICAgICAgICAgICAgICAgc2xpY2U6IFtzdGFydCArIDIsIHRoaXMuaW5kZXhdLFxyXG5cdCAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCB0aGlzLmluZGV4XSxcclxuXHQgICAgICAgICAgICAgICAgbG9jOiBsb2NcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgIGNvbW1lbnRzLnB1c2goZW50cnkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIGNvbW1lbnRzO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuQ29tbWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgY29tbWVudHM7XHJcblx0ICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICBjb21tZW50cyA9IFtdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gKHRoaXMuaW5kZXggPT09IDApO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KTtcclxuXHQgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzV2hpdGVTcGFjZShjaCkpIHtcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaCkpIHtcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDB4MEQgJiYgdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSA9PT0gMHgwQSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09IDB4MkYpIHtcclxuXHQgICAgICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXggKyAxKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAweDJGKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDI7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IHRoaXMuc2tpcFNpbmdsZUxpbmVDb21tZW50KDIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudHMgPSBjb21tZW50cy5jb25jYXQoY29tbWVudCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09IDB4MkEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gMjtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb21tZW50ID0gdGhpcy5za2lwTXVsdGlMaW5lQ29tbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudHMgPSBjb21tZW50cy5jb25jYXQoY29tbWVudCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChzdGFydCAmJiBjaCA9PT0gMHgyRCkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBVKzAwM0UgaXMgJz4nXHJcblx0ICAgICAgICAgICAgICAgIGlmICgodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4ICsgMSkgPT09IDB4MkQpICYmICh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXggKyAyKSA9PT0gMHgzRSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vICctLT4nIGlzIGEgc2luZ2xlLWxpbmUgY29tbWVudFxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSAzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSB0aGlzLnNraXBTaW5nbGVMaW5lQ29tbWVudCgzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzID0gY29tbWVudHMuY29uY2F0KGNvbW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09IDB4M0MpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlLnNsaWNlKHRoaXMuaW5kZXggKyAxLCB0aGlzLmluZGV4ICsgNCkgPT09ICchLS0nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDQ7IC8vIGA8IS0tYFxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSB0aGlzLnNraXBTaW5nbGVMaW5lQ29tbWVudCg0KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzID0gY29tbWVudHMuY29uY2F0KGNvbW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBjb21tZW50cztcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZnV0dXJlLXJlc2VydmVkLXdvcmRzXHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmlzRnV0dXJlUmVzZXJ2ZWRXb3JkID0gZnVuY3Rpb24gKGlkKSB7XHJcblx0ICAgICAgICBzd2l0Y2ggKGlkKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSAnZW51bSc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnZXhwb3J0JzpcclxuXHQgICAgICAgICAgICBjYXNlICdpbXBvcnQnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ3N1cGVyJzpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5pc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQgPSBmdW5jdGlvbiAoaWQpIHtcclxuXHQgICAgICAgIHN3aXRjaCAoaWQpIHtcclxuXHQgICAgICAgICAgICBjYXNlICdpbXBsZW1lbnRzJzpcclxuXHQgICAgICAgICAgICBjYXNlICdpbnRlcmZhY2UnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ3BhY2thZ2UnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ3ByaXZhdGUnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ3Byb3RlY3RlZCc6XHJcblx0ICAgICAgICAgICAgY2FzZSAncHVibGljJzpcclxuXHQgICAgICAgICAgICBjYXNlICdzdGF0aWMnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ3lpZWxkJzpcclxuXHQgICAgICAgICAgICBjYXNlICdsZXQnOlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmlzUmVzdHJpY3RlZFdvcmQgPSBmdW5jdGlvbiAoaWQpIHtcclxuXHQgICAgICAgIHJldHVybiBpZCA9PT0gJ2V2YWwnIHx8IGlkID09PSAnYXJndW1lbnRzJztcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMta2V5d29yZHNcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuaXNLZXl3b3JkID0gZnVuY3Rpb24gKGlkKSB7XHJcblx0ICAgICAgICBzd2l0Y2ggKGlkLmxlbmd0aCkge1xyXG5cdCAgICAgICAgICAgIGNhc2UgMjpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2lmJykgfHwgKGlkID09PSAnaW4nKSB8fCAoaWQgPT09ICdkbycpO1xyXG5cdCAgICAgICAgICAgIGNhc2UgMzpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3ZhcicpIHx8IChpZCA9PT0gJ2ZvcicpIHx8IChpZCA9PT0gJ25ldycpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAoaWQgPT09ICd0cnknKSB8fCAoaWQgPT09ICdsZXQnKTtcclxuXHQgICAgICAgICAgICBjYXNlIDQ6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICd0aGlzJykgfHwgKGlkID09PSAnZWxzZScpIHx8IChpZCA9PT0gJ2Nhc2UnKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKGlkID09PSAndm9pZCcpIHx8IChpZCA9PT0gJ3dpdGgnKSB8fCAoaWQgPT09ICdlbnVtJyk7XHJcblx0ICAgICAgICAgICAgY2FzZSA1OlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKGlkID09PSAnd2hpbGUnKSB8fCAoaWQgPT09ICdicmVhaycpIHx8IChpZCA9PT0gJ2NhdGNoJykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgIChpZCA9PT0gJ3Rocm93JykgfHwgKGlkID09PSAnY29uc3QnKSB8fCAoaWQgPT09ICd5aWVsZCcpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAoaWQgPT09ICdjbGFzcycpIHx8IChpZCA9PT0gJ3N1cGVyJyk7XHJcblx0ICAgICAgICAgICAgY2FzZSA2OlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKGlkID09PSAncmV0dXJuJykgfHwgKGlkID09PSAndHlwZW9mJykgfHwgKGlkID09PSAnZGVsZXRlJykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgIChpZCA9PT0gJ3N3aXRjaCcpIHx8IChpZCA9PT0gJ2V4cG9ydCcpIHx8IChpZCA9PT0gJ2ltcG9ydCcpO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNzpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2RlZmF1bHQnKSB8fCAoaWQgPT09ICdmaW5hbGx5JykgfHwgKGlkID09PSAnZXh0ZW5kcycpO1xyXG5cdCAgICAgICAgICAgIGNhc2UgODpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2Z1bmN0aW9uJykgfHwgKGlkID09PSAnY29udGludWUnKSB8fCAoaWQgPT09ICdkZWJ1Z2dlcicpO1xyXG5cdCAgICAgICAgICAgIGNhc2UgMTA6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdpbnN0YW5jZW9mJyk7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5jb2RlUG9pbnRBdCA9IGZ1bmN0aW9uIChpKSB7XHJcblx0ICAgICAgICB2YXIgY3AgPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KGkpO1xyXG5cdCAgICAgICAgaWYgKGNwID49IDB4RDgwMCAmJiBjcCA8PSAweERCRkYpIHtcclxuXHQgICAgICAgICAgICB2YXIgc2Vjb25kID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdChpICsgMSk7XHJcblx0ICAgICAgICAgICAgaWYgKHNlY29uZCA+PSAweERDMDAgJiYgc2Vjb25kIDw9IDB4REZGRikge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSBjcDtcclxuXHQgICAgICAgICAgICAgICAgY3AgPSAoZmlyc3QgLSAweEQ4MDApICogMHg0MDAgKyBzZWNvbmQgLSAweERDMDAgKyAweDEwMDAwO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBjcDtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhbkhleEVzY2FwZSA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcclxuXHQgICAgICAgIHZhciBsZW4gPSAocHJlZml4ID09PSAndScpID8gNCA6IDI7XHJcblx0ICAgICAgICB2YXIgY29kZSA9IDA7XHJcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmVvZigpICYmIGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0hleERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlICogMTYgKyBoZXhWYWx1ZSh0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgdmFyIGNvZGUgPSAwO1xyXG5cdCAgICAgICAgLy8gQXQgbGVhc3QsIG9uZSBoZXggZGlnaXQgaXMgcmVxdWlyZWQuXHJcblx0ICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICBpZiAoIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0hleERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBjb2RlID0gY29kZSAqIDE2ICsgaGV4VmFsdWUoY2gpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKGNvZGUgPiAweDEwRkZGRiB8fCBjaCAhPT0gJ30nKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5mcm9tQ29kZVBvaW50KGNvZGUpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5nZXRJZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleCsrO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KTtcclxuXHQgICAgICAgICAgICBpZiAoY2ggPT09IDB4NUMpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gQmxhY2tzbGFzaCAoVSswMDVDKSBtYXJrcyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IHN0YXJ0O1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wbGV4SWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaCA+PSAweEQ4MDAgJiYgY2ggPCAweERGRkYpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gTmVlZCB0byBoYW5kbGUgc3Vycm9nYXRlIHBhaXJzLlxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gc3RhcnQ7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbXBsZXhJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyUGFydChjaCkpIHtcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnNsaWNlKHN0YXJ0LCB0aGlzLmluZGV4KTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuZ2V0Q29tcGxleElkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgY3AgPSB0aGlzLmNvZGVQb2ludEF0KHRoaXMuaW5kZXgpO1xyXG5cdCAgICAgICAgdmFyIGlkID0gY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmZyb21Db2RlUG9pbnQoY3ApO1xyXG5cdCAgICAgICAgdGhpcy5pbmRleCArPSBpZC5sZW5ndGg7XHJcblx0ICAgICAgICAvLyAnXFx1JyAoVSswMDVDLCBVKzAwNzUpIGRlbm90ZXMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXHJcblx0ICAgICAgICB2YXIgY2g7XHJcblx0ICAgICAgICBpZiAoY3AgPT09IDB4NUMpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSAhPT0gMHg3NSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VbdGhpcy5pbmRleF0gPT09ICd7Jykge1xyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIGNoID0gdGhpcy5zY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgY2ggPSB0aGlzLnNjYW5IZXhFc2NhcGUoJ3UnKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSBudWxsIHx8IGNoID09PSAnXFxcXCcgfHwgIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJTdGFydChjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlkID0gY2g7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICBjcCA9IHRoaXMuY29kZVBvaW50QXQodGhpcy5pbmRleCk7XHJcblx0ICAgICAgICAgICAgaWYgKCFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyUGFydChjcCkpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGNoID0gY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmZyb21Db2RlUG9pbnQoY3ApO1xyXG5cdCAgICAgICAgICAgIGlkICs9IGNoO1xyXG5cdCAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gY2gubGVuZ3RoO1xyXG5cdCAgICAgICAgICAgIC8vICdcXHUnIChVKzAwNUMsIFUrMDA3NSkgZGVub3RlcyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cclxuXHQgICAgICAgICAgICBpZiAoY3AgPT09IDB4NUMpIHtcclxuXHQgICAgICAgICAgICAgICAgaWQgPSBpZC5zdWJzdHIoMCwgaWQubGVuZ3RoIC0gMSk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpICE9PSAweDc1KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VbdGhpcy5pbmRleF0gPT09ICd7Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2ggPSB0aGlzLnNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjaCA9IHRoaXMuc2NhbkhleEVzY2FwZSgndScpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSBudWxsIHx8IGNoID09PSAnXFxcXCcgfHwgIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJQYXJ0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlkICs9IGNoO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBpZDtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUub2N0YWxUb0RlY2ltYWwgPSBmdW5jdGlvbiAoY2gpIHtcclxuXHQgICAgICAgIC8vIFxcMCBpcyBub3Qgb2N0YWwgZXNjYXBlIHNlcXVlbmNlXHJcblx0ICAgICAgICB2YXIgb2N0YWwgPSAoY2ggIT09ICcwJyk7XHJcblx0ICAgICAgICB2YXIgY29kZSA9IG9jdGFsVmFsdWUoY2gpO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLmVvZigpICYmIGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc09jdGFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICBvY3RhbCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgY29kZSA9IGNvZGUgKiA4ICsgb2N0YWxWYWx1ZSh0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdKTtcclxuXHQgICAgICAgICAgICAvLyAzIGRpZ2l0cyBhcmUgb25seSBhbGxvd2VkIHdoZW4gc3RyaW5nIHN0YXJ0c1xyXG5cdCAgICAgICAgICAgIC8vIHdpdGggMCwgMSwgMiwgM1xyXG5cdCAgICAgICAgICAgIGlmICgnMDEyMycuaW5kZXhPZihjaCkgPj0gMCAmJiAhdGhpcy5lb2YoKSAmJiBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNPY3RhbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlICogOCArIG9jdGFsVmFsdWUodGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBjb2RlOiBjb2RlLFxyXG5cdCAgICAgICAgICAgIG9jdGFsOiBvY3RhbFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbmFtZXMtYW5kLWtleXdvcmRzXHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5JZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHR5cGU7XHJcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgLy8gQmFja3NsYXNoIChVKzAwNUMpIHN0YXJ0cyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cclxuXHQgICAgICAgIHZhciBpZCA9ICh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHN0YXJ0KSA9PT0gMHg1QykgPyB0aGlzLmdldENvbXBsZXhJZGVudGlmaWVyKCkgOiB0aGlzLmdldElkZW50aWZpZXIoKTtcclxuXHQgICAgICAgIC8vIFRoZXJlIGlzIG5vIGtleXdvcmQgb3IgbGl0ZXJhbCB3aXRoIG9ubHkgb25lIGNoYXJhY3Rlci5cclxuXHQgICAgICAgIC8vIFRodXMsIGl0IG11c3QgYmUgYW4gaWRlbnRpZmllci5cclxuXHQgICAgICAgIGlmIChpZC5sZW5ndGggPT09IDEpIHtcclxuXHQgICAgICAgICAgICB0eXBlID0gMyAvKiBJZGVudGlmaWVyICovO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5pc0tleXdvcmQoaWQpKSB7XHJcblx0ICAgICAgICAgICAgdHlwZSA9IDQgLyogS2V5d29yZCAqLztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKGlkID09PSAnbnVsbCcpIHtcclxuXHQgICAgICAgICAgICB0eXBlID0gNSAvKiBOdWxsTGl0ZXJhbCAqLztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKGlkID09PSAndHJ1ZScgfHwgaWQgPT09ICdmYWxzZScpIHtcclxuXHQgICAgICAgICAgICB0eXBlID0gMSAvKiBCb29sZWFuTGl0ZXJhbCAqLztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHR5cGUgPSAzIC8qIElkZW50aWZpZXIgKi87XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodHlwZSAhPT0gMyAvKiBJZGVudGlmaWVyICovICYmIChzdGFydCArIGlkLmxlbmd0aCAhPT0gdGhpcy5pbmRleCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgcmVzdG9yZSA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgdGhpcy5pbmRleCA9IHN0YXJ0O1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkRXNjYXBlZFJlc2VydmVkV29yZCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5pbmRleCA9IHJlc3RvcmU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcblx0ICAgICAgICAgICAgdmFsdWU6IGlkLFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXB1bmN0dWF0b3JzXHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5QdW5jdHVhdG9yID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgIC8vIENoZWNrIGZvciBtb3N0IGNvbW1vbiBzaW5nbGUtY2hhcmFjdGVyIHB1bmN0dWF0b3JzLlxyXG5cdCAgICAgICAgdmFyIHN0ciA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgc3dpdGNoIChzdHIpIHtcclxuXHQgICAgICAgICAgICBjYXNlICcoJzpcclxuXHQgICAgICAgICAgICBjYXNlICd7JzpcclxuXHQgICAgICAgICAgICAgICAgaWYgKHN0ciA9PT0gJ3snKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cmx5U3RhY2sucHVzaCgneycpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSAnLic6XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAnLicgJiYgdGhpcy5zb3VyY2VbdGhpcy5pbmRleCArIDFdID09PSAnLicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFNwcmVhZCBvcGVyYXRvcjogLi4uXHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDI7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdHIgPSAnLi4uJztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlICd9JzpcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmN1cmx5U3RhY2sucG9wKCk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgJyknOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJzsnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJywnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ1snOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ10nOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJzonOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJz8nOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ34nOlxyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIC8vIDQtY2hhcmFjdGVyIHB1bmN0dWF0b3IuXHJcblx0ICAgICAgICAgICAgICAgIHN0ciA9IHRoaXMuc291cmNlLnN1YnN0cih0aGlzLmluZGV4LCA0KTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHN0ciA9PT0gJz4+Pj0nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDQ7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyAzLWNoYXJhY3RlciBwdW5jdHVhdG9ycy5cclxuXHQgICAgICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHIoMCwgMyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3RyID09PSAnPT09JyB8fCBzdHIgPT09ICchPT0nIHx8IHN0ciA9PT0gJz4+PicgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdHIgPT09ICc8PD0nIHx8IHN0ciA9PT0gJz4+PScgfHwgc3RyID09PSAnKio9Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gMztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDItY2hhcmFjdGVyIHB1bmN0dWF0b3JzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHIoMCwgMik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0ciA9PT0gJyYmJyB8fCBzdHIgPT09ICd8fCcgfHwgc3RyID09PSAnPT0nIHx8IHN0ciA9PT0gJyE9JyB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgPT09ICcrPScgfHwgc3RyID09PSAnLT0nIHx8IHN0ciA9PT0gJyo9JyB8fCBzdHIgPT09ICcvPScgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyID09PSAnKysnIHx8IHN0ciA9PT0gJy0tJyB8fCBzdHIgPT09ICc8PCcgfHwgc3RyID09PSAnPj4nIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9PT0gJyY9JyB8fCBzdHIgPT09ICd8PScgfHwgc3RyID09PSAnXj0nIHx8IHN0ciA9PT0gJyU9JyB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgPT09ICc8PScgfHwgc3RyID09PSAnPj0nIHx8IHN0ciA9PT0gJz0+JyB8fCBzdHIgPT09ICcqKicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSAyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMS1jaGFyYWN0ZXIgcHVuY3R1YXRvcnMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJzw+PSErLSolJnxeLycuaW5kZXhPZihzdHIpID49IDApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMuaW5kZXggPT09IHN0YXJ0KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICB0eXBlOiA3IC8qIFB1bmN0dWF0b3IgKi8sXHJcblx0ICAgICAgICAgICAgdmFsdWU6IHN0cixcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1saXRlcmFscy1udW1lcmljLWxpdGVyYWxzXHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5IZXhMaXRlcmFsID0gZnVuY3Rpb24gKHN0YXJ0KSB7XHJcblx0ICAgICAgICB2YXIgbnVtID0gJyc7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICBpZiAoIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0hleERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBudW0gKz0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChudW0ubGVuZ3RoID09PSAwKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJTdGFydCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogNiAvKiBOdW1lcmljTGl0ZXJhbCAqLyxcclxuXHQgICAgICAgICAgICB2YWx1ZTogcGFyc2VJbnQoJzB4JyArIG51bSwgMTYpLFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5CaW5hcnlMaXRlcmFsID0gZnVuY3Rpb24gKHN0YXJ0KSB7XHJcblx0ICAgICAgICB2YXIgbnVtID0gJyc7XHJcblx0ICAgICAgICB2YXIgY2g7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgICAgIGlmIChjaCAhPT0gJzAnICYmIGNoICE9PSAnMScpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIG51bSArPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKG51bS5sZW5ndGggPT09IDApIHtcclxuXHQgICAgICAgICAgICAvLyBvbmx5IDBiIG9yIDBCXHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpO1xyXG5cdCAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcblx0ICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJTdGFydChjaCkgfHwgY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KGNoKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICB0eXBlOiA2IC8qIE51bWVyaWNMaXRlcmFsICovLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludChudW0sIDIpLFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5PY3RhbExpdGVyYWwgPSBmdW5jdGlvbiAocHJlZml4LCBzdGFydCkge1xyXG5cdCAgICAgICAgdmFyIG51bSA9ICcnO1xyXG5cdCAgICAgICAgdmFyIG9jdGFsID0gZmFsc2U7XHJcblx0ICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzT2N0YWxEaWdpdChwcmVmaXguY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICBvY3RhbCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgbnVtID0gJzAnICsgdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIGlmICghY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzT2N0YWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgbnVtICs9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoIW9jdGFsICYmIG51bS5sZW5ndGggPT09IDApIHtcclxuXHQgICAgICAgICAgICAvLyBvbmx5IDBvIG9yIDBPXHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJTdGFydCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSB8fCBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IDYgLyogTnVtZXJpY0xpdGVyYWwgKi8sXHJcblx0ICAgICAgICAgICAgdmFsdWU6IHBhcnNlSW50KG51bSwgOCksXHJcblx0ICAgICAgICAgICAgb2N0YWw6IG9jdGFsLFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmlzSW1wbGljaXRPY3RhbExpdGVyYWwgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAvLyBJbXBsaWNpdCBvY3RhbCwgdW5sZXNzIHRoZXJlIGlzIGEgbm9uLW9jdGFsIGRpZ2l0LlxyXG5cdCAgICAgICAgLy8gKEFubmV4IEIuMS4xIG9uIE51bWVyaWMgTGl0ZXJhbHMpXHJcblx0ICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5pbmRleCArIDE7IGkgPCB0aGlzLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2VbaV07XHJcblx0ICAgICAgICAgICAgaWYgKGNoID09PSAnOCcgfHwgY2ggPT09ICc5Jykge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmICghY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzT2N0YWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbk51bWVyaWNMaXRlcmFsID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlW3N0YXJ0XTtcclxuXHQgICAgICAgIGFzc2VydF8xLmFzc2VydChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkgfHwgKGNoID09PSAnLicpLCAnTnVtZXJpYyBsaXRlcmFsIG11c3Qgc3RhcnQgd2l0aCBhIGRlY2ltYWwgZGlnaXQgb3IgYSBkZWNpbWFsIHBvaW50Jyk7XHJcblx0ICAgICAgICB2YXIgbnVtID0gJyc7XHJcblx0ICAgICAgICBpZiAoY2ggIT09ICcuJykge1xyXG5cdCAgICAgICAgICAgIG51bSA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgICAgICAvLyBIZXggbnVtYmVyIHN0YXJ0cyB3aXRoICcweCcuXHJcblx0ICAgICAgICAgICAgLy8gT2N0YWwgbnVtYmVyIHN0YXJ0cyB3aXRoICcwJy5cclxuXHQgICAgICAgICAgICAvLyBPY3RhbCBudW1iZXIgaW4gRVM2IHN0YXJ0cyB3aXRoICcwbycuXHJcblx0ICAgICAgICAgICAgLy8gQmluYXJ5IG51bWJlciBpbiBFUzYgc3RhcnRzIHdpdGggJzBiJy5cclxuXHQgICAgICAgICAgICBpZiAobnVtID09PSAnMCcpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAneCcgfHwgY2ggPT09ICdYJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkhleExpdGVyYWwoc3RhcnQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ2InIHx8IGNoID09PSAnQicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5CaW5hcnlMaXRlcmFsKHN0YXJ0KTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdvJyB8fCBjaCA9PT0gJ08nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuT2N0YWxMaXRlcmFsKGNoLCBzdGFydCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoICYmIGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc09jdGFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzSW1wbGljaXRPY3RhbExpdGVyYWwoKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5PY3RhbExpdGVyYWwoY2gsIHN0YXJ0KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB3aGlsZSAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIG51bSArPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKGNoID09PSAnLicpIHtcclxuXHQgICAgICAgICAgICBudW0gKz0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICB3aGlsZSAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIG51bSArPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKGNoID09PSAnZScgfHwgY2ggPT09ICdFJykge1xyXG5cdCAgICAgICAgICAgIG51bSArPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICAgICAgaWYgKGNoID09PSAnKycgfHwgY2ggPT09ICctJykge1xyXG5cdCAgICAgICAgICAgICAgICBudW0gKz0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgICAgICB3aGlsZSAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBudW0gKz0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyU3RhcnQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IDYgLyogTnVtZXJpY0xpdGVyYWwgKi8sXHJcblx0ICAgICAgICAgICAgdmFsdWU6IHBhcnNlRmxvYXQobnVtKSxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1saXRlcmFscy1zdHJpbmctbGl0ZXJhbHNcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhblN0cmluZ0xpdGVyYWwgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgdmFyIHF1b3RlID0gdGhpcy5zb3VyY2Vbc3RhcnRdO1xyXG5cdCAgICAgICAgYXNzZXJ0XzEuYXNzZXJ0KChxdW90ZSA9PT0gJ1xcJycgfHwgcXVvdGUgPT09ICdcIicpLCAnU3RyaW5nIGxpdGVyYWwgbXVzdCBzdGFydHMgd2l0aCBhIHF1b3RlJyk7XHJcblx0ICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICB2YXIgb2N0YWwgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBzdHIgPSAnJztcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgaWYgKGNoID09PSBxdW90ZSkge1xyXG5cdCAgICAgICAgICAgICAgICBxdW90ZSA9ICcnO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xyXG5cdCAgICAgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgICAgIGlmICghY2ggfHwgIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndSc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZVt0aGlzLmluZGV4XSA9PT0gJ3snKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gdGhpcy5zY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVuZXNjYXBlZF8xID0gdGhpcy5zY2FuSGV4RXNjYXBlKGNoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmVzY2FwZWRfMSA9PT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSB1bmVzY2FwZWRfMTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd4JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVuZXNjYXBlZCA9IHRoaXMuc2NhbkhleEVzY2FwZShjaCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmVzY2FwZWQgPT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkSGV4RXNjYXBlU2VxdWVuY2UpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSB1bmVzY2FwZWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ24nOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcbic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xccic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcdCc7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcYic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcZic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xceDBCJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnOCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnOSc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggJiYgY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzT2N0YWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9jdFRvRGVjID0gdGhpcy5vY3RhbFRvRGVjaW1hbChjaCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvY3RhbCA9IG9jdFRvRGVjLm9jdGFsIHx8IG9jdGFsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUob2N0VG9EZWMuY29kZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMubGluZU51bWJlcjtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgdGhpcy5zb3VyY2VbdGhpcy5pbmRleF0gPT09ICdcXG4nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChxdW90ZSAhPT0gJycpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmluZGV4ID0gc3RhcnQ7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICB0eXBlOiA4IC8qIFN0cmluZ0xpdGVyYWwgKi8sXHJcblx0ICAgICAgICAgICAgdmFsdWU6IHN0cixcclxuXHQgICAgICAgICAgICBvY3RhbDogb2N0YWwsXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdGVtcGxhdGUtbGl0ZXJhbC1sZXhpY2FsLWNvbXBvbmVudHNcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhblRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGNvb2tlZCA9ICcnO1xyXG5cdCAgICAgICAgdmFyIHRlcm1pbmF0ZWQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICB2YXIgaGVhZCA9ICh0aGlzLnNvdXJjZVtzdGFydF0gPT09ICdgJyk7XHJcblx0ICAgICAgICB2YXIgdGFpbCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIHJhd09mZnNldCA9IDI7XHJcblx0ICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gJ2AnKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJhd09mZnNldCA9IDE7XHJcblx0ICAgICAgICAgICAgICAgIHRhaWwgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB0ZXJtaW5hdGVkID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAnJCcpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAneycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VybHlTdGFjay5wdXNoKCckeycpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGVybWluYXRlZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBjb29rZWQgKz0gY2g7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAnXFxcXCcpIHtcclxuXHQgICAgICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFxuJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFxyJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFx0JztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndSc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZVt0aGlzLmluZGV4XSA9PT0gJ3snKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gdGhpcy5zY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3RvcmUgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVuZXNjYXBlZF8yID0gdGhpcy5zY2FuSGV4RXNjYXBlKGNoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmVzY2FwZWRfMiAhPT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSB1bmVzY2FwZWRfMjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSByZXN0b3JlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSBjaDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd4JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVuZXNjYXBlZCA9IHRoaXMuc2NhbkhleEVzY2FwZShjaCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmVzY2FwZWQgPT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkSGV4RXNjYXBlU2VxdWVuY2UpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSB1bmVzY2FwZWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcYic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcZic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcdic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJzAnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbDogXFwwMSBcXDAyIGFuZCBzbyBvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5UZW1wbGF0ZU9jdGFsTGl0ZXJhbCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcMCc7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzT2N0YWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbDogXFwxIFxcMlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLlRlbXBsYXRlT2N0YWxMaXRlcmFsKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSBjaDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XSA9PT0gJ1xcbicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgdGhpcy5zb3VyY2VbdGhpcy5pbmRleF0gPT09ICdcXG4nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcbic7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBjb29rZWQgKz0gY2g7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKCF0ZXJtaW5hdGVkKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKCFoZWFkKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5jdXJseVN0YWNrLnBvcCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICB0eXBlOiAxMCAvKiBUZW1wbGF0ZSAqLyxcclxuXHQgICAgICAgICAgICB2YWx1ZTogdGhpcy5zb3VyY2Uuc2xpY2Uoc3RhcnQgKyAxLCB0aGlzLmluZGV4IC0gcmF3T2Zmc2V0KSxcclxuXHQgICAgICAgICAgICBjb29rZWQ6IGNvb2tlZCxcclxuXHQgICAgICAgICAgICBoZWFkOiBoZWFkLFxyXG5cdCAgICAgICAgICAgIHRhaWw6IHRhaWwsXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGl0ZXJhbHMtcmVndWxhci1leHByZXNzaW9uLWxpdGVyYWxzXHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnRlc3RSZWdFeHAgPSBmdW5jdGlvbiAocGF0dGVybiwgZmxhZ3MpIHtcclxuXHQgICAgICAgIC8vIFRoZSBCTVAgY2hhcmFjdGVyIHRvIHVzZSBhcyBhIHJlcGxhY2VtZW50IGZvciBhc3RyYWwgc3ltYm9scyB3aGVuXHJcblx0ICAgICAgICAvLyB0cmFuc2xhdGluZyBhbiBFUzYgXCJ1XCItZmxhZ2dlZCBwYXR0ZXJuIHRvIGFuIEVTNS1jb21wYXRpYmxlXHJcblx0ICAgICAgICAvLyBhcHByb3hpbWF0aW9uLlxyXG5cdCAgICAgICAgLy8gTm90ZTogcmVwbGFjaW5nIHdpdGggJ1xcdUZGRkYnIGVuYWJsZXMgZmFsc2UgcG9zaXRpdmVzIGluIHVubGlrZWx5XHJcblx0ICAgICAgICAvLyBzY2VuYXJpb3MuIEZvciBleGFtcGxlLCBgW1xcdXsxMDQ0Zn0tXFx1ezEwNDQwfV1gIGlzIGFuIGludmFsaWRcclxuXHQgICAgICAgIC8vIHBhdHRlcm4gdGhhdCB3b3VsZCBub3QgYmUgZGV0ZWN0ZWQgYnkgdGhpcyBzdWJzdGl0dXRpb24uXHJcblx0ICAgICAgICB2YXIgYXN0cmFsU3Vic3RpdHV0ZSA9ICdcXHVGRkZGJztcclxuXHQgICAgICAgIHZhciB0bXAgPSBwYXR0ZXJuO1xyXG5cdCAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cdCAgICAgICAgaWYgKGZsYWdzLmluZGV4T2YoJ3UnKSA+PSAwKSB7XHJcblx0ICAgICAgICAgICAgdG1wID0gdG1wXHJcblx0ICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcdVxceyhbMC05YS1mQS1GXSspXFx9fFxcXFx1KFthLWZBLUYwLTldezR9KS9nLCBmdW5jdGlvbiAoJDAsICQxLCAkMikge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgY29kZVBvaW50ID0gcGFyc2VJbnQoJDEgfHwgJDIsIDE2KTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4MTBGRkZGKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzZWxmLnRocm93VW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZFJlZ0V4cCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweEZGRkYpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGFzdHJhbFN1YnN0aXR1dGU7XHJcblx0ICAgICAgICAgICAgfSlcclxuXHQgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0vZywgYXN0cmFsU3Vic3RpdHV0ZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBGaXJzdCwgZGV0ZWN0IGludmFsaWQgcmVndWxhciBleHByZXNzaW9ucy5cclxuXHQgICAgICAgIHRyeSB7XHJcblx0ICAgICAgICAgICAgUmVnRXhwKHRtcCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBjYXRjaCAoZSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkUmVnRXhwKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIFJldHVybiBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3QgZm9yIHRoaXMgcGF0dGVybi1mbGFnIHBhaXIsIG9yXHJcblx0ICAgICAgICAvLyBgbnVsbGAgaW4gY2FzZSB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IHN1cHBvcnQgdGhlIGZsYWdzIGl0XHJcblx0ICAgICAgICAvLyB1c2VzLlxyXG5cdCAgICAgICAgdHJ5IHtcclxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBjYXRjaCAoZXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhblJlZ0V4cEJvZHkgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgIGFzc2VydF8xLmFzc2VydChjaCA9PT0gJy8nLCAnUmVndWxhciBleHByZXNzaW9uIGxpdGVyYWwgbXVzdCBzdGFydCB3aXRoIGEgc2xhc2gnKTtcclxuXHQgICAgICAgIHZhciBzdHIgPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgdmFyIGNsYXNzTWFya2VyID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgdGVybWluYXRlZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIHN0ciArPSBjaDtcclxuXHQgICAgICAgICAgICBpZiAoY2ggPT09ICdcXFxcJykge1xyXG5cdCAgICAgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWxpdGVyYWxzLXJlZ3VsYXItZXhwcmVzc2lvbi1saXRlcmFsc1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNsYXNzTWFya2VyKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ10nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjbGFzc01hcmtlciA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICcvJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGVybWluYXRlZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJ1snKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjbGFzc01hcmtlciA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoIXRlcm1pbmF0ZWQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW50ZXJtaW5hdGVkUmVnRXhwKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIEV4Y2x1ZGUgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2guXHJcblx0ICAgICAgICByZXR1cm4gc3RyLnN1YnN0cigxLCBzdHIubGVuZ3RoIC0gMik7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5SZWdFeHBGbGFncyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdHIgPSAnJztcclxuXHQgICAgICAgIHZhciBmbGFncyA9ICcnO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICAgICAgaWYgKCFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyUGFydChjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnICYmICF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3UnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdG9yZSA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2hhciA9IHRoaXMuc2NhbkhleEVzY2FwZSgndScpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXIgIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmbGFncyArPSBjaGFyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoc3RyICs9ICdcXFxcdSc7IHJlc3RvcmUgPCB0aGlzLmluZGV4OyArK3Jlc3RvcmUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHRoaXMuc291cmNlW3Jlc3RvcmVdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSByZXN0b3JlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzICs9ICd1JztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFx1JztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXCc7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGZsYWdzICs9IGNoO1xyXG5cdCAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGZsYWdzO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuUmVnRXhwID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgIHZhciBwYXR0ZXJuID0gdGhpcy5zY2FuUmVnRXhwQm9keSgpO1xyXG5cdCAgICAgICAgdmFyIGZsYWdzID0gdGhpcy5zY2FuUmVnRXhwRmxhZ3MoKTtcclxuXHQgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudGVzdFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IDkgLyogUmVndWxhckV4cHJlc3Npb24gKi8sXHJcblx0ICAgICAgICAgICAgdmFsdWU6ICcnLFxyXG5cdCAgICAgICAgICAgIHBhdHRlcm46IHBhdHRlcm4sXHJcblx0ICAgICAgICAgICAgZmxhZ3M6IGZsYWdzLFxyXG5cdCAgICAgICAgICAgIHJlZ2V4OiB2YWx1ZSxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5sZXggPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgIHR5cGU6IDIgLyogRU9GICovLFxyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogJycsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMuaW5kZXgsXHJcblx0ICAgICAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgY3AgPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpO1xyXG5cdCAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJTdGFydChjcCkpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gVmVyeSBjb21tb246ICggYW5kICkgYW5kIDtcclxuXHQgICAgICAgIGlmIChjcCA9PT0gMHgyOCB8fCBjcCA9PT0gMHgyOSB8fCBjcCA9PT0gMHgzQikge1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5QdW5jdHVhdG9yKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBTdHJpbmcgbGl0ZXJhbCBzdGFydHMgd2l0aCBzaW5nbGUgcXVvdGUgKFUrMDAyNykgb3IgZG91YmxlIHF1b3RlIChVKzAwMjIpLlxyXG5cdCAgICAgICAgaWYgKGNwID09PSAweDI3IHx8IGNwID09PSAweDIyKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhblN0cmluZ0xpdGVyYWwoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIERvdCAoLikgVSswMDJFIGNhbiBhbHNvIHN0YXJ0IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLCBoZW5jZSB0aGUgbmVlZFxyXG5cdCAgICAgICAgLy8gdG8gY2hlY2sgdGhlIG5leHQgY2hhcmFjdGVyLlxyXG5cdCAgICAgICAgaWYgKGNwID09PSAweDJFKSB7XHJcblx0ICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXggKyAxKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbk51bWVyaWNMaXRlcmFsKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5QdW5jdHVhdG9yKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KGNwKSkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5OdW1lcmljTGl0ZXJhbCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gVGVtcGxhdGUgbGl0ZXJhbHMgc3RhcnQgd2l0aCBgIChVKzAwNjApIGZvciB0ZW1wbGF0ZSBoZWFkXHJcblx0ICAgICAgICAvLyBvciB9IChVKzAwN0QpIGZvciB0ZW1wbGF0ZSBtaWRkbGUgb3IgdGVtcGxhdGUgdGFpbC5cclxuXHQgICAgICAgIGlmIChjcCA9PT0gMHg2MCB8fCAoY3AgPT09IDB4N0QgJiYgdGhpcy5jdXJseVN0YWNrW3RoaXMuY3VybHlTdGFjay5sZW5ndGggLSAxXSA9PT0gJyR7JykpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuVGVtcGxhdGUoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIFBvc3NpYmxlIGlkZW50aWZpZXIgc3RhcnQgaW4gYSBzdXJyb2dhdGUgcGFpci5cclxuXHQgICAgICAgIGlmIChjcCA+PSAweEQ4MDAgJiYgY3AgPCAweERGRkYpIHtcclxuXHQgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclN0YXJ0KHRoaXMuY29kZVBvaW50QXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5JZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuc2NhblB1bmN0dWF0b3IoKTtcclxuXHQgICAgfTtcclxuXHQgICAgcmV0dXJuIFNjYW5uZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlNjYW5uZXIgPSBTY2FubmVyO1xyXG5cblxuLyoqKi8gfSxcbi8qIDEzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWUgPSB7fTtcclxuXHRleHBvcnRzLlRva2VuTmFtZVsxIC8qIEJvb2xlYW5MaXRlcmFsICovXSA9ICdCb29sZWFuJztcclxuXHRleHBvcnRzLlRva2VuTmFtZVsyIC8qIEVPRiAqL10gPSAnPGVuZD4nO1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lWzMgLyogSWRlbnRpZmllciAqL10gPSAnSWRlbnRpZmllcic7XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbNCAvKiBLZXl3b3JkICovXSA9ICdLZXl3b3JkJztcclxuXHRleHBvcnRzLlRva2VuTmFtZVs1IC8qIE51bGxMaXRlcmFsICovXSA9ICdOdWxsJztcclxuXHRleHBvcnRzLlRva2VuTmFtZVs2IC8qIE51bWVyaWNMaXRlcmFsICovXSA9ICdOdW1lcmljJztcclxuXHRleHBvcnRzLlRva2VuTmFtZVs3IC8qIFB1bmN0dWF0b3IgKi9dID0gJ1B1bmN0dWF0b3InO1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lWzggLyogU3RyaW5nTGl0ZXJhbCAqL10gPSAnU3RyaW5nJztcclxuXHRleHBvcnRzLlRva2VuTmFtZVs5IC8qIFJlZ3VsYXJFeHByZXNzaW9uICovXSA9ICdSZWd1bGFyRXhwcmVzc2lvbic7XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbMTAgLyogVGVtcGxhdGUgKi9dID0gJ1RlbXBsYXRlJztcclxuXG5cbi8qKiovIH0sXG4vKiAxNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0Ly8gR2VuZXJhdGVkIGJ5IGdlbmVyYXRlLXhodG1sLWVudGl0aWVzLmpzLiBETyBOT1QgTU9ESUZZIVxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHRleHBvcnRzLlhIVE1MRW50aXRpZXMgPSB7XHJcblx0ICAgIHF1b3Q6ICdcXHUwMDIyJyxcclxuXHQgICAgYW1wOiAnXFx1MDAyNicsXHJcblx0ICAgIGFwb3M6ICdcXHUwMDI3JyxcclxuXHQgICAgZ3Q6ICdcXHUwMDNFJyxcclxuXHQgICAgbmJzcDogJ1xcdTAwQTAnLFxyXG5cdCAgICBpZXhjbDogJ1xcdTAwQTEnLFxyXG5cdCAgICBjZW50OiAnXFx1MDBBMicsXHJcblx0ICAgIHBvdW5kOiAnXFx1MDBBMycsXHJcblx0ICAgIGN1cnJlbjogJ1xcdTAwQTQnLFxyXG5cdCAgICB5ZW46ICdcXHUwMEE1JyxcclxuXHQgICAgYnJ2YmFyOiAnXFx1MDBBNicsXHJcblx0ICAgIHNlY3Q6ICdcXHUwMEE3JyxcclxuXHQgICAgdW1sOiAnXFx1MDBBOCcsXHJcblx0ICAgIGNvcHk6ICdcXHUwMEE5JyxcclxuXHQgICAgb3JkZjogJ1xcdTAwQUEnLFxyXG5cdCAgICBsYXF1bzogJ1xcdTAwQUInLFxyXG5cdCAgICBub3Q6ICdcXHUwMEFDJyxcclxuXHQgICAgc2h5OiAnXFx1MDBBRCcsXHJcblx0ICAgIHJlZzogJ1xcdTAwQUUnLFxyXG5cdCAgICBtYWNyOiAnXFx1MDBBRicsXHJcblx0ICAgIGRlZzogJ1xcdTAwQjAnLFxyXG5cdCAgICBwbHVzbW46ICdcXHUwMEIxJyxcclxuXHQgICAgc3VwMjogJ1xcdTAwQjInLFxyXG5cdCAgICBzdXAzOiAnXFx1MDBCMycsXHJcblx0ICAgIGFjdXRlOiAnXFx1MDBCNCcsXHJcblx0ICAgIG1pY3JvOiAnXFx1MDBCNScsXHJcblx0ICAgIHBhcmE6ICdcXHUwMEI2JyxcclxuXHQgICAgbWlkZG90OiAnXFx1MDBCNycsXHJcblx0ICAgIGNlZGlsOiAnXFx1MDBCOCcsXHJcblx0ICAgIHN1cDE6ICdcXHUwMEI5JyxcclxuXHQgICAgb3JkbTogJ1xcdTAwQkEnLFxyXG5cdCAgICByYXF1bzogJ1xcdTAwQkInLFxyXG5cdCAgICBmcmFjMTQ6ICdcXHUwMEJDJyxcclxuXHQgICAgZnJhYzEyOiAnXFx1MDBCRCcsXHJcblx0ICAgIGZyYWMzNDogJ1xcdTAwQkUnLFxyXG5cdCAgICBpcXVlc3Q6ICdcXHUwMEJGJyxcclxuXHQgICAgQWdyYXZlOiAnXFx1MDBDMCcsXHJcblx0ICAgIEFhY3V0ZTogJ1xcdTAwQzEnLFxyXG5cdCAgICBBY2lyYzogJ1xcdTAwQzInLFxyXG5cdCAgICBBdGlsZGU6ICdcXHUwMEMzJyxcclxuXHQgICAgQXVtbDogJ1xcdTAwQzQnLFxyXG5cdCAgICBBcmluZzogJ1xcdTAwQzUnLFxyXG5cdCAgICBBRWxpZzogJ1xcdTAwQzYnLFxyXG5cdCAgICBDY2VkaWw6ICdcXHUwMEM3JyxcclxuXHQgICAgRWdyYXZlOiAnXFx1MDBDOCcsXHJcblx0ICAgIEVhY3V0ZTogJ1xcdTAwQzknLFxyXG5cdCAgICBFY2lyYzogJ1xcdTAwQ0EnLFxyXG5cdCAgICBFdW1sOiAnXFx1MDBDQicsXHJcblx0ICAgIElncmF2ZTogJ1xcdTAwQ0MnLFxyXG5cdCAgICBJYWN1dGU6ICdcXHUwMENEJyxcclxuXHQgICAgSWNpcmM6ICdcXHUwMENFJyxcclxuXHQgICAgSXVtbDogJ1xcdTAwQ0YnLFxyXG5cdCAgICBFVEg6ICdcXHUwMEQwJyxcclxuXHQgICAgTnRpbGRlOiAnXFx1MDBEMScsXHJcblx0ICAgIE9ncmF2ZTogJ1xcdTAwRDInLFxyXG5cdCAgICBPYWN1dGU6ICdcXHUwMEQzJyxcclxuXHQgICAgT2NpcmM6ICdcXHUwMEQ0JyxcclxuXHQgICAgT3RpbGRlOiAnXFx1MDBENScsXHJcblx0ICAgIE91bWw6ICdcXHUwMEQ2JyxcclxuXHQgICAgdGltZXM6ICdcXHUwMEQ3JyxcclxuXHQgICAgT3NsYXNoOiAnXFx1MDBEOCcsXHJcblx0ICAgIFVncmF2ZTogJ1xcdTAwRDknLFxyXG5cdCAgICBVYWN1dGU6ICdcXHUwMERBJyxcclxuXHQgICAgVWNpcmM6ICdcXHUwMERCJyxcclxuXHQgICAgVXVtbDogJ1xcdTAwREMnLFxyXG5cdCAgICBZYWN1dGU6ICdcXHUwMEREJyxcclxuXHQgICAgVEhPUk46ICdcXHUwMERFJyxcclxuXHQgICAgc3psaWc6ICdcXHUwMERGJyxcclxuXHQgICAgYWdyYXZlOiAnXFx1MDBFMCcsXHJcblx0ICAgIGFhY3V0ZTogJ1xcdTAwRTEnLFxyXG5cdCAgICBhY2lyYzogJ1xcdTAwRTInLFxyXG5cdCAgICBhdGlsZGU6ICdcXHUwMEUzJyxcclxuXHQgICAgYXVtbDogJ1xcdTAwRTQnLFxyXG5cdCAgICBhcmluZzogJ1xcdTAwRTUnLFxyXG5cdCAgICBhZWxpZzogJ1xcdTAwRTYnLFxyXG5cdCAgICBjY2VkaWw6ICdcXHUwMEU3JyxcclxuXHQgICAgZWdyYXZlOiAnXFx1MDBFOCcsXHJcblx0ICAgIGVhY3V0ZTogJ1xcdTAwRTknLFxyXG5cdCAgICBlY2lyYzogJ1xcdTAwRUEnLFxyXG5cdCAgICBldW1sOiAnXFx1MDBFQicsXHJcblx0ICAgIGlncmF2ZTogJ1xcdTAwRUMnLFxyXG5cdCAgICBpYWN1dGU6ICdcXHUwMEVEJyxcclxuXHQgICAgaWNpcmM6ICdcXHUwMEVFJyxcclxuXHQgICAgaXVtbDogJ1xcdTAwRUYnLFxyXG5cdCAgICBldGg6ICdcXHUwMEYwJyxcclxuXHQgICAgbnRpbGRlOiAnXFx1MDBGMScsXHJcblx0ICAgIG9ncmF2ZTogJ1xcdTAwRjInLFxyXG5cdCAgICBvYWN1dGU6ICdcXHUwMEYzJyxcclxuXHQgICAgb2NpcmM6ICdcXHUwMEY0JyxcclxuXHQgICAgb3RpbGRlOiAnXFx1MDBGNScsXHJcblx0ICAgIG91bWw6ICdcXHUwMEY2JyxcclxuXHQgICAgZGl2aWRlOiAnXFx1MDBGNycsXHJcblx0ICAgIG9zbGFzaDogJ1xcdTAwRjgnLFxyXG5cdCAgICB1Z3JhdmU6ICdcXHUwMEY5JyxcclxuXHQgICAgdWFjdXRlOiAnXFx1MDBGQScsXHJcblx0ICAgIHVjaXJjOiAnXFx1MDBGQicsXHJcblx0ICAgIHV1bWw6ICdcXHUwMEZDJyxcclxuXHQgICAgeWFjdXRlOiAnXFx1MDBGRCcsXHJcblx0ICAgIHRob3JuOiAnXFx1MDBGRScsXHJcblx0ICAgIHl1bWw6ICdcXHUwMEZGJyxcclxuXHQgICAgT0VsaWc6ICdcXHUwMTUyJyxcclxuXHQgICAgb2VsaWc6ICdcXHUwMTUzJyxcclxuXHQgICAgU2Nhcm9uOiAnXFx1MDE2MCcsXHJcblx0ICAgIHNjYXJvbjogJ1xcdTAxNjEnLFxyXG5cdCAgICBZdW1sOiAnXFx1MDE3OCcsXHJcblx0ICAgIGZub2Y6ICdcXHUwMTkyJyxcclxuXHQgICAgY2lyYzogJ1xcdTAyQzYnLFxyXG5cdCAgICB0aWxkZTogJ1xcdTAyREMnLFxyXG5cdCAgICBBbHBoYTogJ1xcdTAzOTEnLFxyXG5cdCAgICBCZXRhOiAnXFx1MDM5MicsXHJcblx0ICAgIEdhbW1hOiAnXFx1MDM5MycsXHJcblx0ICAgIERlbHRhOiAnXFx1MDM5NCcsXHJcblx0ICAgIEVwc2lsb246ICdcXHUwMzk1JyxcclxuXHQgICAgWmV0YTogJ1xcdTAzOTYnLFxyXG5cdCAgICBFdGE6ICdcXHUwMzk3JyxcclxuXHQgICAgVGhldGE6ICdcXHUwMzk4JyxcclxuXHQgICAgSW90YTogJ1xcdTAzOTknLFxyXG5cdCAgICBLYXBwYTogJ1xcdTAzOUEnLFxyXG5cdCAgICBMYW1iZGE6ICdcXHUwMzlCJyxcclxuXHQgICAgTXU6ICdcXHUwMzlDJyxcclxuXHQgICAgTnU6ICdcXHUwMzlEJyxcclxuXHQgICAgWGk6ICdcXHUwMzlFJyxcclxuXHQgICAgT21pY3JvbjogJ1xcdTAzOUYnLFxyXG5cdCAgICBQaTogJ1xcdTAzQTAnLFxyXG5cdCAgICBSaG86ICdcXHUwM0ExJyxcclxuXHQgICAgU2lnbWE6ICdcXHUwM0EzJyxcclxuXHQgICAgVGF1OiAnXFx1MDNBNCcsXHJcblx0ICAgIFVwc2lsb246ICdcXHUwM0E1JyxcclxuXHQgICAgUGhpOiAnXFx1MDNBNicsXHJcblx0ICAgIENoaTogJ1xcdTAzQTcnLFxyXG5cdCAgICBQc2k6ICdcXHUwM0E4JyxcclxuXHQgICAgT21lZ2E6ICdcXHUwM0E5JyxcclxuXHQgICAgYWxwaGE6ICdcXHUwM0IxJyxcclxuXHQgICAgYmV0YTogJ1xcdTAzQjInLFxyXG5cdCAgICBnYW1tYTogJ1xcdTAzQjMnLFxyXG5cdCAgICBkZWx0YTogJ1xcdTAzQjQnLFxyXG5cdCAgICBlcHNpbG9uOiAnXFx1MDNCNScsXHJcblx0ICAgIHpldGE6ICdcXHUwM0I2JyxcclxuXHQgICAgZXRhOiAnXFx1MDNCNycsXHJcblx0ICAgIHRoZXRhOiAnXFx1MDNCOCcsXHJcblx0ICAgIGlvdGE6ICdcXHUwM0I5JyxcclxuXHQgICAga2FwcGE6ICdcXHUwM0JBJyxcclxuXHQgICAgbGFtYmRhOiAnXFx1MDNCQicsXHJcblx0ICAgIG11OiAnXFx1MDNCQycsXHJcblx0ICAgIG51OiAnXFx1MDNCRCcsXHJcblx0ICAgIHhpOiAnXFx1MDNCRScsXHJcblx0ICAgIG9taWNyb246ICdcXHUwM0JGJyxcclxuXHQgICAgcGk6ICdcXHUwM0MwJyxcclxuXHQgICAgcmhvOiAnXFx1MDNDMScsXHJcblx0ICAgIHNpZ21hZjogJ1xcdTAzQzInLFxyXG5cdCAgICBzaWdtYTogJ1xcdTAzQzMnLFxyXG5cdCAgICB0YXU6ICdcXHUwM0M0JyxcclxuXHQgICAgdXBzaWxvbjogJ1xcdTAzQzUnLFxyXG5cdCAgICBwaGk6ICdcXHUwM0M2JyxcclxuXHQgICAgY2hpOiAnXFx1MDNDNycsXHJcblx0ICAgIHBzaTogJ1xcdTAzQzgnLFxyXG5cdCAgICBvbWVnYTogJ1xcdTAzQzknLFxyXG5cdCAgICB0aGV0YXN5bTogJ1xcdTAzRDEnLFxyXG5cdCAgICB1cHNpaDogJ1xcdTAzRDInLFxyXG5cdCAgICBwaXY6ICdcXHUwM0Q2JyxcclxuXHQgICAgZW5zcDogJ1xcdTIwMDInLFxyXG5cdCAgICBlbXNwOiAnXFx1MjAwMycsXHJcblx0ICAgIHRoaW5zcDogJ1xcdTIwMDknLFxyXG5cdCAgICB6d25qOiAnXFx1MjAwQycsXHJcblx0ICAgIHp3ajogJ1xcdTIwMEQnLFxyXG5cdCAgICBscm06ICdcXHUyMDBFJyxcclxuXHQgICAgcmxtOiAnXFx1MjAwRicsXHJcblx0ICAgIG5kYXNoOiAnXFx1MjAxMycsXHJcblx0ICAgIG1kYXNoOiAnXFx1MjAxNCcsXHJcblx0ICAgIGxzcXVvOiAnXFx1MjAxOCcsXHJcblx0ICAgIHJzcXVvOiAnXFx1MjAxOScsXHJcblx0ICAgIHNicXVvOiAnXFx1MjAxQScsXHJcblx0ICAgIGxkcXVvOiAnXFx1MjAxQycsXHJcblx0ICAgIHJkcXVvOiAnXFx1MjAxRCcsXHJcblx0ICAgIGJkcXVvOiAnXFx1MjAxRScsXHJcblx0ICAgIGRhZ2dlcjogJ1xcdTIwMjAnLFxyXG5cdCAgICBEYWdnZXI6ICdcXHUyMDIxJyxcclxuXHQgICAgYnVsbDogJ1xcdTIwMjInLFxyXG5cdCAgICBoZWxsaXA6ICdcXHUyMDI2JyxcclxuXHQgICAgcGVybWlsOiAnXFx1MjAzMCcsXHJcblx0ICAgIHByaW1lOiAnXFx1MjAzMicsXHJcblx0ICAgIFByaW1lOiAnXFx1MjAzMycsXHJcblx0ICAgIGxzYXF1bzogJ1xcdTIwMzknLFxyXG5cdCAgICByc2FxdW86ICdcXHUyMDNBJyxcclxuXHQgICAgb2xpbmU6ICdcXHUyMDNFJyxcclxuXHQgICAgZnJhc2w6ICdcXHUyMDQ0JyxcclxuXHQgICAgZXVybzogJ1xcdTIwQUMnLFxyXG5cdCAgICBpbWFnZTogJ1xcdTIxMTEnLFxyXG5cdCAgICB3ZWllcnA6ICdcXHUyMTE4JyxcclxuXHQgICAgcmVhbDogJ1xcdTIxMUMnLFxyXG5cdCAgICB0cmFkZTogJ1xcdTIxMjInLFxyXG5cdCAgICBhbGVmc3ltOiAnXFx1MjEzNScsXHJcblx0ICAgIGxhcnI6ICdcXHUyMTkwJyxcclxuXHQgICAgdWFycjogJ1xcdTIxOTEnLFxyXG5cdCAgICByYXJyOiAnXFx1MjE5MicsXHJcblx0ICAgIGRhcnI6ICdcXHUyMTkzJyxcclxuXHQgICAgaGFycjogJ1xcdTIxOTQnLFxyXG5cdCAgICBjcmFycjogJ1xcdTIxQjUnLFxyXG5cdCAgICBsQXJyOiAnXFx1MjFEMCcsXHJcblx0ICAgIHVBcnI6ICdcXHUyMUQxJyxcclxuXHQgICAgckFycjogJ1xcdTIxRDInLFxyXG5cdCAgICBkQXJyOiAnXFx1MjFEMycsXHJcblx0ICAgIGhBcnI6ICdcXHUyMUQ0JyxcclxuXHQgICAgZm9yYWxsOiAnXFx1MjIwMCcsXHJcblx0ICAgIHBhcnQ6ICdcXHUyMjAyJyxcclxuXHQgICAgZXhpc3Q6ICdcXHUyMjAzJyxcclxuXHQgICAgZW1wdHk6ICdcXHUyMjA1JyxcclxuXHQgICAgbmFibGE6ICdcXHUyMjA3JyxcclxuXHQgICAgaXNpbjogJ1xcdTIyMDgnLFxyXG5cdCAgICBub3RpbjogJ1xcdTIyMDknLFxyXG5cdCAgICBuaTogJ1xcdTIyMEInLFxyXG5cdCAgICBwcm9kOiAnXFx1MjIwRicsXHJcblx0ICAgIHN1bTogJ1xcdTIyMTEnLFxyXG5cdCAgICBtaW51czogJ1xcdTIyMTInLFxyXG5cdCAgICBsb3dhc3Q6ICdcXHUyMjE3JyxcclxuXHQgICAgcmFkaWM6ICdcXHUyMjFBJyxcclxuXHQgICAgcHJvcDogJ1xcdTIyMUQnLFxyXG5cdCAgICBpbmZpbjogJ1xcdTIyMUUnLFxyXG5cdCAgICBhbmc6ICdcXHUyMjIwJyxcclxuXHQgICAgYW5kOiAnXFx1MjIyNycsXHJcblx0ICAgIG9yOiAnXFx1MjIyOCcsXHJcblx0ICAgIGNhcDogJ1xcdTIyMjknLFxyXG5cdCAgICBjdXA6ICdcXHUyMjJBJyxcclxuXHQgICAgaW50OiAnXFx1MjIyQicsXHJcblx0ICAgIHRoZXJlNDogJ1xcdTIyMzQnLFxyXG5cdCAgICBzaW06ICdcXHUyMjNDJyxcclxuXHQgICAgY29uZzogJ1xcdTIyNDUnLFxyXG5cdCAgICBhc3ltcDogJ1xcdTIyNDgnLFxyXG5cdCAgICBuZTogJ1xcdTIyNjAnLFxyXG5cdCAgICBlcXVpdjogJ1xcdTIyNjEnLFxyXG5cdCAgICBsZTogJ1xcdTIyNjQnLFxyXG5cdCAgICBnZTogJ1xcdTIyNjUnLFxyXG5cdCAgICBzdWI6ICdcXHUyMjgyJyxcclxuXHQgICAgc3VwOiAnXFx1MjI4MycsXHJcblx0ICAgIG5zdWI6ICdcXHUyMjg0JyxcclxuXHQgICAgc3ViZTogJ1xcdTIyODYnLFxyXG5cdCAgICBzdXBlOiAnXFx1MjI4NycsXHJcblx0ICAgIG9wbHVzOiAnXFx1MjI5NScsXHJcblx0ICAgIG90aW1lczogJ1xcdTIyOTcnLFxyXG5cdCAgICBwZXJwOiAnXFx1MjJBNScsXHJcblx0ICAgIHNkb3Q6ICdcXHUyMkM1JyxcclxuXHQgICAgbGNlaWw6ICdcXHUyMzA4JyxcclxuXHQgICAgcmNlaWw6ICdcXHUyMzA5JyxcclxuXHQgICAgbGZsb29yOiAnXFx1MjMwQScsXHJcblx0ICAgIHJmbG9vcjogJ1xcdTIzMEInLFxyXG5cdCAgICBsb3o6ICdcXHUyNUNBJyxcclxuXHQgICAgc3BhZGVzOiAnXFx1MjY2MCcsXHJcblx0ICAgIGNsdWJzOiAnXFx1MjY2MycsXHJcblx0ICAgIGhlYXJ0czogJ1xcdTI2NjUnLFxyXG5cdCAgICBkaWFtczogJ1xcdTI2NjYnLFxyXG5cdCAgICBsYW5nOiAnXFx1MjdFOCcsXHJcblx0ICAgIHJhbmc6ICdcXHUyN0U5J1xyXG5cdH07XHJcblxuXG4vKioqLyB9LFxuLyogMTUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHR2YXIgZXJyb3JfaGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcblx0dmFyIHNjYW5uZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xyXG5cdHZhciB0b2tlbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcblx0dmFyIFJlYWRlciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFJlYWRlcigpIHtcclxuXHQgICAgICAgIHRoaXMudmFsdWVzID0gW107XHJcblx0ICAgICAgICB0aGlzLmN1cmx5ID0gdGhpcy5wYXJlbiA9IC0xO1xyXG5cdCAgICB9XHJcblx0ICAgIC8vIEEgZnVuY3Rpb24gZm9sbG93aW5nIG9uZSBvZiB0aG9zZSB0b2tlbnMgaXMgYW4gZXhwcmVzc2lvbi5cclxuXHQgICAgUmVhZGVyLnByb3RvdHlwZS5iZWZvcmVGdW5jdGlvbkV4cHJlc3Npb24gPSBmdW5jdGlvbiAodCkge1xyXG5cdCAgICAgICAgcmV0dXJuIFsnKCcsICd7JywgJ1snLCAnaW4nLCAndHlwZW9mJywgJ2luc3RhbmNlb2YnLCAnbmV3JyxcclxuXHQgICAgICAgICAgICAncmV0dXJuJywgJ2Nhc2UnLCAnZGVsZXRlJywgJ3Rocm93JywgJ3ZvaWQnLFxyXG5cdCAgICAgICAgICAgIC8vIGFzc2lnbm1lbnQgb3BlcmF0b3JzXHJcblx0ICAgICAgICAgICAgJz0nLCAnKz0nLCAnLT0nLCAnKj0nLCAnKio9JywgJy89JywgJyU9JywgJzw8PScsICc+Pj0nLCAnPj4+PScsXHJcblx0ICAgICAgICAgICAgJyY9JywgJ3w9JywgJ149JywgJywnLFxyXG5cdCAgICAgICAgICAgIC8vIGJpbmFyeS91bmFyeSBvcGVyYXRvcnNcclxuXHQgICAgICAgICAgICAnKycsICctJywgJyonLCAnKionLCAnLycsICclJywgJysrJywgJy0tJywgJzw8JywgJz4+JywgJz4+PicsICcmJyxcclxuXHQgICAgICAgICAgICAnfCcsICdeJywgJyEnLCAnficsICcmJicsICd8fCcsICc/JywgJzonLCAnPT09JywgJz09JywgJz49JyxcclxuXHQgICAgICAgICAgICAnPD0nLCAnPCcsICc+JywgJyE9JywgJyE9PSddLmluZGV4T2YodCkgPj0gMDtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gRGV0ZXJtaW5lIGlmIGZvcndhcmQgc2xhc2ggKC8pIGlzIGFuIG9wZXJhdG9yIG9yIHBhcnQgb2YgYSByZWd1bGFyIGV4cHJlc3Npb25cclxuXHQgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc3dlZXQuanMvd2lraS9kZXNpZ25cclxuXHQgICAgUmVhZGVyLnByb3RvdHlwZS5pc1JlZ2V4U3RhcnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXMgPSB0aGlzLnZhbHVlc1t0aGlzLnZhbHVlcy5sZW5ndGggLSAxXTtcclxuXHQgICAgICAgIHZhciByZWdleCA9IChwcmV2aW91cyAhPT0gbnVsbCk7XHJcblx0ICAgICAgICBzd2l0Y2ggKHByZXZpb3VzKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSAndGhpcyc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnXSc6XHJcblx0ICAgICAgICAgICAgICAgIHJlZ2V4ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgJyknOlxyXG5cdCAgICAgICAgICAgICAgICB2YXIga2V5d29yZCA9IHRoaXMudmFsdWVzW3RoaXMucGFyZW4gLSAxXTtcclxuXHQgICAgICAgICAgICAgICAgcmVnZXggPSAoa2V5d29yZCA9PT0gJ2lmJyB8fCBrZXl3b3JkID09PSAnd2hpbGUnIHx8IGtleXdvcmQgPT09ICdmb3InIHx8IGtleXdvcmQgPT09ICd3aXRoJyk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgJ30nOlxyXG5cdCAgICAgICAgICAgICAgICAvLyBEaXZpZGluZyBhIGZ1bmN0aW9uIGJ5IGFueXRoaW5nIG1ha2VzIGxpdHRsZSBzZW5zZSxcclxuXHQgICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgdG8gY2hlY2sgZm9yIHRoYXQuXHJcblx0ICAgICAgICAgICAgICAgIHJlZ2V4ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlc1t0aGlzLmN1cmx5IC0gM10gPT09ICdmdW5jdGlvbicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEFub255bW91cyBmdW5jdGlvbiwgZS5nLiBmdW5jdGlvbigpe30gLzQyXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2hlY2sgPSB0aGlzLnZhbHVlc1t0aGlzLmN1cmx5IC0gNF07XHJcblx0ICAgICAgICAgICAgICAgICAgICByZWdleCA9IGNoZWNrID8gIXRoaXMuYmVmb3JlRnVuY3Rpb25FeHByZXNzaW9uKGNoZWNrKSA6IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudmFsdWVzW3RoaXMuY3VybHkgLSA0XSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gTmFtZWQgZnVuY3Rpb24sIGUuZy4gZnVuY3Rpb24gZigpe30gLzQyL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNoZWNrID0gdGhpcy52YWx1ZXNbdGhpcy5jdXJseSAtIDVdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmVnZXggPSBjaGVjayA/ICF0aGlzLmJlZm9yZUZ1bmN0aW9uRXhwcmVzc2lvbihjaGVjaykgOiB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHJlZ2V4O1xyXG5cdCAgICB9O1xyXG5cdCAgICBSZWFkZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8gfHwgdG9rZW4udHlwZSA9PT0gNCAvKiBLZXl3b3JkICovKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAneycpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jdXJseSA9IHRoaXMudmFsdWVzLmxlbmd0aDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4udmFsdWUgPT09ICcoJykge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnBhcmVuID0gdGhpcy52YWx1ZXMubGVuZ3RoO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLnZhbHVlcy5wdXNoKHRva2VuLnZhbHVlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRoaXMudmFsdWVzLnB1c2gobnVsbCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIHJldHVybiBSZWFkZXI7XHJcblx0fSgpKTtcclxuXHR2YXIgVG9rZW5pemVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVG9rZW5pemVyKGNvZGUsIGNvbmZpZykge1xyXG5cdCAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIgPSBuZXcgZXJyb3JfaGFuZGxlcl8xLkVycm9ySGFuZGxlcigpO1xyXG5cdCAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIudG9sZXJhbnQgPSBjb25maWcgPyAodHlwZW9mIGNvbmZpZy50b2xlcmFudCA9PT0gJ2Jvb2xlYW4nICYmIGNvbmZpZy50b2xlcmFudCkgOiBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lciA9IG5ldyBzY2FubmVyXzEuU2Nhbm5lcihjb2RlLCB0aGlzLmVycm9ySGFuZGxlcik7XHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIudHJhY2tDb21tZW50ID0gY29uZmlnID8gKHR5cGVvZiBjb25maWcuY29tbWVudCA9PT0gJ2Jvb2xlYW4nICYmIGNvbmZpZy5jb21tZW50KSA6IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy50cmFja1JhbmdlID0gY29uZmlnID8gKHR5cGVvZiBjb25maWcucmFuZ2UgPT09ICdib29sZWFuJyAmJiBjb25maWcucmFuZ2UpIDogZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLnRyYWNrTG9jID0gY29uZmlnID8gKHR5cGVvZiBjb25maWcubG9jID09PSAnYm9vbGVhbicgJiYgY29uZmlnLmxvYykgOiBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuYnVmZmVyID0gW107XHJcblx0ICAgICAgICB0aGlzLnJlYWRlciA9IG5ldyBSZWFkZXIoKTtcclxuXHQgICAgfVxyXG5cdCAgICBUb2tlbml6ZXIucHJvdG90eXBlLmVycm9ycyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmVycm9ySGFuZGxlci5lcnJvcnM7XHJcblx0ICAgIH07XHJcblx0ICAgIFRva2VuaXplci5wcm90b3R5cGUuZ2V0TmV4dFRva2VuID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xyXG5cdCAgICAgICAgICAgIHZhciBjb21tZW50cyA9IHRoaXMuc2Nhbm5lci5zY2FuQ29tbWVudHMoKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbW1lbnRzLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IGNvbW1lbnRzW2ldO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5zY2FubmVyLnNvdXJjZS5zbGljZShlLnNsaWNlWzBdLCBlLnNsaWNlWzFdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb21tZW50ID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGUubXVsdGlMaW5lID8gJ0Jsb2NrQ29tbWVudCcgOiAnTGluZUNvbW1lbnQnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrUmFuZ2UpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50LnJhbmdlID0gZS5yYW5nZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrTG9jKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudC5sb2MgPSBlLmxvYztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2goY29tbWVudCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLnNjYW5uZXIuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGxvYyA9IHZvaWQgMDtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tMb2MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxvYyA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHt9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHZhciBzdGFydFJlZ2V4ID0gKHRoaXMuc2Nhbm5lci5zb3VyY2VbdGhpcy5zY2FubmVyLmluZGV4XSA9PT0gJy8nKSAmJiB0aGlzLnJlYWRlci5pc1JlZ2V4U3RhcnQoKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHRva2VuID0gc3RhcnRSZWdleCA/IHRoaXMuc2Nhbm5lci5zY2FuUmVnRXhwKCkgOiB0aGlzLnNjYW5uZXIubGV4KCk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMucmVhZGVyLnB1c2godG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0eXBlOiB0b2tlbl8xLlRva2VuTmFtZVt0b2tlbi50eXBlXSxcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnNjYW5uZXIuc291cmNlLnNsaWNlKHRva2VuLnN0YXJ0LCB0b2tlbi5lbmQpXHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrUmFuZ2UpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGVudHJ5LnJhbmdlID0gW3Rva2VuLnN0YXJ0LCB0b2tlbi5lbmRdO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrTG9jKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsb2MuZW5kID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydFxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGVudHJ5LmxvYyA9IGxvYztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gOSAvKiBSZWd1bGFyRXhwcmVzc2lvbiAqLykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSB0b2tlbi5wYXR0ZXJuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGZsYWdzID0gdG9rZW4uZmxhZ3M7XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbnRyeS5yZWdleCA9IHsgcGF0dGVybjogcGF0dGVybiwgZmxhZ3M6IGZsYWdzIH07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaChlbnRyeSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLnNoaWZ0KCk7XHJcblx0ICAgIH07XHJcblx0ICAgIHJldHVybiBUb2tlbml6ZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlRva2VuaXplciA9IFRva2VuaXplcjtcclxuXG5cbi8qKiovIH1cbi8qKioqKiovIF0pXG59KTtcbjsiLCIndXNlIHN0cmljdCdcbnZhciByZWFkb25seVByb3hpZXMgPSBuZXcgV2Vha01hcFxudmFyIGN1cnJlbnRTYW5kYm94ID0gdW5kZWZpbmVkXG52YXIgR0xPQkFMID0gbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKClcbnZhciB1bnNjb3BhYmxlc1N5bWJvbCA9IFN5bWJvbC51bnNjb3BhYmxlc1xudmFyIEZ1bmN0aW9uQ29uc3RydWN0b3IgPSAwLi5jb25zdHJ1Y3Rvci5jb25zdHJ1Y3RvclxuXG5mdW5jdGlvbiBjb21waWxlRXhwcmVzc2lvbihzcmMpIHtcblx0aWYgKHR5cGVvZiBzcmMgIT09ICdzdHJpbmcnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYXJndW1lbnQgdG8gYmUgYSBzdHJpbmcuJylcblx0fVxuXHRcblx0bmV3IEZ1bmN0aW9uQ29uc3RydWN0b3IoJ1widXNlIHN0cmljdFwiOyByZXR1cm4gJyArIHNyYykgLy8gVGVzdHMgZm9yIHN5bnRheCBlcnJvcnMgd2l0aG91dCBydW5uaW5nIHRoZSBjb2RlXG5cdHZhciBjb2RlID0gbmV3IEZ1bmN0aW9uQ29uc3RydWN0b3IoJ3NhbmRib3gnLCAnd2l0aCAoc2FuZGJveCkge3JldHVybiAoZnVuY3Rpb24gKCkge1widXNlIHN0cmljdFwiOyByZXR1cm4gJyArIHNyYyArICd9KS5jYWxsKHRoaXMpfScpXG5cdFxuXHRyZXR1cm4gZnVuY3Rpb24gKHNhbmRib3gpIHtcblx0XHRpZiAoIWlzT2JqZWN0KHNhbmRib3gpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3Qgb3IgZnVuY3Rpb24uJylcblx0XHR9XG5cdFx0aWYgKGN1cnJlbnRTYW5kYm94KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgcnVuIHNhbmRib3hlZCBjb2RlIGluc2lkZSBhbiBhbHJlYWR5LXJ1bm5pbmcgc2FuZGJveC4nKVxuXHRcdH1cblx0XHR2YXIgc2FuZGJveFByb3h5ID0gZ2V0UHJveHkoc2FuZGJveClcblx0XHR2YXIgcmVzdWx0LCBlcnJvclxuXHRcdFxuXHRcdGN1cnJlbnRTYW5kYm94ID0gc2FuZGJveFxuXHRcdHRyeSB7XG5cdFx0XHRyZXN1bHQgPSBjb2RlLmNhbGwoc2FuZGJveFByb3h5LCBzYW5kYm94UHJveHkpXG5cdFx0XHRjdXJyZW50U2FuZGJveCA9IHVuZGVmaW5lZFxuXHRcdH0gY2F0Y2ggKGV4KSB7XG5cdFx0XHRjdXJyZW50U2FuZGJveCA9IHVuZGVmaW5lZFxuXHRcdFx0aWYgKGV4IGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdFx0ZXJyb3IgPSBuZXcgZXguY29uc3RydWN0b3IoJycgKyBleC5tZXNzYWdlKVxuXHRcdFx0XHRlcnJvci5zdGFjayA9ICcnICsgZXguc3RhY2tcblx0XHRcdFx0dGhyb3cgZXJyb3Jcblx0XHRcdH1cblx0XHRcdHRocm93IG5ldyBFcnJvcihTdHJpbmcoZXgpKVxuXHRcdH1cblx0XHRpZiAoaXNPYmplY3QocmVzdWx0KSkge1xuXHRcdFx0dGhyb3cgVHlwZUVycm9yKCdTYW5kYm94ZXMgYXJlIG9ubHkgYWxsb3dlZCB0byByZXR1cm4gcHJpbWl0aXZlIHZhbHVlcy4nKVxuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0XG5cdH1cbn1cbm1vZHVsZS5leHBvcnRzID0gY29tcGlsZUV4cHJlc3Npb25cblxudmFyIHRyYXBzID0ge1xuXHRnZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpIHtcblx0XHRpZiAoY3VycmVudFNhbmRib3gpIHtcblx0XHRcdGlmIChrZXkgPT09IHVuc2NvcGFibGVzU3ltYm9sICYmIHRhcmdldCA9PT0gY3VycmVudFNhbmRib3gpIHtcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZFxuXHRcdFx0fVxuXHRcdFx0aWYgKCFub3RQcml2YXRlKGtleSkpIHtcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZFxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGdldFByb3h5T3JQcmltaXRpdmUoUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSlcblx0XHR9XG5cdFx0cmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcilcblx0fSxcblx0c2V0OiBmdW5jdGlvbiAodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikge1xuXHRcdGlmIChjdXJyZW50U2FuZGJveCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignWW91IGNhbm5vdCBzZXQgcHJvcGVydGllcyBvbiBhIHNhbmRib3hlZCBvYmplY3QuJylcblx0XHR9XG5cdFx0cmV0dXJuIFJlZmxlY3Quc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpXG5cdH0sXG5cdGhhczogZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG5cdFx0aWYgKGN1cnJlbnRTYW5kYm94KSB7XG5cdFx0XHRpZiAodGFyZ2V0ID09PSBjdXJyZW50U2FuZGJveCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0fVxuXHRcdFx0aWYgKCFub3RQcml2YXRlKGtleSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZ2V0UHJveHlPclByaW1pdGl2ZShSZWZsZWN0Lmhhcyh0YXJnZXQsIGtleSkpXG5cdFx0fVxuXHRcdHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIGtleSlcblx0fSxcblx0Z2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0XHRpZiAoY3VycmVudFNhbmRib3gpIHtcblx0XHRcdHJldHVybiBnZXRQcm94eU9yUHJpbWl0aXZlKFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSlcblx0XHR9XG5cdFx0cmV0dXJuIFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KVxuXHR9LFxuXHRzZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gKHRhcmdldCwgcHJvdG8pIHtcblx0XHRpZiAoY3VycmVudFNhbmRib3gpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBjYW5ub3Qgc2V0IHRoZSBwcm90b3R5cGUgb2YgYSBzYW5kYm94ZWQgb2JqZWN0LicpXG5cdFx0fVxuXHRcdHJldHVybiBSZWZsZWN0LnNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG8pXG5cdH0sXG5cdGlzRXh0ZW5zaWJsZTogZnVuY3Rpb24gKHRhcmdldCkge1xuXHRcdGlmIChjdXJyZW50U2FuZGJveCkge1xuXHRcdFx0cmV0dXJuIGdldFByb3h5T3JQcmltaXRpdmUoUmVmbGVjdC5pc0V4dGVuc2libGUodGFyZ2V0KSlcblx0XHR9XG5cdFx0cmV0dXJuIFJlZmxlY3QuaXNFeHRlbnNpYmxlKHRhcmdldClcblx0fSxcblx0cHJldmVudEV4dGVuc2lvbnM6IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0XHRpZiAoY3VycmVudFNhbmRib3gpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBjYW5ub3QgY2hhbmdlIHRoZSBleHRlbnNpYmlsaXR5IG9mIGEgc2FuZGJveGVkIG9iamVjdC4nKVxuXHRcdH1cblx0XHRyZXR1cm4gUmVmbGVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpXG5cdH0sXG5cdGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG5cdFx0aWYgKGN1cnJlbnRTYW5kYm94KSB7XG5cdFx0XHRpZiAoa2V5ID09PSBTeW1ib2wudW5zY29wYWJsZXMgJiYgdGFyZ2V0ID09PSBjdXJyZW50U2FuZGJveCkge1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkXG5cdFx0XHR9XG5cdFx0XHRpZiAoIW5vdFByaXZhdGUoa2V5KSkge1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZ2V0UHJveHlPclByaW1pdGl2ZShSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkpXG5cdFx0fVxuXHRcdHJldHVybiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSlcblx0fSxcblx0ZGVmaW5lUHJvcGVydHk6IGZ1bmN0aW9uICh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuXHRcdGlmIChjdXJyZW50U2FuZGJveCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignWW91IGNhbm5vdCBkZWZpbmUgcHJvcGVydGllcyBvbiBhIHNhbmRib3hlZCBvYmplY3QuJylcblx0XHR9XG5cdFx0cmV0dXJuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpXG5cdH0sXG5cdGRlbGV0ZVByb3BlcnR5OiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcblx0XHRpZiAoY3VycmVudFNhbmRib3gpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBjYW5ub3QgZGVsZXRlIHByb3BlcnRpZXMgb24gYSBzYW5kYm94ZWQgb2JqZWN0LicpXG5cdFx0fVxuXHRcdHJldHVybiBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KVxuXHR9LFxuXHRvd25LZXlzOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdFx0aWYgKGN1cnJlbnRTYW5kYm94KSB7XG5cdFx0XHRyZXR1cm4gZ2V0UHJveHlPclByaW1pdGl2ZShSZWZsZWN0Lm93bktleXModGFyZ2V0KS5maWx0ZXIobm90UHJpdmF0ZSkpXG5cdFx0fVxuXHRcdHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KVxuXHR9LFxuXHRhcHBseTogZnVuY3Rpb24gKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkge1xuXHRcdGlmIChjdXJyZW50U2FuZGJveCkge1xuXHRcdFx0aWYgKHRhcmdldCA9PT0gRnVuY3Rpb25Db25zdHJ1Y3RvciB8fCB0YXJnZXQgPT09IEZ1bmN0aW9uQ29uc3RydWN0b3JQcm94eSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgY2Fubm90IHVzZSB0aGUgRnVuY3Rpb24gY29uc3RydWN0b3IgaW4gYSBzYW5kYm94ZWQgY29udGV4dC4nKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGdldFByb3h5T3JQcmltaXRpdmUoUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpKVxuXHRcdH1cblx0XHRyZXR1cm4gUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpXG5cdH0sXG5cdGNvbnN0cnVjdDogZnVuY3Rpb24gKHRhcmdldCwgYXJndW1lbnRzTGlzdCwgbmV3VGFyZ2V0KSB7XG5cdFx0aWYgKGN1cnJlbnRTYW5kYm94KSB7XG5cdFx0XHRpZiAodGFyZ2V0ID09PSBGdW5jdGlvbkNvbnN0cnVjdG9yIHx8IHRhcmdldCA9PT0gRnVuY3Rpb25Db25zdHJ1Y3RvclByb3h5KSB7XG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBjYW5ub3QgdXNlIHRoZSBGdW5jdGlvbiBjb25zdHJ1Y3RvciBpbiBhIHNhbmRib3hlZCBjb250ZXh0LicpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZ2V0UHJveHlPclByaW1pdGl2ZShSZWZsZWN0LmNvbnN0cnVjdCh0YXJnZXQsIGFyZ3VtZW50c0xpc3QsIG5ld1RhcmdldCkpXG5cdFx0fVxuXHRcdHJldHVybiBSZWZsZWN0LmNvbnN0cnVjdCh0YXJnZXQsIGFyZ3VtZW50c0xpc3QsIG5ld1RhcmdldClcblx0fVxufVxuXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuXHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nIHx8ICh2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKVxufVxuXG5mdW5jdGlvbiBnZXRQcm94eU9yUHJpbWl0aXZlKHZhbHVlKSB7XG5cdGlmIChpc09iamVjdCh2YWx1ZSkpIHtcblx0XHRyZXR1cm4gc2FmZU9iamVjdHMuaW5kZXhPZih2YWx1ZSkgPj0gMCA/IHZhbHVlIDogZ2V0UHJveHkodmFsdWUpXG5cdH1cblx0cmV0dXJuIHZhbHVlXG59XG5cbmZ1bmN0aW9uIGdldFByb3h5KG9iamVjdCwgaGlkZU9yaWdpbmFsKSB7XG5cdGlmIChvYmplY3QgPT09IEdMT0JBTCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBnbG9iYWwgb2JqZWN0IGlzIGZvcmJpZGRlbiBmcm9tIGVudGVyaW5nIGEgc2FuZGJveGVkIGNvbnRleHQuJylcblx0fVxuXHRpZiAob2JqZWN0ID09PSBldmFsRnVuY3Rpb24pIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgZXZhbCBmdW5jdGlvbiBpcyBmb3JiaWRkZW4gZnJvbSBlbnRlcmluZyBhIHNhbmRib3hlZCBjb250ZXh0LicpXG5cdH1cblx0dmFyIHByb3h5ID0gcmVhZG9ubHlQcm94aWVzLmdldChvYmplY3QpXG5cdGlmICh0eXBlb2YgcHJveHkgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0cHJveHkgPSBuZXcgUHJveHkob2JqZWN0LCB0cmFwcylcblx0XHRyZWFkb25seVByb3hpZXMuc2V0KGhpZGVPcmlnaW5hbCA/IHByb3h5IDogb2JqZWN0LCBwcm94eSlcblx0fVxuXHRyZXR1cm4gcHJveHlcbn1cblxuZnVuY3Rpb24gbm90UHJpdmF0ZShrZXkpIHtcblx0cmV0dXJuIHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8IGtleVswXSAhPT0gJ18nXG59XG5cbi8vIEZyZWV6ZSBhbmQgcHJveHkgYW55dGhpbmcgdGhhdCBpcyBhY2Nlc3NpYmxlIHRocm91Z2ggSmF2YVNjcmlwdCBzeW50YXggYWxvbmVcbi8vIFRoaXMgc2hvdWxkIGluY2x1ZGUgYW55IHZhbHVlIHRoYXQgeW91IGNhbiBnZXQgZnJvbSBKYXZhU2NyaXB0IHN5bnRheCBpdHNlbGYuXG4vLyBGb3IgZXhhbXBsZTpcbi8vICAgICBcIm15IHN0cmluZ1wiLmZvb2JhclxuLy8gICAgIHRyeSB7dGhyb3cgMX0gY2F0Y2ggKGVycikge2Vyci5mb29iYXJ9XG4vLyBTeW1ib2xzIGFyZSBpbmNsdWRlZCBoZXJlIGJlY2F1c2UgdGhleSBhcmUgbm90IHByb3RlY3RlZCBieSBvdXIgcHJveHlpbmdcbi8vIGJlY2F1c2UgdGhleSBhcmUgcHJpbWl0aXZlcy5cbnZhciBzYWZlT2JqZWN0cyA9IHJlcXVpcmUoJy4vbGliL21ha2Utc2FmZScpKFtcblx0Qm9vbGVhbi5wcm90b3R5cGUsXG5cdE51bWJlci5wcm90b3R5cGUsXG5cdFN0cmluZy5wcm90b3R5cGUsXG5cdFN5bWJvbC5wcm90b3R5cGUsXG5cdEZ1bmN0aW9uLnByb3RvdHlwZSxcblx0T2JqZWN0LnByb3RvdHlwZSxcblx0QXJyYXkucHJvdG90eXBlLFxuXHRSZWdFeHAucHJvdG90eXBlLFxuXHRFcnJvci5wcm90b3R5cGUsXG5cdEV2YWxFcnJvci5wcm90b3R5cGUsXG5cdFJhbmdlRXJyb3IucHJvdG90eXBlLFxuXHRSZWZlcmVuY2VFcnJvci5wcm90b3R5cGUsXG5cdFN5bnRheEVycm9yLnByb3RvdHlwZSxcblx0VHlwZUVycm9yLnByb3RvdHlwZSxcblx0VVJJRXJyb3IucHJvdG90eXBlLFxuXHRQcm9taXNlLnByb3RvdHlwZSxcblx0T2JqZWN0LmdldFByb3RvdHlwZU9mKGZ1bmN0aW9uKigpe30pLFxuXHRPYmplY3QuZ2V0UHJvdG90eXBlT2YoZnVuY3Rpb24qKCl7fSgpKVxuXSwgaXNPYmplY3QsIGdldFByb3h5LCBHTE9CQUwpXG5cbnZhciBldmFsRnVuY3Rpb24gPSBHTE9CQUwuZXZhbFxudmFyIEZ1bmN0aW9uQ29uc3RydWN0b3JQcm94eSA9IDAuLmNvbnN0cnVjdG9yLmNvbnN0cnVjdG9yXG5cbm1vZHVsZS5leHBvcnRzLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG5cdHJldHVybiBhID09PSBiIHx8IChyZWFkb25seVByb3hpZXMuZ2V0KGEpIHx8IGEpID09PSAocmVhZG9ubHlQcm94aWVzLmdldChiKSB8fCBiKVxufVxuXG5cbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1bnNhZmVPYmplY3RzLCBpc09iamVjdCwgZ2V0UHJveHksIEdMT0JBTCkge1xuXHR2YXIgcHJveGllcyA9IFtdXG5cdHZhciBzYWZlT2JqZWN0cyA9IFtdXG5cdHZhciByZXR1cm5zU2FmZVZhbHVlcyA9IFtcblx0XHRGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXVxuXHRdXG5cdHZhciBnbG9iYWxLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoR0xPQkFMKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09ICdyb290JyAmJiBrZXkgIT09ICdHTE9CQUwnICYmIGtleSAhPT0gJ2dsb2JhbCcgJiYga2V5ICE9PSAnd2luZG93JyAmJiBrZXkgIT09ICdzZWxmJ30pXG5cdHZhciBnbG9iYWxWYWx1ZXMgPSBnbG9iYWxLZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIHRoaXNba2V5XX0sIEdMT0JBTClcblx0XG5cdHdoaWxlICh1bnNhZmVPYmplY3RzLmxlbmd0aCkge1xuXHRcdG1ha2VTYWZlKHVuc2FmZU9iamVjdHMuc2hpZnQoKSlcblx0fVxuXHRcblx0ZnVuY3Rpb24gbWFrZVNhZmUob2JqZWN0KSB7XG5cdFx0aWYgKGlzU2FmZShvYmplY3QpKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0XG5cdFx0dmFyIHJlYWNoYWJsZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdClcblx0XHRcdC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpKVxuXHRcdFxuXHRcdGlmIChvYmplY3QgPT09IEZ1bmN0aW9uLnByb3RvdHlwZSkge1xuXHRcdFx0cmVhY2hhYmxlID0gcmVhY2hhYmxlLmZpbHRlcihpZ25vcmVkS2V5cylcblx0XHR9XG5cdFx0XG5cdFx0cmVhY2hhYmxlLmZvckVhY2gocmVwbGFjZVdpdGhQcm94eSwgb2JqZWN0KVxuXHRcdE9iamVjdC5mcmVlemUob2JqZWN0KVxuXHRcdHNhZmVPYmplY3RzLnB1c2gob2JqZWN0KVxuXHRcdFxuXHRcdHVuc2FmZU9iamVjdHMucHVzaChPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KSlcblx0fVxuXHRcblx0ZnVuY3Rpb24gaWdub3JlZEtleXMoa2V5KSB7XG5cdFx0cmV0dXJuIGtleSAhPT0gJ2NhbGxlcicgJiYga2V5ICE9PSAnYXJndW1lbnRzJ1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBpc1NhZmUodmFsdWUpIHtcblx0XHRyZXR1cm4gIWlzT2JqZWN0KHZhbHVlKSB8fCBwcm94aWVzLmluZGV4T2YodmFsdWUpID49IDAgfHwgc2FmZU9iamVjdHMuaW5kZXhPZih2YWx1ZSkgPj0gMFxuXHR9XG5cdFxuXHRmdW5jdGlvbiByZXBsYWNlV2l0aFByb3h5KGtleSkge1xuXHRcdHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLCBrZXkpXG5cdFx0aWYgKCEoJ3ZhbHVlJyBpbiBkKSkge1xuXHRcdFx0aWYgKGtleSA9PT0gJ19fcHJvdG9fXycgJiYgaXNTYWZlKHRoaXNba2V5XSkpIHtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRpZiAoIWQuY29uZmlndXJhYmxlKSB7XG5cdFx0XHRcdGQuZ2V0ICYmIHVuc2FmZU9iamVjdHMucHVzaChkLmdldClcblx0XHRcdFx0ZC5zZXQgJiYgdW5zYWZlT2JqZWN0cy5wdXNoKGQuc2V0KVxuXHRcdFx0XHQvLyBUaGlzIGdldHRlci9zZXR0ZXIgY291bGQgcG90ZW50aWFsbHkgcmV0dXJuIGEgbm9uLXByb3hpZWQgb2JqZWN0XG5cdFx0XHRcdGNvbnNvbGUud2FybignUG90ZW50aWFsbHkgdnVsbmVyYWJsZSBnZXR0ZXIvc2V0dGVyIGF0ICVzIGluICVzJywga2V5LCB0aGlzKVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdHZhciBnZXR0ZXIgPSBkLmdldCAmJiBnZXRQcm94eShkLmdldCwgdHJ1ZSlcblx0XHRcdHZhciBzZXR0ZXIgPSBkLnNldCAmJiBnZXRQcm94eShkLnNldCwgdHJ1ZSlcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcblx0XHRcdFx0Z2V0OiBnZXR0ZXIsXG5cdFx0XHRcdHNldDogc2V0dGVyLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiBkLmVudW1lcmFibGUsXG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2Vcblx0XHRcdH0pXG5cdFx0XHRnZXR0ZXIgJiYgcHJveGllcy5wdXNoKGdldHRlcilcblx0XHRcdHNldHRlciAmJiBwcm94aWVzLnB1c2goc2V0dGVyKVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdFxuXHRcdHZhciB2YWx1ZSA9IHRoaXNba2V5XVxuXHRcdGlmIChpc1NhZmUodmFsdWUpKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0XG5cdFx0aWYgKGQud3JpdGFibGUpIHtcblx0XHRcdHZhciBwcm94eSA9IGdldFByb3h5KHZhbHVlLCB0cnVlKVxuXHRcdFx0cHJveGllcy5wdXNoKHRoaXNba2V5XSA9IHByb3h5KVxuXHRcdFx0cmVwbGFjZUluR2xvYmFsKHZhbHVlLCBwcm94eSlcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRcblx0XHRpZiAoZC5jb25maWd1cmFibGUpIHtcblx0XHRcdHZhciBwcm94eSA9IGdldFByb3h5KHZhbHVlLCB0cnVlKVxuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuXHRcdFx0XHR2YWx1ZTogcHJveHksXG5cdFx0XHRcdHdyaXRhYmxlOiBmYWxzZSxcblx0XHRcdFx0ZW51bWVyYWJsZTogZC5lbnVtZXJhYmxlLFxuXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlXG5cdFx0XHR9KVxuXHRcdFx0cmVwbGFjZUluR2xvYmFsKHZhbHVlLCBwcm94eSlcblx0XHRcdHByb3hpZXMucHVzaChwcm94eSlcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRcblx0XHR1bnNhZmVPYmplY3RzLnB1c2godmFsdWUpXG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiByZXR1cm5zU2FmZVZhbHVlcy5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcblx0XHRcdC8vIFRoaXMgZnVuY3Rpb24gY291bGQgcG90ZW50aWFsbHkgcmV0dXJuIGEgbm9uLXByb3hpZWQgb2JqZWN0XG5cdFx0XHRjb25zb2xlLndhcm4oJ1BvdGVudGlhbGx5IHZ1bG5lcmFibGUgZnVuY3Rpb24gYXQgJXMgaW4gJXMnLCBrZXksIHRoaXMpXG5cdFx0fVxuXHR9XG5cdFxuXHRmdW5jdGlvbiByZXBsYWNlSW5HbG9iYWwodmFsdWUsIHByb3h5KSB7XG5cdFx0dmFyIGluZGV4ID0gZ2xvYmFsVmFsdWVzLmluZGV4T2YodmFsdWUpXG5cdFx0aWYgKGluZGV4ID49IDApIHtcblx0XHRcdHZhciBrZXkgPSBnbG9iYWxLZXlzW2luZGV4XVxuXHRcdFx0dmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEdMT0JBTCwga2V5KVxuXHRcdFx0aWYgKGQud3JpdGFibGUpIHtcblx0XHRcdFx0R0xPQkFMW2tleV0gPSBwcm94eVxuXHRcdFx0fSBlbHNlIGlmIChkLmNvbmZpZ3VyYWJsZSkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoR0xPQkFMLCBrZXksIHtcblx0XHRcdFx0XHR2YWx1ZTogcHJveHksXG5cdFx0XHRcdFx0d3JpdGFibGU6IGZhbHNlLFxuXHRcdFx0XHRcdGVudW1lcmFibGU6IGQuZW51bWVyYWJsZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlXG5cdFx0XHRcdH0pXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1dhcyBub3QgYWJsZSB0byByZXBsYWNlICVzIGluIGdsb2JhbCBvYmplY3QnLCBrZXkpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRyZXR1cm4gc2FmZU9iamVjdHNcbn1cbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhbnNpUmVnZXggPSByZXF1aXJlKCdhbnNpLXJlZ2V4Jyk7XG52YXIgcmUgPSBuZXcgUmVnRXhwKGFuc2lSZWdleCgpLnNvdXJjZSk7IC8vIHJlbW92ZSB0aGUgYGdgIGZsYWdcbm1vZHVsZS5leHBvcnRzID0gcmUudGVzdC5iaW5kKHJlKTtcbiIsIi8qKlxuICogwqkgQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDE3IEFsbCBSaWdodHMgUmVzZXJ2ZWRcbiAqICAgUHJvamVjdCBuYW1lOiBKU09OYXRhXG4gKiAgIFRoaXMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UsIHNlZSBMSUNFTlNFXG4gKi9cblxuLyoqXG4gKiBAbW9kdWxlIEpTT05hdGFcbiAqIEBkZXNjcmlwdGlvbiBKU09OIHF1ZXJ5IGFuZCB0cmFuc2Zvcm1hdGlvbiBsYW5ndWFnZVxuICovXG5cbi8qKlxuICoganNvbmF0YVxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICogQHJldHVybnMge3tldmFsdWF0ZTogZXZhbHVhdGUsIGFzc2lnbjogYXNzaWdufX0gRXZhbHVhdGVkIGV4cHJlc3Npb25cbiAqL1xudmFyIGpzb25hdGEgPSAoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG9wZXJhdG9ycyA9IHtcbiAgICAgICAgJy4nOiA3NSxcbiAgICAgICAgJ1snOiA4MCxcbiAgICAgICAgJ10nOiAwLFxuICAgICAgICAneyc6IDcwLFxuICAgICAgICAnfSc6IDAsXG4gICAgICAgICcoJzogODAsXG4gICAgICAgICcpJzogMCxcbiAgICAgICAgJywnOiAwLFxuICAgICAgICAnQCc6IDc1LFxuICAgICAgICAnIyc6IDcwLFxuICAgICAgICAnOyc6IDgwLFxuICAgICAgICAnOic6IDgwLFxuICAgICAgICAnPyc6IDIwLFxuICAgICAgICAnKyc6IDUwLFxuICAgICAgICAnLSc6IDUwLFxuICAgICAgICAnKic6IDYwLFxuICAgICAgICAnLyc6IDYwLFxuICAgICAgICAnJSc6IDYwLFxuICAgICAgICAnfCc6IDIwLFxuICAgICAgICAnPSc6IDQwLFxuICAgICAgICAnPCc6IDQwLFxuICAgICAgICAnPic6IDQwLFxuICAgICAgICAnXic6IDQwLFxuICAgICAgICAnKionOiA2MCxcbiAgICAgICAgJy4uJzogMjAsXG4gICAgICAgICc6PSc6IDEwLFxuICAgICAgICAnIT0nOiA0MCxcbiAgICAgICAgJzw9JzogNDAsXG4gICAgICAgICc+PSc6IDQwLFxuICAgICAgICAnfj4nOiA0MCxcbiAgICAgICAgJ2FuZCc6IDMwLFxuICAgICAgICAnb3InOiAyNSxcbiAgICAgICAgJ2luJzogNDAsXG4gICAgICAgICcmJzogNTAsXG4gICAgICAgICchJzogMCwgICAvLyBub3QgYW4gb3BlcmF0b3IsIGJ1dCBuZWVkZWQgYXMgYSBzdG9wIGNoYXJhY3RlciBmb3IgbmFtZSB0b2tlbnNcbiAgICAgICAgJ34nOiAwICAgLy8gbm90IGFuIG9wZXJhdG9yLCBidXQgbmVlZGVkIGFzIGEgc3RvcCBjaGFyYWN0ZXIgZm9yIG5hbWUgdG9rZW5zXG4gICAgfTtcblxuICAgIHZhciBlc2NhcGVzID0geyAgLy8gSlNPTiBzdHJpbmcgZXNjYXBlIHNlcXVlbmNlcyAtIHNlZSBqc29uLm9yZ1xuICAgICAgICAnXCInOiAnXCInLFxuICAgICAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICAgICAgJy8nOiAnLycsXG4gICAgICAgICdiJzogJ1xcYicsXG4gICAgICAgICdmJzogJ1xcZicsXG4gICAgICAgICduJzogJ1xcbicsXG4gICAgICAgICdyJzogJ1xccicsXG4gICAgICAgICd0JzogJ1xcdCdcbiAgICB9O1xuXG4gICAgLy8gVG9rZW5pemVyIChsZXhlcikgLSBpbnZva2VkIGJ5IHRoZSBwYXJzZXIgdG8gcmV0dXJuIG9uZSB0b2tlbiBhdCBhIHRpbWVcbiAgICB2YXIgdG9rZW5pemVyID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gMDtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gICAgICAgIHZhciBjcmVhdGUgPSBmdW5jdGlvbiAodHlwZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSB7dHlwZTogdHlwZSwgdmFsdWU6IHZhbHVlLCBwb3NpdGlvbjogcG9zaXRpb259O1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc2NhblJlZ2V4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyB0aGUgcHJlZml4ICcvJyB3aWxsIGhhdmUgYmVlbiBwcmV2aW91c2x5IHNjYW5uZWQuIEZpbmQgdGhlIGVuZCBvZiB0aGUgcmVnZXguXG4gICAgICAgICAgICAvLyBzZWFyY2ggZm9yIGNsb3NpbmcgJy8nIGlnbm9yaW5nIGFueSB0aGF0IGFyZSBlc2NhcGVkLCBvciB3aXRoaW4gYnJhY2tldHNcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIGRlcHRoID0gMDtcbiAgICAgICAgICAgIHZhciBwYXR0ZXJuO1xuICAgICAgICAgICAgdmFyIGZsYWdzO1xuICAgICAgICAgICAgd2hpbGUocG9zaXRpb24gPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudENoYXIgPSBwYXRoLmNoYXJBdChwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgaWYoY3VycmVudENoYXIgPT09ICcvJyAmJiBwYXRoLmNoYXJBdChwb3NpdGlvbiAtIDEpICE9PSAnXFxcXCcgJiYgZGVwdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5kIG9mIHJlZ2V4IGZvdW5kXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSBwYXRoLnN1YnN0cmluZyhzdGFydCwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBpZihwYXR0ZXJuID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiUzAzMDFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENoYXIgPSBwYXRoLmNoYXJBdChwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZsYWdzXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKGN1cnJlbnRDaGFyID09PSAnaScgfHwgY3VycmVudENoYXIgPT09ICdtJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaGFyID0gcGF0aC5jaGFyQXQocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZsYWdzID0gcGF0aC5zdWJzdHJpbmcoc3RhcnQsIHBvc2l0aW9uKSArICdnJztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZigoY3VycmVudENoYXIgPT09ICcoJyB8fCBjdXJyZW50Q2hhciA9PT0gJ1snIHx8IGN1cnJlbnRDaGFyID09PSAneycpICYmIHBhdGguY2hhckF0KHBvc2l0aW9uIC0gMSkgIT09ICdcXFxcJyApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoKGN1cnJlbnRDaGFyID09PSAnKScgfHwgY3VycmVudENoYXIgPT09ICddJyB8fCBjdXJyZW50Q2hhciA9PT0gJ30nKSAmJiBwYXRoLmNoYXJBdChwb3NpdGlvbiAtIDEpICE9PSAnXFxcXCcgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIlMwMzAyXCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBuZXh0ID0gZnVuY3Rpb24gKHByZWZpeCkge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uID49IGxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgY3VycmVudENoYXIgPSBwYXRoLmNoYXJBdChwb3NpdGlvbik7XG4gICAgICAgICAgICAvLyBza2lwIHdoaXRlc3BhY2VcbiAgICAgICAgICAgIHdoaWxlIChwb3NpdGlvbiA8IGxlbmd0aCAmJiAnIFxcdFxcblxcclxcdicuaW5kZXhPZihjdXJyZW50Q2hhcikgPiAtMSkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgY3VycmVudENoYXIgPSBwYXRoLmNoYXJBdChwb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IGZvciByZWdleFxuICAgICAgICAgICAgaWYgKHByZWZpeCAhPT0gdHJ1ZSAmJiBjdXJyZW50Q2hhciA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCdyZWdleCcsIHNjYW5SZWdleCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhhbmRsZSBkb3VibGUtY2hhciBvcGVyYXRvcnNcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhciA9PT0gJy4nICYmIHBhdGguY2hhckF0KHBvc2l0aW9uICsgMSkgPT09ICcuJykge1xuICAgICAgICAgICAgICAgIC8vIGRvdWJsZS1kb3QgLi4gcmFuZ2Ugb3BlcmF0b3JcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUoJ29wZXJhdG9yJywgJy4uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudENoYXIgPT09ICc6JyAmJiBwYXRoLmNoYXJBdChwb3NpdGlvbiArIDEpID09PSAnPScpIHtcbiAgICAgICAgICAgICAgICAvLyA6PSBhc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCdvcGVyYXRvcicsICc6PScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnIScgJiYgcGF0aC5jaGFyQXQocG9zaXRpb24gKyAxKSA9PT0gJz0nKSB7XG4gICAgICAgICAgICAgICAgLy8gIT1cbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUoJ29wZXJhdG9yJywgJyE9Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudENoYXIgPT09ICc+JyAmJiBwYXRoLmNoYXJBdChwb3NpdGlvbiArIDEpID09PSAnPScpIHtcbiAgICAgICAgICAgICAgICAvLyA+PVxuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZSgnb3BlcmF0b3InLCAnPj0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhciA9PT0gJzwnICYmIHBhdGguY2hhckF0KHBvc2l0aW9uICsgMSkgPT09ICc9Jykge1xuICAgICAgICAgICAgICAgIC8vIDw9XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCdvcGVyYXRvcicsICc8PScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnKicgJiYgcGF0aC5jaGFyQXQocG9zaXRpb24gKyAxKSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgLy8gKiogIGRlc2NlbmRhbnQgd2lsZGNhcmRcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUoJ29wZXJhdG9yJywgJyoqJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudENoYXIgPT09ICd+JyAmJiBwYXRoLmNoYXJBdChwb3NpdGlvbiArIDEpID09PSAnPicpIHtcbiAgICAgICAgICAgICAgICAvLyB+PiAgY2hhaW4gZnVuY3Rpb25cbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUoJ29wZXJhdG9yJywgJ34+Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IGZvciBzaW5nbGUgY2hhciBvcGVyYXRvcnNcbiAgICAgICAgICAgIGlmIChvcGVyYXRvcnMuaGFzT3duUHJvcGVydHkoY3VycmVudENoYXIpKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCdvcGVyYXRvcicsIGN1cnJlbnRDaGFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgZm9yIHN0cmluZyBsaXRlcmFsc1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnXCInIHx8IGN1cnJlbnRDaGFyID09PSBcIidcIikge1xuICAgICAgICAgICAgICAgIHZhciBxdW90ZVR5cGUgPSBjdXJyZW50Q2hhcjtcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUgcXVvdGVkIHN0cmluZyBsaXRlcmFsIC0gZmluZCBlbmQgb2Ygc3RyaW5nXG4gICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICB2YXIgcXN0ciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaGFyID0gcGF0aC5jaGFyQXQocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudENoYXIgPT09ICdcXFxcJykgeyAvLyBlc2NhcGUgc2VxdWVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2hhciA9IHBhdGguY2hhckF0KHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlc2NhcGVzLmhhc093blByb3BlcnR5KGN1cnJlbnRDaGFyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFzdHIgKz0gZXNjYXBlc1tjdXJyZW50Q2hhcl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRDaGFyID09PSAndScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcXHUgc2hvdWxkIGJlIGZvbGxvd2VkIGJ5IDQgaGV4IGRpZ2l0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvY3RldHMgPSBwYXRoLnN1YnN0cihwb3NpdGlvbiArIDEsIDQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXlswLTlhLWZBLUZdKyQvLnRlc3Qob2N0ZXRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29kZXBvaW50ID0gcGFyc2VJbnQob2N0ZXRzLCAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlcG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiUzAxMDRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbGxlZ2FsIGVzY2FwZSBzZXF1ZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJTMDEwM1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogY3VycmVudENoYXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudENoYXIgPT09IHF1b3RlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUoJ3N0cmluZycsIHFzdHIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXN0ciArPSBjdXJyZW50Q2hhcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiUzAxMDFcIixcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IGZvciBudW1iZXJzXG4gICAgICAgICAgICB2YXIgbnVtcmVnZXggPSAvXi0/KDB8KFsxLTldWzAtOV0qKSkoXFwuWzAtOV0rKT8oW0VlXVstK10/WzAtOV0rKT8vO1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gbnVtcmVnZXguZXhlYyhwYXRoLnN1YnN0cmluZyhwb3NpdGlvbikpO1xuICAgICAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIG51bSA9IHBhcnNlRmxvYXQobWF0Y2hbMF0pO1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4obnVtKSAmJiBpc0Zpbml0ZShudW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZSgnbnVtYmVyJywgbnVtKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlMwMTAyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiBtYXRjaFswXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgZm9yIHF1b3RlZCBuYW1lcyAoYmFja3RpY2tzKVxuICAgICAgICAgICAgdmFyIG5hbWU7XG4gICAgICAgICAgICBpZihjdXJyZW50Q2hhciA9PT0gJ2AnKSB7XG4gICAgICAgICAgICAgICAgLy8gc2NhbiBmb3IgY2xvc2luZyBxdW90ZVxuICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IHBhdGguaW5kZXhPZignYCcsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBpZihlbmQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBwYXRoLnN1YnN0cmluZyhwb3NpdGlvbiwgZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBlbmQgKyAxO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCduYW1lJywgbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gbGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogXCJTMDEwNVwiLFxuICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgZm9yIG5hbWVzXG4gICAgICAgICAgICB2YXIgaSA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIGNoO1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGNoID0gcGF0aC5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IGxlbmd0aCB8fCAnIFxcdFxcblxcclxcdicuaW5kZXhPZihjaCkgPiAtMSB8fCBvcGVyYXRvcnMuaGFzT3duUHJvcGVydHkoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoLmNoYXJBdChwb3NpdGlvbikgPT09ICckJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFyaWFibGUgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gcGF0aC5zdWJzdHJpbmcocG9zaXRpb24gKyAxLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUoJ3ZhcmlhYmxlJywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gcGF0aC5zdWJzdHJpbmcocG9zaXRpb24sIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnb3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2luJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdhbmQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCdvcGVyYXRvcicsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RydWUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCd2YWx1ZScsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZhbHNlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZSgndmFsdWUnLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUoJ3ZhbHVlJywgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSBsZW5ndGggJiYgbmFtZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaXRlc3BhY2UgYXQgZW5kIG9mIGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCduYW1lJywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBmdW5jdGlvbiBzaWduYXR1cmUgZGVmaW5pdGlvbiBhbmQgcmV0dXJucyBhIHZhbGlkYXRpb24gZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2lnbmF0dXJlIC0gdGhlIHNpZ25hdHVyZSBiZXR3ZWVuIHRoZSA8YW5nbGUgYnJhY2tldHM+XG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSB2YWxpZGF0aW9uIGZ1bmN0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIFJlZ2V4IHRoYXQgcmVwcmVzZW50cyB0aGlzIHNpZ25hdHVyZSBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCB3aGVuIGludm9rZWQsXG4gICAgICAgIC8vIHJldHVybnMgdGhlIHZhbGlkYXRlZCAocG9zc2libHkgZml4ZWQtdXApIGFyZ3VtZW50cywgb3IgdGhyb3dzIGEgdmFsaWRhdGlvbiBlcnJvclxuICAgICAgICAvLyBzdGVwIHRocm91Z2ggdGhlIHNpZ25hdHVyZSwgb25lIHN5bWJvbCBhdCBhIHRpbWVcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gMTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgICAgICB2YXIgcGFyYW0gPSB7fTtcbiAgICAgICAgdmFyIHByZXZQYXJhbSA9IHBhcmFtO1xuICAgICAgICB3aGlsZSAocG9zaXRpb24gPCBzaWduYXR1cmUubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgc3ltYm9sID0gc2lnbmF0dXJlLmNoYXJBdChwb3NpdGlvbik7XG4gICAgICAgICAgICBpZihzeW1ib2wgPT09ICc6Jykge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gZmlndXJlIG91dCB3aGF0IHRvIGRvIHdpdGggdGhlIHJldHVybiB0eXBlXG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIGl0IGZvciBub3dcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChwYXJhbSk7XG4gICAgICAgICAgICAgICAgcHJldlBhcmFtID0gcGFyYW07XG4gICAgICAgICAgICAgICAgcGFyYW0gPSB7fTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBmaW5kQ2xvc2luZ0JyYWNrZXQgPSBmdW5jdGlvbihzdHIsIHN0YXJ0LCBvcGVuU3ltYm9sLCBjbG9zZVN5bWJvbCkge1xuICAgICAgICAgICAgICAgIC8vIHJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjbG9zaW5nIHN5bWJvbCAoZS5nLiBicmFja2V0KSBpbiBhIHN0cmluZ1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgYmFsYW5jZXMgdGhlIG9wZW5pbmcgc3ltYm9sIGF0IHBvc2l0aW9uIHN0YXJ0XG4gICAgICAgICAgICAgICAgdmFyIGRlcHRoID0gMTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBzdGFydDtcbiAgICAgICAgICAgICAgICB3aGlsZShwb3NpdGlvbiA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gc3RyLmNoYXJBdChwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbCA9PT0gY2xvc2VTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gb3V0IG9mIHdoaWxlIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHN5bWJvbCA9PT0gb3BlblN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzd2l0Y2ggKHN5bWJvbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3MnOiAvLyBzdHJpbmdcbiAgICAgICAgICAgICAgICBjYXNlICduJzogLy8gbnVtYmVyXG4gICAgICAgICAgICAgICAgY2FzZSAnYic6IC8vIGJvb2xlYW5cbiAgICAgICAgICAgICAgICBjYXNlICdsJzogLy8gbm90IHNvIHN1cmUgYWJvdXQgZXhwZWN0aW5nIG51bGw/XG4gICAgICAgICAgICAgICAgY2FzZSAnbyc6IC8vIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICBwYXJhbS5yZWdleCA9ICdbJyArIHN5bWJvbCArICdtXSc7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLnR5cGUgPSBzeW1ib2w7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYSc6IC8vIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIC8vICBub3JtYWxseSB0cmVhdCBhbnkgdmFsdWUgYXMgc2luZ2xldG9uIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLnJlZ2V4ID0gJ1thc25ibGZvbV0nO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbS50eXBlID0gc3ltYm9sO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbS5hcnJheSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZic6IC8vIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLnJlZ2V4ID0gJ2YnO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbS50eXBlID0gc3ltYm9sO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2onOiAvLyBhbnkgSlNPTiB0eXBlXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLnJlZ2V4ID0gJ1thc25ibG9tXSc7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLnR5cGUgPSBzeW1ib2w7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAneCc6IC8vIGFueSB0eXBlXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLnJlZ2V4ID0gJ1thc25ibGZvbV0nO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbS50eXBlID0gc3ltYm9sO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJy0nOiAvLyB1c2UgY29udGV4dCBpZiBwYXJhbSBub3Qgc3VwcGxpZWRcbiAgICAgICAgICAgICAgICAgICAgcHJldlBhcmFtLmNvbnRleHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBwcmV2UGFyYW0uY29udGV4dFJlZ2V4ID0gbmV3IFJlZ0V4cChwcmV2UGFyYW0ucmVnZXgpOyAvLyBwcmUtY29tcGlsZWQgdG8gdGVzdCB0aGUgY29udGV4dCB0eXBlIGF0IHJ1bnRpbWVcbiAgICAgICAgICAgICAgICAgICAgcHJldlBhcmFtLnJlZ2V4ICs9ICc/JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnPyc6IC8vIG9wdGlvbmFsIHBhcmFtXG4gICAgICAgICAgICAgICAgY2FzZSAnKyc6IC8vIG9uZSBvciBtb3JlXG4gICAgICAgICAgICAgICAgICAgIHByZXZQYXJhbS5yZWdleCArPSBzeW1ib2w7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJygnOiAvLyBjaG9pY2Ugb2YgdHlwZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VhcmNoIGZvcndhcmQgZm9yIG1hdGNoaW5nICcpJ1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kUGFyZW4gPSBmaW5kQ2xvc2luZ0JyYWNrZXQoc2lnbmF0dXJlLCBwb3NpdGlvbiwgJygnLCAnKScpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hvaWNlID0gc2lnbmF0dXJlLnN1YnN0cmluZyhwb3NpdGlvbiArIDEsIGVuZFBhcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoY2hvaWNlLmluZGV4T2YoJzwnKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIHBhcmFtZXRlcml6ZWQgdHlwZXMsIHNpbXBsZSByZWdleFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0ucmVnZXggPSAnWycgKyBjaG9pY2UgKyAnbV0nO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBoYXJkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlMwNDAyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNob2ljZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLnR5cGUgPSAnKCcgKyBjaG9pY2UgKyAnKSc7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gZW5kUGFyZW47XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnPCc6IC8vIHR5cGUgcGFyYW1ldGVyIC0gY2FuIG9ubHkgYmUgYXBwbGllZCB0byAnYScgYW5kICdmJ1xuICAgICAgICAgICAgICAgICAgICBpZihwcmV2UGFyYW0udHlwZSA9PT0gJ2EnIHx8IHByZXZQYXJhbS50eXBlID09PSAnZicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlYXJjaCBmb3J3YXJkIGZvciBtYXRjaGluZyAnPidcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmRQb3MgPSBmaW5kQ2xvc2luZ0JyYWNrZXQoc2lnbmF0dXJlLCBwb3NpdGlvbiwgJzwnLCAnPicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldlBhcmFtLnN1YnR5cGUgPSBzaWduYXR1cmUuc3Vic3RyaW5nKHBvc2l0aW9uICsgMSwgZW5kUG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gZW5kUG9zO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiUzA0MDFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcHJldlBhcmFtLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlZ2V4U3RyID0gJ14nICtcbiAgICAgICAgICBwYXJhbXMubWFwKGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICAgICAgICAgIHJldHVybiAnKCcgKyBwYXJhbS5yZWdleCArICcpJztcbiAgICAgICAgICB9KS5qb2luKCcnKSArXG4gICAgICAgICAgJyQnO1xuICAgICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4U3RyKTtcbiAgICAgICAgdmFyIGdldFN5bWJvbCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgc3ltYm9sO1xuICAgICAgICAgICAgaWYoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSAnZic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gJ3MnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSAnbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSAnYic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9ICdsJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSAnYSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9ICdvJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW55IHZhbHVlIGNhbiBiZSB1bmRlZmluZWQsIGJ1dCBzaG91bGQgYmUgYWxsb3dlZCB0byBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gJ20nOyAvLyBtIGZvciBtaXNzaW5nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdGhyb3dWYWxpZGF0aW9uRXJyb3IgPSBmdW5jdGlvbihiYWRBcmdzLCBiYWRTaWcpIHtcbiAgICAgICAgICAgIC8vIHRvIGZpZ3VyZSBvdXQgd2hlcmUgdGhpcyB3ZW50IHdyb25nIHdlIG5lZWQgYXBwbHkgZWFjaCBjb21wb25lbnQgb2YgdGhlXG4gICAgICAgICAgICAvLyByZWdleCB0byBlYWNoIGFyZ3VtZW50IHVudGlsIHdlIGdldCB0byB0aGUgb25lIHRoYXQgZmFpbHMgdG8gbWF0Y2hcbiAgICAgICAgICAgIHZhciBwYXJ0aWFsUGF0dGVybiA9ICdeJztcbiAgICAgICAgICAgIHZhciBnb29kVG8gPSAwO1xuICAgICAgICAgICAgZm9yKHZhciBpbmRleCA9IDA7IGluZGV4IDwgcGFyYW1zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHBhcnRpYWxQYXR0ZXJuICs9IHBhcmFtc1tpbmRleF0ucmVnZXg7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gYmFkU2lnLm1hdGNoKHBhcnRpYWxQYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICBpZihtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmYWlsZWQgaGVyZVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlQwNDEwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBiYWRBcmdzW2dvb2RUb10sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogZ29vZFRvICsgMVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnb29kVG8gPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBpdCBnb3QgdGhpcyBmYXIsIGl0J3MgcHJvYmFibHkgYmVjYXVzZSBvZiBleHRyYW5lb3VzIGFyZ3VtZW50cyAod2VcbiAgICAgICAgICAgIC8vIGhhdmVuJ3QgYWRkZWQgdGhlIHRyYWlsaW5nICckJyBpbiB0aGUgcmVnZXggeWV0LlxuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiVDA0MTBcIixcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICB2YWx1ZTogYmFkQXJnc1tnb29kVG9dLFxuICAgICAgICAgICAgICAgIGluZGV4OiBnb29kVG8gKyAxXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWZpbml0aW9uOiBzaWduYXR1cmUsXG4gICAgICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24oYXJncywgY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBzdXBwbGllZFNpZyA9ICcnO1xuICAgICAgICAgICAgICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwcGxpZWRTaWcgKz0gZ2V0U3ltYm9sKGFyZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGlzVmFsaWQgPSByZWdleC5leGVjKHN1cHBsaWVkU2lnKTtcbiAgICAgICAgICAgICAgICBpZihpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWxpZGF0ZWRBcmdzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IGFyZ3NbYXJnSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gaXNWYWxpZFtpbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYobWF0Y2ggPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtLmNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3Vic3RpdHV0ZSBjb250ZXh0IHZhbHVlIGZvciBtaXNzaW5nIGFyZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaXJzdCBjaGVjayB0aGF0IHRoZSBjb250ZXh0IHZhbHVlIGlzIHRoZSByaWdodCB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZXh0VHlwZSA9IGdldFN5bWJvbChjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGVzdCBjb250ZXh0VHlwZSBhZ2FpbnN0IHRoZSByZWdleCBmb3IgdGhpcyBhcmcgKHdpdGhvdXQgdGhlIHRyYWlsaW5nID8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHBhcmFtLmNvbnRleHRSZWdleC50ZXN0KGNvbnRleHRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVkQXJncy5wdXNoKGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udGV4dCB2YWx1ZSBub3QgY29tcGF0aWJsZSB3aXRoIHRoaXMgYXJndW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlQwNDExXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGFyZ0luZGV4ICsgMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlZEFyZ3MucHVzaChhcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF5IGhhdmUgbWF0Y2hlZCBtdWx0aXBsZSBhcmdzIChpZiB0aGUgcmVnZXggZW5kcyB3aXRoIGEgJysnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BsaXQgaW50byBzaW5nbGUgdG9rZW5zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2guc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24oc2luZ2xlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSAnYScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaW5nbGUgPT09ICdtJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1pc3NpbmcgKHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3NbYXJnSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcnJheU9LID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyB0aGVyZSB0eXBlIGluZm9ybWF0aW9uIG9uIHRoZSBjb250ZW50cyBvZiB0aGUgYXJyYXk/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbS5zdWJ0eXBlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2luZ2xlICE9PSAnYScgJiYgbWF0Y2ggIT09IHBhcmFtLnN1YnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5T0sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzaW5nbGUgPT09ICdhJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1UeXBlID0gZ2V0U3ltYm9sKGFyZ1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1UeXBlICE9PSBwYXJhbS5zdWJ0eXBlLmNoYXJBdCgwKSkgeyAvLyBUT0RPIHJlY3Vyc2UgZnVydGhlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheU9LID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGV2ZXJ5IGl0ZW0gaW4gdGhlIGFycmF5IGlzIHRoaXMgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlmZmVyZW50SXRlbXMgPSBhcmcuZmlsdGVyKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZ2V0U3ltYm9sKHZhbCkgIT09IGl0ZW1UeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5T0sgPSAoZGlmZmVyZW50SXRlbXMubGVuZ3RoID09PSAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhcnJheU9LKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiVDA0MTJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGFyZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBhcmdJbmRleCArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBwYXJhbS5zdWJ0eXBlIC8vIFRPRE8gdHJhbnNsYXRlIHN5bWJvbCB0byB0eXBlIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGZ1bmN0aW9uIGV4cGVjdHMgYW4gYXJyYXkuIElmIGl0J3Mgbm90IG9uZSwgbWFrZSBpdCBzb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaW5nbGUgIT09ICdhJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBbYXJnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZWRBcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ0luZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZWRBcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ0luZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZWRBcmdzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvd1ZhbGlkYXRpb25FcnJvcihhcmdzLCBzdXBwbGllZFNpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gVGhpcyBwYXJzZXIgaW1wbGVtZW50cyB0aGUgJ1RvcCBkb3duIG9wZXJhdG9yIHByZWNlZGVuY2UnIGFsZ29yaXRobSBkZXZlbG9wZWQgYnkgVmF1Z2hhbiBSIFByYXR0OyBodHRwOi8vZGwuYWNtLm9yZy9jaXRhdGlvbi5jZm0/aWQ9NTEyOTMxLlxuICAgIC8vIGFuZCBidWlsZHMgb24gdGhlIEphdmFzY3JpcHQgZnJhbWV3b3JrIGRlc2NyaWJlZCBieSBEb3VnbGFzIENyb2NrZm9yZCBhdCBodHRwOi8vamF2YXNjcmlwdC5jcm9ja2ZvcmQuY29tL3Rkb3AvdGRvcC5odG1sXG4gICAgLy8gYW5kIGluICdCZWF1dGlmdWwgQ29kZScsIGVkaXRlZCBieSBBbmR5IE9yYW0gYW5kIEdyZWcgV2lsc29uLCBDb3B5cmlnaHQgMjAwNyBPJ1JlaWxseSBNZWRpYSwgSW5jLiA3OTgtMC01OTYtNTEwMDQtNlxuXG4gICAgdmFyIHBhcnNlciA9IGZ1bmN0aW9uIChzb3VyY2UsIHJlY292ZXIpIHtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIHZhciBsZXhlcjtcblxuICAgICAgICB2YXIgc3ltYm9sX3RhYmxlID0ge307XG4gICAgICAgIHZhciBlcnJvcnMgPSBbXTtcblxuICAgICAgICB2YXIgcmVtYWluaW5nVG9rZW5zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gW107XG4gICAgICAgICAgICBpZihub2RlLmlkICE9PSAnKGVuZCknKSB7XG4gICAgICAgICAgICAgICAgcmVtYWluaW5nLnB1c2goe3R5cGU6IG5vZGUudHlwZSwgdmFsdWU6IG5vZGUudmFsdWUsIHBvc2l0aW9uOiBub2RlLnBvc2l0aW9ufSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbnh0ID0gbGV4ZXIoKTtcbiAgICAgICAgICAgIHdoaWxlKG54dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlbWFpbmluZy5wdXNoKG54dCk7XG4gICAgICAgICAgICAgICAgbnh0ID0gbGV4ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZW1haW5pbmc7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGJhc2Vfc3ltYm9sID0ge1xuICAgICAgICAgICAgbnVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gZXJyb3IgLSBzeW1ib2wgaGFzIGJlZW4gaW52b2tlZCBhcyBhIHVuYXJ5IG9wZXJhdG9yXG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogJ1MwMjExJyxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IHRoaXMudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmKHJlY292ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyLnJlbWFpbmluZyA9IHJlbWFpbmluZ1Rva2VucygpO1xuICAgICAgICAgICAgICAgICAgICBlcnIudHlwZSA9ICdlcnJvcic7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjaztcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc3ltYm9sID0gZnVuY3Rpb24gKGlkLCBicCkge1xuICAgICAgICAgICAgdmFyIHMgPSBzeW1ib2xfdGFibGVbaWRdO1xuICAgICAgICAgICAgYnAgPSBicCB8fCAwO1xuICAgICAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnAgPj0gcy5sYnApIHtcbiAgICAgICAgICAgICAgICAgICAgcy5sYnAgPSBicDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHMgPSBPYmplY3QuY3JlYXRlKGJhc2Vfc3ltYm9sKTtcbiAgICAgICAgICAgICAgICBzLmlkID0gcy52YWx1ZSA9IGlkO1xuICAgICAgICAgICAgICAgIHMubGJwID0gYnA7XG4gICAgICAgICAgICAgICAgc3ltYm9sX3RhYmxlW2lkXSA9IHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaGFuZGxlRXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGlmKHJlY292ZXIpIHtcbiAgICAgICAgICAgICAgICAvLyB0b2tlbml6ZSB0aGUgcmVzdCBvZiB0aGUgYnVmZmVyIGFuZCBhZGQgaXQgdG8gYW4gZXJyb3IgdG9rZW5cbiAgICAgICAgICAgICAgICBlcnIucmVtYWluaW5nID0gcmVtYWluaW5nVG9rZW5zKCk7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgICAgICB2YXIgc3ltYm9sID0gc3ltYm9sX3RhYmxlW1wiKGVycm9yKVwiXTtcbiAgICAgICAgICAgICAgICBub2RlID0gT2JqZWN0LmNyZWF0ZShzeW1ib2wpO1xuICAgICAgICAgICAgICAgIG5vZGUuZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgbm9kZS50eXBlID0gXCIoZXJyb3IpXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVyci5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhZHZhbmNlID0gZnVuY3Rpb24gKGlkLCBpbmZpeCkge1xuICAgICAgICAgICAgaWYgKGlkICYmIG5vZGUuaWQgIT09IGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGU7XG4gICAgICAgICAgICAgICAgaWYobm9kZS5pZCA9PT0gJyhlbmQpJykge1xuICAgICAgICAgICAgICAgICAgICAvLyB1bmV4cGVjdGVkIGVuZCBvZiBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9IFwiUzAyMDNcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2RlID0gXCJTMDIwMlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZXJyID0ge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogbm9kZS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IG5vZGUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmV4dF90b2tlbiA9IGxleGVyKGluZml4KTtcbiAgICAgICAgICAgIGlmIChuZXh0X3Rva2VuID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHN5bWJvbF90YWJsZVtcIihlbmQpXCJdO1xuICAgICAgICAgICAgICAgIG5vZGUucG9zaXRpb24gPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gbmV4dF90b2tlbi52YWx1ZTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gbmV4dF90b2tlbi50eXBlO1xuICAgICAgICAgICAgdmFyIHN5bWJvbDtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ25hbWUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3ZhcmlhYmxlJzpcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gc3ltYm9sX3RhYmxlW1wiKG5hbWUpXCJdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdvcGVyYXRvcic6XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IHN5bWJvbF90YWJsZVt2YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlMwMjA0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IG5leHRfdG9rZW4ucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gXCJsaXRlcmFsXCI7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IHN5bWJvbF90YWJsZVtcIihsaXRlcmFsKVwiXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncmVnZXgnOlxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gXCJyZWdleFwiO1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBzeW1ib2xfdGFibGVbXCIocmVnZXgpXCJdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiUzAyMDVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IG5leHRfdG9rZW4ucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUgPSBPYmplY3QuY3JlYXRlKHN5bWJvbCk7XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBub2RlLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgbm9kZS5wb3NpdGlvbiA9IG5leHRfdG9rZW4ucG9zaXRpb247XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQcmF0dCdzIGFsZ29yaXRobVxuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChyYnApIHtcbiAgICAgICAgICAgIHZhciBsZWZ0O1xuICAgICAgICAgICAgdmFyIHQgPSBub2RlO1xuICAgICAgICAgICAgYWR2YW5jZShudWxsLCB0cnVlKTtcbiAgICAgICAgICAgIGxlZnQgPSB0Lm51ZCgpO1xuICAgICAgICAgICAgd2hpbGUgKHJicCA8IG5vZGUubGJwKSB7XG4gICAgICAgICAgICAgICAgdCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSB0LmxlZChsZWZ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB0ZXJtaW5hbCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHN5bWJvbChpZCwgMCk7XG4gICAgICAgICAgICBzLm51ZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBtYXRjaCBpbmZpeCBvcGVyYXRvcnNcbiAgICAgICAgLy8gPGV4cHJlc3Npb24+IDxvcGVyYXRvcj4gPGV4cHJlc3Npb24+XG4gICAgICAgIC8vIGxlZnQgYXNzb2NpYXRpdmVcbiAgICAgICAgdmFyIGluZml4ID0gZnVuY3Rpb24gKGlkLCBicCwgbGVkKSB7XG4gICAgICAgICAgICB2YXIgYmluZGluZ1Bvd2VyID0gYnAgfHwgb3BlcmF0b3JzW2lkXTtcbiAgICAgICAgICAgIHZhciBzID0gc3ltYm9sKGlkLCBiaW5kaW5nUG93ZXIpO1xuICAgICAgICAgICAgcy5sZWQgPSBsZWQgfHwgZnVuY3Rpb24gKGxlZnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxocyA9IGxlZnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5yaHMgPSBleHByZXNzaW9uKGJpbmRpbmdQb3dlcik7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gXCJiaW5hcnlcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBtYXRjaCBpbmZpeCBvcGVyYXRvcnNcbiAgICAgICAgLy8gPGV4cHJlc3Npb24+IDxvcGVyYXRvcj4gPGV4cHJlc3Npb24+XG4gICAgICAgIC8vIHJpZ2h0IGFzc29jaWF0aXZlXG4gICAgICAgIHZhciBpbmZpeHIgPSBmdW5jdGlvbiAoaWQsIGJwLCBsZWQpIHtcbiAgICAgICAgICAgIHZhciBiaW5kaW5nUG93ZXIgPSBicCB8fCBvcGVyYXRvcnNbaWRdO1xuICAgICAgICAgICAgdmFyIHMgPSBzeW1ib2woaWQsIGJpbmRpbmdQb3dlcik7XG4gICAgICAgICAgICBzLmxlZCA9IGxlZCB8fCBmdW5jdGlvbiAobGVmdCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGhzID0gbGVmdDtcbiAgICAgICAgICAgICAgICB0aGlzLnJocyA9IGV4cHJlc3Npb24oYmluZGluZ1Bvd2VyIC0gMSk7IC8vIHN1YnRyYWN0IDEgZnJvbSBiaW5kaW5nUG93ZXIgZm9yIHJpZ2h0IGFzc29jaWF0aXZlIG9wZXJhdG9yc1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwiYmluYXJ5XCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbWF0Y2ggcHJlZml4IG9wZXJhdG9yc1xuICAgICAgICAvLyA8b3BlcmF0b3I+IDxleHByZXNzaW9uPlxuICAgICAgICB2YXIgcHJlZml4ID0gZnVuY3Rpb24gKGlkLCBudWQpIHtcbiAgICAgICAgICAgIHZhciBzID0gc3ltYm9sKGlkKTtcbiAgICAgICAgICAgIHMubnVkID0gbnVkIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uKDcwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBcInVuYXJ5XCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGVybWluYWwoXCIoZW5kKVwiKTtcbiAgICAgICAgdGVybWluYWwoXCIobmFtZSlcIik7XG4gICAgICAgIHRlcm1pbmFsKFwiKGxpdGVyYWwpXCIpO1xuICAgICAgICB0ZXJtaW5hbChcIihyZWdleClcIik7XG4gICAgICAgIHN5bWJvbChcIjpcIik7XG4gICAgICAgIHN5bWJvbChcIjtcIik7XG4gICAgICAgIHN5bWJvbChcIixcIik7XG4gICAgICAgIHN5bWJvbChcIilcIik7XG4gICAgICAgIHN5bWJvbChcIl1cIik7XG4gICAgICAgIHN5bWJvbChcIn1cIik7XG4gICAgICAgIHN5bWJvbChcIi4uXCIpOyAvLyByYW5nZSBvcGVyYXRvclxuICAgICAgICBpbmZpeChcIi5cIik7IC8vIGZpZWxkIHJlZmVyZW5jZVxuICAgICAgICBpbmZpeChcIitcIik7IC8vIG51bWVyaWMgYWRkaXRpb25cbiAgICAgICAgaW5maXgoXCItXCIpOyAvLyBudW1lcmljIHN1YnRyYWN0aW9uXG4gICAgICAgIGluZml4KFwiKlwiKTsgLy8gbnVtZXJpYyBtdWx0aXBsaWNhdGlvblxuICAgICAgICBpbmZpeChcIi9cIik7IC8vIG51bWVyaWMgZGl2aXNpb25cbiAgICAgICAgaW5maXgoXCIlXCIpOyAvLyBudW1lcmljIG1vZHVsdXNcbiAgICAgICAgaW5maXgoXCI9XCIpOyAvLyBlcXVhbGl0eVxuICAgICAgICBpbmZpeChcIjxcIik7IC8vIGxlc3MgdGhhblxuICAgICAgICBpbmZpeChcIj5cIik7IC8vIGdyZWF0ZXIgdGhhblxuICAgICAgICBpbmZpeChcIiE9XCIpOyAvLyBub3QgZXF1YWwgdG9cbiAgICAgICAgaW5maXgoXCI8PVwiKTsgLy8gbGVzcyB0aGFuIG9yIGVxdWFsXG4gICAgICAgIGluZml4KFwiPj1cIik7IC8vIGdyZWF0ZXIgdGhhbiBvciBlcXVhbFxuICAgICAgICBpbmZpeChcIiZcIik7IC8vIHN0cmluZyBjb25jYXRlbmF0aW9uXG4gICAgICAgIGluZml4KFwiYW5kXCIpOyAvLyBCb29sZWFuIEFORFxuICAgICAgICBpbmZpeChcIm9yXCIpOyAvLyBCb29sZWFuIE9SXG4gICAgICAgIGluZml4KFwiaW5cIik7IC8vIGlzIG1lbWJlciBvZiBhcnJheVxuICAgICAgICB0ZXJtaW5hbChcImFuZFwiKTsgLy8gdGhlICdrZXl3b3JkcycgY2FuIGFsc28gYmUgdXNlZCBhcyB0ZXJtaW5hbHMgKGZpZWxkIG5hbWVzKVxuICAgICAgICB0ZXJtaW5hbChcIm9yXCIpOyAvL1xuICAgICAgICB0ZXJtaW5hbChcImluXCIpOyAvL1xuICAgICAgICBpbmZpeHIoXCI6PVwiKTsgLy8gYmluZCB2YXJpYWJsZVxuICAgICAgICBwcmVmaXgoXCItXCIpOyAvLyB1bmFyeSBudW1lcmljIG5lZ2F0aW9uXG4gICAgICAgIGluZml4KFwifj5cIik7IC8vIGZ1bmN0aW9uIGFwcGxpY2F0aW9uXG5cbiAgICAgICAgaW5maXhyKFwiKGVycm9yKVwiLCAxMCwgZnVuY3Rpb24obGVmdCkge1xuICAgICAgICAgICAgdGhpcy5saHMgPSBsZWZ0O1xuXG4gICAgICAgICAgICB0aGlzLmVycm9yID0gbm9kZS5lcnJvcjtcbiAgICAgICAgICAgIHRoaXMucmVtYWluaW5nID0gcmVtYWluaW5nVG9rZW5zKCk7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSAnZXJyb3InO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGZpZWxkIHdpbGRjYXJkIChzaW5nbGUgbGV2ZWwpXG4gICAgICAgIHByZWZpeCgnKicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFwid2lsZGNhcmRcIjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBkZXNjZW5kYW50IHdpbGRjYXJkIChtdWx0aS1sZXZlbClcbiAgICAgICAgcHJlZml4KCcqKicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFwiZGVzY2VuZGFudFwiO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGZ1bmN0aW9uIGludm9jYXRpb25cbiAgICAgICAgaW5maXgoXCIoXCIsIG9wZXJhdG9yc1snKCddLCBmdW5jdGlvbiAobGVmdCkge1xuICAgICAgICAgICAgLy8gbGVmdCBpcyBpcyB3aGF0IHdlIGFyZSB0cnlpbmcgdG8gaW52b2tlXG4gICAgICAgICAgICB0aGlzLnByb2NlZHVyZSA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSAnZnVuY3Rpb24nO1xuICAgICAgICAgICAgdGhpcy5hcmd1bWVudHMgPSBbXTtcbiAgICAgICAgICAgIGlmIChub2RlLmlkICE9PSAnKScpIHtcbiAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdvcGVyYXRvcicgJiYgbm9kZS5pZCA9PT0gJz8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXJ0aWFsIGZ1bmN0aW9uIGFwcGxpY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSAncGFydGlhbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFyZ3VtZW50cy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZSgnPycpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmd1bWVudHMucHVzaChleHByZXNzaW9uKDApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCAhPT0gJywnKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZSgnLCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkdmFuY2UoXCIpXCIsIHRydWUpO1xuICAgICAgICAgICAgLy8gaWYgdGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIGlzICdmdW5jdGlvbicgb3IgzrssIHRoZW4gdGhpcyBpcyBmdW5jdGlvbiBkZWZpbml0aW9uIChsYW1iZGEgZnVuY3Rpb24pXG4gICAgICAgICAgICBpZiAobGVmdC50eXBlID09PSAnbmFtZScgJiYgKGxlZnQudmFsdWUgPT09ICdmdW5jdGlvbicgfHwgbGVmdC52YWx1ZSA9PT0gJ1xcdTAzQkInKSkge1xuICAgICAgICAgICAgICAgIC8vIGFsbCBvZiB0aGUgYXJncyBtdXN0IGJlIFZBUklBQkxFIHRva2Vuc1xuICAgICAgICAgICAgICAgIHRoaXMuYXJndW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGFyZywgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZy50eXBlICE9PSAndmFyaWFibGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlMwMjA4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGFyZy5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogYXJnLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpbmRleCArIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gJ2xhbWJkYSc7XG4gICAgICAgICAgICAgICAgLy8gaXMgdGhlIG5leHQgdG9rZW4gYSAnPCcgLSBpZiBzbywgcGFyc2UgdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZVxuICAgICAgICAgICAgICAgIGlmKG5vZGUuaWQgPT09ICc8Jykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2lnUG9zID0gbm9kZS5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlcHRoID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpZyA9ICc8JztcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUoZGVwdGggPiAwICYmIG5vZGUuaWQgIT09ICd7JyAmJiBub2RlLmlkICE9PSAnKGVuZCknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9rID0gYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodG9rLmlkID09PSAnPicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHRvay5pZCA9PT0gJzwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZyArPSB0b2sudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZSgnPicpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaWduYXR1cmUgPSBwYXJzZVNpZ25hdHVyZShzaWcpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZXJ0IHRoZSBwb3NpdGlvbiBpbnRvIHRoaXMgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyci5wb3NpdGlvbiA9IHNpZ1BvcyArIGVyci5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoIGVyciApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHBhcnNlIHRoZSBmdW5jdGlvbiBib2R5XG4gICAgICAgICAgICAgICAgYWR2YW5jZSgneycpO1xuICAgICAgICAgICAgICAgIHRoaXMuYm9keSA9IGV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICAgICAgYWR2YW5jZSgnfScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHBhcmVudGhlc2lzIC0gYmxvY2sgZXhwcmVzc2lvblxuICAgICAgICBwcmVmaXgoXCIoXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBleHByZXNzaW9ucyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUuaWQgIT09IFwiKVwiKSB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChleHByZXNzaW9uKDApKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCAhPT0gXCI7XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkdmFuY2UoXCI7XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWR2YW5jZShcIilcIiwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSAnYmxvY2snO1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGFycmF5IGNvbnN0cnVjdG9yXG4gICAgICAgIHByZWZpeChcIltcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgICAgIGlmIChub2RlLmlkICE9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBleHByZXNzaW9uKDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCA9PT0gXCIuLlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByYW5nZSBvcGVyYXRvclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0ge3R5cGU6IFwiYmluYXJ5XCIsIHZhbHVlOiBcIi4uXCIsIHBvc2l0aW9uOiBub2RlLnBvc2l0aW9uLCBsaHM6IGl0ZW19O1xuICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShcIi4uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UucmhzID0gZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSByYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmlkICE9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShcIixcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWR2YW5jZShcIl1cIiwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gYTtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFwidW5hcnlcIjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBmaWx0ZXIgLSBwcmVkaWNhdGUgb3IgYXJyYXkgaW5kZXhcbiAgICAgICAgaW5maXgoXCJbXCIsIG9wZXJhdG9yc1snWyddLCBmdW5jdGlvbiAobGVmdCkge1xuICAgICAgICAgICAgaWYobm9kZS5pZCA9PT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBlbXB0eSBwcmVkaWNhdGUgbWVhbnMgbWFpbnRhaW4gc2luZ2xldG9uIGFycmF5cyBpbiB0aGUgb3V0cHV0XG4gICAgICAgICAgICAgICAgdmFyIHN0ZXAgPSBsZWZ0O1xuICAgICAgICAgICAgICAgIHdoaWxlKHN0ZXAgJiYgc3RlcC50eXBlID09PSAnYmluYXJ5JyAmJiBzdGVwLnZhbHVlID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RlcCA9IHN0ZXAubGhzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGVwLmtlZXBBcnJheSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYWR2YW5jZShcIl1cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubGhzID0gbGVmdDtcbiAgICAgICAgICAgICAgICB0aGlzLnJocyA9IGV4cHJlc3Npb24ob3BlcmF0b3JzWyddJ10pO1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9ICdiaW5hcnknO1xuICAgICAgICAgICAgICAgIGFkdmFuY2UoXCJdXCIsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBvcmRlci1ieVxuICAgICAgICBpbmZpeChcIl5cIiwgb3BlcmF0b3JzWydeJ10sIGZ1bmN0aW9uIChsZWZ0KSB7XG4gICAgICAgICAgICBhZHZhbmNlKFwiKFwiKTtcbiAgICAgICAgICAgIHZhciB0ZXJtcyA9IFtdO1xuICAgICAgICAgICAgZm9yKDs7KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlcm0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NlbmRpbmc6IGZhbHNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCA9PT0gXCI8XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYXNjZW5kaW5nIHNvcnRcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShcIjxcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmlkID09PSBcIj5cIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZXNjZW5kaW5nIHNvcnRcbiAgICAgICAgICAgICAgICAgICAgdGVybS5kZXNjZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShcIj5cIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy91bnNwZWNpZmllZCAtIGRlZmF1bHQgdG8gYXNjZW5kaW5nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRlcm0uZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICAgICAgdGVybXMucHVzaCh0ZXJtKTtcbiAgICAgICAgICAgICAgICBpZihub2RlLmlkICE9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWR2YW5jZShcIixcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZHZhbmNlKFwiKVwiKTtcbiAgICAgICAgICAgIHRoaXMubGhzID0gbGVmdDtcbiAgICAgICAgICAgIHRoaXMucmhzID0gdGVybXM7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSAnYmluYXJ5JztcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgb2JqZWN0UGFyc2VyID0gZnVuY3Rpb24gKGxlZnQpIHtcbiAgICAgICAgICAgIHZhciBhID0gW107XG4gICAgICAgICAgICBpZiAobm9kZS5pZCAhPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShcIjpcIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2ID0gZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKFtuLCB2XSk7IC8vIGhvbGRzIGFuIGFycmF5IG9mIG5hbWUvdmFsdWUgZXhwcmVzc2lvbiBwYWlyc1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCAhPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoXCIsXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkdmFuY2UoXCJ9XCIsIHRydWUpO1xuICAgICAgICAgICAgaWYodHlwZW9mIGxlZnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gTlVEIC0gdW5hcnkgcHJlZml4IGZvcm1cbiAgICAgICAgICAgICAgICB0aGlzLmxocyA9IGE7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gXCJ1bmFyeVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBMRUQgLSBiaW5hcnkgaW5maXggZm9ybVxuICAgICAgICAgICAgICAgIHRoaXMubGhzID0gbGVmdDtcbiAgICAgICAgICAgICAgICB0aGlzLnJocyA9IGE7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gJ2JpbmFyeSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBvYmplY3QgY29uc3RydWN0b3JcbiAgICAgICAgcHJlZml4KFwie1wiLCBvYmplY3RQYXJzZXIpO1xuXG4gICAgICAgIC8vIG9iamVjdCBncm91cGluZ1xuICAgICAgICBpbmZpeChcIntcIiwgb3BlcmF0b3JzWyd7J10sIG9iamVjdFBhcnNlcik7XG5cbiAgICAgICAgLy8gaWYvdGhlbi9lbHNlIHRlcm5hcnkgb3BlcmF0b3IgPzpcbiAgICAgICAgaW5maXgoXCI/XCIsIG9wZXJhdG9yc1snPyddLCBmdW5jdGlvbiAobGVmdCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gJ2NvbmRpdGlvbic7XG4gICAgICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLnRoZW4gPSBleHByZXNzaW9uKDApO1xuICAgICAgICAgICAgaWYgKG5vZGUuaWQgPT09ICc6Jykge1xuICAgICAgICAgICAgICAgIC8vIGVsc2UgY29uZGl0aW9uXG4gICAgICAgICAgICAgICAgYWR2YW5jZShcIjpcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5lbHNlID0gZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBvYmplY3QgdHJhbnNmb3JtZXJcbiAgICAgICAgcHJlZml4KFwifFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSAndHJhbnNmb3JtJztcbiAgICAgICAgICAgIHRoaXMucGF0dGVybiA9IGV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICBhZHZhbmNlKCd8Jyk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSA9IGV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICBpZihub2RlLmlkID09PSAnLCcpIHtcbiAgICAgICAgICAgICAgICBhZHZhbmNlKCcsJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGUgPSBleHByZXNzaW9uKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWR2YW5jZSgnfCcpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHRhaWwgY2FsbCBvcHRpbWl6YXRpb25cbiAgICAgICAgLy8gdGhpcyBpcyBpbnZva2VkIGJ5IHRoZSBwb3N0IHBhcnNlciB0byBhbmFseXNlIGxhbWJkYSBmdW5jdGlvbnMgdG8gc2VlXG4gICAgICAgIC8vIGlmIHRoZXkgbWFrZSBhIHRhaWwgY2FsbC4gIElmIHNvLCBpdCBpcyByZXBsYWNlZCBieSBhIHRodW5rIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgaW52b2tlZCBieSB0aGUgdHJhbXBvbGluZSBsb29wIGR1cmluZyBmdW5jdGlvbiBhcHBsaWNhdGlvbi5cbiAgICAgICAgLy8gVGhpcyBlbmFibGVzIHRhaWwtcmVjdXJzaXZlIGZ1bmN0aW9ucyB0byBiZSB3cml0dGVuIHdpdGhvdXQgZ3Jvd2luZyB0aGUgc3RhY2tcbiAgICAgICAgdmFyIHRhaWxfY2FsbF9vcHRpbWl6ZSA9IGZ1bmN0aW9uKGV4cHIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICBpZihleHByLnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGh1bmsgPSB7dHlwZTogJ2xhbWJkYScsIHRodW5rOiB0cnVlLCBhcmd1bWVudHM6IFtdLCBwb3NpdGlvbjogZXhwci5wb3NpdGlvbn07XG4gICAgICAgICAgICAgICAgdGh1bmsuYm9keSA9IGV4cHI7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGh1bms7XG4gICAgICAgICAgICB9IGVsc2UgaWYoZXhwci50eXBlID09PSAnY29uZGl0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIGFuYWx5c2UgYm90aCBicmFuY2hlc1xuICAgICAgICAgICAgICAgIGV4cHIudGhlbiA9IHRhaWxfY2FsbF9vcHRpbWl6ZShleHByLnRoZW4pO1xuICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBleHByLmVsc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cHIuZWxzZSA9IHRhaWxfY2FsbF9vcHRpbWl6ZShleHByLmVsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBleHByO1xuICAgICAgICAgICAgfSBlbHNlIGlmKGV4cHIudHlwZSA9PT0gJ2Jsb2NrJykge1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgdGhlIGxhc3QgZXhwcmVzc2lvbiBpbiB0aGUgYmxvY2tcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gZXhwci5leHByZXNzaW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBleHByLmV4cHJlc3Npb25zW2xlbmd0aCAtIDFdID0gdGFpbF9jYWxsX29wdGltaXplKGV4cHIuZXhwcmVzc2lvbnNbbGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBleHByO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBleHByO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBwb3N0LXBhcnNlIHN0YWdlXG4gICAgICAgIC8vIHRoZSBwdXJwb3NlIG9mIHRoaXMgaXMgZmxhdHRlbiB0aGUgcGFydHMgb2YgdGhlIEFTVCByZXByZXNlbnRpbmcgbG9jYXRpb24gcGF0aHMsXG4gICAgICAgIC8vIGNvbnZlcnRpbmcgdGhlbSB0byBhcnJheXMgb2Ygc3RlcHMgd2hpY2ggaW4gdHVybiBtYXkgY29udGFpbiBhcnJheXMgb2YgcHJlZGljYXRlcy5cbiAgICAgICAgLy8gZm9sbG93aW5nIHRoaXMsIG5vZGVzIGNvbnRhaW5pbmcgJy4nIGFuZCAnWycgc2hvdWxkIGJlIGVsaW1pbmF0ZWQgZnJvbSB0aGUgQVNULlxuICAgICAgICB2YXIgYXN0X29wdGltaXplID0gZnVuY3Rpb24gKGV4cHIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZXhwci52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxzdGVwID0gYXN0X29wdGltaXplKGV4cHIubGhzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7dHlwZTogJ3BhdGgnLCBzdGVwczogW119O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsc3RlcC50eXBlID09PSAncGF0aCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocmVzdWx0LnN0ZXBzLCBsc3RlcC5zdGVwcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0ZXBzID0gW2xzdGVwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3QgPSBhc3Rfb3B0aW1pemUoZXhwci5yaHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlc3QudHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdC5wcm9jZWR1cmUudHlwZSA9PT0gJ3BhdGgnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN0LnByb2NlZHVyZS5zdGVwcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3QucHJvY2VkdXJlLnN0ZXBzWzBdLnR5cGUgPT09ICduYW1lJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0ZXBzW3Jlc3VsdC5zdGVwcy5sZW5ndGgtMV0udHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGZ1bmN0aW9uIGluIGNoYWluIG9mIGZ1bmN0aW9ucyAtIHdpbGwgb3ZlcnJpZGUgYSB0aGVuYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RlcHNbcmVzdWx0LnN0ZXBzLmxlbmd0aC0xXS5uZXh0RnVuY3Rpb24gPSByZXN0LnByb2NlZHVyZS5zdGVwc1swXS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVzdC50eXBlICE9PSAncGF0aCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdCA9IHt0eXBlOiAncGF0aCcsIHN0ZXBzOiBbcmVzdF19O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShyZXN1bHQuc3RlcHMsIHJlc3Quc3RlcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFueSBzdGVwcyB3aXRoaW4gYSBwYXRoIHRoYXQgYXJlIGxpdGVyYWxzLCBzaG91bGQgYmUgY2hhbmdlZCB0byAnbmFtZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RlcHMuZmlsdGVyKGZ1bmN0aW9uKHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0ZXAudHlwZSA9PT0gJ2xpdGVyYWwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24obGl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpdC50eXBlID0gJ25hbWUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFueSBzdGVwIHRoYXQgc2lnbmFscyBrZWVwaW5nIGEgc2luZ2xldG9uIGFycmF5LCBzaG91bGQgYmUgZmxhZ2dlZCBvbiB0aGUgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlc3VsdC5zdGVwcy5maWx0ZXIoZnVuY3Rpb24oc3RlcCkgeyByZXR1cm4gc3RlcC5rZWVwQXJyYXkgPT09IHRydWU7fSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQua2VlcFNpbmdsZXRvbkFycmF5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgZmlyc3Qgc3RlcCBpcyBhIHBhdGggY29uc3RydWN0b3IsIGZsYWcgaXQgZm9yIHNwZWNpYWwgaGFuZGxpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQuc3RlcHNbMF0udHlwZSA9PT0gJ3VuYXJ5JyAmJiByZXN1bHQuc3RlcHNbMF0udmFsdWUgPT09ICdbJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RlcHNbMF0uY29uc2FycmF5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcmVkaWNhdGVkIHN0ZXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMSFMgaXMgYSBzdGVwIG9yIGEgcHJlZGljYXRlZCBzdGVwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUkhTIGlzIHRoZSBwcmVkaWNhdGUgZXhwclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGFzdF9vcHRpbWl6ZShleHByLmxocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0ZXAgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVzdWx0LnR5cGUgPT09ICdwYXRoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwID0gcmVzdWx0LnN0ZXBzW3Jlc3VsdC5zdGVwcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGVwLmdyb3VwICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlMwMjA5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHByLnBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RlcC5wcmVkaWNhdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXAucHJlZGljYXRlID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXAucHJlZGljYXRlLnB1c2goYXN0X29wdGltaXplKGV4cHIucmhzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBncm91cC1ieVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExIUyBpcyBhIHN0ZXAgb3IgYSBwcmVkaWNhdGVkIHN0ZXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSSFMgaXMgdGhlIG9iamVjdCBjb25zdHJ1Y3RvciBleHByXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYXN0X29wdGltaXplKGV4cHIubGhzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdC5ncm91cCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJTMDIxMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogZXhwci5wb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvYmplY3QgY29uc3RydWN0b3IgLSBwcm9jZXNzIGVhY2ggcGFpclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ncm91cCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGhzOiBleHByLnJocy5tYXAoZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbYXN0X29wdGltaXplKHBhaXJbMF0pLCBhc3Rfb3B0aW1pemUocGFpclsxXSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3JkZXItYnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMSFMgaXMgdGhlIGFycmF5IHRvIGJlIG9yZGVyZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSSFMgZGVmaW5lcyB0aGUgdGVybXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7dHlwZTogJ3NvcnQnLCB2YWx1ZTogZXhwci52YWx1ZSwgcG9zaXRpb246IGV4cHIucG9zaXRpb259O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5saHMgPSBhc3Rfb3B0aW1pemUoZXhwci5saHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5yaHMgPSBleHByLnJocy5tYXAoZnVuY3Rpb24gKHRlcm1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjZW5kaW5nOiB0ZXJtcy5kZXNjZW5kaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogYXN0X29wdGltaXplKHRlcm1zLmV4cHJlc3Npb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc6PSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge3R5cGU6ICdiaW5kJywgdmFsdWU6IGV4cHIudmFsdWUsIHBvc2l0aW9uOiBleHByLnBvc2l0aW9ufTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubGhzID0gYXN0X29wdGltaXplKGV4cHIubGhzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucmhzID0gYXN0X29wdGltaXplKGV4cHIucmhzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ34+JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7dHlwZTogJ2FwcGx5JywgdmFsdWU6IGV4cHIudmFsdWUsIHBvc2l0aW9uOiBleHByLnBvc2l0aW9ufTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubGhzID0gYXN0X29wdGltaXplKGV4cHIubGhzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucmhzID0gYXN0X29wdGltaXplKGV4cHIucmhzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge3R5cGU6IGV4cHIudHlwZSwgdmFsdWU6IGV4cHIudmFsdWUsIHBvc2l0aW9uOiBleHByLnBvc2l0aW9ufTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubGhzID0gYXN0X29wdGltaXplKGV4cHIubGhzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucmhzID0gYXN0X29wdGltaXplKGV4cHIucmhzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd1bmFyeSc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHt0eXBlOiBleHByLnR5cGUsIHZhbHVlOiBleHByLnZhbHVlLCBwb3NpdGlvbjogZXhwci5wb3NpdGlvbn07XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHByLnZhbHVlID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFycmF5IGNvbnN0cnVjdG9yIC0gcHJvY2VzcyBlYWNoIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5leHByZXNzaW9ucyA9IGV4cHIuZXhwcmVzc2lvbnMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzdF9vcHRpbWl6ZShpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV4cHIudmFsdWUgPT09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdG9yIC0gcHJvY2VzcyBlYWNoIHBhaXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5saHMgPSBleHByLmxocy5tYXAoZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2FzdF9vcHRpbWl6ZShwYWlyWzBdKSwgYXN0X29wdGltaXplKHBhaXJbMV0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxsIG90aGVyIHVuYXJ5IGV4cHJlc3Npb25zIC0ganVzdCBwcm9jZXNzIHRoZSBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZXhwcmVzc2lvbiA9IGFzdF9vcHRpbWl6ZShleHByLmV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdW5hcnkgbWludXMgb24gYSBudW1iZXIsIHRoZW4gcHJlLXByb2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByLnZhbHVlID09PSAnLScgJiYgcmVzdWx0LmV4cHJlc3Npb24udHlwZSA9PT0gJ2xpdGVyYWwnICYmIGlzTnVtZXJpYyhyZXN1bHQuZXhwcmVzc2lvbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuZXhwcmVzc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPSAtcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICBjYXNlICdwYXJ0aWFsJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge3R5cGU6IGV4cHIudHlwZSwgbmFtZTogZXhwci5uYW1lLCB2YWx1ZTogZXhwci52YWx1ZSwgcG9zaXRpb246IGV4cHIucG9zaXRpb259O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXJndW1lbnRzID0gZXhwci5hcmd1bWVudHMubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhc3Rfb3B0aW1pemUoYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wcm9jZWR1cmUgPSBhc3Rfb3B0aW1pemUoZXhwci5wcm9jZWR1cmUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdsYW1iZGEnOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7dHlwZTogZXhwci50eXBlLCBhcmd1bWVudHM6IGV4cHIuYXJndW1lbnRzLCBzaWduYXR1cmU6IGV4cHIuc2lnbmF0dXJlLCBwb3NpdGlvbjogZXhwci5wb3NpdGlvbn07XG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gYXN0X29wdGltaXplKGV4cHIuYm9keSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ib2R5ID0gdGFpbF9jYWxsX29wdGltaXplKGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjb25kaXRpb24nOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7dHlwZTogZXhwci50eXBlLCBwb3NpdGlvbjogZXhwci5wb3NpdGlvbn07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jb25kaXRpb24gPSBhc3Rfb3B0aW1pemUoZXhwci5jb25kaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQudGhlbiA9IGFzdF9vcHRpbWl6ZShleHByLnRoZW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV4cHIuZWxzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5lbHNlID0gYXN0X29wdGltaXplKGV4cHIuZWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndHJhbnNmb3JtJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge3R5cGU6IGV4cHIudHlwZSwgcG9zaXRpb246IGV4cHIucG9zaXRpb259O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucGF0dGVybiA9IGFzdF9vcHRpbWl6ZShleHByLnBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQudXBkYXRlID0gYXN0X29wdGltaXplKGV4cHIudXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGV4cHIuZGVsZXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmRlbGV0ZSA9IGFzdF9vcHRpbWl6ZShleHByLmRlbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYmxvY2snOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7dHlwZTogZXhwci50eXBlLCBwb3NpdGlvbjogZXhwci5wb3NpdGlvbn07XG4gICAgICAgICAgICAgICAgICAgIC8vIGFycmF5IG9mIGV4cHJlc3Npb25zIC0gcHJvY2VzcyBlYWNoIG9uZVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuZXhwcmVzc2lvbnMgPSBleHByLmV4cHJlc3Npb25zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzdF9vcHRpbWl6ZShpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gc2NhbiB0aGUgYXJyYXkgb2YgZXhwcmVzc2lvbnMgdG8gc2VlIGlmIGFueSBvZiB0aGVtIGFzc2lnbiB2YXJpYWJsZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgc28sIG5lZWQgdG8gbWFyayB0aGUgYmxvY2sgYXMgb25lIHRoYXQgbmVlZHMgdG8gY3JlYXRlIGEgbmV3IGZyYW1lXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ25hbWUnOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7dHlwZTogJ3BhdGgnLCBzdGVwczogW2V4cHJdfTtcbiAgICAgICAgICAgICAgICAgICAgaWYoZXhwci5rZWVwQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5rZWVwU2luZ2xldG9uQXJyYXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xpdGVyYWwnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3dpbGRjYXJkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdkZXNjZW5kYW50JzpcbiAgICAgICAgICAgICAgICBjYXNlICd2YXJpYWJsZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAncmVnZXgnOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBleHByO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdvcGVyYXRvcic6XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSB0b2tlbnMgJ2FuZCcgYW5kICdvcicgbWlnaHQgaGF2ZSBiZWVuIHVzZWQgYXMgYSBuYW1lIHJhdGhlciB0aGFuIGFuIG9wZXJhdG9yXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHByLnZhbHVlID09PSAnYW5kJyB8fCBleHByLnZhbHVlID09PSAnb3InIHx8IGV4cHIudmFsdWUgPT09ICdpbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIudHlwZSA9ICduYW1lJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGFzdF9vcHRpbWl6ZShleHByKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovIGlmIChleHByLnZhbHVlID09PSAnPycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhcnRpYWwgYXBwbGljYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV4cHI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJTMDIwMVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHByLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiBleHByLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZXhwcjtcbiAgICAgICAgICAgICAgICAgICAgaWYoZXhwci5saHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGFzdF9vcHRpbWl6ZShleHByLmxocyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBcIlMwMjA2XCI7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHByLmlkID09PSAnKGVuZCknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gXCJTMDIwN1wiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogZXhwci52YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZihyZWNvdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiAnZXJyb3InLCBlcnJvcjogZXJyfTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyci5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbm93IGludm9rZSB0aGUgdG9rZW5pemVyIGFuZCB0aGUgcGFyc2VyIGFuZCByZXR1cm4gdGhlIHN5bnRheCB0cmVlXG4gICAgICAgIGxleGVyID0gdG9rZW5pemVyKHNvdXJjZSk7XG4gICAgICAgIGFkdmFuY2UoKTtcbiAgICAgICAgLy8gcGFyc2UgdGhlIHRva2Vuc1xuICAgICAgICB2YXIgZXhwciA9IGV4cHJlc3Npb24oMCk7XG4gICAgICAgIGlmIChub2RlLmlkICE9PSAnKGVuZCknKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0ge1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiUzAyMDFcIixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogbm9kZS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICB0b2tlbjogbm9kZS52YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgZXhwciA9IGFzdF9vcHRpbWl6ZShleHByKTtcblxuICAgICAgICBpZihlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZXhwci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9O1xuXG4gICAgLy8gU3RhcnQgb2YgRXZhbHVhdG9yIGNvZGVcblxuICAgIHZhciBzdGF0aWNGcmFtZSA9IGNyZWF0ZUZyYW1lKG51bGwpO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdmFsdWUgaXMgYSBmaW5pdGUgbnVtYmVyXG4gICAgICogQHBhcmFtIHtmbG9hdH0gbiAtIG51bWJlciB0byBldmFsdWF0ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIG4gaXMgYSBmaW5pdGUgbnVtYmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdW1lcmljKG4pIHtcbiAgICAgICAgdmFyIGlzTnVtID0gZmFsc2U7XG4gICAgICAgIGlmKHR5cGVvZiBuID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdmFyIG51bSA9IHBhcnNlRmxvYXQobik7XG4gICAgICAgICAgICBpc051bSA9ICFpc05hTihudW0pO1xuICAgICAgICAgICAgaWYgKGlzTnVtICYmICFpc0Zpbml0ZShudW0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIkQxMDAxXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuLFxuICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFja1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTnVtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYXJnIGlzIGFuIGFycmF5IG9mIHN0cmluZ3NcbiAgICAgKiBAcGFyYW0geyp9IGFyZyAtIHRoZSBpdGVtIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBhcmcgaXMgYW4gYXJyYXkgb2Ygc3RyaW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlPZlN0cmluZ3MoYXJnKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAoYXJnLmZpbHRlcihmdW5jdGlvbihpdGVtKXtyZXR1cm4gdHlwZW9mIGl0ZW0gIT09ICdzdHJpbmcnO30pLmxlbmd0aCA9PT0gMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGFyZyBpcyBhbiBhcnJheSBvZiBudW1iZXJzXG4gICAgICogQHBhcmFtIHsqfSBhcmcgLSB0aGUgaXRlbSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYXJnIGlzIGFuIGFycmF5IG9mIG51bWJlcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5T2ZOdW1iZXJzKGFyZykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGlmKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gKGFyZy5maWx0ZXIoZnVuY3Rpb24oaXRlbSl7cmV0dXJuICFpc051bWVyaWMoaXRlbSk7fSkubGVuZ3RoID09PSAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIFBvbHlmaWxsXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBOdW1iZXIuaXNJbnRlZ2VyID0gTnVtYmVyLmlzSW50ZWdlciB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmXG4gICAgICAgICAgaXNGaW5pdGUodmFsdWUpICYmXG4gICAgICAgICAgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBleHByZXNzaW9uIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGVkIGlucHV0IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZXZhbHVhdGUoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgdmFyIGVudHJ5Q2FsbGJhY2sgPSBlbnZpcm9ubWVudC5sb29rdXAoJ19fZXZhbHVhdGVfZW50cnknKTtcbiAgICAgICAgaWYoZW50cnlDYWxsYmFjaykge1xuICAgICAgICAgICAgZW50cnlDYWxsYmFjayhleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3BhdGgnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGVQYXRoKGV4cHIuc3RlcHMsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbm9ybWFsaXplU2VxdWVuY2UocmVzdWx0LCBleHByLmtlZXBTaW5nbGV0b25BcnJheSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGVCaW5hcnkoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3VuYXJ5JzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGV2YWx1YXRlVW5hcnkoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ25hbWUnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV2YWx1YXRlTmFtZShleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbGl0ZXJhbCc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXZhbHVhdGVMaXRlcmFsKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3aWxkY2FyZCc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXZhbHVhdGVXaWxkY2FyZChleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGVzY2VuZGFudCc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXZhbHVhdGVEZXNjZW5kYW50cyhleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29uZGl0aW9uJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGV2YWx1YXRlQ29uZGl0aW9uKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdibG9jayc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBldmFsdWF0ZUJsb2NrKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdiaW5kJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGV2YWx1YXRlQmluZEV4cHJlc3Npb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JlZ2V4JzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBldmFsdWF0ZVJlZ2V4KGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBldmFsdWF0ZUZ1bmN0aW9uKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd2YXJpYWJsZSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXZhbHVhdGVWYXJpYWJsZShleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbGFtYmRhJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBldmFsdWF0ZUxhbWJkYShleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncGFydGlhbCc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBldmFsdWF0ZVBhcnRpYWxBcHBsaWNhdGlvbihleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYXBwbHknOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGVBcHBseUV4cHJlc3Npb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NvcnQnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGVTb3J0RXhwcmVzc2lvbihleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndHJhbnNmb3JtJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBldmFsdWF0ZVRyYW5zZm9ybUV4cHJlc3Npb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGVudmlyb25tZW50Lmxvb2t1cCgnX19qc29uYXRhX2FzeW5jJykgJiZcbiAgICAgICAgICAodHlwZW9mIHJlc3VsdCA9PT0gJ3VuZGVmaW5lZCcgfHwgcmVzdWx0ID09PSBudWxsIHx8IHR5cGVvZiByZXN1bHQudGhlbiAhPT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmKGVudmlyb25tZW50Lmxvb2t1cCgnX19qc29uYXRhX2FzeW5jJykgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSAnZnVuY3Rpb24nICYmIGV4cHIubmV4dEZ1bmN0aW9uICYmIHR5cGVvZiByZXN1bHRbZXhwci5uZXh0RnVuY3Rpb25dID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBhbHRob3VnaCB0aGlzIGlzIGEgJ3RoZW5hYmxlJywgaXQgaXMgY2hhaW5pbmcgYSBkaWZmZXJlbnQgZnVuY3Rpb25cbiAgICAgICAgICAgIC8vIHNvIGRvbid0IHlpZWxkIHNpbmNlIHlpZWxkaW5nIHdpbGwgdHJpZ2dlciB0aGUgLnRoZW4oKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgcmVzdWx0O1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAoZXhwci5oYXNPd25Qcm9wZXJ0eSgncHJlZGljYXRlJykpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogYXBwbHlQcmVkaWNhdGVzKGV4cHIucHJlZGljYXRlLCByZXN1bHQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVNlcXVlbmNlKHJlc3VsdCk7XG5cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwci5oYXNPd25Qcm9wZXJ0eSgnZ3JvdXAnKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBldmFsdWF0ZUdyb3VwRXhwcmVzc2lvbihleHByLmdyb3VwLCByZXN1bHQsIGVudmlyb25tZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBleGl0Q2FsbGJhY2sgPSBlbnZpcm9ubWVudC5sb29rdXAoJ19fZXZhbHVhdGVfZXhpdCcpO1xuICAgICAgICBpZihleGl0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgIGV4aXRDYWxsYmFjayhleHByLCBpbnB1dCwgZW52aXJvbm1lbnQsIHJlc3VsdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIHBhdGggZXhwcmVzc2lvbiBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGV2YWx1YXRlUGF0aChleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpIHtcbiAgICAgICAgdmFyIGlucHV0U2VxdWVuY2U7XG4gICAgICAgIC8vIGV4cHIgaXMgYW4gYXJyYXkgb2Ygc3RlcHNcbiAgICAgICAgLy8gaWYgdGhlIGZpcnN0IHN0ZXAgaXMgYSB2YXJpYWJsZSByZWZlcmVuY2UgKCQuLi4pLCBpbmNsdWRpbmcgcm9vdCByZWZlcmVuY2UgKCQkKSxcbiAgICAgICAgLy8gICB0aGVuIHRoZSBwYXRoIGlzIGFic29sdXRlIHJhdGhlciB0aGFuIHJlbGF0aXZlXG4gICAgICAgIGlmIChleHByWzBdLnR5cGUgPT09ICd2YXJpYWJsZScpIHtcbiAgICAgICAgICAgIGlucHV0U2VxdWVuY2UgPSBbaW5wdXRdOyAvLyBkdW1teSBzaW5nbGV0b24gc2VxdWVuY2UgZm9yIGZpcnN0IChhYnNvbHV0ZSkgc3RlcFxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBpbnB1dFNlcXVlbmNlID0gaW5wdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBpbnB1dCBpcyBub3QgYW4gYXJyYXksIG1ha2UgaXQgc29cbiAgICAgICAgICAgIGlucHV0U2VxdWVuY2UgPSBbaW5wdXRdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdFNlcXVlbmNlO1xuXG4gICAgICAgIC8vIGV2YWx1YXRlIGVhY2ggc3RlcCBpbiB0dXJuXG4gICAgICAgIGZvcih2YXIgaWkgPSAwOyBpaSA8IGV4cHIubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RlcCA9IGV4cHJbaWldO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGUgZmlyc3Qgc3RlcCBpcyBhbiBleHBsaWNpdCBhcnJheSBjb25zdHJ1Y3RvciwgdGhlbiBqdXN0IGV2YWx1YXRlIHRoYXQgKGkuZS4gZG9uJ3QgaXRlcmF0ZSBvdmVyIGEgY29udGV4dCBhcnJheSlcbiAgICAgICAgICAgIGlmKGlpID09PSAwICYmIHN0ZXAuY29uc2FycmF5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0U2VxdWVuY2UgPSB5aWVsZCAqIGV2YWx1YXRlKHN0ZXAsIGlucHV0U2VxdWVuY2UsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0U2VxdWVuY2UgPSB5aWVsZCAqIGV2YWx1YXRlU3RlcChzdGVwLCBpbnB1dFNlcXVlbmNlLCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHR5cGVvZiByZXN1bHRTZXF1ZW5jZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcmVzdWx0U2VxdWVuY2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dFNlcXVlbmNlID0gcmVzdWx0U2VxdWVuY2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0U2VxdWVuY2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIGEgSlNPTmF0YSBzZXF1ZW5jZSAtIHNpbmdsZXRvbiBhcnJheXMgYmVjb21lIGF0b21pYyB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzZXF1ZW5jZSAtIGlucHV0IHNlcXVlbmNlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBrZWVwU2luZ2xldG9uIC0ga2VlcCBzaW5nbGV0b24gc2VxdWVuY2VzIGFzIGFycmF5c1xuICAgICAqIEByZXR1cm5zIHsqfSBub3JtYWxpemVkIHNlcXVlbmNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplU2VxdWVuY2Uoc2VxdWVuY2UsIGtlZXBTaW5nbGV0b24pIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYodHlwZW9mIHNlcXVlbmNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2UgaWYoIUFycmF5LmlzQXJyYXkoc2VxdWVuY2UpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzZXF1ZW5jZTtcbiAgICAgICAgfSBlbHNlIGlmIChzZXF1ZW5jZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmKGtlZXBTaW5nbGV0b24pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzZXF1ZW5jZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gc2VxdWVuY2VbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2VxdWVuY2UubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gc2VxdWVuY2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBhIHN0ZXAgd2l0aGluIGEgcGF0aFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGVkIGlucHV0IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZXZhbHVhdGVTdGVwKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cblxuICAgICAgICBmb3IodmFyIGlpID0gMDsgaWkgPCBpbnB1dC5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICAgIHZhciByZXMgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIsIGlucHV0W2lpXSwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgaWYgKCEoQXJyYXkuaXNBcnJheShyZXMpICYmIChleHByLnZhbHVlICE9PSAnWycgKSkgJiYgIWV4cHIuY29uc2FycmF5KSB7XG4gICAgICAgICAgICAgICAgcmVzID0gW3Jlc107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpcyByZXMgYW4gYXJyYXkgLSBpZiBzbywgZmxhdHRlbiBpdCBpbnRvIHRoZSBwYXJlbnQgYXJyYXlcbiAgICAgICAgICAgIHJlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbm5lclJlcykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5uZXJSZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGlubmVyUmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHByZWRpY2F0ZXMgdG8gaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcmVkaWNhdGVzIC0gUHJlZGljYXRlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gYXBwbHkgcHJlZGljYXRlcyBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmVzdWx0IGFmdGVyIGFwcGx5aW5nIHByZWRpY2F0ZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogYXBwbHlQcmVkaWNhdGVzKHByZWRpY2F0ZXMsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgaW5wdXRTZXF1ZW5jZSA9IGlucHV0O1xuICAgICAgICAvLyBsaHMgcG90ZW50aWFsbHkgaG9sZHMgYW4gYXJyYXlcbiAgICAgICAgLy8gd2Ugd2FudCB0byBpdGVyYXRlIG92ZXIgdGhlIGFycmF5LCBhbmQgb25seSBrZWVwIHRoZSBpdGVtcyB0aGF0IGFyZVxuICAgICAgICAvLyB0cnV0aHkgd2hlbiBhcHBsaWVkIHRvIHRoZSBwcmVkaWNhdGUuXG4gICAgICAgIC8vIGlmIHRoZSBwcmVkaWNhdGUgZXZhbHVhdGVzIHRvIGFuIGludGVnZXIsIHRoZW4gc2VsZWN0IHRoYXQgaW5kZXhcblxuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IodmFyIGlpID0gMDsgaWkgPCBwcmVkaWNhdGVzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgdmFyIHByZWRpY2F0ZSA9IHByZWRpY2F0ZXNbaWldO1xuICAgICAgICAgICAgLy8gaWYgaXQncyBub3QgYW4gYXJyYXksIHR1cm4gaXQgaW50byBvbmVcbiAgICAgICAgICAgIC8vIHNpbmNlIGluIFhQYXRoID49IDIuMCBhbiBpdGVtIGlzIGVxdWl2YWxlbnQgdG8gYSBzaW5nbGV0b24gc2VxdWVuY2Ugb2YgdGhhdCBpdGVtXG4gICAgICAgICAgICAvLyBpZiBpbnB1dCBpcyBub3QgYW4gYXJyYXksIG1ha2UgaXQgc29cbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dFNlcXVlbmNlKSkge1xuICAgICAgICAgICAgICAgIGlucHV0U2VxdWVuY2UgPSBbaW5wdXRTZXF1ZW5jZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlLnR5cGUgPT09ICdsaXRlcmFsJyAmJiBpc051bWVyaWMocHJlZGljYXRlLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHByZWRpY2F0ZS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJvdW5kIGl0IGRvd25cbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb3VudCBpbiBmcm9tIGVuZCBvZiBhcnJheVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGlucHV0U2VxdWVuY2UubGVuZ3RoICsgaW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBpbnB1dFNlcXVlbmNlW2luZGV4XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IHlpZWxkICogZXZhbHVhdGVGaWx0ZXIocHJlZGljYXRlLCBpbnB1dFNlcXVlbmNlLCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dFNlcXVlbmNlID0gcmVzdWx0cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBmaWx0ZXIgcHJlZGljYXRlIHRvIGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJlZGljYXRlIC0gZmlsdGVyIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBJbnB1dCBkYXRhIHRvIGFwcGx5IHByZWRpY2F0ZXMgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IFJlc3VsdCBhZnRlciBhcHBseWluZyBwcmVkaWNhdGVzXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGV2YWx1YXRlRmlsdGVyKHByZWRpY2F0ZSwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGZvcih2YXIgaW5kZXggPSAwOyBpbmRleCA8IGlucHV0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBpbnB1dFtpbmRleF07XG4gICAgICAgICAgICB2YXIgcmVzID0geWllbGQgKiBldmFsdWF0ZShwcmVkaWNhdGUsIGl0ZW0sIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgIGlmIChpc051bWVyaWMocmVzKSkge1xuICAgICAgICAgICAgICAgIHJlcyA9IFtyZXNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoaXNBcnJheU9mTnVtYmVycyhyZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzLmZvckVhY2goZnVuY3Rpb24oaXJlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoaXJlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJvdW5kIGl0IGRvd25cbiAgICAgICAgICAgICAgICAgICAgICAgIGlyZXMgPSBNYXRoLmZsb29yKGlyZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpcmVzIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY291bnQgaW4gZnJvbSBlbmQgb2YgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlyZXMgPSBpbnB1dC5sZW5ndGggKyBpcmVzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpcmVzID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZ1bmN0aW9uQm9vbGVhbihyZXMpKSB7IC8vIHRydXRoeVxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBiaW5hcnkgZXhwcmVzc2lvbiBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gKiBldmFsdWF0ZUJpbmFyeShleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIGxocyA9IHlpZWxkICogZXZhbHVhdGUoZXhwci5saHMsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgIHZhciByaHMgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIucmhzLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICB2YXIgb3AgPSBleHByLnZhbHVlO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV2YWx1YXRlTnVtZXJpY0V4cHJlc3Npb24obGhzLCByaHMsIG9wKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnPSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnIT0nOlxuICAgICAgICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV2YWx1YXRlQ29tcGFyaXNvbkV4cHJlc3Npb24obGhzLCByaHMsIG9wKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnJic6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV2YWx1YXRlU3RyaW5nQ29uY2F0KGxocywgcmhzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYW5kJzpcbiAgICAgICAgICAgICAgICBjYXNlICdvcic6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV2YWx1YXRlQm9vbGVhbkV4cHJlc3Npb24obGhzLCByaHMsIG9wKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnLi4nOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBldmFsdWF0ZVJhbmdlRXhwcmVzc2lvbihsaHMsIHJocyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2luJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZXZhbHVhdGVJbmNsdWRlc0V4cHJlc3Npb24obGhzLCByaHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgIGVyci5wb3NpdGlvbiA9IGV4cHIucG9zaXRpb247XG4gICAgICAgICAgICBlcnIudG9rZW4gPSBvcDtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIHVuYXJ5IGV4cHJlc3Npb24gYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBKU09OYXRhIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBJbnB1dCBkYXRhIHRvIGV2YWx1YXRlIGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW52aXJvbm1lbnQgLSBFbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0ZWQgaW5wdXQgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKiBldmFsdWF0ZVVuYXJ5KGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIHN3aXRjaCAoZXhwci52YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBldmFsdWF0ZShleHByLmV4cHJlc3Npb24sIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTnVtZXJpYyhyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IC1yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJEMTAwMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogZXhwci5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiBleHByLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgICAgIC8vIGFycmF5IGNvbnN0cnVjdG9yIC0gZXZhbHVhdGUgZWFjaCBpdGVtXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yKHZhciBpaSA9IDA7IGlpIDwgZXhwci5leHByZXNzaW9ucy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBleHByLmV4cHJlc3Npb25zW2lpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0geWllbGQgKiBldmFsdWF0ZShpdGVtLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXRlbS52YWx1ZSA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jdGlvbkFwcGVuZChyZXN1bHQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgICAgIC8vIG9iamVjdCBjb25zdHJ1Y3RvciAtIGFwcGx5IGdyb3VwaW5nXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBldmFsdWF0ZUdyb3VwRXhwcmVzc2lvbihleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBuYW1lIG9iamVjdCBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVOYW1lKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICAvLyBsb29rdXAgdGhlICduYW1lJyBpdGVtIGluIHRoZSBpbnB1dFxuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yKHZhciBpaSA9IDA7IGlpIDwgaW5wdXQubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9ICBldmFsdWF0ZU5hbWUoZXhwciwgaW5wdXRbaWldLCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlucHV0ICE9PSBudWxsICYmIHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGlucHV0W2V4cHIudmFsdWVdO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVNlcXVlbmNlKHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgbGl0ZXJhbCBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0ZWQgaW5wdXQgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2YWx1YXRlTGl0ZXJhbChleHByKSB7XG4gICAgICAgIHJldHVybiBleHByLnZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIHdpbGRjYXJkIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHJldHVybnMgeyp9IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVXaWxkY2FyZChleHByLCBpbnB1dCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBpZiAoaW5wdXQgIT09IG51bGwgJiYgdHlwZW9mIGlucHV0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoaW5wdXQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGlucHV0W2tleV07XG4gICAgICAgICAgICAgICAgaWYoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBmbGF0dGVuKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IGZ1bmN0aW9uQXBwZW5kKHJlc3VsdHMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gbm9ybWFsaXplU2VxdWVuY2UocmVzdWx0cyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZsYXR0ZW5lZCBhcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZyAtIHRoZSBhcnJheSB0byBiZSBmbGF0dGVuXG4gICAgICogQHBhcmFtIHtBcnJheX0gZmxhdHRlbmVkIC0gY2FycmllcyB0aGUgZmxhdHRlbmVkIGFycmF5IC0gaWYgbm90IGRlZmluZWQsIHdpbGwgaW5pdGlhbGl6ZSB0byBbXVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gLSB0aGUgZmxhdHRlbmVkIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbihhcmcsIGZsYXR0ZW5lZCkge1xuICAgICAgICBpZih0eXBlb2YgZmxhdHRlbmVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZmxhdHRlbmVkID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICBhcmcuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGZsYXR0ZW4oaXRlbSwgZmxhdHRlbmVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmxhdHRlbmVkLnB1c2goYXJnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmxhdHRlbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIGRlc2NlbmRhbnRzIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHJldHVybnMgeyp9IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVEZXNjZW5kYW50cyhleHByLCBpbnB1dCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgcmVzdWx0U2VxdWVuY2UgPSBbXTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIHRyYXZlcnNlIGFsbCBkZXNjZW5kYW50cyBvZiB0aGlzIG9iamVjdC9hcnJheVxuICAgICAgICAgICAgcmVjdXJzZURlc2NlbmRhbnRzKGlucHV0LCByZXN1bHRTZXF1ZW5jZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0U2VxdWVuY2UubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0U2VxdWVuY2VbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdFNlcXVlbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzZSB0aHJvdWdoIGRlc2NlbmRhbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZXN1bHRzIC0gUmVzdWx0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlY3Vyc2VEZXNjZW5kYW50cyhpbnB1dCwgcmVzdWx0cykge1xuICAgICAgICAvLyB0aGlzIGlzIHRoZSBlcXVpdmFsZW50IG9mIC8vKiBpbiBYUGF0aFxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgaW5wdXQuZm9yRWFjaChmdW5jdGlvbiAobWVtYmVyKSB7XG4gICAgICAgICAgICAgICAgcmVjdXJzZURlc2NlbmRhbnRzKG1lbWJlciwgcmVzdWx0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dCAhPT0gbnVsbCAmJiB0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhpbnB1dCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmVjdXJzZURlc2NlbmRhbnRzKGlucHV0W2tleV0sIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBudW1lcmljIGV4cHJlc3Npb24gYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxocyAtIExIUyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByaHMgLSBSSFMgdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3AgLSBvcGNvZGVcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmVzdWx0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVOdW1lcmljRXhwcmVzc2lvbihsaHMsIHJocywgb3ApIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHJocyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIGlmIGVpdGhlciBzaWRlIGlzIHVuZGVmaW5lZCwgdGhlIHJlc3VsdCBpcyB1bmRlZmluZWRcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVtZXJpYyhsaHMpKSB7XG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgY29kZTogXCJUMjAwMVwiLFxuICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBsaHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc051bWVyaWMocmhzKSkge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiVDIwMDJcIixcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmhzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbGhzICsgcmhzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbGhzIC0gcmhzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbGhzICogcmhzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbGhzIC8gcmhzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbGhzICUgcmhzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgY29tcGFyaXNvbiBleHByZXNzaW9uIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsaHMgLSBMSFMgdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmhzIC0gUkhTIHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wIC0gb3Bjb2RlXG4gICAgICogQHJldHVybnMgeyp9IFJlc3VsdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2YWx1YXRlQ29tcGFyaXNvbkV4cHJlc3Npb24obGhzLCByaHMsIG9wKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgLy8gdHlwZSBjaGVja3NcbiAgICAgICAgdmFyIGx0eXBlID0gdHlwZW9mIGxocztcbiAgICAgICAgdmFyIHJ0eXBlID0gdHlwZW9mIHJocztcblxuICAgICAgICBpZiAobHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHJ0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gaWYgZWl0aGVyIHNpZGUgaXMgdW5kZWZpbmVkLCB0aGUgcmVzdWx0IGlzIGZhbHNlXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGlmIGFhIG9yIGJiIGFyZSBub3Qgc3RyaW5nIG9yIG51bWVyaWMgdmFsdWVzLCB0aGVuIHRocm93IGFuIGVycm9yXG4gICAgICAgICAgICBpZiAoIShsdHlwZSA9PT0gJ3N0cmluZycgfHwgbHR5cGUgPT09ICdudW1iZXInKSB8fCAhKHJ0eXBlID09PSAnc3RyaW5nJyB8fCBydHlwZSA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlQyMDEwXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogIShsdHlwZSA9PT0gJ3N0cmluZycgfHwgbHR5cGUgPT09ICdudW1iZXInKSA/IGxocyA6IHJoc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vaWYgYWEgYW5kIGJiIGFyZSBub3Qgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAgICAgICAgaWYgKGx0eXBlICE9PSBydHlwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogXCJUMjAwOVwiLFxuICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGxocyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUyOiByaHNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgICAgIGNhc2UgJz0nOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxocyA9PT0gcmhzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnIT0nOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IChsaHMgIT09IHJocyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxocyA8IHJocztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxocyA8PSByaHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxocyA+IHJocztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxocyA+PSByaHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmNsdXNpb24gb3BlcmF0b3IgLSBpblxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxocyAtIExIUyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByaHMgLSBSSFMgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlIGlmIGxocyBpcyBhIG1lbWJlciBvZiByaHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmFsdWF0ZUluY2x1ZGVzRXhwcmVzc2lvbihsaHMsIHJocykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiByaHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBpZiBlaXRoZXIgc2lkZSBpcyB1bmRlZmluZWQsIHRoZSByZXN1bHQgaXMgZmFsc2VcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFBcnJheS5pc0FycmF5KHJocykpIHtcbiAgICAgICAgICAgIHJocyA9IFtyaHNdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHJocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYocmhzW2ldID09PSBsaHMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBib29sZWFuIGV4cHJlc3Npb24gYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxocyAtIExIUyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByaHMgLSBSSFMgdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3AgLSBvcGNvZGVcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmVzdWx0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVCb29sZWFuRXhwcmVzc2lvbihsaHMsIHJocywgb3ApIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgICAgICBjYXNlICdhbmQnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmN0aW9uQm9vbGVhbihsaHMpICYmIGZ1bmN0aW9uQm9vbGVhbihyaHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnb3InOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmN0aW9uQm9vbGVhbihsaHMpIHx8IGZ1bmN0aW9uQm9vbGVhbihyaHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgc3RyaW5nIGNvbmNhdGVuYXRpb24gYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxocyAtIExIUyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByaHMgLSBSSFMgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfCp9IENvbmNhdGVuYXRlZCBzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmFsdWF0ZVN0cmluZ0NvbmNhdChsaHMsIHJocykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIHZhciBsc3RyID0gJyc7XG4gICAgICAgIHZhciByc3RyID0gJyc7XG4gICAgICAgIGlmICh0eXBlb2YgbGhzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbHN0ciA9IGZ1bmN0aW9uU3RyaW5nKGxocyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByaHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByc3RyID0gZnVuY3Rpb25TdHJpbmcocmhzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IGxzdHIuY29uY2F0KHJzdHIpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIGdyb3VwIGV4cHJlc3Npb24gYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBKU09OYXRhIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBJbnB1dCBkYXRhIHRvIGV2YWx1YXRlIGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW52aXJvbm1lbnQgLSBFbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHt7fX0gRXZhbHVhdGVkIGlucHV0IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZXZhbHVhdGVHcm91cEV4cHJlc3Npb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgdmFyIGdyb3VwcyA9IHt9O1xuICAgICAgICAvLyBncm91cCB0aGUgaW5wdXQgc2VxdWVuY2UgYnkgJ2tleScgZXhwcmVzc2lvblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBpbnB1dCA9IFtpbnB1dF07XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHZhciBpdGVtSW5kZXggPSAwOyBpdGVtSW5kZXggPCBpbnB1dC5sZW5ndGg7IGl0ZW1JbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGlucHV0W2l0ZW1JbmRleF07XG4gICAgICAgICAgICBmb3IodmFyIHBhaXJJbmRleCA9IDA7IHBhaXJJbmRleCA8IGV4cHIubGhzLmxlbmd0aDsgcGFpckluZGV4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFpciA9IGV4cHIubGhzW3BhaXJJbmRleF07XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHlpZWxkICogZXZhbHVhdGUocGFpclswXSwgaXRlbSwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIC8vIGtleSBoYXMgdG8gYmUgYSBzdHJpbmdcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mICBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiVDEwMDNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToga2V5XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHtkYXRhOiBpdGVtLCBleHByOiBwYWlyWzFdfTtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYSB2YWx1ZSBhbHJlYWR5IGV4aXN0cyBpbiB0aGlzIHNsb3RcbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwZW5kIGl0IGFzIGFuIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIGdyb3Vwc1trZXldLmRhdGEgPSBmdW5jdGlvbkFwcGVuZChncm91cHNba2V5XS5kYXRhLCBpdGVtKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncm91cHNba2V5XSA9IGVudHJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGl0ZXJhdGUgb3ZlciB0aGUgZ3JvdXBzIHRvIGV2YWx1YXRlIHRoZSAndmFsdWUnIGV4cHJlc3Npb25cbiAgICAgICAgZm9yIChrZXkgaW4gZ3JvdXBzKSB7XG4gICAgICAgICAgICBlbnRyeSA9IGdyb3Vwc1trZXldO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0geWllbGQgKiBldmFsdWF0ZShlbnRyeS5leHByLCBlbnRyeS5kYXRhLCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICBpZih0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgcmFuZ2UgZXhwcmVzc2lvbiBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbGhzIC0gTEhTIHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJocyAtIFJIUyB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmVzdWx0YW50IGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVSYW5nZUV4cHJlc3Npb24obGhzLCByaHMpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHJocyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIGlmIGVpdGhlciBzaWRlIGlzIHVuZGVmaW5lZCwgdGhlIHJlc3VsdCBpcyB1bmRlZmluZWRcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGhzID4gcmhzKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgbGhzIGlzIGdyZWF0ZXIgdGhhbiB0aGUgcmhzLCByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGxocykpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIlQyMDAzXCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgdmFsdWU6IGxoc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIocmhzKSkge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiVDIwMDRcIixcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmhzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gbmV3IEFycmF5KHJocyAtIGxocyArIDEpO1xuICAgICAgICBmb3IgKHZhciBpdGVtID0gbGhzLCBpbmRleCA9IDA7IGl0ZW0gPD0gcmhzOyBpdGVtKyssIGluZGV4KyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgYmluZCBleHByZXNzaW9uIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGVkIGlucHV0IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZXZhbHVhdGVCaW5kRXhwcmVzc2lvbihleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpIHtcbiAgICAgICAgLy8gVGhlIFJIUyBpcyB0aGUgZXhwcmVzc2lvbiB0byBldmFsdWF0ZVxuICAgICAgICAvLyBUaGUgTEhTIGlzIHRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZSB0byBiaW5kIHRvIC0gc2hvdWxkIGJlIGEgVkFSSUFCTEUgdG9rZW5cbiAgICAgICAgdmFyIHZhbHVlID0geWllbGQgKiBldmFsdWF0ZShleHByLnJocywgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgaWYgKGV4cHIubGhzLnR5cGUgIT09ICd2YXJpYWJsZScpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkQyMDA1XCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgdG9rZW46IGV4cHIudmFsdWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGV4cHIubGhzLnR5cGUgPT09ICdwYXRoJyA/IGV4cHIubGhzLnN0ZXBzWzBdLnZhbHVlIDogZXhwci5saHMudmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZW52aXJvbm1lbnQuYmluZChleHByLmxocy52YWx1ZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgY29uZGl0aW9uIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGVkIGlucHV0IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZXZhbHVhdGVDb25kaXRpb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciBjb25kaXRpb24gPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIuY29uZGl0aW9uLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICBpZiAoZnVuY3Rpb25Cb29sZWFuKGNvbmRpdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGUoZXhwci50aGVuLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHByLmVsc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIuZWxzZSwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIGJsb2NrIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGVkIGlucHV0IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZXZhbHVhdGVCbG9jayhleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgLy8gY3JlYXRlIGEgbmV3IGZyYW1lIHRvIGxpbWl0IHRoZSBzY29wZSBvZiB2YXJpYWJsZSBhc3NpZ25tZW50c1xuICAgICAgICAvLyBUT0RPLCBvbmx5IGRvIHRoaXMgaWYgdGhlIHBvc3QtcGFyc2Ugc3RhZ2UgaGFzIGZsYWdnZWQgdGhpcyBhcyByZXF1aXJlZFxuICAgICAgICB2YXIgZnJhbWUgPSBjcmVhdGVGcmFtZShlbnZpcm9ubWVudCk7XG4gICAgICAgIC8vIGludm9rZSBlYWNoIGV4cHJlc3Npb24gaW4gdHVyblxuICAgICAgICAvLyBvbmx5IHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IG9uZVxuICAgICAgICBmb3IodmFyIGlpID0gMDsgaWkgPCBleHByLmV4cHJlc3Npb25zLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBldmFsdWF0ZShleHByLmV4cHJlc3Npb25zW2lpXSwgaW5wdXQsIGZyYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZSBhIHJlZ2V4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBleHByZXNzaW9uIGNvbnRhaW5pbmcgcmVnZXhcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEhpZ2hlciBvcmRlciBmdW5jdGlvbiByZXByZXNlbnRpbmcgcHJlcGFyZWQgcmVnZXhcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmFsdWF0ZVJlZ2V4KGV4cHIpIHtcbiAgICAgICAgZXhwci52YWx1ZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICB2YXIgY2xvc3VyZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgdmFyIHJlID0gZXhwci52YWx1ZTtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSByZS5leGVjKHN0cik7XG4gICAgICAgICAgICBpZihtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2g6IG1hdGNoWzBdLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogbWF0Y2guaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwczogW11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmKG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IG1hdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZ3JvdXBzLnB1c2gobWF0Y2hbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHJlLmxhc3RJbmRleCA+PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBjbG9zdXJlKHN0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihuZXh0ICYmIG5leHQubWF0Y2ggPT09ICcnICYmIHJlLmxhc3RJbmRleCA9PT0gZXhwci52YWx1ZS5sYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaGVzIHplcm8gbGVuZ3RoIHN0cmluZzsgdGhpcyB3aWxsIG5ldmVyIHByb2dyZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIkQxMDA0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogZXhwci5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGV4cHIudmFsdWUuc291cmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNsb3N1cmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgdmFyaWFibGUgYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBKU09OYXRhIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBJbnB1dCBkYXRhIHRvIGV2YWx1YXRlIGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW52aXJvbm1lbnQgLSBFbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0ZWQgaW5wdXQgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2YWx1YXRlVmFyaWFibGUoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIC8vIGxvb2t1cCB0aGUgdmFyaWFibGUgdmFsdWUgaW4gdGhlIGVudmlyb25tZW50XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIC8vIGlmIHRoZSB2YXJpYWJsZSBuYW1lIGlzIGVtcHR5IHN0cmluZywgdGhlbiBpdCByZWZlcnMgdG8gY29udGV4dCB2YWx1ZVxuICAgICAgICBpZiAoZXhwci52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGlucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gZW52aXJvbm1lbnQubG9va3VwKGV4cHIudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc29ydCAvIG9yZGVyLWJ5IG9wZXJhdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBBU1QgZm9yIG9wZXJhdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gT3JkZXJlZCBzZXF1ZW5jZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKiBldmFsdWF0ZVNvcnRFeHByZXNzaW9uKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIC8vIGV2YWx1YXRlIHRoZSBsaHMsIHRoZW4gc29ydCB0aGUgcmVzdWx0cyBpbiBvcmRlciBhY2NvcmRpbmcgdG8gcmhzIGV4cHJlc3Npb25cbiAgICAgICAgdmFyIGxocyA9IHlpZWxkICogZXZhbHVhdGUoZXhwci5saHMsIGlucHV0LCBlbnZpcm9ubWVudCk7XG5cbiAgICAgICAgLy8gc29ydCB0aGUgbGhzIGFycmF5XG4gICAgICAgIC8vIHVzZSBjb21wYXJhdG9yIGZ1bmN0aW9uXG4gICAgICAgIHZhciBjb21wYXJhdG9yID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgLy8gZXhwci5yaHMgaXMgYW4gYXJyYXkgb2Ygb3JkZXItYnkgaW4gcHJpb3JpdHkgb3JkZXJcbiAgICAgICAgICAgIHZhciBjb21wID0gMDtcbiAgICAgICAgICAgIGZvcih2YXIgaW5kZXggPSAwOyBjb21wID09PSAwICYmIGluZGV4IDwgZXhwci5yaHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlcm0gPSBleHByLnJoc1tpbmRleF07XG4gICAgICAgICAgICAgICAgLy9ldmFsdWF0ZSB0aGUgcmhzIGV4cHJlc3Npb24gaW4gdGhlIGNvbnRleHQgb2YgYVxuICAgICAgICAgICAgICAgIHZhciBhYSA9IGRyaXZlR2VuZXJhdG9yKHRlcm0uZXhwcmVzc2lvbiwgYSwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIC8vZXZhbHVhdGUgdGhlIHJocyBleHByZXNzaW9uIGluIHRoZSBjb250ZXh0IG9mIGJcbiAgICAgICAgICAgICAgICB2YXIgYmIgPSBkcml2ZUdlbmVyYXRvcih0ZXJtLmV4cHJlc3Npb24sIGIsIGVudmlyb25tZW50KTtcblxuICAgICAgICAgICAgICAgIC8vIHR5cGUgY2hlY2tzXG4gICAgICAgICAgICAgICAgdmFyIGF0eXBlID0gdHlwZW9mIGFhO1xuICAgICAgICAgICAgICAgIHZhciBidHlwZSA9IHR5cGVvZiBiYjtcbiAgICAgICAgICAgICAgICAvLyB1bmRlZmluZWQgc2hvdWxkIGJlIGxhc3QgaW4gc29ydCBvcmRlclxuICAgICAgICAgICAgICAgIGlmKGF0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBzd2FwIHRoZW0sIHVubGVzcyBidHlwZSBpcyBhbHNvIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICBjb21wID0gKGJ0eXBlID09PSAndW5kZWZpbmVkJykgPyAwIDogMTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKGJ0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIGFhIG9yIGJiIGFyZSBub3Qgc3RyaW5nIG9yIG51bWVyaWMgdmFsdWVzLCB0aGVuIHRocm93IGFuIGVycm9yXG4gICAgICAgICAgICAgICAgaWYoIShhdHlwZSA9PT0gJ3N0cmluZycgfHwgYXR5cGUgPT09ICdudW1iZXInKSB8fCAhKGJ0eXBlID09PSAnc3RyaW5nJyB8fCBidHlwZSA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiVDIwMDhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogIShhdHlwZSA9PT0gJ3N0cmluZycgfHwgYXR5cGUgPT09ICdudW1iZXInKSA/IGFhIDogYmJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL2lmIGFhIGFuZCBiYiBhcmUgbm90IG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgICAgICAgICAgICBpZihhdHlwZSAhPT0gYnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJUMjAwN1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogZXhwci5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlMjogYmJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoYWEgPT09IGJiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJvdGggdGhlIHNhbWUgLSBtb3ZlIG9uIHRvIG5leHQgdGVybVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFhIDwgYmIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcCA9IC0xO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXAgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZih0ZXJtLmRlc2NlbmRpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcCA9IC1jb21wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG9ubHkgc3dhcCBhICYgYiBpZiBjb21wIGVxdWFscyAxXG4gICAgICAgICAgICByZXR1cm4gY29tcCA9PT0gMTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXN1bHQgPSBmdW5jdGlvblNvcnQobGhzLCBjb21wYXJhdG9yKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBhIHRyYW5zZm9ybWVyIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBBU1QgZm9yIG9wZXJhdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gdHJhbmZvcm1lciBmdW5jdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2YWx1YXRlVHJhbnNmb3JtRXhwcmVzc2lvbihleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpIHtcbiAgICAgICAgLy8gY3JlYXRlIGEgZnVuY3Rpb24gdG8gaW1wbGVtZW50IHRoZSB0cmFuc2Zvcm0gZGVmaW5pdGlvblxuICAgICAgICB2YXIgdHJhbnNmb3JtZXIgPSBmdW5jdGlvbioob2JqKSB7IC8vIHNpZ25hdHVyZSA8KG9hKTpvPlxuICAgICAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICAgICAgaWYodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYSBjb3B5IG9mIG9iaiB3aXRoIGNoYW5nZXMgc3BlY2lmaWVkIGJ5IHRoZSBwYXR0ZXJuL29wZXJhdGlvblxuICAgICAgICAgICAgdmFyIGNsb25lRnVuY3Rpb24gPSBlbnZpcm9ubWVudC5sb29rdXAoJ2Nsb25lJyk7XG4gICAgICAgICAgICBpZighaXNGdW5jdGlvbihjbG9uZUZ1bmN0aW9uKSkge1xuICAgICAgICAgICAgICAgIC8vIHRocm93IHR5cGUgZXJyb3JcbiAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiVDIwMTNcIixcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHByLnBvc2l0aW9uXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB5aWVsZCAqIGFwcGx5KGNsb25lRnVuY3Rpb24sIFtvYmpdLCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IHlpZWxkICogZXZhbHVhdGUoZXhwci5wYXR0ZXJuLCByZXN1bHQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgIGlmKHR5cGVvZiBtYXRjaGVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGlmKCFBcnJheS5pc0FycmF5KG1hdGNoZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMgPSBbbWF0Y2hlc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvcih2YXIgaWkgPSAwOyBpaSA8IG1hdGNoZXMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IG1hdGNoZXNbaWldO1xuICAgICAgICAgICAgICAgICAgICAvLyBldmFsdWF0ZSB0aGUgdXBkYXRlIHZhbHVlIGZvciBlYWNoIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGUgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIudXBkYXRlLCBtYXRjaCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgbXVzdCBiZSBhbiBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZVR5cGUgPSB0eXBlb2YgdXBkYXRlO1xuICAgICAgICAgICAgICAgICAgICBpZih1cGRhdGVUeXBlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodXBkYXRlVHlwZSAhPT0gJ29iamVjdCcgfHwgdXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3cgdHlwZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJUMjAxMVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIudXBkYXRlLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdXBkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1lcmdlIHRoZSB1cGRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgcHJvcCBpbiB1cGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFtwcm9wXSA9IHVwZGF0ZVtwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSwgaWYgc3BlY2lmaWVkLCBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ3MgKG9yIHNpbmdsZSBzdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBleHByLmRlbGV0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWxldGlvbnMgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIuZGVsZXRlLCBtYXRjaCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGRlbGV0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gZGVsZXRpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkZWxldGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0aW9ucyA9IFtkZWxldGlvbnNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXlPZlN0cmluZ3MoZGVsZXRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aHJvdyB0eXBlIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiVDIwMTJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIuZGVsZXRlLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqaiA9IDA7IGpqIDwgZGVsZXRpb25zLmxlbmd0aDsgamorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgbWF0Y2hbZGVsZXRpb25zW2pqXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBkZWZpbmVGdW5jdGlvbih0cmFuc2Zvcm1lciwgJzwob2EpOm8+Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgYW4gZXhwcmVzc2lvbiBieSBkcml2aW5nIHRoZSBnZW5lcmF0b3IgdG8gY29tcGxldGlvblxuICAgICAqIFVzZWQgd2hlbiBpdCdzIG5vdCBwb3NzaWJsZSB0byB5aWVsZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gQVNUXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gcmVzdWx0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJpdmVHZW5lcmF0b3IoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIHZhciBnZW4gPSBldmFsdWF0ZShleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAvLyByZXR1cm5zIGEgZ2VuZXJhdG9yIC0gc28gaXRlcmF0ZSBvdmVyIGl0XG4gICAgICAgIHZhciBjb21wID0gZ2VuLm5leHQoKTtcbiAgICAgICAgd2hpbGUgKCFjb21wLmRvbmUpIHtcbiAgICAgICAgICAgIGNvbXAgPSBnZW4ubmV4dChjb21wLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcC52YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgY2hhaW4gPSBkcml2ZUdlbmVyYXRvcihwYXJzZXIoJ2Z1bmN0aW9uKCRmLCAkZykgeyBmdW5jdGlvbigkeCl7ICRnKCRmKCR4KSkgfSB9JyksIG51bGwsIHN0YXRpY0ZyYW1lKTtcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBmdW5jdGlvbiBvbiB0aGUgUkhTIHVzaW5nIHRoZSBzZXF1ZW5jZSBvbiB0aGUgTEhTIGFzIHRoZSBmaXJzdCBhcmd1bWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGVkIGlucHV0IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZXZhbHVhdGVBcHBseUV4cHJlc3Npb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cblxuICAgICAgICBpZihleHByLnJocy50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgZnVuY3Rpb24gX2ludm9jYXRpb25fOyBpbnZva2UgaXQgd2l0aCBsaHMgZXhwcmVzc2lvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICAgICAgICAgIGV4cHIucmhzLmFyZ3VtZW50cy51bnNoaWZ0KGV4cHIubGhzKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGVGdW5jdGlvbihleHByLnJocywgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgIGV4cHIucmhzLmFyZ3VtZW50cy5zaGlmdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxocyA9IHlpZWxkICogZXZhbHVhdGUoZXhwci5saHMsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICB2YXIgZnVuYyA9IHlpZWxkICogZXZhbHVhdGUoZXhwci5yaHMsIGlucHV0LCBlbnZpcm9ubWVudCk7XG5cbiAgICAgICAgICAgIGlmKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlQyMDA2XCIsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogZXhwci5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihpc0Z1bmN0aW9uKGxocykpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGZ1bmN0aW9uIGNoYWluaW5nIChmdW5jMSB+PiBmdW5jMilcbiAgICAgICAgICAgICAgICAvLyDOuygkZiwgJGcpIHsgzrsoJHgpeyAkZygkZigkeCkpIH0gfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogYXBwbHkoY2hhaW4sIFtsaHMsIGZ1bmNdLCBlbnZpcm9ubWVudCwgbnVsbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogYXBwbHkoZnVuYywgW2xoc10sIGVudmlyb25tZW50LCBudWxsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmcgLSBleHByZXNzaW9uIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlIGlmIGl0IGlzIGEgZnVuY3Rpb24gKGxhbWJkYSBvciBidWlsdC1pbilcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gKChhcmcgJiYgKGFyZy5fanNvbmF0YV9mdW5jdGlvbiA9PT0gdHJ1ZSB8fCBhcmcuX2pzb25hdGFfbGFtYmRhID09PSB0cnVlKSkgfHwgdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVzdHMgd2hldGhlciBhcmcgaXMgYSBsYW1iZGEgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyp9IGFyZyAtIHRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IC0gdHJ1ZSBpZiBpdCBpcyBhIGxhbWJkYSBmdW5jdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTGFtYmRhKGFyZykge1xuICAgICAgICByZXR1cm4gYXJnICYmIGFyZy5fanNvbmF0YV9sYW1iZGEgPT09IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZyAtIGV4cHJlc3Npb24gdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUgaWYgaXQgaXMgYSBnZW5lcmF0b3IgaS5lLiB0aGUgcmVzdWx0IGZyb20gY2FsbGluZyBhXG4gICAgICogZ2VuZXJhdG9yIGZ1bmN0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNHZW5lcmF0b3IoYXJnKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgYXJnICE9PSBudWxsICYmXG4gICAgICAgICAgICBTeW1ib2wuaXRlcmF0b3IgaW4gYXJnICYmXG4gICAgICAgICAgICB0eXBlb2YgYXJnW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICduZXh0JyBpbiBhcmcgJiZcbiAgICAgICAgICAgIHR5cGVvZiBhcmcubmV4dCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIGZ1bmN0aW9uIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2FwcGx5dG9dIC0gTEhTIG9mIH4+IG9wZXJhdG9yXG4gICAgICogQHJldHVybnMgeyp9IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGV2YWx1YXRlRnVuY3Rpb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBwcm9jZWR1cmVcbiAgICAgICAgLy8gY2FuJ3QgYXNzdW1lIHRoYXQgZXhwci5wcm9jZWR1cmUgaXMgYSBsYW1iZGEgdHlwZSBkaXJlY3RseVxuICAgICAgICAvLyBjb3VsZCBiZSBhbiBleHByZXNzaW9uIHRoYXQgZXZhbHVhdGVzIHRvIGEgZnVuY3Rpb24gKGUuZy4gdmFyaWFibGUgcmVmZXJlbmNlLCBwYXJlbnMgZXhwciBldGMuXG4gICAgICAgIC8vIGV2YWx1YXRlIGl0IGdlbmVyaWNhbGx5IGZpcnN0LCB0aGVuIGNoZWNrIHRoYXQgaXQgaXMgYSBmdW5jdGlvbi4gIFRocm93IGVycm9yIGlmIG5vdC5cbiAgICAgICAgdmFyIHByb2MgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIucHJvY2VkdXJlLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvYyA9PT0gJ3VuZGVmaW5lZCcgJiYgZXhwci5wcm9jZWR1cmUudHlwZSA9PT0gJ3BhdGgnICYmIGVudmlyb25tZW50Lmxvb2t1cChleHByLnByb2NlZHVyZS5zdGVwc1swXS52YWx1ZSkpIHtcbiAgICAgICAgICAgIC8vIGhlbHAgdGhlIHVzZXIgb3V0IGhlcmUgaWYgdGhleSBzaW1wbHkgZm9yZ290IHRoZSBsZWFkaW5nICRcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIlQxMDA1XCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgdG9rZW46IGV4cHIucHJvY2VkdXJlLnN0ZXBzWzBdLnZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV2YWx1YXRlZEFyZ3MgPSBbXTtcbiAgICAgICAgLy8gZWFnZXIgZXZhbHVhdGlvbiAtIGV2YWx1YXRlIHRoZSBhcmd1bWVudHNcbiAgICAgICAgZm9yICh2YXIgamogPSAwOyBqaiA8IGV4cHIuYXJndW1lbnRzLmxlbmd0aDsgamorKykge1xuICAgICAgICAgICAgLy8gb25seSBldmFsdWF0ZSAnZWFnZXInIGFyZ3VtZW50cyBhdCB0aGlzIHN0YWdlOyB3cmFwIHRoZSAnbGF6eScgb25lcyBpbiBhIGNsb3N1cmVcbiAgICAgICAgICAgIGV2YWx1YXRlZEFyZ3MucHVzaCh5aWVsZCogZXZhbHVhdGUoZXhwci5hcmd1bWVudHNbampdLCBpbnB1dCwgZW52aXJvbm1lbnQpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBseSB0aGUgcHJvY2VkdXJlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBpZihpbnB1dCBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgLy8gICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnB1dCwgJ19fZW52X18nLCB7XG4gICAgICAgICAgICAvLyAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgLy8gICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAvLyAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gICAgICAgICAgICAgcmV0dXJuIGVudmlyb25tZW50O1xuICAgICAgICAgICAgLy8gICAgICAgICB9XG4gICAgICAgICAgICAvLyAgICAgfSk7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGFwcGx5KHByb2MsIGV2YWx1YXRlZEFyZ3MsIGlucHV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBhZGQgdGhlIHBvc2l0aW9uIGZpZWxkIHRvIHRoZSBlcnJvclxuICAgICAgICAgICAgZXJyLnBvc2l0aW9uID0gZXhwci5wb3NpdGlvbjtcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgZnVuY3Rpb24gaWRlbnRpZmllclxuICAgICAgICAgICAgZXJyLnRva2VuID0gZXhwci5wcm9jZWR1cmUudHlwZSA9PT0gJ3BhdGgnID8gZXhwci5wcm9jZWR1cmUuc3RlcHNbMF0udmFsdWUgOiBleHByLnByb2NlZHVyZS52YWx1ZTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHByb2NlZHVyZSBvciBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9jIC0gUHJvY2VkdXJlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyAtIEFyZ3VtZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZWxmIC0gU2VsZlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXN1bHQgb2YgcHJvY2VkdXJlXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGFwcGx5KHByb2MsIGFyZ3MsIHNlbGYpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgcmVzdWx0ID0geWllbGQgKiBhcHBseUlubmVyKHByb2MsIGFyZ3MsIHNlbGYpO1xuICAgICAgICB3aGlsZShpc0xhbWJkYShyZXN1bHQpICYmIHJlc3VsdC50aHVuayA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gdHJhbXBvbGluZSBsb29wIC0gdGhpcyBnZXRzIGludm9rZWQgYXMgYSByZXN1bHQgb2YgdGFpbC1jYWxsIG9wdGltaXphdGlvblxuICAgICAgICAgICAgLy8gdGhlIGZ1bmN0aW9uIHJldHVybmVkIGEgdGFpbC1jYWxsIHRodW5rXG4gICAgICAgICAgICAvLyB1bnBhY2sgaXQsIGV2YWx1YXRlIGl0cyBhcmd1bWVudHMsIGFuZCBhcHBseSB0aGUgdGFpbCBjYWxsXG4gICAgICAgICAgICB2YXIgbmV4dCA9IHlpZWxkICogZXZhbHVhdGUocmVzdWx0LmJvZHkucHJvY2VkdXJlLCByZXN1bHQuaW5wdXQsIHJlc3VsdC5lbnZpcm9ubWVudCk7XG4gICAgICAgICAgICB2YXIgZXZhbHVhdGVkQXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yKHZhciBpaSA9IDA7IGlpIDwgcmVzdWx0LmJvZHkuYXJndW1lbnRzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgICAgIGV2YWx1YXRlZEFyZ3MucHVzaCh5aWVsZCAqIGV2YWx1YXRlKHJlc3VsdC5ib2R5LmFyZ3VtZW50c1tpaV0sIHJlc3VsdC5pbnB1dCwgcmVzdWx0LmVudmlyb25tZW50KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogYXBwbHlJbm5lcihuZXh0LCBldmFsdWF0ZWRBcmdzLCBzZWxmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHByb2NlZHVyZSBvciBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9jIC0gUHJvY2VkdXJlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyAtIEFyZ3VtZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZWxmIC0gU2VsZlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXN1bHQgb2YgcHJvY2VkdXJlXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGFwcGx5SW5uZXIocHJvYywgYXJncywgc2VsZikge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgdmFsaWRhdGVkQXJncyA9IGFyZ3M7XG4gICAgICAgIGlmKHByb2MpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlZEFyZ3MgPSB2YWxpZGF0ZUFyZ3VtZW50cyhwcm9jLnNpZ25hdHVyZSwgYXJncywgc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTGFtYmRhKHByb2MpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGFwcGx5UHJvY2VkdXJlKHByb2MsIHZhbGlkYXRlZEFyZ3MpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2MgJiYgcHJvYy5fanNvbmF0YV9mdW5jdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcHJvYy5pbXBsZW1lbnRhdGlvbi5hcHBseShzZWxmLCB2YWxpZGF0ZWRBcmdzKTtcbiAgICAgICAgICAgIC8vIGBwcm9jLmltcGxlbWVudGF0aW9uYCBtaWdodCBiZSBhIGdlbmVyYXRvciBmdW5jdGlvblxuICAgICAgICAgICAgLy8gYW5kIGByZXN1bHRgIG1pZ2h0IGJlIGEgZ2VuZXJhdG9yIC0gaWYgc28sIHlpZWxkXG4gICAgICAgICAgICBpZihpc0dlbmVyYXRvcihyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKnJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmVzdWx0ID0gcHJvYy5hcHBseShzZWxmLCB2YWxpZGF0ZWRBcmdzKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZihpc0dlbmVyYXRvcihyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKnJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIlQxMDA2XCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2tcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBsYW1iZGEgYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBKU09OYXRhIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBJbnB1dCBkYXRhIHRvIGV2YWx1YXRlIGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW52aXJvbm1lbnQgLSBFbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHt7bGFtYmRhOiBib29sZWFuLCBpbnB1dDogKiwgZW52aXJvbm1lbnQ6ICosIGFyZ3VtZW50czogKiwgYm9keTogKn19IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVMYW1iZGEoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIC8vIG1ha2UgYSBmdW5jdGlvbiAoY2xvc3VyZSlcbiAgICAgICAgdmFyIHByb2NlZHVyZSA9IHtcbiAgICAgICAgICAgIF9qc29uYXRhX2xhbWJkYTogdHJ1ZSxcbiAgICAgICAgICAgIGlucHV0OiBpbnB1dCxcbiAgICAgICAgICAgIGVudmlyb25tZW50OiBlbnZpcm9ubWVudCxcbiAgICAgICAgICAgIGFyZ3VtZW50czogZXhwci5hcmd1bWVudHMsXG4gICAgICAgICAgICBzaWduYXR1cmU6IGV4cHIuc2lnbmF0dXJlLFxuICAgICAgICAgICAgYm9keTogZXhwci5ib2R5XG4gICAgICAgIH07XG4gICAgICAgIGlmKGV4cHIudGh1bmsgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHByb2NlZHVyZS50aHVuayA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb2NlZHVyZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBwYXJ0aWFsIGFwcGxpY2F0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBKU09OYXRhIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBJbnB1dCBkYXRhIHRvIGV2YWx1YXRlIGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW52aXJvbm1lbnQgLSBFbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0ZWQgaW5wdXQgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKiBldmFsdWF0ZVBhcnRpYWxBcHBsaWNhdGlvbihleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpIHtcbiAgICAgICAgLy8gcGFydGlhbGx5IGFwcGx5IGEgZnVuY3Rpb25cbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgLy8gZXZhbHVhdGUgdGhlIGFyZ3VtZW50c1xuICAgICAgICB2YXIgZXZhbHVhdGVkQXJncyA9IFtdO1xuICAgICAgICBmb3IodmFyIGlpID0gMDsgaWkgPCBleHByLmFyZ3VtZW50cy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICAgIHZhciBhcmcgPSBleHByLmFyZ3VtZW50c1tpaV07XG4gICAgICAgICAgICBpZiAoYXJnLnR5cGUgPT09ICdvcGVyYXRvcicgJiYgYXJnLnZhbHVlID09PSAnPycpIHtcbiAgICAgICAgICAgICAgICBldmFsdWF0ZWRBcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXZhbHVhdGVkQXJncy5wdXNoKHlpZWxkICogZXZhbHVhdGUoYXJnLCBpbnB1dCwgZW52aXJvbm1lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBsb29rdXAgdGhlIHByb2NlZHVyZVxuICAgICAgICB2YXIgcHJvYyA9IHlpZWxkICogZXZhbHVhdGUoZXhwci5wcm9jZWR1cmUsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvYyA9PT0gJ3VuZGVmaW5lZCcgJiYgZXhwci5wcm9jZWR1cmUudHlwZSA9PT0gJ3BhdGgnICYmIGVudmlyb25tZW50Lmxvb2t1cChleHByLnByb2NlZHVyZS5zdGVwc1swXS52YWx1ZSkpIHtcbiAgICAgICAgICAgIC8vIGhlbHAgdGhlIHVzZXIgb3V0IGhlcmUgaWYgdGhleSBzaW1wbHkgZm9yZ290IHRoZSBsZWFkaW5nICRcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIlQxMDA3XCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgdG9rZW46IGV4cHIucHJvY2VkdXJlLnN0ZXBzWzBdLnZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xhbWJkYShwcm9jKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcGFydGlhbEFwcGx5UHJvY2VkdXJlKHByb2MsIGV2YWx1YXRlZEFyZ3MpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2MgJiYgcHJvYy5fanNvbmF0YV9mdW5jdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcGFydGlhbEFwcGx5TmF0aXZlRnVuY3Rpb24ocHJvYy5pbXBsZW1lbnRhdGlvbiwgZXZhbHVhdGVkQXJncyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb2MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcnRpYWxBcHBseU5hdGl2ZUZ1bmN0aW9uKHByb2MsIGV2YWx1YXRlZEFyZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiVDEwMDhcIixcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogZXhwci5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICB0b2tlbjogZXhwci5wcm9jZWR1cmUudHlwZSA9PT0gJ3BhdGgnID8gZXhwci5wcm9jZWR1cmUuc3RlcHNbMF0udmFsdWUgOiBleHByLnByb2NlZHVyZS52YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIHRoZSBhcmd1bWVudHMgYWdhaW5zdCB0aGUgc2lnbmF0dXJlIHZhbGlkYXRvciAoaWYgaXQgZXhpc3RzKVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNpZ25hdHVyZSAtIHZhbGlkYXRvciBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgLSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgKiBAcGFyYW0geyp9IGNvbnRleHQgLSBjb250ZXh0IHZhbHVlXG4gICAgICogQHJldHVybnMge0FycmF5fSAtIHZhbGlkYXRlZCBhcmd1bWVudHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUFyZ3VtZW50cyhzaWduYXR1cmUsIGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgICAgaWYodHlwZW9mIHNpZ25hdHVyZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gdmFsaWRhdGVcbiAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWxpZGF0ZWRBcmdzID0gc2lnbmF0dXJlLnZhbGlkYXRlKGFyZ3MsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVkQXJncztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBwcm9jZWR1cmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvYyAtIFByb2NlZHVyZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgLSBBcmd1bWVudHNcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmVzdWx0IG9mIHByb2NlZHVyZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKiBhcHBseVByb2NlZHVyZShwcm9jLCBhcmdzKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciBlbnYgPSBjcmVhdGVGcmFtZShwcm9jLmVudmlyb25tZW50KTtcbiAgICAgICAgcHJvYy5hcmd1bWVudHMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0sIGluZGV4KSB7XG4gICAgICAgICAgICBlbnYuYmluZChwYXJhbS52YWx1ZSwgYXJnc1tpbmRleF0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jLmJvZHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBsYW1iZGEgdGhhdCB3cmFwcyBhIG5hdGl2ZSBmdW5jdGlvbiAtIGdlbmVyYXRlZCBieSBwYXJ0aWFsbHkgZXZhbHVhdGluZyBhIG5hdGl2ZVxuICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBhcHBseU5hdGl2ZUZ1bmN0aW9uKHByb2MuYm9keSwgZW52KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGUocHJvYy5ib2R5LCBwcm9jLmlucHV0LCBlbnYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFydGlhbGx5IGFwcGx5IHByb2NlZHVyZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9jIC0gUHJvY2VkdXJlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyAtIEFyZ3VtZW50c1xuICAgICAqIEByZXR1cm5zIHt7bGFtYmRhOiBib29sZWFuLCBpbnB1dDogKiwgZW52aXJvbm1lbnQ6IHtiaW5kLCBsb29rdXB9LCBhcmd1bWVudHM6IEFycmF5LCBib2R5OiAqfX0gUmVzdWx0IG9mIHBhcnRpYWxseSBhcHBsaWVkIHByb2NlZHVyZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnRpYWxBcHBseVByb2NlZHVyZShwcm9jLCBhcmdzKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIGNsb3N1cmUsIGJpbmQgdGhlIHN1cHBsaWVkIHBhcmFtZXRlcnMgYW5kIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIHJlbWFpbmluZyAoPykgcGFyYW1ldGVyc1xuICAgICAgICB2YXIgZW52ID0gY3JlYXRlRnJhbWUocHJvYy5lbnZpcm9ubWVudCk7XG4gICAgICAgIHZhciB1bmJvdW5kQXJncyA9IFtdO1xuICAgICAgICBwcm9jLmFyZ3VtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBhcmcgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChhcmcgJiYgYXJnLnR5cGUgPT09ICdvcGVyYXRvcicgJiYgYXJnLnZhbHVlID09PSAnPycpIHtcbiAgICAgICAgICAgICAgICB1bmJvdW5kQXJncy5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW52LmJpbmQocGFyYW0udmFsdWUsIGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcHJvY2VkdXJlID0ge1xuICAgICAgICAgICAgX2pzb25hdGFfbGFtYmRhOiB0cnVlLFxuICAgICAgICAgICAgaW5wdXQ6IHByb2MuaW5wdXQsXG4gICAgICAgICAgICBlbnZpcm9ubWVudDogZW52LFxuICAgICAgICAgICAgYXJndW1lbnRzOiB1bmJvdW5kQXJncyxcbiAgICAgICAgICAgIGJvZHk6IHByb2MuYm9keVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcHJvY2VkdXJlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnRpYWxseSBhcHBseSBuYXRpdmUgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuYXRpdmUgLSBOYXRpdmUgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIC0gQXJndW1lbnRzXG4gICAgICogQHJldHVybnMge3tsYW1iZGE6IGJvb2xlYW4sIGlucHV0OiAqLCBlbnZpcm9ubWVudDoge2JpbmQsIGxvb2t1cH0sIGFyZ3VtZW50czogQXJyYXksIGJvZHk6ICp9fSBSZXN1bHQgb2YgcGFydGlhbGx5IGFwcGx5aW5nIG5hdGl2ZSBmdW5jdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnRpYWxBcHBseU5hdGl2ZUZ1bmN0aW9uKG5hdGl2ZSwgYXJncykge1xuICAgICAgICAvLyBjcmVhdGUgYSBsYW1iZGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBhbmQgaW52b2tlcyB0aGUgbmF0aXZlIGZ1bmN0aW9uXG4gICAgICAgIC8vIGdldCB0aGUgbGlzdCBvZiBkZWNsYXJlZCBhcmd1bWVudHMgZnJvbSB0aGUgbmF0aXZlIGZ1bmN0aW9uXG4gICAgICAgIC8vIHRoaXMgaGFzIHRvIGJlIHBpY2tlZCBvdXQgZnJvbSB0aGUgdG9TdHJpbmcoKSB2YWx1ZVxuICAgICAgICB2YXIgc2lnQXJncyA9IGdldE5hdGl2ZUZ1bmN0aW9uQXJndW1lbnRzKG5hdGl2ZSk7XG4gICAgICAgIHNpZ0FyZ3MgPSBzaWdBcmdzLm1hcChmdW5jdGlvbiAoc2lnQXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gJyQnICsgc2lnQXJnLnRyaW0oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBib2R5ID0gJ2Z1bmN0aW9uKCcgKyBzaWdBcmdzLmpvaW4oJywgJykgKyAnKXsgXyB9JztcblxuICAgICAgICB2YXIgYm9keUFTVCA9IHBhcnNlcihib2R5KTtcbiAgICAgICAgYm9keUFTVC5ib2R5ID0gbmF0aXZlO1xuXG4gICAgICAgIHZhciBwYXJ0aWFsID0gcGFydGlhbEFwcGx5UHJvY2VkdXJlKGJvZHlBU1QsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gcGFydGlhbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBuYXRpdmUgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvYyAtIFByb2NlZHVyZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnYgLSBFbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHsqfSBSZXN1bHQgb2YgYXBwbHlpbmcgbmF0aXZlIGZ1bmN0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGFwcGx5TmF0aXZlRnVuY3Rpb24ocHJvYywgZW52KSB7XG4gICAgICAgIHZhciBzaWdBcmdzID0gZ2V0TmF0aXZlRnVuY3Rpb25Bcmd1bWVudHMocHJvYyk7XG4gICAgICAgIC8vIGdlbmVyYXRlIHRoZSBhcnJheSBvZiBhcmd1bWVudHMgZm9yIGludm9raW5nIHRoZSBmdW5jdGlvbiAtIGxvb2sgdGhlbSB1cCBpbiB0aGUgZW52aXJvbm1lbnRcbiAgICAgICAgdmFyIGFyZ3MgPSBzaWdBcmdzLm1hcChmdW5jdGlvbiAoc2lnQXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gZW52Lmxvb2t1cChzaWdBcmcudHJpbSgpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHByb2MuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIGlmKGlzR2VuZXJhdG9yKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IG5hdGl2ZSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gRnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7KnxBcnJheX0gTmF0aXZlIGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE5hdGl2ZUZ1bmN0aW9uQXJndW1lbnRzKGZ1bmMpIHtcbiAgICAgICAgdmFyIHNpZ25hdHVyZSA9IGZ1bmMudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIHNpZ1BhcmVucyA9IC9cXCgoW14pXSopXFwpLy5leGVjKHNpZ25hdHVyZSlbMV07IC8vIHRoZSBjb250ZW50cyBvZiB0aGUgcGFyZW5zXG4gICAgICAgIHZhciBzaWdBcmdzID0gc2lnUGFyZW5zLnNwbGl0KCcsJyk7XG4gICAgICAgIHJldHVybiBzaWdBcmdzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBkZWZpbml0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uIGluIEphdmFzY3JpcHRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2lnbmF0dXJlIC0gSlNPTmF0YSBmdW5jdGlvbiBzaWduYXR1cmUgZGVmaW5pdGlvblxuICAgICAqIEByZXR1cm5zIHt7aW1wbGVtZW50YXRpb246ICosIHNpZ25hdHVyZTogKn19IGZ1bmN0aW9uIGRlZmluaXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWZpbmVGdW5jdGlvbihmdW5jLCBzaWduYXR1cmUpIHtcbiAgICAgICAgdmFyIGRlZmluaXRpb24gPSB7XG4gICAgICAgICAgICBfanNvbmF0YV9mdW5jdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIGltcGxlbWVudGF0aW9uOiBmdW5jXG4gICAgICAgIH07XG4gICAgICAgIGlmKHR5cGVvZiBzaWduYXR1cmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBkZWZpbml0aW9uLnNpZ25hdHVyZSA9IHBhcnNlU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3VtIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgLSBBcmd1bWVudHNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUb3RhbCB2YWx1ZSBvZiBhcmd1bWVudHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblN1bShhcmdzKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyZ3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uKG51bSl7dG90YWwgKz0gbnVtO30pO1xuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ291bnQgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJncyAtIEFyZ3VtZW50c1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkNvdW50KGFyZ3MpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgYXJncyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFyZ3MubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1heCBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIC0gQXJndW1lbnRzXG4gICAgICogQHJldHVybnMge251bWJlcn0gTWF4IGVsZW1lbnQgaW4gdGhlIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25NYXgoYXJncykge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcmdzID09PSAndW5kZWZpbmVkJyB8fCBhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCBhcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNaW4gZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJncyAtIEFyZ3VtZW50c1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IE1pbiBlbGVtZW50IGluIHRoZSBhcnJheVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uTWluKGFyZ3MpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgYXJncyA9PT0gJ3VuZGVmaW5lZCcgfHwgYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTWF0aC5taW4uYXBwbHkoTWF0aCwgYXJncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXZlcmFnZSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIC0gQXJndW1lbnRzXG4gICAgICogQHJldHVybnMge251bWJlcn0gQXZlcmFnZSBlbGVtZW50IGluIHRoZSBhcnJheVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uQXZlcmFnZShhcmdzKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyZ3MgPT09ICd1bmRlZmluZWQnIHx8IGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uKG51bSl7dG90YWwgKz0gbnVtO30pO1xuICAgICAgICByZXR1cm4gdG90YWwvYXJncy5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RpbmdpZnkgYXJndW1lbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZyAtIEFyZ3VtZW50c1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFN0cmluZyBmcm9tIGFyZ3VtZW50c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uU3RyaW5nKGFyZykge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0cjtcblxuICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIGFscmVhZHkgYSBzdHJpbmdcbiAgICAgICAgICAgIHN0ciA9IGFyZztcbiAgICAgICAgfSBlbHNlIGlmKGlzRnVuY3Rpb24oYXJnKSkge1xuICAgICAgICAgICAgLy8gZnVuY3Rpb25zIChidWlsdC1pbiBhbmQgbGFtYmRhIGNvbnZlcnQgdG8gZW1wdHkgc3RyaW5nXG4gICAgICAgICAgICBzdHIgPSAnJztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJyAmJiAhaXNGaW5pdGUoYXJnKSkge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiRDMwMDFcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogYXJnLFxuICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHN0ciA9IEpTT04uc3RyaW5naWZ5KGFyZywgZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgdmFsICE9PSAndW5kZWZpbmVkJyAmJiB2YWwgIT09IG51bGwgJiYgdmFsLnRvUHJlY2lzaW9uICYmIGlzTnVtZXJpYyh2YWwpKSA/IE51bWJlcih2YWwudG9QcmVjaXNpb24oMTMpKSA6XG4gICAgICAgICAgICAgICAgICAgICh2YWwgJiYgaXNGdW5jdGlvbih2YWwpKSA/ICcnIDogdmFsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHN1YnN0cmluZyBiYXNlZCBvbiBjaGFyYWN0ZXIgbnVtYmVyIGFuZCBsZW5ndGhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gU3RyaW5nIHRvIGV2YWx1YXRlXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBzdGFydCAtIENoYXJhY3RlciBudW1iZXIgdG8gc3RhcnQgc3Vic3RyaW5nXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBbbGVuZ3RoXSAtIE51bWJlciBvZiBjaGFyYWN0ZXJzIGluIHN1YnN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8Kn0gU3Vic3RyaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25TdWJzdHJpbmcoc3RyLCBzdGFydCwgbGVuZ3RoKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgc3Vic3RyaW5nIHVwIHVudGlsIGEgY2hhcmFjdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIFN0cmluZyB0byBldmFsdWF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjaGFycyAtIENoYXJhY3RlciB0byBkZWZpbmUgc3Vic3RyaW5nIGJvdW5kYXJ5XG4gICAgICogQHJldHVybnMgeyp9IFN1YnN0cmluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uU3Vic3RyaW5nQmVmb3JlKHN0ciwgY2hhcnMpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3MgPSBzdHIuaW5kZXhPZihjaGFycyk7XG4gICAgICAgIGlmIChwb3MgPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgcG9zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgc3Vic3RyaW5nIGFmdGVyIGEgY2hhcmFjdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIFN0cmluZyB0byBldmFsdWF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjaGFycyAtIENoYXJhY3RlciB0byBkZWZpbmUgc3Vic3RyaW5nIGJvdW5kYXJ5XG4gICAgICogQHJldHVybnMgeyp9IFN1YnN0cmluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uU3Vic3RyaW5nQWZ0ZXIoc3RyLCBjaGFycykge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvcyA9IHN0ci5pbmRleE9mKGNoYXJzKTtcbiAgICAgICAgaWYgKHBvcyA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihwb3MgKyBjaGFycy5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvd2VyY2FzZSBhIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBTdHJpbmcgdG8gZXZhbHVhdGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBMb3dlcmNhc2Ugc3RyaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Mb3dlcmNhc2Uoc3RyKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBwZXJjYXNlIGEgc3RyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIFN0cmluZyB0byBldmFsdWF0ZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFVwcGVyY2FzZSBzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblVwcGVyY2FzZShzdHIpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHIudG9VcHBlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBsZW5ndGggb2YgYSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gc3RyaW5nXG4gICAgICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkxlbmd0aChzdHIpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHIubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSBhbmQgdHJpbSB3aGl0ZXNwYWNlIHdpdGhpbiBhIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBzdHJpbmcgdG8gYmUgdHJpbW1lZFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdHJpbW1lZCBzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblRyaW0oc3RyKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3JtYWxpemUgd2hpdGVzcGFjZVxuICAgICAgICB2YXIgcmVzdWx0ID0gc3RyLnJlcGxhY2UoL1sgXFx0XFxuXFxyXSsvZ20sICcgJyk7XG4gICAgICAgIGlmKHJlc3VsdC5jaGFyQXQoMCkgPT09ICcgJykge1xuICAgICAgICAgICAgLy8gc3RyaXAgbGVhZGluZyBzcGFjZVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICBpZihyZXN1bHQuY2hhckF0KHJlc3VsdC5sZW5ndGggLSAxKSA9PT0gJyAnKSB7XG4gICAgICAgICAgICAvLyBzdHJpcCB0cmFpbGluZyBzcGFjZVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cmluZygwLCByZXN1bHQubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWQgYSBzdHJpbmcgdG8gYSBtaW5pbXVtIHdpZHRoIGJ5IGFkZGluZyBjaGFyYWN0ZXJzIHRvIHRoZSBzdGFydCBvciBlbmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gc3RyaW5nIHRvIGJlIHBhZGRlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIHRoZSBtaW5pbXVtIHdpZHRoOyArdmUgcGFkcyB0byB0aGUgcmlnaHQsIC12ZSBwYWRzIHRvIHRoZSBsZWZ0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFyXSAtIHRoZSBwYWQgY2hhcmFjdGVyKHMpOyBkZWZhdWx0cyB0byAnICdcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHBhZGRlZCBzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblBhZChzdHIsIHdpZHRoLCBjaGFyKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0eXBlb2YgY2hhciA9PT0gJ3VuZGVmaW5lZCcgfHwgY2hhci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNoYXIgPSAnICc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgcGFkTGVuZ3RoID0gTWF0aC5hYnMod2lkdGgpIC0gc3RyLmxlbmd0aDtcbiAgICAgICAgaWYocGFkTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSAobmV3IEFycmF5KHBhZExlbmd0aCArIDEpKS5qb2luKGNoYXIpO1xuICAgICAgICAgICAgaWYoY2hhci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgcGFkZGluZyA9IHBhZGRpbmcuc3Vic3RyaW5nKDAsIHBhZExlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih3aWR0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzdHIgKyBwYWRkaW5nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBwYWRkaW5nICsgc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3RyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhlIHN0ciBjb250YWlucyB0aGUgdG9rZW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gc3RyaW5nIHRvIHRlc3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdG9rZW4gLSBzdWJzdHJpbmcgb3IgcmVnZXggdG8gZmluZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSAtIHRydWUgaWYgc3RyIGNvbnRhaW5zIHRva2VuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Db250YWlucyhzdHIsIHRva2VuKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIGlmKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IChzdHIuaW5kZXhPZih0b2tlbikgIT09IC0xKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gdG9rZW4oc3RyKTtcbiAgICAgICAgICAgIHJlc3VsdCA9ICh0eXBlb2YgbWF0Y2hlcyAhPT0gJ3VuZGVmaW5lZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXRjaCBhIHN0cmluZyB3aXRoIGEgcmVnZXggcmV0dXJuaW5nIGFuIGFycmF5IG9mIG9iamVjdCBjb250YWluaW5nIGRldGFpbHMgb2YgZWFjaCBtYXRjaFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVnZXggLSB0aGUgcmVnZXggYXBwbGllZCB0byB0aGUgc3RyaW5nXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBbbGltaXRdIC0gbWF4IG51bWJlciBvZiBtYXRjaGVzIHRvIHJldHVyblxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGFycmF5IG9mIG1hdGNoIG9iamVjdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbk1hdGNoKHN0ciwgcmVnZXgsIGxpbWl0KSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsaW1pdCwgaWYgc3BlY2lmaWVkLCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlclxuICAgICAgICBpZihsaW1pdCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbGltaXQsXG4gICAgICAgICAgICAgICAgY29kZTogJ0QzMDQwJyxcbiAgICAgICAgICAgICAgICBpbmRleDogM1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBpZih0eXBlb2YgbGltaXQgPT09ICd1bmRlZmluZWQnIHx8IGxpbWl0ID4gMCkge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gcmVnZXgoc3RyKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWF0Y2hlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAodHlwZW9mIG1hdGNoZXMgIT09ICd1bmRlZmluZWQnICYmICh0eXBlb2YgbGltaXQgPT09ICd1bmRlZmluZWQnIHx8IGNvdW50IDwgbGltaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoOiBtYXRjaGVzLm1hdGNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IG1hdGNoZXMuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cHM6IG1hdGNoZXMuZ3JvdXBzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gbWF0Y2hlcy5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXRjaCBhIHN0cmluZyB3aXRoIGEgcmVnZXggcmV0dXJuaW5nIGFuIGFycmF5IG9mIG9iamVjdCBjb250YWluaW5nIGRldGFpbHMgb2YgZWFjaCBtYXRjaFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0dGVybiAtIHRoZSBzdWJzdHJpbmcvcmVnZXggYXBwbGllZCB0byB0aGUgc3RyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcGxhY2VtZW50IC0gdGV4dCB0byByZXBsYWNlIHRoZSBtYXRjaGVkIHN1YnN0cmluZ3NcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IFtsaW1pdF0gLSBtYXggbnVtYmVyIG9mIG1hdGNoZXMgdG8gcmV0dXJuXG4gICAgICogQHJldHVybnMge0FycmF5fSBUaGUgYXJyYXkgb2YgbWF0Y2ggb2JqZWN0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uKiBmdW5jdGlvblJlcGxhY2Uoc3RyLCBwYXR0ZXJuLCByZXBsYWNlbWVudCwgbGltaXQpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBhdHRlcm4gY2Fubm90IGJlIGFuIGVtcHR5IHN0cmluZ1xuICAgICAgICBpZihwYXR0ZXJuID09PSAnJykge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiRDMwMTBcIixcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGF0dGVybixcbiAgICAgICAgICAgICAgICBpbmRleDogMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxpbWl0LCBpZiBzcGVjaWZpZWQsIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyXG4gICAgICAgIGlmKGxpbWl0IDwgMCkge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiRDMwMTFcIixcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbGltaXQsXG4gICAgICAgICAgICAgICAgaW5kZXg6IDRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVwbGFjZXI7XG4gICAgICAgIGlmKHR5cGVvZiByZXBsYWNlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlcGxhY2VyID0gZnVuY3Rpb24gKHJlZ2V4TWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3Vic3RpdHV0ZSA9ICcnO1xuICAgICAgICAgICAgICAgIC8vIHNjYW4gZm9yd2FyZCwgY29weWluZyB0aGUgcmVwbGFjZW1lbnQgdGV4dCBpbnRvIHRoZSBzdWJzdGl0dXRlIHN0cmluZ1xuICAgICAgICAgICAgICAgIC8vIGFuZCByZXBsYWNlIGFueSBvY2N1cnJlbmNlIG9mICRuIHdpdGggdGhlIHZhbHVlcyBtYXRjaGVkIGJ5IHRoZSByZWdleFxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcmVwbGFjZW1lbnQuaW5kZXhPZignJCcsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggIT09IC0xICYmIHBvc2l0aW9uIDwgcmVwbGFjZW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGUgKz0gcmVwbGFjZW1lbnQuc3Vic3RyaW5nKHBvc2l0aW9uLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gaW5kZXggKyAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9sbGFyVmFsID0gcmVwbGFjZW1lbnQuY2hhckF0KHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbGxhclZhbCA9PT0gJyQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsaXRlcmFsICRcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGUgKz0gJyQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkb2xsYXJWYWwgPT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0ZSArPSByZWdleE1hdGNoLm1hdGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhEaWdpdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihyZWdleE1hdGNoLmdyb3Vwcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBzdWItbWF0Y2hlczsgYW55ICQgZm9sbG93ZWQgYnkgYSBkaWdpdCB3aWxsIGJlIHJlcGxhY2VkIGJ5IGFuIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heERpZ2l0cyA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1heCBudW1iZXIgb2YgZGlnaXRzIHRvIHBhcnNlIGZvbGxvd2luZyB0aGUgJFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heERpZ2l0cyA9IE1hdGguZmxvb3IoTWF0aC5sb2cocmVnZXhNYXRjaC5ncm91cHMubGVuZ3RoKSAqIE1hdGguTE9HMTBFKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHBhcnNlSW50KHJlcGxhY2VtZW50LnN1YnN0cmluZyhwb3NpdGlvbiwgcG9zaXRpb24gKyBtYXhEaWdpdHMpLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihtYXhEaWdpdHMgPiAxICYmIGluZGV4ID4gcmVnZXhNYXRjaC5ncm91cHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBwYXJzZUludChyZXBsYWNlbWVudC5zdWJzdHJpbmcocG9zaXRpb24sIHBvc2l0aW9uICsgbWF4RGlnaXRzIC0gMSksIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4oaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVnZXhNYXRjaC5ncm91cHMubGVuZ3RoID4gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1Ym1hdGNoID0gcmVnZXhNYXRjaC5ncm91cHNbaW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdWJtYXRjaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGUgKz0gc3VibWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gaW5kZXgudG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBhIGNhcHR1cmUgZ3JvdXAsIHRyZWF0IHRoZSAkIGFzIGxpdGVyYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRlICs9ICckJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHJlcGxhY2VtZW50LmluZGV4T2YoJyQnLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1YnN0aXR1dGUgKz0gcmVwbGFjZW1lbnQuc3Vic3RyaW5nKHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Vic3RpdHV0ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXBsYWNlciA9IHJlcGxhY2VtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSAwO1xuXG4gICAgICAgIGlmKHR5cGVvZiBsaW1pdCA9PT0gJ3VuZGVmaW5lZCcgfHwgbGltaXQgPiAwKSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgICAgaWYodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gc3RyLmluZGV4T2YocGF0dGVybiwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIHdoaWxlKGluZGV4ICE9PSAtMSAmJiAodHlwZW9mIGxpbWl0ID09PSAndW5kZWZpbmVkJyB8fCBjb3VudCA8IGxpbWl0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyLnN1YnN0cmluZyhwb3NpdGlvbiwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gaW5kZXggKyBwYXR0ZXJuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBzdHIuaW5kZXhPZihwYXR0ZXJuLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHIuc3Vic3RyaW5nKHBvc2l0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBwYXR0ZXJuKHN0cik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtYXRjaGVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHlwZW9mIG1hdGNoZXMgIT09ICd1bmRlZmluZWQnICYmICh0eXBlb2YgbGltaXQgPT09ICd1bmRlZmluZWQnIHx8IGNvdW50IDwgbGltaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyLnN1YnN0cmluZyhwb3NpdGlvbiwgbWF0Y2hlcy5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZWRXaXRoID0geWllbGQgKiBhcHBseShyZXBsYWNlciwgW21hdGNoZXNdLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHJlcGxhY2VkV2l0aCBpcyBhIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIHJlcGxhY2VkV2l0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gcmVwbGFjZWRXaXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3QgYSBzdHJpbmcgLSB0aHJvdyBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJEMzAxMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlcGxhY2VkV2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IG1hdGNoZXMuc3RhcnQgKyBtYXRjaGVzLm1hdGNoLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gbWF0Y2hlcy5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0ci5zdWJzdHJpbmcocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHN0cjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzdHI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJhc2U2NCBlbmNvZGUgYSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gc3RyaW5nXG4gICAgICogQHJldHVybnMge1N0cmluZ30gQmFzZSA2NCBlbmNvZGluZyBvZiB0aGUgYmluYXJ5IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkJhc2U2NGVuY29kZShzdHIpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2UgYnRvYSBpbiBhIGJyb3dzZXIsIG9yIEJ1ZmZlciBpbiBOb2RlLmpzXG5cbiAgICAgICAgdmFyIGJ0b2EgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB3aW5kb3cuYnRvYSA6XG4gICAgICAgICAgICBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW1wbHkgZG9pbmcgYG5ldyBCdWZmZXJgIGF0IHRoaXMgcG9pbnQgY2F1c2VzIEJyb3dzZXJpZnkgdG8gcHVsbFxuICAgICAgICAgICAgICAgIC8vIGluIHRoZSBlbnRpcmUgQnVmZmVyIGJyb3dzZXIgbGlicmFyeSwgd2hpY2ggaXMgbGFyZ2UgYW5kIHVubmVjZXNzYXJ5LlxuICAgICAgICAgICAgICAgIC8vIFVzaW5nIGBnbG9iYWwuQnVmZmVyYCBkZWZlYXRzIHRoaXMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBnbG9iYWwuQnVmZmVyKHN0ciwgJ2JpbmFyeScpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIHJldHVybiBidG9hKHN0cik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmFzZTY0IGRlY29kZSBhIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBCYXNlIDY0IGVuY29kaW5nIG9mIHRoZSBiaW5hcnkgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uQmFzZTY0ZGVjb2RlKHN0cikge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSBidG9hIGluIGEgYnJvd3Nlciwgb3IgQnVmZmVyIGluIE5vZGUuanNcbiAgICAgICAgdmFyIGF0b2IgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB3aW5kb3cuYXRvYiA6XG4gICAgICAgICAgICBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW1wbHkgZG9pbmcgYG5ldyBCdWZmZXJgIGF0IHRoaXMgcG9pbnQgY2F1c2VzIEJyb3dzZXJpZnkgdG8gcHVsbFxuICAgICAgICAgICAgICAgIC8vIGluIHRoZSBlbnRpcmUgQnVmZmVyIGJyb3dzZXIgbGlicmFyeSwgd2hpY2ggaXMgbGFyZ2UgYW5kIHVubmVjZXNzYXJ5LlxuICAgICAgICAgICAgICAgIC8vIFVzaW5nIGBnbG9iYWwuQnVmZmVyYCBkZWZlYXRzIHRoaXMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBnbG9iYWwuQnVmZmVyKHN0ciwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIHJldHVybiBhdG9iKHN0cik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BsaXQgYSBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBzdWJzdHJpbmdzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZXBhcmF0b3IgLSB0aGUgdG9rZW4gb3IgcmVnZXggdGhhdCBzcGxpdHMgdGhlIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gW2xpbWl0XSAtIG1heCBudW1iZXIgb2Ygc3Vic3RyaW5nc1xuICAgICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGFycmF5IG9mIHN0cmluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uU3BsaXQoc3RyLCBzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsaW1pdCwgaWYgc3BlY2lmaWVkLCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlclxuICAgICAgICBpZihsaW1pdCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkQzMDIwXCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgdmFsdWU6IGxpbWl0LFxuICAgICAgICAgICAgICAgIGluZGV4OiAzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGlmKHR5cGVvZiBsaW1pdCA9PT0gJ3VuZGVmaW5lZCcgfHwgbGltaXQgPiAwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlcGFyYXRvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzdHIuc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBzZXBhcmF0b3Ioc3RyKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1hdGNoZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0eXBlb2YgbWF0Y2hlcyAhPT0gJ3VuZGVmaW5lZCcgJiYgKHR5cGVvZiBsaW1pdCA9PT0gJ3VuZGVmaW5lZCcgfHwgY291bnQgPCBsaW1pdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0ci5zdWJzdHJpbmcoc3RhcnQsIG1hdGNoZXMuc3RhcnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gbWF0Y2hlcy5lbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gbWF0Y2hlcy5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBsaW1pdCA9PT0gJ3VuZGVmaW5lZCcgfHwgY291bnQgPCBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RyLnN1YnN0cmluZyhzdGFydCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW3N0cl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBKb2luIGFuIGFycmF5IG9mIHN0cmluZ3NcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzdHJzIC0gYXJyYXkgb2Ygc3RyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzZXBhcmF0b3JdIC0gdGhlIHRva2VuIHRoYXQgc3BsaXRzIHRoZSBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgY29uY2F0ZW5hdGVkIHN0cmluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uSm9pbihzdHJzLCBzZXBhcmF0b3IpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2Ygc3RycyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBzZXBhcmF0b3IgaXMgbm90IHNwZWNpZmllZCwgZGVmYXVsdCB0byBlbXB0eSBzdHJpbmdcbiAgICAgICAgaWYodHlwZW9mIHNlcGFyYXRvciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IFwiXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3Rycy5qb2luKHNlcGFyYXRvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0cyBhIG51bWJlciBpbnRvIGEgZGVjaW1hbCBzdHJpbmcgcmVwcmVzZW50YXRpb24gdXNpbmcgWFBhdGggMy4xIEYmTyBmbjpmb3JtYXQtbnVtYmVyIHNwZWNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBudW1iZXIgdG8gZm9ybWF0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBpY3R1cmUgLSBwaWN0dXJlIHN0cmluZyBkZWZpbml0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIG92ZXJyaWRlIGxvY2FsZSBkZWZhdWx0c1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBmb3JtYXR0ZWQgc3RyaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Gb3JtYXROdW1iZXIodmFsdWUsIHBpY3R1cmUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgXCJkZWNpbWFsLXNlcGFyYXRvclwiOiBcIi5cIixcbiAgICAgICAgICAgIFwiZ3JvdXBpbmctc2VwYXJhdG9yXCI6IFwiLFwiLFxuICAgICAgICAgICAgXCJleHBvbmVudC1zZXBhcmF0b3JcIjogXCJlXCIsXG4gICAgICAgICAgICBcImluZmluaXR5XCI6IFwiSW5maW5pdHlcIixcbiAgICAgICAgICAgIFwibWludXMtc2lnblwiOiBcIi1cIixcbiAgICAgICAgICAgIFwiTmFOXCI6IFwiTmFOXCIsXG4gICAgICAgICAgICBcInBlcmNlbnRcIjogXCIlXCIsXG4gICAgICAgICAgICBcInBlci1taWxsZVwiOiBcIlxcdTIwMzBcIixcbiAgICAgICAgICAgIFwiemVyby1kaWdpdFwiOiBcIjBcIixcbiAgICAgICAgICAgIFwiZGlnaXRcIjogXCIjXCIsXG4gICAgICAgICAgICBcInBhdHRlcm4tc2VwYXJhdG9yXCI6IFwiO1wiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gaWYgYG9wdGlvbnNgIGlzIHNwZWNpZmllZCwgdGhlbiBpdHMgZW50cmllcyBvdmVycmlkZSBkZWZhdWx0c1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IGRlZmF1bHRzO1xuICAgICAgICBpZih0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlY2ltYWxEaWdpdEZhbWlseSA9IFtdO1xuICAgICAgICB2YXIgemVyb0NoYXJDb2RlID0gcHJvcGVydGllc1snemVyby1kaWdpdCddLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGZvcih2YXIgaWkgPSB6ZXJvQ2hhckNvZGU7IGlpIDwgemVyb0NoYXJDb2RlICsgMTA7IGlpKyspIHtcbiAgICAgICAgICAgIGRlY2ltYWxEaWdpdEZhbWlseS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoaWkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhY3RpdmVDaGFycyA9IGRlY2ltYWxEaWdpdEZhbWlseS5jb25jYXQoW3Byb3BlcnRpZXNbJ2RlY2ltYWwtc2VwYXJhdG9yJ10sIHByb3BlcnRpZXNbJ2V4cG9uZW50LXNlcGFyYXRvciddLCBwcm9wZXJ0aWVzWydncm91cGluZy1zZXBhcmF0b3InXSwgcHJvcGVydGllcy5kaWdpdCwgcHJvcGVydGllc1sncGF0dGVybi1zZXBhcmF0b3InXV0pO1xuXG4gICAgICAgIHZhciBzdWJQaWN0dXJlcyA9IHBpY3R1cmUuc3BsaXQocHJvcGVydGllc1sncGF0dGVybi1zZXBhcmF0b3InXSk7XG5cbiAgICAgICAgaWYoc3ViUGljdHVyZXMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGNvZGU6ICdEMzA4MCcsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2tcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3BsaXRQYXJ0cyA9IGZ1bmN0aW9uKHN1YnBpY3R1cmUpIHtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoO1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaWkgPSAwOyBpaSA8IHN1YnBpY3R1cmUubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoID0gc3VicGljdHVyZS5jaGFyQXQoaWkpO1xuICAgICAgICAgICAgICAgICAgICBpZihhY3RpdmVDaGFycy5pbmRleE9mKGNoKSAhPT0gLTEgJiYgY2ggIT09IHByb3BlcnRpZXNbJ2V4cG9uZW50LXNlcGFyYXRvciddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VicGljdHVyZS5zdWJzdHJpbmcoMCwgaWkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHZhciBzdWZmaXggPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoO1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaWkgPSBzdWJwaWN0dXJlLmxlbmd0aCAtIDE7IGlpID49IDA7IGlpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2ggPSBzdWJwaWN0dXJlLmNoYXJBdChpaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKGFjdGl2ZUNoYXJzLmluZGV4T2YoY2gpICE9PSAtMSAmJiBjaCAhPT0gcHJvcGVydGllc1snZXhwb25lbnQtc2VwYXJhdG9yJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJwaWN0dXJlLnN1YnN0cmluZyhpaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHZhciBhY3RpdmVQYXJ0ID0gc3VicGljdHVyZS5zdWJzdHJpbmcocHJlZml4Lmxlbmd0aCwgc3VicGljdHVyZS5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBtYW50aXNzYVBhcnQsIGV4cG9uZW50UGFydCwgaW50ZWdlclBhcnQsIGZyYWN0aW9uYWxQYXJ0O1xuICAgICAgICAgICAgdmFyIGV4cG9uZW50UG9zaXRpb24gPSBzdWJwaWN0dXJlLmluZGV4T2YocHJvcGVydGllc1snZXhwb25lbnQtc2VwYXJhdG9yJ10sIHByZWZpeC5sZW5ndGgpO1xuICAgICAgICAgICAgaWYoZXhwb25lbnRQb3NpdGlvbiA9PT0gLTEgfHwgZXhwb25lbnRQb3NpdGlvbiA+IHN1YnBpY3R1cmUubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG1hbnRpc3NhUGFydCA9IGFjdGl2ZVBhcnQ7XG4gICAgICAgICAgICAgICAgZXhwb25lbnRQYXJ0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYW50aXNzYVBhcnQgPSBhY3RpdmVQYXJ0LnN1YnN0cmluZygwLCBleHBvbmVudFBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBleHBvbmVudFBhcnQgPSBhY3RpdmVQYXJ0LnN1YnN0cmluZyhleHBvbmVudFBvc2l0aW9uICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGVjaW1hbFBvc2l0aW9uID0gbWFudGlzc2FQYXJ0LmluZGV4T2YocHJvcGVydGllc1snZGVjaW1hbC1zZXBhcmF0b3InXSk7XG4gICAgICAgICAgICBpZihkZWNpbWFsUG9zaXRpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaW50ZWdlclBhcnQgPSBtYW50aXNzYVBhcnQ7XG4gICAgICAgICAgICAgICAgZnJhY3Rpb25hbFBhcnQgPSBzdWZmaXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGludGVnZXJQYXJ0ID0gbWFudGlzc2FQYXJ0LnN1YnN0cmluZygwLCBkZWNpbWFsUG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGZyYWN0aW9uYWxQYXJ0ID0gbWFudGlzc2FQYXJ0LnN1YnN0cmluZyhkZWNpbWFsUG9zaXRpb24gKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgICAgICAgc3VmZml4OiBzdWZmaXgsXG4gICAgICAgICAgICAgICAgYWN0aXZlUGFydDogYWN0aXZlUGFydCxcbiAgICAgICAgICAgICAgICBtYW50aXNzYVBhcnQ6IG1hbnRpc3NhUGFydCxcbiAgICAgICAgICAgICAgICBleHBvbmVudFBhcnQ6IGV4cG9uZW50UGFydCxcbiAgICAgICAgICAgICAgICBpbnRlZ2VyUGFydDogaW50ZWdlclBhcnQsXG4gICAgICAgICAgICAgICAgZnJhY3Rpb25hbFBhcnQ6IGZyYWN0aW9uYWxQYXJ0LFxuICAgICAgICAgICAgICAgIHN1YnBpY3R1cmU6IHN1YnBpY3R1cmVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gdmFsaWRhdGUgdGhlIHBpY3R1cmUgc3RyaW5nLCBGJk8gNC43LjNcbiAgICAgICAgdmFyIHZhbGlkYXRlID0gZnVuY3Rpb24ocGFydHMpIHtcbiAgICAgICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgICAgIHZhciBpaTtcbiAgICAgICAgICAgIHZhciBzdWJwaWN0dXJlID0gcGFydHMuc3VicGljdHVyZTtcbiAgICAgICAgICAgIHZhciBkZWNpbWFsUG9zID0gc3VicGljdHVyZS5pbmRleE9mKHByb3BlcnRpZXNbJ2RlY2ltYWwtc2VwYXJhdG9yJ10pO1xuICAgICAgICAgICAgaWYoZGVjaW1hbFBvcyAhPT0gc3VicGljdHVyZS5sYXN0SW5kZXhPZihwcm9wZXJ0aWVzWydkZWNpbWFsLXNlcGFyYXRvciddKSkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gJ0QzMDgxJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHN1YnBpY3R1cmUuaW5kZXhPZihwcm9wZXJ0aWVzLnBlcmNlbnQpICE9PSBzdWJwaWN0dXJlLmxhc3RJbmRleE9mKHByb3BlcnRpZXMucGVyY2VudCkpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICdEMzA4Mic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihzdWJwaWN0dXJlLmluZGV4T2YocHJvcGVydGllc1sncGVyLW1pbGxlJ10pICE9PSBzdWJwaWN0dXJlLmxhc3RJbmRleE9mKHByb3BlcnRpZXNbJ3Blci1taWxsZSddKSkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gJ0QzMDgzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHN1YnBpY3R1cmUuaW5kZXhPZihwcm9wZXJ0aWVzLnBlcmNlbnQpICE9PSAtMSAmJiBzdWJwaWN0dXJlLmluZGV4T2YocHJvcGVydGllc1sncGVyLW1pbGxlJ10pICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gJ0QzMDg0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yKGlpID0gMDsgaWkgPCBwYXJ0cy5tYW50aXNzYVBhcnQubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoID0gcGFydHMubWFudGlzc2FQYXJ0LmNoYXJBdChpaSk7XG4gICAgICAgICAgICAgICAgaWYoZGVjaW1hbERpZ2l0RmFtaWx5LmluZGV4T2YoY2gpICE9PSAtMSB8fCBjaCA9PT0gcHJvcGVydGllcy5kaWdpdCkge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKCF2YWxpZCkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gJ0QzMDg1JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaGFyVHlwZXMgPSBwYXJ0cy5hY3RpdmVQYXJ0LnNwbGl0KCcnKS5tYXAoZnVuY3Rpb24oY2hhcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY3RpdmVDaGFycy5pbmRleE9mKGNoYXIpID09PSAtMSA/ICdwJyA6ICdhJztcbiAgICAgICAgICAgIH0pLmpvaW4oJycpO1xuICAgICAgICAgICAgaWYoY2hhclR5cGVzLmluZGV4T2YoJ3AnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICdEMzA4Nic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihkZWNpbWFsUG9zICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmKHN1YnBpY3R1cmUuY2hhckF0KGRlY2ltYWxQb3MgLSAxKSA9PT0gcHJvcGVydGllc1snZ3JvdXBpbmctc2VwYXJhdG9yJ10gfHwgc3VicGljdHVyZS5jaGFyQXQoZGVjaW1hbFBvcyArIDEpID09PSBwcm9wZXJ0aWVzWydncm91cGluZy1zZXBhcmF0b3InXSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9ICdEMzA4Nyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmKHBhcnRzLmludGVnZXJQYXJ0LmNoYXJBdChwYXJ0cy5pbnRlZ2VyUGFydC5sZW5ndGggLSAxKSA9PT0gcHJvcGVydGllc1snZ3JvdXBpbmctc2VwYXJhdG9yJ10pIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICdEMzA4OCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihzdWJwaWN0dXJlLmluZGV4T2YocHJvcGVydGllc1snZ3JvdXBpbmctc2VwYXJhdG9yJ10gKyBwcm9wZXJ0aWVzWydncm91cGluZy1zZXBhcmF0b3InXSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSAnRDMwODknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG9wdGlvbmFsRGlnaXRQb3MgPSBwYXJ0cy5pbnRlZ2VyUGFydC5pbmRleE9mKHByb3BlcnRpZXMuZGlnaXQpO1xuICAgICAgICAgICAgaWYob3B0aW9uYWxEaWdpdFBvcyAhPT0gLTEgJiYgcGFydHMuaW50ZWdlclBhcnQuc3Vic3RyaW5nKDAsIG9wdGlvbmFsRGlnaXRQb3MpLnNwbGl0KCcnKS5maWx0ZXIoZnVuY3Rpb24oY2hhcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWNpbWFsRGlnaXRGYW1pbHkuaW5kZXhPZihjaGFyKSA+IC0xO1xuICAgICAgICAgICAgfSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gJ0QzMDkwJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbmFsRGlnaXRQb3MgPSBwYXJ0cy5mcmFjdGlvbmFsUGFydC5sYXN0SW5kZXhPZihwcm9wZXJ0aWVzLmRpZ2l0KTtcbiAgICAgICAgICAgIGlmKG9wdGlvbmFsRGlnaXRQb3MgIT09IC0xICYmIHBhcnRzLmZyYWN0aW9uYWxQYXJ0LnN1YnN0cmluZyhvcHRpb25hbERpZ2l0UG9zKS5zcGxpdCgnJykuZmlsdGVyKGZ1bmN0aW9uKGNoYXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjaW1hbERpZ2l0RmFtaWx5LmluZGV4T2YoY2hhcikgPiAtMTtcbiAgICAgICAgICAgIH0pLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICdEMzA5MSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZXhwb25lbnRFeGlzdHMgPSAodHlwZW9mIHBhcnRzLmV4cG9uZW50UGFydCA9PT0gJ3N0cmluZycpO1xuICAgICAgICAgICAgaWYoZXhwb25lbnRFeGlzdHMgJiYgcGFydHMuZXhwb25lbnRQYXJ0Lmxlbmd0aCA+IDAgJiYgKHN1YnBpY3R1cmUuaW5kZXhPZihwcm9wZXJ0aWVzLnBlcmNlbnQpICE9PSAtMSB8fCBzdWJwaWN0dXJlLmluZGV4T2YocHJvcGVydGllc1sncGVyLW1pbGxlJ10pICE9PSAtMSkpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICdEMzA5Mic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihleHBvbmVudEV4aXN0cyAmJiAocGFydHMuZXhwb25lbnRQYXJ0Lmxlbmd0aCA9PT0gMCB8fCBwYXJ0cy5leHBvbmVudFBhcnQuc3BsaXQoJycpLmZpbHRlcihmdW5jdGlvbihjaGFyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY2ltYWxEaWdpdEZhbWlseS5pbmRleE9mKGNoYXIpID09PSAtMTtcbiAgICAgICAgICAgIH0pLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSAnRDMwOTMnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFja1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gYW5hbHlzZSB0aGUgcGljdHVyZSBzdHJpbmcsIEYmTyA0LjcuNFxuICAgICAgICB2YXIgYW5hbHlzZSA9IGZ1bmN0aW9uKHBhcnRzKSB7XG4gICAgICAgICAgICB2YXIgZ2V0R3JvdXBpbmdQb3NpdGlvbnMgPSBmdW5jdGlvbihwYXJ0LCB0b0xlZnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwaW5nUG9zaXRpb24gPSBwYXJ0LmluZGV4T2YocHJvcGVydGllc1snZ3JvdXBpbmctc2VwYXJhdG9yJ10pO1xuICAgICAgICAgICAgICAgIHdoaWxlKGdyb3VwaW5nUG9zaXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFyc1RvVGhlUmlnaHQgPSAodG9MZWZ0ID8gcGFydC5zdWJzdHJpbmcoMCwgZ3JvdXBpbmdQb3NpdGlvbikgOiBwYXJ0LnN1YnN0cmluZyhncm91cGluZ1Bvc2l0aW9uKSkuc3BsaXQoJycpLmZpbHRlcihmdW5jdGlvbihjaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjaW1hbERpZ2l0RmFtaWx5LmluZGV4T2YoY2hhcikgIT09IC0xIHx8IGNoYXIgPT09IHByb3BlcnRpZXMuZGlnaXQ7XG4gICAgICAgICAgICAgICAgICAgIH0pLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goY2hhcnNUb1RoZVJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBpbmdQb3NpdGlvbiA9IHBhcnRzLmludGVnZXJQYXJ0LmluZGV4T2YocHJvcGVydGllc1snZ3JvdXBpbmctc2VwYXJhdG9yJ10sIGdyb3VwaW5nUG9zaXRpb24gKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9ucztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgaW50ZWdlclBhcnRHcm91cGluZ1Bvc2l0aW9ucyA9IGdldEdyb3VwaW5nUG9zaXRpb25zKHBhcnRzLmludGVnZXJQYXJ0KTtcbiAgICAgICAgICAgIHZhciByZWd1bGFyID0gZnVuY3Rpb24oaW5kZXhlcykge1xuICAgICAgICAgICAgICAgIC8vIGFyZSB0aGUgZ3JvdXBpbmcgcG9zaXRpb25zIHJlZ3VsYXI/IGkuZS4gc2FtZSBpbnRlcnZhbCBiZXR3ZWVuIGVhY2ggb2YgdGhlbVxuICAgICAgICAgICAgICAgIGlmKGluZGV4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZ2NkID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYiA9PT0gMCA/IGEgOiBnY2QoYiwgYSAlIGIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gZmluZCB0aGUgZ3JlYXRlc3QgY29tbW9uIGRpdmlzb3Igb2YgYWxsIHRoZSBwb3NpdGlvbnNcbiAgICAgICAgICAgICAgICB2YXIgZmFjdG9yID0gaW5kZXhlcy5yZWR1Y2UoZ2NkKTtcbiAgICAgICAgICAgICAgICAvLyBpcyBldmVyeSBwb3NpdGlvbiBzZXBhcmF0ZWQgYnkgdGhpcyBkaXZpc29yPyBJZiBzbywgaXQncyByZWd1bGFyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpbmRleCA9IDE7IGluZGV4IDw9IGluZGV4ZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGluZGV4ZXMuaW5kZXhPZihpbmRleCAqIGZhY3RvcikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFjdG9yO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHJlZ3VsYXJHcm91cGluZyA9IHJlZ3VsYXIoaW50ZWdlclBhcnRHcm91cGluZ1Bvc2l0aW9ucyk7XG4gICAgICAgICAgICB2YXIgZnJhY3Rpb25hbFBhcnRHcm91cGluZ1Bvc2l0aW9ucyA9IGdldEdyb3VwaW5nUG9zaXRpb25zKHBhcnRzLmZyYWN0aW9uYWxQYXJ0LCB0cnVlKTtcblxuICAgICAgICAgICAgdmFyIG1pbmltdW1JbnRlZ2VyUGFydFNpemUgPSBwYXJ0cy5pbnRlZ2VyUGFydC5zcGxpdCgnJykuZmlsdGVyKGZ1bmN0aW9uKGNoYXIpIHsgcmV0dXJuIGRlY2ltYWxEaWdpdEZhbWlseS5pbmRleE9mKGNoYXIpICE9PSAtMTsgfSkubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHNjYWxpbmdGYWN0b3IgPSBtaW5pbXVtSW50ZWdlclBhcnRTaXplO1xuXG4gICAgICAgICAgICB2YXIgZnJhY3Rpb25hbFBhcnRBcnJheSA9IHBhcnRzLmZyYWN0aW9uYWxQYXJ0LnNwbGl0KCcnKTtcbiAgICAgICAgICAgIHZhciBtaW5pbXVtRmFjdGlvbmFsUGFydFNpemUgPSBmcmFjdGlvbmFsUGFydEFycmF5LmZpbHRlcihmdW5jdGlvbihjaGFyKSB7IHJldHVybiBkZWNpbWFsRGlnaXRGYW1pbHkuaW5kZXhPZihjaGFyKSAhPT0gLTE7IH0pLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBtYXhpbXVtRmFjdGlvbmFsUGFydFNpemUgPSBmcmFjdGlvbmFsUGFydEFycmF5LmZpbHRlcihmdW5jdGlvbihjaGFyKSB7IHJldHVybiBkZWNpbWFsRGlnaXRGYW1pbHkuaW5kZXhPZihjaGFyKSAhPT0gLTEgfHwgY2hhciA9PT0gcHJvcGVydGllcy5kaWdpdDsgfSkubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGV4cG9uZW50UHJlc2VudCA9IHR5cGVvZiBwYXJ0cy5leHBvbmVudFBhcnQgPT09ICdzdHJpbmcnO1xuICAgICAgICAgICAgaWYobWluaW11bUludGVnZXJQYXJ0U2l6ZSA9PT0gMCAmJiBtYXhpbXVtRmFjdGlvbmFsUGFydFNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZihleHBvbmVudFByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bUZhY3Rpb25hbFBhcnRTaXplID0gMTtcbiAgICAgICAgICAgICAgICAgICAgbWF4aW11bUZhY3Rpb25hbFBhcnRTaXplID0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtaW5pbXVtSW50ZWdlclBhcnRTaXplID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihleHBvbmVudFByZXNlbnQgJiYgbWluaW11bUludGVnZXJQYXJ0U2l6ZSA9PT0gMCAmJiBwYXJ0cy5pbnRlZ2VyUGFydC5pbmRleE9mKHByb3BlcnRpZXMuZGlnaXQpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIG1pbmltdW1JbnRlZ2VyUGFydFNpemUgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYobWluaW11bUludGVnZXJQYXJ0U2l6ZSA9PT0gMCAmJiBtaW5pbXVtRmFjdGlvbmFsUGFydFNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBtaW5pbXVtRmFjdGlvbmFsUGFydFNpemUgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1pbmltdW1FeHBvbmVudFNpemUgPSAwO1xuICAgICAgICAgICAgaWYoZXhwb25lbnRQcmVzZW50KSB7XG4gICAgICAgICAgICAgICAgbWluaW11bUV4cG9uZW50U2l6ZSA9IHBhcnRzLmV4cG9uZW50UGFydC5zcGxpdCgnJykuZmlsdGVyKGZ1bmN0aW9uKGNoYXIpIHsgcmV0dXJuIGRlY2ltYWxEaWdpdEZhbWlseS5pbmRleE9mKGNoYXIpICE9PSAtMTsgfSkubGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGludGVnZXJQYXJ0R3JvdXBpbmdQb3NpdGlvbnM6IGludGVnZXJQYXJ0R3JvdXBpbmdQb3NpdGlvbnMsXG4gICAgICAgICAgICAgICAgcmVndWxhckdyb3VwaW5nOiByZWd1bGFyR3JvdXBpbmcsXG4gICAgICAgICAgICAgICAgbWluaW11bUludGVnZXJQYXJ0U2l6ZTogbWluaW11bUludGVnZXJQYXJ0U2l6ZSxcbiAgICAgICAgICAgICAgICBzY2FsaW5nRmFjdG9yOiBzY2FsaW5nRmFjdG9yLFxuICAgICAgICAgICAgICAgIHByZWZpeDogcGFydHMucHJlZml4LFxuICAgICAgICAgICAgICAgIGZyYWN0aW9uYWxQYXJ0R3JvdXBpbmdQb3NpdGlvbnM6IGZyYWN0aW9uYWxQYXJ0R3JvdXBpbmdQb3NpdGlvbnMsXG4gICAgICAgICAgICAgICAgbWluaW11bUZhY3Rpb25hbFBhcnRTaXplOiBtaW5pbXVtRmFjdGlvbmFsUGFydFNpemUsXG4gICAgICAgICAgICAgICAgbWF4aW11bUZhY3Rpb25hbFBhcnRTaXplOiBtYXhpbXVtRmFjdGlvbmFsUGFydFNpemUsXG4gICAgICAgICAgICAgICAgbWluaW11bUV4cG9uZW50U2l6ZTogbWluaW11bUV4cG9uZW50U2l6ZSxcbiAgICAgICAgICAgICAgICBzdWZmaXg6IHBhcnRzLnN1ZmZpeCxcbiAgICAgICAgICAgICAgICBwaWN0dXJlOiBwYXJ0cy5zdWJwaWN0dXJlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwYXJ0cyA9IHN1YlBpY3R1cmVzLm1hcChzcGxpdFBhcnRzKTtcbiAgICAgICAgcGFydHMuZm9yRWFjaCh2YWxpZGF0ZSk7XG5cbiAgICAgICAgdmFyIHZhcmlhYmxlcyA9IHBhcnRzLm1hcChhbmFseXNlKTtcblxuICAgICAgICBpZih2YXJpYWJsZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB2YXJpYWJsZXMucHVzaChKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhcmlhYmxlc1swXSkpKTtcbiAgICAgICAgICAgIHZhcmlhYmxlc1sxXS5wcmVmaXggPSBwcm9wZXJ0aWVzWydtaW51cy1zaWduJ10gKyB2YXJpYWJsZXNbMV0ucHJlZml4O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETyBjYWNoZSB0aGUgcmVzdWx0IG9mIHRoZSBhbmFseXNpc1xuXG4gICAgICAgIC8vIGZvcm1hdCB0aGUgbnVtYmVyXG4gICAgICAgIC8vIGJ1bGxldCAxOiBUT0RPOiBOYU4gLSBub3Qgc3VyZSB3ZSdkIGV2ZXIgZ2V0IHRoaXMgaW4gSlNPTlxuICAgICAgICB2YXIgcGljO1xuICAgICAgICAvLyBidWxsZXQgMjpcbiAgICAgICAgaWYodmFsdWUgPj0gMCkge1xuICAgICAgICAgICAgcGljID0gdmFyaWFibGVzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGljID0gdmFyaWFibGVzWzFdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhZGp1c3RlZE51bWJlcjtcbiAgICAgICAgLy8gYnVsbGV0IDM6XG4gICAgICAgIGlmKHBpYy5waWN0dXJlLmluZGV4T2YocHJvcGVydGllcy5wZXJjZW50KSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGFkanVzdGVkTnVtYmVyID0gdmFsdWUgKiAxMDA7XG4gICAgICAgIH0gZWxzZSBpZihwaWMucGljdHVyZS5pbmRleE9mKHByb3BlcnRpZXNbJ3Blci1taWxsZSddKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGFkanVzdGVkTnVtYmVyID0gdmFsdWUgKiAxMDAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRqdXN0ZWROdW1iZXIgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBidWxsZXQgNDpcbiAgICAgICAgLy8gVE9ETzogaW5maW5pdHkgLSBub3Qgc3VyZSB3ZSdkIGV2ZXIgZ2V0IHRoaXMgaW4gSlNPTlxuICAgICAgICAvLyBidWxsZXQgNTpcbiAgICAgICAgdmFyIG1hbnRpc3NhLCBleHBvbmVudDtcbiAgICAgICAgaWYocGljLm1pbmltdW1FeHBvbmVudFNpemUgPT09IDApIHtcbiAgICAgICAgICAgIG1hbnRpc3NhID0gYWRqdXN0ZWROdW1iZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBtYW50aXNzYSAqIDEwXmV4cG9uZW50ID0gYWRqdXN0ZWROdW1iZXJcbiAgICAgICAgICAgIHZhciBtYXhNYW50aXNzYSA9IE1hdGgucG93KDEwLCBwaWMuc2NhbGluZ0ZhY3Rvcik7XG4gICAgICAgICAgICB2YXIgbWluTWFudGlzc2EgPSBNYXRoLnBvdygxMCwgcGljLnNjYWxpbmdGYWN0b3IgLSAxKTtcbiAgICAgICAgICAgIG1hbnRpc3NhID0gYWRqdXN0ZWROdW1iZXI7XG4gICAgICAgICAgICBleHBvbmVudCA9IDA7XG4gICAgICAgICAgICB3aGlsZShtYW50aXNzYSA8IG1pbk1hbnRpc3NhKSB7XG4gICAgICAgICAgICAgICAgbWFudGlzc2EgKj0gMTA7XG4gICAgICAgICAgICAgICAgZXhwb25lbnQgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlKG1hbnRpc3NhID4gbWF4TWFudGlzc2EpIHtcbiAgICAgICAgICAgICAgICBtYW50aXNzYSAvPSAxMDtcbiAgICAgICAgICAgICAgICBleHBvbmVudCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGJ1bGxldCA2OlxuICAgICAgICB2YXIgcm91bmRlZE51bWJlciA9IGZ1bmN0aW9uUm91bmQobWFudGlzc2EsIHBpYy5tYXhpbXVtRmFjdGlvbmFsUGFydFNpemUpO1xuICAgICAgICAvLyBidWxsZXQgNzpcbiAgICAgICAgdmFyIG1ha2VTdHJpbmcgPSBmdW5jdGlvbih2YWx1ZSwgZHApIHtcbiAgICAgICAgICAgIHZhciBzdHIgPSBNYXRoLmFicyh2YWx1ZSkudG9GaXhlZChkcCk7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllc1snemVyby1kaWdpdCddICE9PSAnMCcpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJycpLm1hcChmdW5jdGlvbiAoZGlnaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoZGlnaXQgPj0gJzAnICYmIGRpZ2l0IDw9JzknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjaW1hbERpZ2l0RmFtaWx5W2RpZ2l0LmNoYXJDb2RlQXQoMCkgLSA0OF07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlnaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdHJpbmdWYWx1ZSA9IG1ha2VTdHJpbmcocm91bmRlZE51bWJlciwgcGljLm1heGltdW1GYWN0aW9uYWxQYXJ0U2l6ZSk7XG4gICAgICAgIHZhciBkZWNpbWFsUG9zID0gc3RyaW5nVmFsdWUuaW5kZXhPZignLicpO1xuICAgICAgICBpZihkZWNpbWFsUG9zID09PSAtMSkge1xuICAgICAgICAgICAgc3RyaW5nVmFsdWUgPSBzdHJpbmdWYWx1ZSArIHByb3BlcnRpZXNbJ2RlY2ltYWwtc2VwYXJhdG9yJ107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpbmdWYWx1ZSA9IHN0cmluZ1ZhbHVlLnJlcGxhY2UoJy4nLCBwcm9wZXJ0aWVzWydkZWNpbWFsLXNlcGFyYXRvciddKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZShzdHJpbmdWYWx1ZS5jaGFyQXQoMCkgPT09IHByb3BlcnRpZXNbJ3plcm8tZGlnaXQnXSkge1xuICAgICAgICAgICAgc3RyaW5nVmFsdWUgPSBzdHJpbmdWYWx1ZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUoc3RyaW5nVmFsdWUuY2hhckF0KHN0cmluZ1ZhbHVlLmxlbmd0aCAtIDEpID09PSBwcm9wZXJ0aWVzWyd6ZXJvLWRpZ2l0J10pIHtcbiAgICAgICAgICAgIHN0cmluZ1ZhbHVlID0gc3RyaW5nVmFsdWUuc3Vic3RyaW5nKDAsIHN0cmluZ1ZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ1bGxldHMgOCAmIDk6XG4gICAgICAgIGRlY2ltYWxQb3MgPSBzdHJpbmdWYWx1ZS5pbmRleE9mKHByb3BlcnRpZXNbJ2RlY2ltYWwtc2VwYXJhdG9yJ10pO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IHBpYy5taW5pbXVtSW50ZWdlclBhcnRTaXplIC0gZGVjaW1hbFBvcztcbiAgICAgICAgdmFyIHBhZFJpZ2h0ID0gcGljLm1pbmltdW1GYWN0aW9uYWxQYXJ0U2l6ZSAtIChzdHJpbmdWYWx1ZS5sZW5ndGggLSBkZWNpbWFsUG9zIC0gMSk7XG4gICAgICAgIHN0cmluZ1ZhbHVlID0gKHBhZExlZnQgPiAwID8gbmV3IEFycmF5KHBhZExlZnQgKyAxKS5qb2luKCcwJykgOiAnJykgKyBzdHJpbmdWYWx1ZTtcbiAgICAgICAgc3RyaW5nVmFsdWUgPSBzdHJpbmdWYWx1ZSArIChwYWRSaWdodCA+IDAgPyBuZXcgQXJyYXkocGFkUmlnaHQgKyAxKS5qb2luKCcwJykgOiAnJyk7XG4gICAgICAgIGRlY2ltYWxQb3MgPSBzdHJpbmdWYWx1ZS5pbmRleE9mKHByb3BlcnRpZXNbJ2RlY2ltYWwtc2VwYXJhdG9yJ10pO1xuICAgICAgICAvLyBidWxsZXQgMTA6XG4gICAgICAgIGlmKHBpYy5yZWd1bGFyR3JvdXBpbmcgPiAwKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXBDb3VudCA9IE1hdGguZmxvb3IoKGRlY2ltYWxQb3MgLSAxKSAvIHBpYy5yZWd1bGFyR3JvdXBpbmcpO1xuICAgICAgICAgICAgZm9yKHZhciBncm91cCA9IDE7IGdyb3VwIDw9IGdyb3VwQ291bnQ7IGdyb3VwKyspIHtcbiAgICAgICAgICAgICAgICBzdHJpbmdWYWx1ZSA9IFtzdHJpbmdWYWx1ZS5zbGljZSgwLCBkZWNpbWFsUG9zIC0gZ3JvdXAgKiBwaWMucmVndWxhckdyb3VwaW5nKSwgcHJvcGVydGllc1snZ3JvdXBpbmctc2VwYXJhdG9yJ10sIHN0cmluZ1ZhbHVlLnNsaWNlKGRlY2ltYWxQb3MgLSBncm91cCAqIHBpYy5yZWd1bGFyR3JvdXBpbmcpXS5qb2luKCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBpYy5pbnRlZ2VyUGFydEdyb3VwaW5nUG9zaXRpb25zLmZvckVhY2goZnVuY3Rpb24gKHBvcykge1xuICAgICAgICAgICAgICAgIHN0cmluZ1ZhbHVlID0gW3N0cmluZ1ZhbHVlLnNsaWNlKDAsIGRlY2ltYWxQb3MgLSBwb3MpLCBwcm9wZXJ0aWVzWydncm91cGluZy1zZXBhcmF0b3InXSwgc3RyaW5nVmFsdWUuc2xpY2UoZGVjaW1hbFBvcyAtIHBvcyldLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgIGRlY2ltYWxQb3MrKztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ1bGxldCAxMTpcbiAgICAgICAgZGVjaW1hbFBvcyA9IHN0cmluZ1ZhbHVlLmluZGV4T2YocHJvcGVydGllc1snZGVjaW1hbC1zZXBhcmF0b3InXSk7XG4gICAgICAgIHBpYy5mcmFjdGlvbmFsUGFydEdyb3VwaW5nUG9zaXRpb25zLmZvckVhY2goZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgICAgICBzdHJpbmdWYWx1ZSA9IFtzdHJpbmdWYWx1ZS5zbGljZSgwLCBwb3MgKyBkZWNpbWFsUG9zICsgMSksIHByb3BlcnRpZXNbJ2dyb3VwaW5nLXNlcGFyYXRvciddLCBzdHJpbmdWYWx1ZS5zbGljZShwb3MgKyBkZWNpbWFsUG9zICsgMSldLmpvaW4oJycpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gYnVsbGV0IDEyOlxuICAgICAgICBkZWNpbWFsUG9zID0gc3RyaW5nVmFsdWUuaW5kZXhPZihwcm9wZXJ0aWVzWydkZWNpbWFsLXNlcGFyYXRvciddKTtcbiAgICAgICAgaWYocGljLnBpY3R1cmUuaW5kZXhPZihwcm9wZXJ0aWVzWydkZWNpbWFsLXNlcGFyYXRvciddKSA9PT0gLTEgfHwgZGVjaW1hbFBvcyA9PT0gc3RyaW5nVmFsdWUubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgc3RyaW5nVmFsdWUgPSBzdHJpbmdWYWx1ZS5zdWJzdHJpbmcoMCwgc3RyaW5nVmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYnVsbGV0IDEzOlxuICAgICAgICBpZih0eXBlb2YgZXhwb25lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB2YXIgc3RyaW5nRXhwb25lbnQgPSBtYWtlU3RyaW5nKGV4cG9uZW50LCAwKTtcbiAgICAgICAgICAgIHBhZExlZnQgPSBwaWMubWluaW11bUV4cG9uZW50U2l6ZSAtIHN0cmluZ0V4cG9uZW50Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmKHBhZExlZnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nRXhwb25lbnQgPSBuZXcgQXJyYXkocGFkTGVmdCArIDEpLmpvaW4oJzAnKSArIHN0cmluZ0V4cG9uZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyaW5nVmFsdWUgPSBzdHJpbmdWYWx1ZSArIHByb3BlcnRpZXNbJ2V4cG9uZW50LXNlcGFyYXRvciddICsgKGV4cG9uZW50IDwgMCA/IHByb3BlcnRpZXNbJ21pbnVzLXNpZ24nXSA6ICcnKSArIHN0cmluZ0V4cG9uZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ1bGxldCAxNDpcbiAgICAgICAgc3RyaW5nVmFsdWUgPSBwaWMucHJlZml4ICsgc3RyaW5nVmFsdWUgKyBwaWMuc3VmZml4O1xuICAgICAgICByZXR1cm4gc3RyaW5nVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBudW1iZXIgdG8gYSBzdHJpbmcgdXNpbmcgYSBzcGVjaWZpZWQgbnVtYmVyIGJhc2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSB0aGUgbnVtYmVyIHRvIGNvbnZlcnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JhZGl4XSAtIHRoZSBudW1iZXIgYmFzZTsgbXVzdCBiZSBiZXR3ZWVuIDIgYW5kIDM2LiBEZWZhdWx0cyB0byAxMFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIGNvbnZlcnRlZCBzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkZvcm1hdEJhc2UodmFsdWUsIHJhZGl4KSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gZnVuY3Rpb25Sb3VuZCh2YWx1ZSk7XG5cbiAgICAgICAgaWYodHlwZW9mIHJhZGl4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmFkaXggPSAxMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhZGl4ID0gZnVuY3Rpb25Sb3VuZChyYWRpeCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihyYWRpeCA8IDIgfHwgcmFkaXggPiAzNikge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGNvZGU6ICdEMzEwMCcsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJhZGl4XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gdmFsdWUudG9TdHJpbmcocmFkaXgpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FzdCBhcmd1bWVudCB0byBudW1iZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnIC0gQXJndW1lbnRcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBudW1lcmljIHZhbHVlIG9mIGFyZ3VtZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25OdW1iZXIoYXJnKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgLy8gYWxyZWFkeSBhIG51bWJlclxuICAgICAgICAgICAgcmVzdWx0ID0gYXJnO1xuICAgICAgICB9IGVsc2UgaWYodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgJiYgL14tPygwfChbMS05XVswLTldKikpKFxcLlswLTldKyk/KFtFZV1bLStdP1swLTldKyk/JC8udGVzdChhcmcpICYmICFpc05hTihwYXJzZUZsb2F0KGFyZykpICYmIGlzRmluaXRlKGFyZykpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcnNlRmxvYXQoYXJnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkQzMDMwXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGFyZyxcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICBpbmRleDogMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFic29sdXRlIHZhbHVlIG9mIGEgbnVtYmVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZyAtIEFyZ3VtZW50XG4gICAgICogQHJldHVybnMge051bWJlcn0gYWJzb2x1dGUgdmFsdWUgb2YgYXJndW1lbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkFicyhhcmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gTWF0aC5hYnMoYXJnKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSb3VuZHMgYSBudW1iZXIgZG93biB0byBpbnRlZ2VyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZyAtIEFyZ3VtZW50XG4gICAgICogQHJldHVybnMge051bWJlcn0gcm91bmRlZCBpbnRlZ2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25GbG9vcihhcmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gTWF0aC5mbG9vcihhcmcpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJvdW5kcyBhIG51bWJlciB1cCB0byBpbnRlZ2VyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZyAtIEFyZ3VtZW50XG4gICAgICogQHJldHVybnMge051bWJlcn0gcm91bmRlZCBpbnRlZ2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25DZWlsKGFyZykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBNYXRoLmNlaWwoYXJnKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSb3VuZCB0byBoYWxmIGV2ZW5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJnIC0gQXJndW1lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcHJlY2lzaW9uIC0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzXG4gICAgICogQHJldHVybnMge051bWJlcn0gcm91bmRlZCBpbnRlZ2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Sb3VuZChhcmcsIHByZWNpc2lvbikge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZihwcmVjaXNpb24pIHtcbiAgICAgICAgICAgIC8vIHNoaWZ0IHRoZSBkZWNpbWFsIHBsYWNlIC0gdGhpcyBuZWVkcyB0byBiZSBkb25lIGluIGEgc3RyaW5nIHNpbmNlIG11bHRpcGx5aW5nXG4gICAgICAgICAgICAvLyBieSBhIHBvd2VyIG9mIHRlbiBjYW4gaW50cm9kdWNlIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbiBlcnJvcnMgd2hpY2ggbWVzcyB1cFxuICAgICAgICAgICAgLy8gdGhpcyByb3VuZGluZyBhbGdvcml0aG0gLSBTZWUgJ0RlY2ltYWwgcm91bmRpbmcnIGluXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3JvdW5kXG4gICAgICAgICAgICAvLyBTaGlmdFxuICAgICAgICAgICAgdmFyIHZhbHVlID0gYXJnLnRvU3RyaW5nKCkuc3BsaXQoJ2UnKTtcbiAgICAgICAgICAgIGFyZyA9ICsodmFsdWVbMF0gKyAnZScgKyAodmFsdWVbMV0gPyAoK3ZhbHVlWzFdICsgcHJlY2lzaW9uKSA6IHByZWNpc2lvbikpO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyByb3VuZCB1cCB0byBuZWFyZXN0IGludFxuICAgICAgICByZXN1bHQgPSBNYXRoLnJvdW5kKGFyZyk7XG4gICAgICAgIHZhciBkaWZmID0gcmVzdWx0IC0gYXJnO1xuICAgICAgICBpZihNYXRoLmFicyhkaWZmKSA9PT0gMC41ICYmIE1hdGguYWJzKHJlc3VsdCAlIDIpID09PSAxKSB7XG4gICAgICAgICAgICAvLyByb3VuZGVkIHRoZSB3cm9uZyB3YXkgLSBhZGp1c3QgdG8gbmVhcmVzdCBldmVuIG51bWJlclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0IC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZihwcmVjaXNpb24pIHtcbiAgICAgICAgICAgIC8vIFNoaWZ0IGJhY2tcbiAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0LnRvU3RyaW5nKCkuc3BsaXQoJ2UnKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICByZXN1bHQgPSArKHZhbHVlWzBdICsgJ2UnICsgKHZhbHVlWzFdID8gKCt2YWx1ZVsxXSAtIHByZWNpc2lvbikgOiAtcHJlY2lzaW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoT2JqZWN0LmlzKHJlc3VsdCwgLTApKSB7IC8vIEVTTGludCBydWxlICduby1jb21wYXJlLW5lZy16ZXJvJyBzdWdnZXN0cyB0aGlzIHdheVxuICAgICAgICAgICAgLy8gSlNPTiBkb2Vzbid0IGRvIC0wXG4gICAgICAgICAgICByZXN1bHQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3F1YXJlIHJvb3Qgb2YgbnVtYmVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZyAtIEFyZ3VtZW50XG4gICAgICogQHJldHVybnMge051bWJlcn0gc3F1YXJlIHJvb3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblNxcnQoYXJnKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGFyZyA8IDApIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkQzMDYwXCIsXG4gICAgICAgICAgICAgICAgaW5kZXg6IDEsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGFyZ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IE1hdGguc3FydChhcmcpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmFpc2VzIG51bWJlciB0byB0aGUgcG93ZXIgb2YgdGhlIHNlY29uZCBudW1iZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJnIC0gdGhlIGJhc2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZXhwIC0gdGhlIGV4cG9uZW50XG4gICAgICogQHJldHVybnMge051bWJlcn0gcm91bmRlZCBpbnRlZ2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Qb3dlcihhcmcsIGV4cCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBNYXRoLnBvdyhhcmcsIGV4cCk7XG5cbiAgICAgICAgaWYoIWlzRmluaXRlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkQzMDYxXCIsXG4gICAgICAgICAgICAgICAgaW5kZXg6IDEsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGFyZyxcbiAgICAgICAgICAgICAgICBleHA6IGV4cFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJhbmRvbSBudW1iZXIgMCA8PSBuIDwgMVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHJhbmRvbSBudW1iZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblJhbmRvbSgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgYW4gaW5wdXQgYW5kIHJldHVybiBhIGJvb2xlYW5cbiAgICAgKiBAcGFyYW0geyp9IGFyZyAtIEFyZ3VtZW50c1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBCb29sZWFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Cb29sZWFuKGFyZykge1xuICAgICAgICAvLyBjYXN0IGFyZyB0byBpdHMgZWZmZWN0aXZlIGJvb2xlYW4gdmFsdWVcbiAgICAgICAgLy8gYm9vbGVhbjogdW5jaGFuZ2VkXG4gICAgICAgIC8vIHN0cmluZzogemVyby1sZW5ndGggLT4gZmFsc2U7IG90aGVyd2lzZSAtPiB0cnVlXG4gICAgICAgIC8vIG51bWJlcjogMCAtPiBmYWxzZTsgb3RoZXJ3aXNlIC0+IHRydWVcbiAgICAgICAgLy8gbnVsbCAtPiBmYWxzZVxuICAgICAgICAvLyBhcnJheTogZW1wdHkgLT4gZmFsc2U7IGxlbmd0aCA+IDEgLT4gdHJ1ZVxuICAgICAgICAvLyBvYmplY3Q6IGVtcHR5IC0+IGZhbHNlOyBub24tZW1wdHkgLT4gdHJ1ZVxuICAgICAgICAvLyBmdW5jdGlvbiAtPiBmYWxzZVxuXG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICAgIGlmIChhcmcubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuY3Rpb25Cb29sZWFuKGFyZ1swXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRydWVzID0gYXJnLmZpbHRlcihmdW5jdGlvbih2YWwpIHtyZXR1cm4gZnVuY3Rpb25Cb29sZWFuKHZhbCk7fSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZXMubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGFyZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc051bWVyaWMoYXJnKSkge1xuICAgICAgICAgICAgaWYgKGFyZyAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYXJnICE9PSBudWxsICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoYXJnKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGl0J3Mgbm90IGEgbGFtYmRhIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKCEoaXNMYW1iZGEoYXJnKSB8fCBhcmcuX2pzb25hdGFfZnVuY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyAmJiBhcmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSBCb29sZWFuIE5PVCBvZiB0aGUgYXJnXG4gICAgICogQHBhcmFtIHsqfSBhcmcgLSBhcmd1bWVudFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIE5PVCBhcmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbk5vdChhcmcpIHtcbiAgICAgICAgcmV0dXJuICFmdW5jdGlvbkJvb2xlYW4oYXJnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBtYXAgZnJvbSBhbiBhcnJheSBvZiBhcmd1bWVudHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyXSAtIGFycmF5IHRvIG1hcCBvdmVyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIGZ1bmN0aW9uIHRvIGFwcGx5XG4gICAgICogQHJldHVybnMge0FycmF5fSBNYXAgYXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZnVuY3Rpb25NYXAoYXJyLCBmdW5jKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIC8vIGRvIHRoZSBtYXAgLSBpdGVyYXRlIG92ZXIgdGhlIGFycmF5cywgYW5kIGludm9rZSBmdW5jXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZnVuY19hcmdzID0gW2FycltpXV07IC8vIHRoZSBmaXJzdCBhcmcgKHZhbHVlKSBpcyByZXF1aXJlZFxuICAgICAgICAgICAgLy8gdGhlIG90aGVyIHR3byBhcmUgb3B0aW9uYWwgLSBvbmx5IHN1cHBseSBpdCBpZiB0aGUgZnVuY3Rpb24gY2FuIHRha2UgaXRcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSB0eXBlb2YgZnVuYyA9PT0gJ2Z1bmN0aW9uJyA/IGZ1bmMubGVuZ3RoIDpcbiAgICAgICAgICAgICAgICBmdW5jLl9qc29uYXRhX2Z1bmN0aW9uID09PSB0cnVlID8gZnVuYy5pbXBsZW1lbnRhdGlvbi5sZW5ndGggOiBmdW5jLmFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBpZihsZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICAgIGZ1bmNfYXJncy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYobGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgICAgICBmdW5jX2FyZ3MucHVzaChhcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaW52b2tlIGZ1bmNcbiAgICAgICAgICAgIHZhciByZXMgPSB5aWVsZCAqIGFwcGx5KGZ1bmMsIGZ1bmNfYXJncywgbnVsbCk7XG4gICAgICAgICAgICBpZih0eXBlb2YgcmVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIFRoaXMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGRvZXMgbm90IGhhdmUgYSB5aWVsZCgpLCBwcmVzdW1hYmx5IHRvIG1ha2UgaXRcbiAgICAvLyBjb25zaXN0ZW50IHdpdGggb3RoZXIgc2ltaWxhciBmdW5jdGlvbnMuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbWFwIGZyb20gYW4gYXJyYXkgb2YgYXJndW1lbnRzXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2Fycl0gLSBhcnJheSB0byBmaWx0ZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gcHJlZGljYXRlIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge0FycmF5fSBNYXAgYXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZnVuY3Rpb25GaWx0ZXIoYXJyLCBmdW5jKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS15aWVsZFxuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcnIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIHZhciBwcmVkaWNhdGUgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBhcnJheSkge1xuICAgICAgICAgICAgdmFyIGl0ID0gYXBwbHkoZnVuYywgW3ZhbHVlLCBpbmRleCwgYXJyYXldLCBudWxsKTtcbiAgICAgICAgICAgIC8vIHJldHVybnMgYSBnZW5lcmF0b3IgLSBzbyBpdGVyYXRlIG92ZXIgaXRcbiAgICAgICAgICAgIHZhciByZXMgPSBpdC5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAoIXJlcy5kb25lKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gaXQubmV4dChyZXMudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBhcnJbaV07XG4gICAgICAgICAgICBpZihmdW5jdGlvbkJvb2xlYW4ocHJlZGljYXRlKGVudHJ5LCBpLCBhcnIpKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udm9sdmVzICh6aXBzKSBlYWNoIHZhbHVlIGZyb20gYSBzZXQgb2YgYXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdIC0gYXJyYXlzIHRvIHppcFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gWmlwcGVkIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25aaXAoKSB7XG4gICAgICAgIC8vIHRoaXMgY2FuIHRha2UgYSB2YXJpYWJsZSBudW1iZXIgb2YgYXJndW1lbnRzXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAvLyBsZW5ndGggb2YgdGhlIHNob3J0ZXN0IGFycmF5XG4gICAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1pbi5hcHBseShNYXRoLCBhcmdzLm1hcChmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgIGlmKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmcubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0pKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdHVwbGUgPSBhcmdzLm1hcCgoYXJnKSA9PiB7cmV0dXJuIGFyZ1tpXTt9KTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHR1cGxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvbGQgbGVmdCBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNlcXVlbmNlIC0gU2VxdWVuY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5pdCAtIEluaXRpYWwgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmVzdWx0XG4gICAgICovXG4gICAgZnVuY3Rpb24qIGZ1bmN0aW9uRm9sZExlZnQoc2VxdWVuY2UsIGZ1bmMsIGluaXQpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2Ygc2VxdWVuY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICBpZiAoIShmdW5jLmxlbmd0aCA9PT0gMiB8fCAoZnVuYy5fanNvbmF0YV9mdW5jdGlvbiA9PT0gdHJ1ZSAmJiBmdW5jLmltcGxlbWVudGF0aW9uLmxlbmd0aCA9PT0gMikgfHwgZnVuYy5hcmd1bWVudHMubGVuZ3RoID09PSAyKSkge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgIGNvZGU6IFwiRDMwNTBcIixcbiAgICAgICAgICAgICAgICBpbmRleDogMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgaWYgKHR5cGVvZiBpbml0ID09PSAndW5kZWZpbmVkJyAmJiBzZXF1ZW5jZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzZXF1ZW5jZVswXTtcbiAgICAgICAgICAgIGluZGV4ID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGluaXQ7XG4gICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBzZXF1ZW5jZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogYXBwbHkoZnVuYywgW3Jlc3VsdCwgc2VxdWVuY2VbaW5kZXhdXSwgbnVsbCk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4ga2V5cyBmb3IgYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZyAtIE9iamVjdFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2Yga2V5c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uS2V5cyhhcmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGlmKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgLy8gbWVyZ2UgdGhlIGtleXMgb2YgYWxsIG9mIHRoZSBpdGVtcyBpbiB0aGUgYXJyYXlcbiAgICAgICAgICAgIHZhciBtZXJnZSA9IHt9O1xuICAgICAgICAgICAgYXJnLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gZnVuY3Rpb25LZXlzKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGlmKEFycmF5LmlzQXJyYXkoa2V5cykpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2Vba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuY3Rpb25LZXlzKG1lcmdlKTtcbiAgICAgICAgfSBlbHNlIGlmKGFyZyAhPT0gbnVsbCAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiAhKGlzTGFtYmRhKGFyZykpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBPYmplY3Qua2V5cyhhcmcpO1xuICAgICAgICAgICAgaWYocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB2YWx1ZSBmcm9tIGFuIG9iamVjdCBmb3IgYSBnaXZlbiBrZXlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gT2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIEtleSBpbiBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7Kn0gVmFsdWUgb2Yga2V5IGluIG9iamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uTG9va3VwKG9iamVjdCwga2V5KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBldmFsdWF0ZU5hbWUoe3ZhbHVlOiBrZXl9LCBvYmplY3QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGVuZCBzZWNvbmQgYXJndW1lbnQgdG8gZmlyc3RcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gYXJnMSAtIEZpcnN0IGFyZ3VtZW50XG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGFyZzIgLSBTZWNvbmQgYXJndW1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gQXBwZW5kZWQgYXJndW1lbnRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25BcHBlbmQoYXJnMSwgYXJnMikge1xuICAgICAgICAvLyBkaXNyZWdhcmQgdW5kZWZpbmVkIGFyZ3NcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcxID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZzI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhcmcyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZzE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgZWl0aGVyIGFyZ3VtZW50IGlzIG5vdCBhbiBhcnJheSwgbWFrZSBpdCBzb1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJnMSkpIHtcbiAgICAgICAgICAgIGFyZzEgPSBbYXJnMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZzIpKSB7XG4gICAgICAgICAgICBhcmcyID0gW2FyZzJdO1xuICAgICAgICB9XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGFyZzEsIGFyZzIpO1xuICAgICAgICByZXR1cm4gYXJnMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBhcmd1bWVudCBpcyB1bmRlZmluZWRcbiAgICAgKiBAcGFyYW0geyp9IGFyZyAtIGFyZ3VtZW50XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IEZhbHNlIGlmIGFyZ3VtZW50IHVuZGVmaW5lZCwgb3RoZXJ3aXNlIHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkV4aXN0cyhhcmcpe1xuICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIGFuIG9iamVjdCBpbnRvIGFuIGFycmF5IG9mIG9iamVjdCB3aXRoIG9uZSBwcm9wZXJ0eSBlYWNoXG4gICAgICogQHBhcmFtIHsqfSBhcmcgLSB0aGUgb2JqZWN0IHRvIHNwbGl0XG4gICAgICogQHJldHVybnMgeyp9IC0gdGhlIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25TcHJlYWQoYXJnKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBpZihBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICAgIC8vIHNwcmVhZCBhbGwgb2YgdGhlIGl0ZW1zIGluIHRoZSBhcnJheVxuICAgICAgICAgICAgYXJnLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmN0aW9uQXBwZW5kKHJlc3VsdCwgZnVuY3Rpb25TcHJlYWQoaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZihhcmcgIT09IG51bGwgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgIWlzTGFtYmRhKGFyZykpIHtcbiAgICAgICAgICAgIGZvcih2YXIga2V5IGluIGFyZykge1xuICAgICAgICAgICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IGFyZ1trZXldO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhcmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpbnRvIGEgc2luZ2xlIG9iamVjdC4gIER1cGxpY2F0ZSBwcm9wZXJ0aWVzIGFyZVxuICAgICAqIG92ZXJyaWRkZW4gYnkgZW50cmllcyBsYXRlciBpbiB0aGUgYXJyYXlcbiAgICAgKiBAcGFyYW0geyp9IGFyZyAtIHRoZSBvYmplY3RzIHRvIG1lcmdlXG4gICAgICogQHJldHVybnMgeyp9IC0gdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uTWVyZ2UoYXJnKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICAgICAgYXJnLmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICBmb3IodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnNlcyB0aGUgb3JkZXIgb2YgaXRlbXMgaW4gYW4gYXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnIgLSB0aGUgYXJyYXkgdG8gcmV2ZXJzZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gLSB0aGUgcmV2ZXJzZWQgYXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblJldmVyc2UoYXJyKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZihhcnIubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtsZW5ndGggLSBpIC0gMV0gPSBhcnJbaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBvYmogLSB0aGUgaW5wdXQgb2JqZWN0IHRvIGl0ZXJhdGUgb3ZlclxuICAgICAqIEBwYXJhbSB7Kn0gZnVuYyAtIHRoZSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGtleS92YWx1ZSBwYWlyXG4gICAgICogQHJldHVybnMge0FycmF5fSAtIHRoZSByZXN1bHRhbnQgYXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZnVuY3Rpb25FYWNoKG9iaiwgZnVuYykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgZm9yKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICB2YXIgZnVuY19hcmdzID0gW29ialtrZXldLCBrZXldO1xuICAgICAgICAgICAgLy8gaW52b2tlIGZ1bmNcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHlpZWxkICogYXBwbHkoZnVuYywgZnVuY19hcmdzLCBudWxsKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgdGhlIG1lcmdlIHNvcnQgKHN0YWJsZSkgd2l0aCBvcHRpb25hbCBjb21wYXJhdG9yIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnIgLSB0aGUgYXJyYXkgdG8gc29ydFxuICAgICAqIEBwYXJhbSB7Kn0gY29tcGFyYXRvciAtIGNvbXBhcmF0b3IgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IC0gc29ydGVkIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Tb3J0KGFyciwgY29tcGFyYXRvcikge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcnIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoYXJyLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbXA7XG4gICAgICAgIGlmKHR5cGVvZiBjb21wYXJhdG9yID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gaW5qZWN0IGEgZGVmYXVsdCBjb21wYXJhdG9yIC0gb25seSB3b3JrcyBmb3IgbnVtZXJpYyBvciBzdHJpbmcgYXJyYXlzXG4gICAgICAgICAgICBpZiAoIWlzQXJyYXlPZk51bWJlcnMoYXJyKSAmJiAhaXNBcnJheU9mU3RyaW5ncyhhcnIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogXCJEMzA3MFwiLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogMVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbXAgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhID4gYjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZih0eXBlb2YgY29tcGFyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZm9yIGludGVybmFsIHVzYWdlIG9mIGZ1bmN0aW9uU29ydCAoaS5lLiBvcmRlci1ieSBzeW50YXgpXG4gICAgICAgICAgICBjb21wID0gY29tcGFyYXRvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXAgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHZhciBpdCA9IGFwcGx5KGNvbXBhcmF0b3IsIFthLCBiXSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJucyBhIGdlbmVyYXRvciAtIHNvIGl0ZXJhdGUgb3ZlciBpdFxuICAgICAgICAgICAgICAgIHZhciBjb21wID0gaXQubmV4dCgpO1xuICAgICAgICAgICAgICAgIHdoaWxlICghY29tcC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXAgPSBpdC5uZXh0KGNvbXAudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcC52YWx1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWVyZ2UgPSBmdW5jdGlvbihsLCByKSB7XG4gICAgICAgICAgICB2YXIgbWVyZ2VfaXRlciA9IGZ1bmN0aW9uKHJlc3VsdCwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICAgICAgICBpZiAobGVmdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocmVzdWx0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyaWdodC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocmVzdWx0LCBsZWZ0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbXAobGVmdFswXSwgcmlnaHRbMF0pKSB7IC8vIGludm9rZSB0aGUgY29tcGFyYXRvciBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdCByZXR1cm5zIHRydWUgLSBzd2FwIGxlZnQgYW5kIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJpZ2h0WzBdKTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VfaXRlcihyZXN1bHQsIGxlZnQsIHJpZ2h0LnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2Uga2VlcCB0aGUgc2FtZSBvcmRlclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsZWZ0WzBdKTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VfaXRlcihyZXN1bHQsIGxlZnQuc2xpY2UoMSksIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG1lcmdlZCA9IFtdO1xuICAgICAgICAgICAgbWVyZ2VfaXRlcihtZXJnZWQsIGwsIHIpO1xuICAgICAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc29ydCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgICAgICBpZihhcnJheS5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pZGRsZSA9IE1hdGguZmxvb3IoYXJyYXkubGVuZ3RoIC8gMik7XG4gICAgICAgICAgICAgICAgdmFyIGxlZnQgPSBhcnJheS5zbGljZSgwLCBtaWRkbGUpO1xuICAgICAgICAgICAgICAgIHZhciByaWdodCA9IGFycmF5LnNsaWNlKG1pZGRsZSk7XG4gICAgICAgICAgICAgICAgbGVmdCA9IHNvcnQobGVmdCk7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSBzb3J0KHJpZ2h0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2UobGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBzb3J0KGFycik7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSYW5kb21seSBzaHVmZmxlcyB0aGUgY29udGVudHMgb2YgYW4gYXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnIgLSB0aGUgaW5wdXQgYXJyYXlcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBzaHVmZmxlZCBhcnJheVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uU2h1ZmZsZShhcnIpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgYXJyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGFyci5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNodWZmbGUgdXNpbmcgdGhlICdpbnNpZGUtb3V0JyB2YXJpYW50IG9mIHRoZSBGaXNoZXItWWF0ZXMgYWxnb3JpdGhtXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGkgKyAxKSk7IC8vIHJhbmRvbSBpbnRlZ2VyIHN1Y2ggdGhhdCAwIOKJpCBqIOKJpCBpXG4gICAgICAgICAgICBpZihpICE9PSBqKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gcmVzdWx0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2pdID0gYXJyW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGEgcHJlZGljYXRlIGZ1bmN0aW9uIHRvIGVhY2gga2V5L3ZhbHVlIHBhaXIgaW4gYW4gb2JqZWN0LCBhbmQgcmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZ1xuICAgICAqIG9ubHkgdGhlIGtleS92YWx1ZSBwYWlycyB0aGF0IHBhc3NlZCB0aGUgcHJlZGljYXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYXJnIC0gdGhlIG9iamVjdCB0byBiZSBzaWZ0ZWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZnVuYyAtIHRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gKGxhbWJkYSBvciBuYXRpdmUpXG4gICAgICogQHJldHVybnMge29iamVjdH0gLSBzaWZ0ZWQgb2JqZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25TaWZ0KGFyZywgZnVuYykge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICAgICAgdmFyIHByZWRpY2F0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBpdCA9IGFwcGx5KGZ1bmMsIFt2YWx1ZSwga2V5LCBvYmplY3RdLCBudWxsKTtcbiAgICAgICAgICAgIC8vIHJldHVybnMgYSBnZW5lcmF0b3IgLSBzbyBpdGVyYXRlIG92ZXIgaXRcbiAgICAgICAgICAgIHZhciByZXMgPSBpdC5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAoIXJlcy5kb25lKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gaXQubmV4dChyZXMudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IodmFyIGl0ZW0gaW4gYXJnKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBhcmdbaXRlbV07XG4gICAgICAgICAgICBpZihmdW5jdGlvbkJvb2xlYW4ocHJlZGljYXRlKGVudHJ5LCBpdGVtLCBhcmcpKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpdGVtXSA9IGVudHJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW1wdHkgb2JqZWN0cyBzaG91bGQgYmUgY2hhbmdlZCB0byB1bmRlZmluZWRcbiAgICAgICAgaWYoT2JqZWN0LmtleXMocmVzdWx0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gUmVndWxhciBleHByZXNzaW9uIHRvIG1hdGNoIGFuIElTTyA4NjAxIGZvcm1hdHRlZCB0aW1lc3RhbXBcbiAgICB2YXIgaXNvODYwMXJlZ2V4ID0gbmV3IFJlZ0V4cCgnXlxcXFxkezR9LVswMV1cXFxcZC1bMC0zXVxcXFxkVFswLTJdXFxcXGQ6WzAtNV1cXFxcZDpbMC01XVxcXFxkXFxcXC5cXFxcZCsoWystXVswLTJdXFxcXGQ6WzAtNV1cXFxcZHxaKSQnKTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFuIElTTyA4NjAxIHRpbWVzdGFtcCB0byBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGVwb2NoXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGltZXN0YW1wIC0gdGhlIElTTyA4NjAxIHRpbWVzdGFtcCB0byBiZSBjb252ZXJ0ZWRcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSAtIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgZXBvY2hcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblRvTWlsbGlzKHRpbWVzdGFtcCkge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiB0aW1lc3RhbXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIWlzbzg2MDFyZWdleC50ZXN0KHRpbWVzdGFtcCkpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkQzMTEwXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRpbWVzdGFtcFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBEYXRlLnBhcnNlKHRpbWVzdGFtcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBlcG9jaCB0byBhbiBJU08gODYwMSB0aW1lc3RhbXBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWlsbGlzIC0gbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBlcG9jaCB0byBiZSBjb252ZXJ0ZWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSAtIGFuIElTTyA4NjAxIGZvcm1hdHRlZCB0aW1lc3RhbXBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkZyb21NaWxsaXMobWlsbGlzKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIG1pbGxpcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IERhdGUobWlsbGlzKS50b0lTT1N0cmluZygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb25lcyBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnIC0gb2JqZWN0IHRvIGNsb25lIChkZWVwIGNvcHkpXG4gICAgICogQHJldHVybnMgeyp9IC0gdGhlIGNsb25lZCBvYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkNsb25lKGFyZykge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZnVuY3Rpb25TdHJpbmcoYXJnKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGZyYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVuY2xvc2luZ0Vudmlyb25tZW50IC0gRW5jbG9zaW5nIGVudmlyb25tZW50XG4gICAgICogQHJldHVybnMge3tiaW5kOiBiaW5kLCBsb29rdXA6IGxvb2t1cH19IENyZWF0ZWQgZnJhbWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGcmFtZShlbmNsb3NpbmdFbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgYmluZGluZ3MgPSB7fTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJpbmQ6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGJpbmRpbmdzW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG9va3VwOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZihiaW5kaW5ncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGJpbmRpbmdzW25hbWVdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZW5jbG9zaW5nRW52aXJvbm1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBlbmNsb3NpbmdFbnZpcm9ubWVudC5sb29rdXAobmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBGdW5jdGlvbiByZWdpc3RyYXRpb25cbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdzdW0nLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvblN1bSwgJzxhPG4+Om4+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2NvdW50JywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25Db3VudCwgJzxhOm4+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ21heCcsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uTWF4LCAnPGE8bj46bj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnbWluJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25NaW4sICc8YTxuPjpuPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdhdmVyYWdlJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25BdmVyYWdlLCAnPGE8bj46bj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnc3RyaW5nJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25TdHJpbmcsICc8eC06cz4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnc3Vic3RyaW5nJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25TdWJzdHJpbmcsICc8cy1ubj86cz4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnc3Vic3RyaW5nQmVmb3JlJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25TdWJzdHJpbmdCZWZvcmUsICc8cy1zOnM+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3N1YnN0cmluZ0FmdGVyJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25TdWJzdHJpbmdBZnRlciwgJzxzLXM6cz4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnbG93ZXJjYXNlJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25Mb3dlcmNhc2UsICc8cy06cz4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgndXBwZXJjYXNlJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25VcHBlcmNhc2UsICc8cy06cz4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnbGVuZ3RoJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25MZW5ndGgsICc8cy06bj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgndHJpbScsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uVHJpbSwgJzxzLTpzPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdwYWQnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvblBhZCwgJzxzLW5zPzpzPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdtYXRjaCcsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uTWF0Y2gsICc8cy1mPHM6bz5uPzphPG8+PicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdjb250YWlucycsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uQ29udGFpbnMsICc8cy0oc2YpOmI+JykpOyAvLyBUT0RPIDxzLShzZjxzOm8+KTpiPlxuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3JlcGxhY2UnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvblJlcGxhY2UsICc8cy0oc2YpKHNmKW4/OnM+JykpOyAvLyBUT0RPIDxzLShzZjxzOm8+KShzZjxvOnM+KW4/OnM+XG4gICAgc3RhdGljRnJhbWUuYmluZCgnc3BsaXQnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvblNwbGl0LCAnPHMtKHNmKW4/OmE8cz4+JykpOyAvLyBUT0RPIDxzLShzZjxzOm8+KW4/OmE8cz4+XG4gICAgc3RhdGljRnJhbWUuYmluZCgnam9pbicsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uSm9pbiwgJzxhPHM+cz86cz4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnZm9ybWF0TnVtYmVyJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25Gb3JtYXROdW1iZXIsICc8bi1zbz86cz4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnZm9ybWF0QmFzZScsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uRm9ybWF0QmFzZSwgJzxuLW4/OnM+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ251bWJlcicsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uTnVtYmVyLCAnPChucyktOm4+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2Zsb29yJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25GbG9vciwgJzxuLTpuPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdjZWlsJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25DZWlsLCAnPG4tOm4+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3JvdW5kJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25Sb3VuZCwgJzxuLW4/Om4+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2FicycsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uQWJzLCAnPG4tOm4+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3NxcnQnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvblNxcnQsICc8bi06bj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgncG93ZXInLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvblBvd2VyLCAnPG4tbjpuPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdyYW5kb20nLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvblJhbmRvbSwgJzw6bj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnYm9vbGVhbicsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uQm9vbGVhbiwgJzx4LTpiPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdub3QnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbk5vdCwgJzx4LTpiPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdtYXAnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbk1hcCwgJzxhZj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnemlwJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25aaXAsICc8YSs+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2ZpbHRlcicsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uRmlsdGVyLCAnPGFmPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdyZWR1Y2UnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbkZvbGRMZWZ0LCAnPGFmaj86aj4nKSk7IC8vIFRPRE8gPGY8amo6aj5hPGo+aj86aj5cbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdzaWZ0JywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25TaWZ0LCAnPG8tZj86bz4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgna2V5cycsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uS2V5cywgJzx4LTphPHM+PicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdsb29rdXAnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbkxvb2t1cCwgJzx4LXM6eD4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnYXBwZW5kJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25BcHBlbmQsICc8eHg6YT4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnZXhpc3RzJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25FeGlzdHMsICc8eDpiPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdzcHJlYWQnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvblNwcmVhZCwgJzx4LTphPG8+PicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdtZXJnZScsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uTWVyZ2UsICc8YTxvPjpvPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdyZXZlcnNlJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25SZXZlcnNlLCAnPGE6YT4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnZWFjaCcsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uRWFjaCwgJzxvLWY6YT4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnc29ydCcsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uU29ydCwgJzxhZj86YT4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnc2h1ZmZsZScsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uU2h1ZmZsZSwgJzxhOmE+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2Jhc2U2NGVuY29kZScsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uQmFzZTY0ZW5jb2RlLCAnPHMtOnM+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2Jhc2U2NGRlY29kZScsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uQmFzZTY0ZGVjb2RlLCAnPHMtOnM+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3RvTWlsbGlzJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25Ub01pbGxpcywgJzxzLTpuPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdmcm9tTWlsbGlzJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25Gcm9tTWlsbGlzLCAnPG4tOnM+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2Nsb25lJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25DbG9uZSwgJzwob2EpLTpvPicpKTtcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGVzXG4gICAgICpcbiAgICAgKi9cbiAgICB2YXIgZXJyb3JDb2RlcyA9IHtcbiAgICAgICAgXCJTMDEwMVwiOiBcIlN0cmluZyBsaXRlcmFsIG11c3QgYmUgdGVybWluYXRlZCBieSBhIG1hdGNoaW5nIHF1b3RlXCIsXG4gICAgICAgIFwiUzAxMDJcIjogXCJOdW1iZXIgb3V0IG9mIHJhbmdlOiB7e3Rva2VufX1cIixcbiAgICAgICAgXCJTMDEwM1wiOiBcIlVuc3VwcG9ydGVkIGVzY2FwZSBzZXF1ZW5jZTogXFxcXHt7dG9rZW59fVwiLFxuICAgICAgICBcIlMwMTA0XCI6IFwiVGhlIGVzY2FwZSBzZXF1ZW5jZSBcXFxcdSBtdXN0IGJlIGZvbGxvd2VkIGJ5IDQgaGV4IGRpZ2l0c1wiLFxuICAgICAgICBcIlMwMTA1XCI6IFwiUXVvdGVkIHByb3BlcnR5IG5hbWUgbXVzdCBiZSB0ZXJtaW5hdGVkIHdpdGggYSBiYWNrcXVvdGUgKGApXCIsXG4gICAgICAgIFwiUzAyMDFcIjogXCJTeW50YXggZXJyb3I6IHt7dG9rZW59fVwiLFxuICAgICAgICBcIlMwMjAyXCI6IFwiRXhwZWN0ZWQge3t2YWx1ZX19LCBnb3Qge3t0b2tlbn19XCIsXG4gICAgICAgIFwiUzAyMDNcIjogXCJFeHBlY3RlZCB7e3ZhbHVlfX0gYmVmb3JlIGVuZCBvZiBleHByZXNzaW9uXCIsXG4gICAgICAgIFwiUzAyMDRcIjogXCJVbmtub3duIG9wZXJhdG9yOiB7e3Rva2VufX1cIixcbiAgICAgICAgXCJTMDIwNVwiOiBcIlVuZXhwZWN0ZWQgdG9rZW46IHt7dG9rZW59fVwiLFxuICAgICAgICBcIlMwMjA2XCI6IFwiVW5rbm93biBleHByZXNzaW9uIHR5cGU6IHt7dG9rZW59fVwiLFxuICAgICAgICBcIlMwMjA3XCI6IFwiVW5leHBlY3RlZCBlbmQgb2YgZXhwcmVzc2lvblwiLFxuICAgICAgICBcIlMwMjA4XCI6IFwiUGFyYW1ldGVyIHt7dmFsdWV9fSBvZiBmdW5jdGlvbiBkZWZpbml0aW9uIG11c3QgYmUgYSB2YXJpYWJsZSBuYW1lIChzdGFydCB3aXRoICQpXCIsXG4gICAgICAgIFwiUzAyMDlcIjogXCJBIHByZWRpY2F0ZSBjYW5ub3QgZm9sbG93IGEgZ3JvdXBpbmcgZXhwcmVzc2lvbiBpbiBhIHN0ZXBcIixcbiAgICAgICAgXCJTMDIxMFwiOiBcIkVhY2ggc3RlcCBjYW4gb25seSBoYXZlIG9uZSBncm91cGluZyBleHByZXNzaW9uXCIsXG4gICAgICAgIFwiUzAyMTFcIjogXCJUaGUgc3ltYm9sIHt7dG9rZW59fSBjYW5ub3QgYmUgdXNlZCBhcyBhIHVuYXJ5IG9wZXJhdG9yXCIsXG4gICAgICAgIFwiUzAzMDFcIjogXCJFbXB0eSByZWd1bGFyIGV4cHJlc3Npb25zIGFyZSBub3QgYWxsb3dlZFwiLFxuICAgICAgICBcIlMwMzAyXCI6IFwiTm8gdGVybWluYXRpbmcgLyBpbiByZWd1bGFyIGV4cHJlc3Npb25cIixcbiAgICAgICAgXCJTMDQwMlwiOiBcIkNob2ljZSBncm91cHMgY29udGFpbmluZyBwYXJhbWV0ZXJpemVkIHR5cGVzIGFyZSBub3Qgc3VwcG9ydGVkXCIsXG4gICAgICAgIFwiUzA0MDFcIjogXCJUeXBlIHBhcmFtZXRlcnMgY2FuIG9ubHkgYmUgYXBwbGllZCB0byBmdW5jdGlvbnMgYW5kIGFycmF5c1wiLFxuICAgICAgICBcIlMwNTAwXCI6IFwiQXR0ZW1wdGVkIHRvIGV2YWx1YXRlIGFuIGV4cHJlc3Npb24gY29udGFpbmluZyBzeW50YXggZXJyb3IocylcIixcbiAgICAgICAgXCJUMDQxMFwiOiBcIkFyZ3VtZW50IHt7aW5kZXh9fSBvZiBmdW5jdGlvbiB7e3Rva2VufX0gZG9lcyBub3QgbWF0Y2ggZnVuY3Rpb24gc2lnbmF0dXJlXCIsXG4gICAgICAgIFwiVDA0MTFcIjogXCJDb250ZXh0IHZhbHVlIGlzIG5vdCBhIGNvbXBhdGlibGUgdHlwZSB3aXRoIGFyZ3VtZW50IHt7aW5kZXh9fSBvZiBmdW5jdGlvbiB7e3Rva2VufX1cIixcbiAgICAgICAgXCJUMDQxMlwiOiBcIkFyZ3VtZW50IHt7aW5kZXh9fSBvZiBmdW5jdGlvbiB7e3Rva2VufX0gbXVzdCBiZSBhbiBhcnJheSBvZiB7e3R5cGV9fVwiLFxuICAgICAgICBcIkQxMDAxXCI6IFwiTnVtYmVyIG91dCBvZiByYW5nZToge3t2YWx1ZX19XCIsXG4gICAgICAgIFwiRDEwMDJcIjogXCJDYW5ub3QgbmVnYXRlIGEgbm9uLW51bWVyaWMgdmFsdWU6IHt7dmFsdWV9fVwiLFxuICAgICAgICBcIlQxMDAzXCI6IFwiS2V5IGluIG9iamVjdCBzdHJ1Y3R1cmUgbXVzdCBldmFsdWF0ZSB0byBhIHN0cmluZzsgZ290OiB7e3ZhbHVlfX1cIixcbiAgICAgICAgXCJEMTAwNFwiOiBcIlJlZ3VsYXIgZXhwcmVzc2lvbiBtYXRjaGVzIHplcm8gbGVuZ3RoIHN0cmluZ1wiLFxuICAgICAgICBcIlQxMDA1XCI6IFwiQXR0ZW1wdGVkIHRvIGludm9rZSBhIG5vbi1mdW5jdGlvbi4gRGlkIHlvdSBtZWFuICR7e3t0b2tlbn19fT9cIixcbiAgICAgICAgXCJUMTAwNlwiOiBcIkF0dGVtcHRlZCB0byBpbnZva2UgYSBub24tZnVuY3Rpb25cIixcbiAgICAgICAgXCJUMTAwN1wiOiBcIkF0dGVtcHRlZCB0byBwYXJ0aWFsbHkgYXBwbHkgYSBub24tZnVuY3Rpb24uIERpZCB5b3UgbWVhbiAke3t7dG9rZW59fX0/XCIsXG4gICAgICAgIFwiVDEwMDhcIjogXCJBdHRlbXB0ZWQgdG8gcGFydGlhbGx5IGFwcGx5IGEgbm9uLWZ1bmN0aW9uXCIsXG4gICAgICAgIFwiVDIwMDFcIjogXCJUaGUgbGVmdCBzaWRlIG9mIHRoZSB7e3Rva2VufX0gb3BlcmF0b3IgbXVzdCBldmFsdWF0ZSB0byBhIG51bWJlclwiLFxuICAgICAgICBcIlQyMDAyXCI6IFwiVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHt7dG9rZW59fSBvcGVyYXRvciBtdXN0IGV2YWx1YXRlIHRvIGEgbnVtYmVyXCIsXG4gICAgICAgIFwiVDIwMDNcIjogXCJUaGUgbGVmdCBzaWRlIG9mIHRoZSByYW5nZSBvcGVyYXRvciAoLi4pIG11c3QgZXZhbHVhdGUgdG8gYW4gaW50ZWdlclwiLFxuICAgICAgICBcIlQyMDA0XCI6IFwiVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHJhbmdlIG9wZXJhdG9yICguLikgbXVzdCBldmFsdWF0ZSB0byBhbiBpbnRlZ2VyXCIsXG4gICAgICAgIFwiRDIwMDVcIjogXCJUaGUgbGVmdCBzaWRlIG9mIDo9IG11c3QgYmUgYSB2YXJpYWJsZSBuYW1lIChzdGFydCB3aXRoICQpXCIsXG4gICAgICAgIFwiVDIwMDZcIjogXCJUaGUgcmlnaHQgc2lkZSBvZiB0aGUgZnVuY3Rpb24gYXBwbGljYXRpb24gb3BlcmF0b3Igfj4gbXVzdCBiZSBhIGZ1bmN0aW9uXCIsXG4gICAgICAgIFwiVDIwMDdcIjogXCJUeXBlIG1pc21hdGNoIHdoZW4gY29tcGFyaW5nIHZhbHVlcyB7e3ZhbHVlfX0gYW5kIHt7dmFsdWUyfX0gaW4gb3JkZXItYnkgY2xhdXNlXCIsXG4gICAgICAgIFwiVDIwMDhcIjogXCJUaGUgZXhwcmVzc2lvbnMgd2l0aGluIGFuIG9yZGVyLWJ5IGNsYXVzZSBtdXN0IGV2YWx1YXRlIHRvIG51bWVyaWMgb3Igc3RyaW5nIHZhbHVlc1wiLFxuICAgICAgICBcIlQyMDA5XCI6IFwiVGhlIHZhbHVlcyB7e3ZhbHVlfX0gYW5kIHt7dmFsdWUyfX0gZWl0aGVyIHNpZGUgb2Ygb3BlcmF0b3Ige3t0b2tlbn19IG11c3QgYmUgb2YgdGhlIHNhbWUgZGF0YSB0eXBlXCIsXG4gICAgICAgIFwiVDIwMTBcIjogXCJUaGUgZXhwcmVzc2lvbnMgZWl0aGVyIHNpZGUgb2Ygb3BlcmF0b3Ige3t0b2tlbn19IG11c3QgZXZhbHVhdGUgdG8gbnVtZXJpYyBvciBzdHJpbmcgdmFsdWVzXCIsXG4gICAgICAgIFwiVDIwMTFcIjogXCJUaGUgaW5zZXJ0L3VwZGF0ZSBjbGF1c2Ugb2YgdGhlIHRyYW5zZm9ybSBleHByZXNzaW9uIG11c3QgZXZhbHVhdGUgdG8gYW4gb2JqZWN0OiB7e3ZhbHVlfX1cIixcbiAgICAgICAgXCJUMjAxMlwiOiBcIlRoZSBkZWxldGUgY2xhdXNlIG9mIHRoZSB0cmFuc2Zvcm0gZXhwcmVzc2lvbiBtdXN0IGV2YWx1YXRlIHRvIGEgc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3M6IHt7dmFsdWV9fVwiLFxuICAgICAgICBcIlQyMDEzXCI6IFwiVGhlIHRyYW5zZm9ybSBleHByZXNzaW9uIGNsb25lcyB0aGUgaW5wdXQgb2JqZWN0IHVzaW5nIHRoZSAkY2xvbmUoKSBmdW5jdGlvbi4gIFRoaXMgaGFzIGJlZW4gb3ZlcnJpZGRlbiBpbiB0aGUgY3VycmVudCBzY29wZSBieSBhIG5vbi1mdW5jdGlvbi5cIixcbiAgICAgICAgXCJEMzAwMVwiOiBcIkF0dGVtcHRpbmcgdG8gaW52b2tlIHN0cmluZyBmdW5jdGlvbiBvbiBJbmZpbml0eSBvciBOYU5cIixcbiAgICAgICAgXCJEMzAxMFwiOiBcIlNlY29uZCBhcmd1bWVudCBvZiByZXBsYWNlIGZ1bmN0aW9uIGNhbm5vdCBiZSBhbiBlbXB0eSBzdHJpbmdcIixcbiAgICAgICAgXCJEMzAxMVwiOiBcIkZvdXJ0aCBhcmd1bWVudCBvZiByZXBsYWNlIGZ1bmN0aW9uIG11c3QgZXZhbHVhdGUgdG8gYSBwb3NpdGl2ZSBudW1iZXJcIixcbiAgICAgICAgXCJEMzAxMlwiOiBcIkF0dGVtcHRlZCB0byByZXBsYWNlIGEgbWF0Y2hlZCBzdHJpbmcgd2l0aCBhIG5vbi1zdHJpbmcgdmFsdWVcIixcbiAgICAgICAgXCJEMzAyMFwiOiBcIlRoaXJkIGFyZ3VtZW50IG9mIHNwbGl0IGZ1bmN0aW9uIG11c3QgZXZhbHVhdGUgdG8gYSBwb3NpdGl2ZSBudW1iZXJcIixcbiAgICAgICAgXCJEMzAzMFwiOiBcIlVuYWJsZSB0byBjYXN0IHZhbHVlIHRvIGEgbnVtYmVyOiB7e3ZhbHVlfX1cIixcbiAgICAgICAgXCJEMzA0MFwiOiBcIlRoaXJkIGFyZ3VtZW50IG9mIG1hdGNoIGZ1bmN0aW9uIG11c3QgZXZhbHVhdGUgdG8gYSBwb3NpdGl2ZSBudW1iZXJcIixcbiAgICAgICAgXCJEMzA1MFwiOiBcIkZpcnN0IGFyZ3VtZW50IG9mIHJlZHVjZSBmdW5jdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24gd2l0aCB0d28gYXJndW1lbnRzXCIsXG4gICAgICAgIFwiRDMwNjBcIjogXCJUaGUgc3FydCBmdW5jdGlvbiBjYW5ub3QgYmUgYXBwbGllZCB0byBhIG5lZ2F0aXZlIG51bWJlcjoge3t2YWx1ZX19XCIsXG4gICAgICAgIFwiRDMwNjFcIjogXCJUaGUgcG93ZXIgZnVuY3Rpb24gaGFzIHJlc3VsdGVkIGluIGEgdmFsdWUgdGhhdCBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXMgYSBKU09OIG51bWJlcjogYmFzZT17e3ZhbHVlfX0sIGV4cG9uZW50PXt7ZXhwfX1cIixcbiAgICAgICAgXCJEMzA3MFwiOiBcIlRoZSBzaW5nbGUgYXJndW1lbnQgZm9ybSBvZiB0aGUgc29ydCBmdW5jdGlvbiBjYW4gb25seSBiZSBhcHBsaWVkIHRvIGFuIGFycmF5IG9mIHN0cmluZ3Mgb3IgYW4gYXJyYXkgb2YgbnVtYmVycy4gIFVzZSB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIHNwZWNpZnkgYSBjb21wYXJpc29uIGZ1bmN0aW9uXCIsXG4gICAgICAgIFwiRDMwODBcIjogXCJUaGUgcGljdHVyZSBzdHJpbmcgbXVzdCBvbmx5IGNvbnRhaW4gYSBtYXhpbXVtIG9mIHR3byBzdWItcGljdHVyZXNcIixcbiAgICAgICAgXCJEMzA4MVwiOiBcIlRoZSBzdWItcGljdHVyZSBtdXN0IG5vdCBjb250YWluIG1vcmUgdGhhbiBvbmUgaW5zdGFuY2Ugb2YgdGhlICdkZWNpbWFsLXNlcGFyYXRvcicgY2hhcmFjdGVyXCIsXG4gICAgICAgIFwiRDMwODJcIjogXCJUaGUgc3ViLXBpY3R1cmUgbXVzdCBub3QgY29udGFpbiBtb3JlIHRoYW4gb25lIGluc3RhbmNlIG9mIHRoZSAncGVyY2VudCcgY2hhcmFjdGVyXCIsXG4gICAgICAgIFwiRDMwODNcIjogXCJUaGUgc3ViLXBpY3R1cmUgbXVzdCBub3QgY29udGFpbiBtb3JlIHRoYW4gb25lIGluc3RhbmNlIG9mIHRoZSAncGVyLW1pbGxlJyBjaGFyYWN0ZXJcIixcbiAgICAgICAgXCJEMzA4NFwiOiBcIlRoZSBzdWItcGljdHVyZSBtdXN0IG5vdCBjb250YWluIGJvdGggYSAncGVyY2VudCcgYW5kIGEgJ3Blci1taWxsZScgY2hhcmFjdGVyXCIsXG4gICAgICAgIFwiRDMwODVcIjogXCJUaGUgbWFudGlzc2EgcGFydCBvZiBhIHN1Yi1waWN0dXJlIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyIHRoYXQgaXMgZWl0aGVyIGFuICdvcHRpb25hbCBkaWdpdCBjaGFyYWN0ZXInIG9yIGEgbWVtYmVyIG9mIHRoZSAnZGVjaW1hbCBkaWdpdCBmYW1pbHknXCIsXG4gICAgICAgIFwiRDMwODZcIjogXCJUaGUgc3ViLXBpY3R1cmUgbXVzdCBub3QgY29udGFpbiBhIHBhc3NpdmUgY2hhcmFjdGVyIHRoYXQgaXMgcHJlY2VkZWQgYnkgYW4gYWN0aXZlIGNoYXJhY3RlciBhbmQgdGhhdCBpcyBmb2xsb3dlZCBieSBhbm90aGVyIGFjdGl2ZSBjaGFyYWN0ZXJcIixcbiAgICAgICAgXCJEMzA4N1wiOiBcIlRoZSBzdWItcGljdHVyZSBtdXN0IG5vdCBjb250YWluIGEgJ2dyb3VwaW5nLXNlcGFyYXRvcicgY2hhcmFjdGVyIHRoYXQgYXBwZWFycyBhZGphY2VudCB0byBhICdkZWNpbWFsLXNlcGFyYXRvcicgY2hhcmFjdGVyXCIsXG4gICAgICAgIFwiRDMwODhcIjogXCJUaGUgc3ViLXBpY3R1cmUgbXVzdCBub3QgY29udGFpbiBhICdncm91cGluZy1zZXBhcmF0b3InIGF0IHRoZSBlbmQgb2YgdGhlIGludGVnZXIgcGFydFwiLFxuICAgICAgICBcIkQzMDg5XCI6IFwiVGhlIHN1Yi1waWN0dXJlIG11c3Qgbm90IGNvbnRhaW4gdHdvIGFkamFjZW50IGluc3RhbmNlcyBvZiB0aGUgJ2dyb3VwaW5nLXNlcGFyYXRvcicgY2hhcmFjdGVyXCIsXG4gICAgICAgIFwiRDMwOTBcIjogXCJUaGUgaW50ZWdlciBwYXJ0IG9mIHRoZSBzdWItcGljdHVyZSBtdXN0IG5vdCBjb250YWluIGEgbWVtYmVyIG9mIHRoZSAnZGVjaW1hbCBkaWdpdCBmYW1pbHknIHRoYXQgaXMgZm9sbG93ZWQgYnkgYW4gaW5zdGFuY2Ugb2YgdGhlICdvcHRpb25hbCBkaWdpdCBjaGFyYWN0ZXInXCIsXG4gICAgICAgIFwiRDMwOTFcIjogXCJUaGUgZnJhY3Rpb25hbCBwYXJ0IG9mIHRoZSBzdWItcGljdHVyZSBtdXN0IG5vdCBjb250YWluIGFuIGluc3RhbmNlIG9mIHRoZSAnb3B0aW9uYWwgZGlnaXQgY2hhcmFjdGVyJyB0aGF0IGlzIGZvbGxvd2VkIGJ5IGEgbWVtYmVyIG9mIHRoZSAnZGVjaW1hbCBkaWdpdCBmYW1pbHknXCIsXG4gICAgICAgIFwiRDMwOTJcIjogXCJBIHN1Yi1waWN0dXJlIHRoYXQgY29udGFpbnMgYSAncGVyY2VudCcgb3IgJ3Blci1taWxsZScgY2hhcmFjdGVyIG11c3Qgbm90IGNvbnRhaW4gYSBjaGFyYWN0ZXIgdHJlYXRlZCBhcyBhbiAnZXhwb25lbnQtc2VwYXJhdG9yJ1wiLFxuICAgICAgICBcIkQzMDkzXCI6IFwiVGhlIGV4cG9uZW50IHBhcnQgb2YgdGhlIHN1Yi1waWN0dXJlIG11c3QgY29tcHJpc2Ugb25seSBvZiBvbmUgb3IgbW9yZSBjaGFyYWN0ZXJzIHRoYXQgYXJlIG1lbWJlcnMgb2YgdGhlICdkZWNpbWFsIGRpZ2l0IGZhbWlseSdcIixcbiAgICAgICAgXCJEMzEwMFwiOiBcIlRoZSByYWRpeCBvZiB0aGUgZm9ybWF0QmFzZSBmdW5jdGlvbiBtdXN0IGJlIGJldHdlZW4gMiBhbmQgMzYuICBJdCB3YXMgZ2l2ZW4ge3t2YWx1ZX19XCIsXG4gICAgICAgIFwiRDMxMTBcIjogXCJUaGUgYXJndW1lbnQgb2YgdGhlIHRvTWlsbGlzIGZ1bmN0aW9uIG11c3QgYmUgYW4gSVNPIDg2MDEgZm9ybWF0dGVkIHRpbWVzdGFtcC4gR2l2ZW4ge3t2YWx1ZX19XCJcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogbG9va3VwIGEgbWVzc2FnZSB0ZW1wbGF0ZSBmcm9tIHRoZSBjYXRhbG9nIGFuZCBzdWJzdGl0dXRlIHRoZSBpbnNlcnRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVyciAtIGVycm9yIGNvZGUgdG8gbG9va3VwXG4gICAgICogQHJldHVybnMge3N0cmluZ30gbWVzc2FnZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvb2t1cE1lc3NhZ2UoZXJyKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gJ1Vua25vd24gZXJyb3InO1xuICAgICAgICBpZih0eXBlb2YgZXJyLm1lc3NhZ2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRlbXBsYXRlID0gZXJyb3JDb2Rlc1tlcnIuY29kZV07XG4gICAgICAgIGlmKHR5cGVvZiB0ZW1wbGF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBhbnkgaGFuZGxlYmFycywgcmVwbGFjZSB0aGVtIHdpdGggdGhlIGZpZWxkIHJlZmVyZW5jZXNcbiAgICAgICAgICAgIC8vIHRyaXBsZSBicmFjZXMgLSByZXBsYWNlIHdpdGggdmFsdWVcbiAgICAgICAgICAgIC8vIGRvdWJsZSBicmFjZXMgLSByZXBsYWNlIHdpdGgganNvbiBzdHJpbmdpZmllZCB2YWx1ZVxuICAgICAgICAgICAgbWVzc2FnZSA9IHRlbXBsYXRlLnJlcGxhY2UoL1xce1xce1xceyhbXn1dKyl9fX0vZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyclthcmd1bWVudHNbMV1dO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKC9cXHtcXHsoW159XSspfX0vZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGVyclthcmd1bWVudHNbMV1dKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEpTT05hdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucyAtIHJlY292ZXI6IGF0dGVtcHQgdG8gcmVjb3ZlciBvbiBwYXJzZSBlcnJvclxuICAgICAqIEByZXR1cm5zIHt7ZXZhbHVhdGU6IGV2YWx1YXRlLCBhc3NpZ246IGFzc2lnbn19IEV2YWx1YXRlZCBleHByZXNzaW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24ganNvbmF0YShleHByLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBhc3Q7XG4gICAgICAgIHZhciBlcnJvcnM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhc3QgPSBwYXJzZXIoZXhwciwgb3B0aW9ucyAmJiBvcHRpb25zLnJlY292ZXIpO1xuICAgICAgICAgICAgZXJyb3JzID0gYXN0LmVycm9ycztcbiAgICAgICAgICAgIGRlbGV0ZSBhc3QuZXJyb3JzO1xuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgLy8gaW5zZXJ0IGVycm9yIG1lc3NhZ2UgaW50byBzdHJ1Y3R1cmVcbiAgICAgICAgICAgIGVyci5tZXNzYWdlID0gbG9va3VwTWVzc2FnZShlcnIpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbnZpcm9ubWVudCA9IGNyZWF0ZUZyYW1lKHN0YXRpY0ZyYW1lKTtcblxuICAgICAgICB2YXIgdGltZXN0YW1wID0gbmV3IERhdGUoKTsgLy8gd2lsbCBiZSBvdmVycmlkZGVuIG9uIGVhY2ggY2FsbCB0byBldmFsdXRlKClcbiAgICAgICAgZW52aXJvbm1lbnQuYmluZCgnbm93JywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGltZXN0YW1wLnRvSlNPTigpO1xuICAgICAgICB9LCAnPDpzPicpKTtcbiAgICAgICAgZW52aXJvbm1lbnQuYmluZCgnbWlsbGlzJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGltZXN0YW1wLmdldFRpbWUoKTtcbiAgICAgICAgfSwgJzw6bj4nKSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbiAoaW5wdXQsIGJpbmRpbmdzLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIC8vIHRocm93IGlmIHRoZSBleHByZXNzaW9uIGNvbXBpbGVkIHdpdGggc3ludGF4IGVycm9yc1xuICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBlcnJvcnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiAnUzA1MDAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IDBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBsb29rdXBNZXNzYWdlKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGJpbmRpbmdzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXhlY19lbnY7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSB2YXJpYWJsZSBiaW5kaW5ncyBoYXZlIGJlZW4gcGFzc2VkIGluIC0gY3JlYXRlIGEgZnJhbWUgdG8gaG9sZCB0aGVzZVxuICAgICAgICAgICAgICAgICAgICBleGVjX2VudiA9IGNyZWF0ZUZyYW1lKGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdiBpbiBiaW5kaW5ncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY19lbnYuYmluZCh2LCBiaW5kaW5nc1t2XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBleGVjX2VudiA9IGVudmlyb25tZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBwdXQgdGhlIGlucHV0IGRvY3VtZW50IGludG8gdGhlIGVudmlyb25tZW50IGFzIHRoZSByb290IG9iamVjdFxuICAgICAgICAgICAgICAgIGV4ZWNfZW52LmJpbmQoJyQnLCBpbnB1dCk7XG5cbiAgICAgICAgICAgICAgICAvLyBjYXB0dXJlIHRoZSB0aW1lc3RhbXAgYW5kIHB1dCBpdCBpbiB0aGUgZXhlY3V0aW9uIGVudmlyb25tZW50XG4gICAgICAgICAgICAgICAgLy8gdGhlICRub3coKSBhbmQgJG1pbGxpcygpIGZ1bmN0aW9ucyB3aWxsIHJldHVybiB0aGlzIHZhbHVlIC0gd2hlbmV2ZXIgaXQgaXMgY2FsbGVkXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wID0gbmV3IERhdGUoKTtcblxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQsIGl0O1xuICAgICAgICAgICAgICAgIC8vIGlmIGEgY2FsbGJhY2sgZnVuY3Rpb24gaXMgc3VwcGxpZWQsIHRoZW4gZHJpdmUgdGhlIGdlbmVyYXRvciBpbiBhIHByb21pc2UgY2hhaW5cbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhlY19lbnYuYmluZCgnX19qc29uYXRhX2FzeW5jJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGVuSGFuZGxlciA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gaXQubmV4dChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUudGhlbih0aGVuSGFuZGxlcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlID0gbG9va3VwTWVzc2FnZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGl0ID0gZXZhbHVhdGUoYXN0LCBpbnB1dCwgZXhlY19lbnYpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBpdC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZS50aGVuKHRoZW5IYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBubyBjYWxsYmFjayBmdW5jdGlvbiAtIGRyaXZlIHRoZSBnZW5lcmF0b3IgdG8gY29tcGxldGlvbiBzeW5jaHJvbm91c2x5XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdCA9IGV2YWx1YXRlKGFzdCwgaW5wdXQsIGV4ZWNfZW52KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGl0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBpdC5uZXh0KHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2VydCBlcnJvciBtZXNzYWdlIGludG8gc3RydWN0dXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IGxvb2t1cE1lc3NhZ2UoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhc3NpZ246IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGVudmlyb25tZW50LmJpbmQobmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlZ2lzdGVyRnVuY3Rpb246IGZ1bmN0aW9uKG5hbWUsIGltcGxlbWVudGF0aW9uLCBzaWduYXR1cmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnVuYyA9IGRlZmluZUZ1bmN0aW9uKGltcGxlbWVudGF0aW9uLCBzaWduYXR1cmUpO1xuICAgICAgICAgICAgICAgIGVudmlyb25tZW50LmJpbmQobmFtZSwgZnVuYyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBqc29uYXRhLnBhcnNlciA9IHBhcnNlcjsgLy8gVE9ETyByZW1vdmUgdGhpcyBpbiBhIGZ1dHVyZSByZWxlYXNlIC0gdXNlIGFzdCgpIGluc3RlYWRcblxuICAgIHJldHVybiBqc29uYXRhO1xuXG59KSgpO1xuXG4vLyBub2RlLmpzIG9ubHkgLSBleHBvcnQgdGhlIGpzb25hdGEgYW5kIHBhcnNlciBmdW5jdGlvbnNcbi8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlXG5pZih0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ganNvbmF0YTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGxvZ2xldmVsID0gcmVxdWlyZSgnbG9nbGV2ZWwnKTtcbnZhciBjaGFsayA9IHJlcXVpcmUoJ2NoYWxrJyk7XG5cbnZhciBsb2dnZXJzID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TG9nZ2VyO1xuXG5mdW5jdGlvbiBnZXRMb2dnZXIoKSB7XG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgIF9yZWYkbGV2ZWwgPSBfcmVmLmxldmVsLFxuICAgICAgbGV2ZWwgPSBfcmVmJGxldmVsID09PSB1bmRlZmluZWQgPyBnZXREZWZhdWx0TGV2ZWwoKSA6IF9yZWYkbGV2ZWwsXG4gICAgICBfcmVmJHByZWZpeCA9IF9yZWYucHJlZml4LFxuICAgICAgcHJlZml4ID0gX3JlZiRwcmVmaXggPT09IHVuZGVmaW5lZCA/ICcnIDogX3JlZiRwcmVmaXg7XG5cbiAgaWYgKGxvZ2dlcnNbcHJlZml4XSkge1xuICAgIHJldHVybiBsb2dnZXJzW3ByZWZpeF07XG4gIH1cbiAgdmFyIGNvbG9yZWRQcmVmaXggPSBwcmVmaXggPyBgJHtjaGFsay5kaW0ocHJlZml4KX0gYCA6ICcnO1xuICB2YXIgbGV2ZWxQcmVmaXggPSB7XG4gICAgVFJBQ0U6IGNoYWxrLmRpbSgnW1RSQUNFXScpLFxuICAgIERFQlVHOiBjaGFsay5jeWFuKCdbREVCVUddJyksXG4gICAgSU5GTzogY2hhbGsuYmx1ZSgnW0lORk9dJyksXG4gICAgV0FSTjogY2hhbGsueWVsbG93KCdbV0FSTl0nKSxcbiAgICBFUlJPUjogY2hhbGsucmVkKCdbRVJST1JdJylcbiAgfTtcblxuICB2YXIgbG9nZ2VyID0gbG9nbGV2ZWwuZ2V0TG9nZ2VyKGAke3ByZWZpeH0tbG9nZ2VyYCk7XG5cbiAgLy8gdGhpcyBpcyB0aGUgcGx1Z2luIFwiYXBpXCJcbiAgdmFyIG9yaWdpbmFsRmFjdG9yeSA9IGxvZ2dlci5tZXRob2RGYWN0b3J5O1xuICBsb2dnZXIubWV0aG9kRmFjdG9yeSA9IG1ldGhvZEZhY3Rvcnk7XG5cbiAgdmFyIG9yaWdpbmFsU2V0TGV2ZWwgPSBsb2dnZXIuc2V0TGV2ZWw7XG4gIGxvZ2dlci5zZXRMZXZlbCA9IHNldExldmVsO1xuICBsb2dnZXIuc2V0TGV2ZWwobGV2ZWwpO1xuICBsb2dnZXJzW3ByZWZpeF0gPSBsb2dnZXI7XG4gIHJldHVybiBsb2dnZXI7XG5cbiAgZnVuY3Rpb24gbWV0aG9kRmFjdG9yeSgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZmFjdG9yeUFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGZhY3RvcnlBcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBsb2dMZXZlbCA9IGZhY3RvcnlBcmdzWzBdO1xuXG4gICAgdmFyIHJhd01ldGhvZCA9IG9yaWdpbmFsRmFjdG9yeS5hcHBseSh1bmRlZmluZWQsIGZhY3RvcnlBcmdzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmF3TWV0aG9kLmFwcGx5KHVuZGVmaW5lZCwgW2Ake2NvbG9yZWRQcmVmaXh9JHtsZXZlbFByZWZpeFtsb2dMZXZlbC50b1VwcGVyQ2FzZSgpXX06YF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0TGV2ZWwobGV2ZWxUb1NldFRvKSB7XG4gICAgdmFyIHBlcnNpc3QgPSBmYWxzZTsgLy8gdXNlcyBicm93c2VyIGxvY2FsU3RvcmFnZVxuICAgIHJldHVybiBvcmlnaW5hbFNldExldmVsLmNhbGwobG9nZ2VyLCBsZXZlbFRvU2V0VG8sIHBlcnNpc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRMZXZlbCgpIHtcbiAgdmFyIGxvZ0xldmVsID0gcHJvY2Vzcy5lbnYuTE9HX0xFVkVMO1xuXG4gIGlmIChsb2dMZXZlbCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWxvZ0xldmVsKSB7XG4gICAgcmV0dXJuICd3YXJuJztcbiAgfVxuICByZXR1cm4gbG9nTGV2ZWw7XG59IiwiLypcbiogbG9nbGV2ZWwgLSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWxcbipcbiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeVxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4qL1xuKGZ1bmN0aW9uIChyb290LCBkZWZpbml0aW9uKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LmxvZyA9IGRlZmluaXRpb24oKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIFNsaWdodGx5IGR1YmlvdXMgdHJpY2tzIHRvIGN1dCBkb3duIG1pbmltaXplZCBmaWxlIHNpemVcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG4gICAgdmFyIHVuZGVmaW5lZFR5cGUgPSBcInVuZGVmaW5lZFwiO1xuXG4gICAgdmFyIGxvZ01ldGhvZHMgPSBbXG4gICAgICAgIFwidHJhY2VcIixcbiAgICAgICAgXCJkZWJ1Z1wiLFxuICAgICAgICBcImluZm9cIixcbiAgICAgICAgXCJ3YXJuXCIsXG4gICAgICAgIFwiZXJyb3JcIlxuICAgIF07XG5cbiAgICAvLyBDcm9zcy1icm93c2VyIGJpbmQgZXF1aXZhbGVudCB0aGF0IHdvcmtzIGF0IGxlYXN0IGJhY2sgdG8gSUU2XG4gICAgZnVuY3Rpb24gYmluZE1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9ialttZXRob2ROYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QuYmluZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5iaW5kKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKG1ldGhvZCwgb2JqKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBNaXNzaW5nIGJpbmQgc2hpbSBvciBJRTggKyBNb2Rlcm5penIsIGZhbGxiYWNrIHRvIHdyYXBwaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KG1ldGhvZCwgW29iaiwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEJ1aWxkIHRoZSBiZXN0IGxvZ2dpbmcgbWV0aG9kIHBvc3NpYmxlIGZvciB0aGlzIGVudlxuICAgIC8vIFdoZXJldmVyIHBvc3NpYmxlIHdlIHdhbnQgdG8gYmluZCwgbm90IHdyYXAsIHRvIHByZXNlcnZlIHN0YWNrIHRyYWNlc1xuICAgIGZ1bmN0aW9uIHJlYWxNZXRob2QobWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2RlYnVnJykge1xuICAgICAgICAgICAgbWV0aG9kTmFtZSA9ICdsb2cnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIG1ldGhvZCBwb3NzaWJsZSwgZm9yIG5vdyAtIGZpeGVkIGxhdGVyIGJ5IGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXNcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlW21ldGhvZE5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsIG1ldGhvZE5hbWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGUubG9nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsICdsb2cnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBub29wO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlc2UgcHJpdmF0ZSBmdW5jdGlvbnMgYWx3YXlzIG5lZWQgYHRoaXNgIHRvIGJlIHNldCBwcm9wZXJseVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZUxvZ2dpbmdNZXRob2RzKGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9nTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBsb2dNZXRob2RzW2ldO1xuICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXSA9IChpIDwgbGV2ZWwpID9cbiAgICAgICAgICAgICAgICBub29wIDpcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmaW5lIGxvZy5sb2cgYXMgYW4gYWxpYXMgZm9yIGxvZy5kZWJ1Z1xuICAgICAgICB0aGlzLmxvZyA9IHRoaXMuZGVidWc7XG4gICAgfVxuXG4gICAgLy8gSW4gb2xkIElFIHZlcnNpb25zLCB0aGUgY29uc29sZSBpc24ndCBwcmVzZW50IHVudGlsIHlvdSBmaXJzdCBvcGVuIGl0LlxuICAgIC8vIFdlIGJ1aWxkIHJlYWxNZXRob2QoKSByZXBsYWNlbWVudHMgaGVyZSB0aGF0IHJlZ2VuZXJhdGUgbG9nZ2luZyBtZXRob2RzXG4gICAgZnVuY3Rpb24gZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyhtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwodGhpcywgbGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBCeSBkZWZhdWx0LCB3ZSB1c2UgY2xvc2VseSBib3VuZCByZWFsIG1ldGhvZHMgd2hlcmV2ZXIgcG9zc2libGUsIGFuZFxuICAgIC8vIG90aGVyd2lzZSB3ZSB3YWl0IGZvciBhIGNvbnNvbGUgdG8gYXBwZWFyLCBhbmQgdGhlbiB0cnkgYWdhaW4uXG4gICAgZnVuY3Rpb24gZGVmYXVsdE1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgcmV0dXJuIHJlYWxNZXRob2QobWV0aG9kTmFtZSkgfHxcbiAgICAgICAgICAgICAgIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2dnZXIobmFtZSwgZGVmYXVsdExldmVsLCBmYWN0b3J5KSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgY3VycmVudExldmVsO1xuICAgICAgdmFyIHN0b3JhZ2VLZXkgPSBcImxvZ2xldmVsXCI7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICBzdG9yYWdlS2V5ICs9IFwiOlwiICsgbmFtZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbE51bSkge1xuICAgICAgICAgIHZhciBsZXZlbE5hbWUgPSAobG9nTWV0aG9kc1tsZXZlbE51bV0gfHwgJ3NpbGVudCcpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSkgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldID0gbGV2ZWxOYW1lO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9XG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIgKyBsZXZlbE5hbWUgKyBcIjtcIjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFBlcnNpc3RlZExldmVsKCkge1xuICAgICAgICAgIHZhciBzdG9yZWRMZXZlbDtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlKSByZXR1cm47XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV07XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gY29va2llcyBpZiBsb2NhbCBzdG9yYWdlIGdpdmVzIHVzIG5vdGhpbmdcbiAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlZExldmVsID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29va2llID0gd2luZG93LmRvY3VtZW50LmNvb2tpZTtcbiAgICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGNvb2tpZS5pbmRleE9mKFxuICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiKTtcbiAgICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IC9eKFteO10rKS8uZXhlYyhjb29raWUuc2xpY2UobG9jYXRpb24pKVsxXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHRoZSBzdG9yZWQgbGV2ZWwgaXMgbm90IHZhbGlkLCB0cmVhdCBpdCBhcyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG4gICAgICAgICAgaWYgKHNlbGYubGV2ZWxzW3N0b3JlZExldmVsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzdG9yZWRMZXZlbDtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICAqXG4gICAgICAgKiBQdWJsaWMgbG9nZ2VyIEFQSSAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwgZm9yIGRldGFpbHNcbiAgICAgICAqXG4gICAgICAgKi9cblxuICAgICAgc2VsZi5uYW1lID0gbmFtZTtcblxuICAgICAgc2VsZi5sZXZlbHMgPSB7IFwiVFJBQ0VcIjogMCwgXCJERUJVR1wiOiAxLCBcIklORk9cIjogMiwgXCJXQVJOXCI6IDMsXG4gICAgICAgICAgXCJFUlJPUlwiOiA0LCBcIlNJTEVOVFwiOiA1fTtcblxuICAgICAgc2VsZi5tZXRob2RGYWN0b3J5ID0gZmFjdG9yeSB8fCBkZWZhdWx0TWV0aG9kRmFjdG9yeTtcblxuICAgICAgc2VsZi5nZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudExldmVsO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCwgcGVyc2lzdCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwic3RyaW5nXCIgJiYgc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBsZXZlbCA9IHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcIm51bWJlclwiICYmIGxldmVsID49IDAgJiYgbGV2ZWwgPD0gc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGxldmVsO1xuICAgICAgICAgICAgICBpZiAocGVyc2lzdCAhPT0gZmFsc2UpIHsgIC8vIGRlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgICAgICAgICAgIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYsIGxldmVsLCBuYW1lKTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlICYmIGxldmVsIDwgc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gXCJObyBjb25zb2xlIGF2YWlsYWJsZSBmb3IgbG9nZ2luZ1wiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJsb2cuc2V0TGV2ZWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIGxldmVsOiBcIiArIGxldmVsO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0RGVmYXVsdExldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgICAgaWYgKCFnZXRQZXJzaXN0ZWRMZXZlbCgpKSB7XG4gICAgICAgICAgICAgIHNlbGYuc2V0TGV2ZWwobGV2ZWwsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmVuYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlRSQUNFLCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZGlzYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlNJTEVOVCwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBJbml0aWFsaXplIHdpdGggdGhlIHJpZ2h0IGxldmVsXG4gICAgICB2YXIgaW5pdGlhbExldmVsID0gZ2V0UGVyc2lzdGVkTGV2ZWwoKTtcbiAgICAgIGlmIChpbml0aWFsTGV2ZWwgPT0gbnVsbCkge1xuICAgICAgICAgIGluaXRpYWxMZXZlbCA9IGRlZmF1bHRMZXZlbCA9PSBudWxsID8gXCJXQVJOXCIgOiBkZWZhdWx0TGV2ZWw7XG4gICAgICB9XG4gICAgICBzZWxmLnNldExldmVsKGluaXRpYWxMZXZlbCwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICpcbiAgICAgKiBUb3AtbGV2ZWwgQVBJXG4gICAgICpcbiAgICAgKi9cblxuICAgIHZhciBkZWZhdWx0TG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuXG4gICAgdmFyIF9sb2dnZXJzQnlOYW1lID0ge307XG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXIgPSBmdW5jdGlvbiBnZXRMb2dnZXIobmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIgfHwgbmFtZSA9PT0gXCJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBzdXBwbHkgYSBuYW1lIHdoZW4gY3JlYXRpbmcgYSBsb2dnZXIuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdO1xuICAgICAgICBpZiAoIWxvZ2dlcikge1xuICAgICAgICAgIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdID0gbmV3IExvZ2dlcihcbiAgICAgICAgICAgIG5hbWUsIGRlZmF1bHRMb2dnZXIuZ2V0TGV2ZWwoKSwgZGVmYXVsdExvZ2dlci5tZXRob2RGYWN0b3J5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyO1xuICAgIH07XG5cbiAgICAvLyBHcmFiIHRoZSBjdXJyZW50IGdsb2JhbCBsb2cgdmFyaWFibGUgaW4gY2FzZSBvZiBvdmVyd3JpdGVcbiAgICB2YXIgX2xvZyA9ICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlKSA/IHdpbmRvdy5sb2cgOiB1bmRlZmluZWQ7XG4gICAgZGVmYXVsdExvZ2dlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlICYmXG4gICAgICAgICAgICAgICB3aW5kb3cubG9nID09PSBkZWZhdWx0TG9nZ2VyKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9nID0gX2xvZztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xuICAgIH07XG5cbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlcnMgPSBmdW5jdGlvbiBnZXRMb2dnZXJzKCkge1xuICAgICAgICByZXR1cm4gX2xvZ2dlcnNCeU5hbWU7XG4gICAgfTtcblxuICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xufSkpO1xuIiwidmFyIHBlcmZvcm1hbmNlID0gZ2xvYmFsLnBlcmZvcm1hbmNlIHx8IHt9O1xuXG52YXIgcHJlc2VudCA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBuYW1lcyA9IFsnbm93JywgJ3dlYmtpdE5vdycsICdtc05vdycsICdtb3pOb3cnLCAnb05vdyddO1xuICB3aGlsZSAobmFtZXMubGVuZ3RoKSB7XG4gICAgdmFyIG5hbWUgPSBuYW1lcy5zaGlmdCgpO1xuICAgIGlmIChuYW1lIGluIHBlcmZvcm1hbmNlKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybWFuY2VbbmFtZV0uYmluZChwZXJmb3JtYW5jZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGRhdGVOb3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgfTtcbiAgdmFyIG5hdmlnYXRpb25TdGFydCA9IChwZXJmb3JtYW5jZS50aW1pbmcgfHwge30pLm5hdmlnYXRpb25TdGFydCB8fCBkYXRlTm93KCk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRhdGVOb3coKSAtIG5hdmlnYXRpb25TdGFydDtcbiAgfTtcbn0oKSk7XG5cbnByZXNlbnQucGVyZm9ybWFuY2VOb3cgPSBwZXJmb3JtYW5jZS5ub3c7XG5wcmVzZW50Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHBlcmZvcm1hbmNlLm5vdyA9IHByZXNlbnQucGVyZm9ybWFuY2VOb3c7XG59O1xucHJlc2VudC5jb25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgcGVyZm9ybWFuY2Uubm93ID0gcHJlc2VudDtcbn07XG5wcmVzZW50LmNvbmZsaWN0KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcHJlc2VudDtcbiIsIi8vIEV4cG9ydCAuL2xpYi9yYW5kZ2VuXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL3JhbmRnZW5cIik7XG4iLCIvKmpzbGludCBpbmRlbnQ6IDIsIHBsdXNwbHVzOiB0cnVlLCBzbG9wcHk6IHRydWUgKi9cbi8vIEdlbmVyYXRlIHVuaWZvcm1seSBkaXN0cmlidXRlZCByYW5kb20gbnVtYmVyc1xuLy8gR2l2ZXMgYSByYW5kb20gbnVtYmVyIG9uIHRoZSBpbnRlcnZhbCBbbWluLCBtYXgpLlxuLy8gSWYgZGlzY3JldGUgaXMgdHJ1ZSwgdGhlIG51bWJlciB3aWxsIGJlIGFuIGludGVnZXIuXG5mdW5jdGlvbiBydW5pZihtaW4sIG1heCwgZGlzY3JldGUpIHtcbiAgaWYgKG1pbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWluID0gMDtcbiAgfVxuICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICBtYXggPSAxO1xuICB9XG4gIGlmIChkaXNjcmV0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZGlzY3JldGUgPSBmYWxzZTtcbiAgfVxuICBpZiAoZGlzY3JldGUpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihydW5pZihtaW4sIG1heCwgZmFsc2UpKTtcbiAgfVxuICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xufVxuXG4vLyBHZW5lcmF0ZSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gbnVibWVyc1xuLy8gQWxnb3JpdGhtIGFkYXB0ZWQgZnJvbTpcbi8vIGh0dHA6Ly9jLWZhcS5jb20vbGliL2dhdXNzaWFuLmh0bWxcbmZ1bmN0aW9uIHJub3JtKG1lYW4sIHN0ZGV2KSB7XG4gIHZhciB1MSwgdTIsIHYxLCB2MiwgcztcbiAgaWYgKG1lYW4gPT09IHVuZGVmaW5lZCkge1xuICAgIG1lYW4gPSAwLjA7XG4gIH1cbiAgaWYgKHN0ZGV2ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGRldiA9IDEuMDtcbiAgfVxuICBpZiAocm5vcm0udjIgPT09IG51bGwpIHtcbiAgICBkbyB7XG4gICAgICB1MSA9IE1hdGgucmFuZG9tKCk7XG4gICAgICB1MiA9IE1hdGgucmFuZG9tKCk7XG5cbiAgICAgIHYxID0gMiAqIHUxIC0gMTtcbiAgICAgIHYyID0gMiAqIHUyIC0gMTtcbiAgICAgIHMgPSB2MSAqIHYxICsgdjIgKiB2MjtcbiAgICB9IHdoaWxlIChzID09PSAwIHx8IHMgPj0gMSk7XG5cbiAgICBybm9ybS52MiA9IHYyICogTWF0aC5zcXJ0KC0yICogTWF0aC5sb2cocykgLyBzKTtcbiAgICByZXR1cm4gc3RkZXYgKiB2MSAqIE1hdGguc3FydCgtMiAqIE1hdGgubG9nKHMpIC8gcykgKyBtZWFuO1xuICB9XG5cbiAgdjIgPSBybm9ybS52MjtcbiAgcm5vcm0udjIgPSBudWxsO1xuICByZXR1cm4gc3RkZXYgKiB2MiArIG1lYW47XG59XG5cbnJub3JtLnYyID0gbnVsbDtcblxuLy8gR2VuZXJhdGUgQ2hpLXNxdWFyZSBkaXN0cmlidXRlZCByYW5kb20gbnVtYmVyc1xuZnVuY3Rpb24gcmNoaXNxKGRlZ3JlZXNPZkZyZWVkb20pIHtcbiAgaWYgKGRlZ3JlZXNPZkZyZWVkb20gPT09IHVuZGVmaW5lZCkge1xuICAgIGRlZ3JlZXNPZkZyZWVkb20gPSAxO1xuICB9XG4gIHZhciBpLCB6LCBzdW0gPSAwLjA7XG4gIGZvciAoaSA9IDA7IGkgPCBkZWdyZWVzT2ZGcmVlZG9tOyBpKyspIHtcbiAgICB6ID0gcm5vcm0oKTtcbiAgICBzdW0gKz0geiAqIHo7XG4gIH1cblxuICByZXR1cm4gc3VtO1xufVxuXG4vLyBHZW5lcmF0ZSBQb2lzc29uIGRpc3RyaWJ1dGVkIHJhbmRvbSBudW1iZXJzXG5mdW5jdGlvbiBycG9pc3NvbihsYW1iZGEpIHtcbiAgaWYgKGxhbWJkYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGFtYmRhID0gMTtcbiAgfVxuICB2YXIgbCA9IE1hdGguZXhwKC1sYW1iZGEpLFxuICAgIGsgPSAwLFxuICAgIHAgPSAxLjA7XG4gIGRvIHtcbiAgICBrKys7XG4gICAgcCAqPSBNYXRoLnJhbmRvbSgpO1xuICB9IHdoaWxlIChwID4gbCk7XG5cbiAgcmV0dXJuIGsgLSAxO1xufVxuXG4vLyBHZW5lcmF0ZSBDYXVjaHkgZGlzdHJpYnV0ZWQgcmFuZG9tIG51bWJlcnNcbmZ1bmN0aW9uIHJjYXVjaHkobG9jLCBzY2FsZSkge1xuICBpZiAobG9jID09PSB1bmRlZmluZWQpIHtcbiAgICBsb2MgPSAwLjA7XG4gIH1cbiAgaWYgKHNjYWxlID09PSB1bmRlZmluZWQpIHtcbiAgICBzY2FsZSA9IDEuMDtcbiAgfVxuICB2YXIgbjIsIG4xID0gcm5vcm0oKTtcbiAgZG8ge1xuICAgIG4yID0gcm5vcm0oKTtcbiAgfSB3aGlsZSAobjIgPT09IDAuMCk7XG5cbiAgcmV0dXJuIGxvYyArIHNjYWxlICogbjEgLyBuMjtcbn1cblxuLy8gQmVybm91bGxpIGRpc3RyaWJ1dGlvbjogZ2l2ZXMgMSB3aXRoIHByb2JhYmlsaXR5IHBcbmZ1bmN0aW9uIHJiZXJub3VsbGkocCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKSA8IHAgPyAxIDogMDtcbn1cblxuLy8gVmVjdG9yaXplIGEgcmFuZG9tIGdlbmVyYXRvclxuZnVuY3Rpb24gdmVjdG9yaXplKGdlbmVyYXRvcikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBuLCByZXN1bHQsIGksIGFyZ3M7XG4gICAgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgIG4gPSBhcmdzLnNoaWZ0KCk7XG4gICAgcmVzdWx0ID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgcmVzdWx0LnB1c2goZ2VuZXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLy8gR2VuZXJhdGUgYSBoaXN0b2dyYW0gZnJvbSBhIGxpc3Qgb2YgbnVtYmVyc1xuZnVuY3Rpb24gaGlzdG9ncmFtKGRhdGEsIGJpbkNvdW50KSB7XG4gIGJpbkNvdW50ID0gYmluQ291bnQgfHwgMTA7XG5cbiAgdmFyIGJpbnMsIGksIHNjYWxlZCxcbiAgICBtYXggPSBNYXRoLm1heC5hcHBseSh0aGlzLCBkYXRhKSxcbiAgICBtaW4gPSBNYXRoLm1pbi5hcHBseSh0aGlzLCBkYXRhKTtcblxuICAvLyBlZGdlIGNhc2U6IG1heCA9PSBtaW5cbiAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgcmV0dXJuIFtkYXRhLmxlbmd0aF07XG4gIH1cblxuICBiaW5zID0gW107XG5cbiAgLy8gemVybyBlYWNoIGJpblxuICBmb3IgKGkgPSAwOyBpIDwgYmluQ291bnQ7IGkrKykge1xuICAgIGJpbnMucHVzaCgwKTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gc2NhbGUgaXQgdG8gYmUgYmV0d2VlbiAwIGFuZCAxXG4gICAgc2NhbGVkID0gKGRhdGFbaV0gLSBtaW4pIC8gKG1heCAtIG1pbik7XG5cbiAgICAvLyBzY2FsZSBpdCB1cCB0byB0aGUgaGlzdG9ncmFtIHNpemVcbiAgICBzY2FsZWQgKj0gYmluQ291bnQ7XG5cbiAgICAvLyBkcm9wIGl0IGluIGEgYmluXG4gICAgc2NhbGVkID0gTWF0aC5mbG9vcihzY2FsZWQpO1xuXG4gICAgLy8gZWRnZSBjYXNlOiB0aGUgbWF4XG4gICAgaWYgKHNjYWxlZCA9PT0gYmluQ291bnQpIHsgc2NhbGVkLS07IH1cblxuICAgIGJpbnNbc2NhbGVkXSsrO1xuICB9XG5cbiAgcmV0dXJuIGJpbnM7XG59XG5cbi8qKlxuICogR2V0IGEgcmFuZG9tIGVsZW1lbnQgZnJvbSBhIGxpc3RcbiAqL1xuZnVuY3Rpb24gcmxpc3QobGlzdCkge1xuICByZXR1cm4gbGlzdFtydW5pZigwLCBsaXN0Lmxlbmd0aCwgdHJ1ZSldO1xufVxuXG5leHBvcnRzLnJ1bmlmID0gcnVuaWY7XG5leHBvcnRzLnJub3JtID0gcm5vcm07XG5leHBvcnRzLnJjaGlzcSA9IHJjaGlzcTtcbmV4cG9ydHMucnBvaXNzb24gPSBycG9pc3NvbjtcbmV4cG9ydHMucmNhdWNoeSA9IHJjYXVjaHk7XG5leHBvcnRzLnJiZXJub3VsbGkgPSByYmVybm91bGxpO1xuZXhwb3J0cy5ybGlzdCA9IHJsaXN0O1xuXG5leHBvcnRzLnJ2dW5pZiA9IHZlY3Rvcml6ZShydW5pZik7XG5leHBvcnRzLnJ2bm9ybSA9IHZlY3Rvcml6ZShybm9ybSk7XG5leHBvcnRzLnJ2Y2hpc3EgPSB2ZWN0b3JpemUocmNoaXNxKTtcbmV4cG9ydHMucnZwb2lzc29uID0gdmVjdG9yaXplKHJwb2lzc29uKTtcbmV4cG9ydHMucnZjYXVjaHkgPSB2ZWN0b3JpemUocmNhdWNoeSk7XG5leHBvcnRzLnJ2YmVybm91bGxpID0gdmVjdG9yaXplKHJiZXJub3VsbGkpO1xuZXhwb3J0cy5ydmxpc3QgPSB2ZWN0b3JpemUocmxpc3QpO1xuXG5leHBvcnRzLmhpc3RvZ3JhbSA9IGhpc3RvZ3JhbTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhbnNpUmVnZXggPSByZXF1aXJlKCdhbnNpLXJlZ2V4JykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IHN0ci5yZXBsYWNlKGFuc2lSZWdleCwgJycpIDogc3RyO1xufTtcbiIsIi8qIGpzaGludCBub2RlOiB0cnVlICovXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIG1ha2VBcnJheUZyb20ob2JqKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkob2JqKTtcbn1cbnZhclxuICBQRU5ESU5HID0gXCJwZW5kaW5nXCIsXG4gIFJFU09MVkVEID0gXCJyZXNvbHZlZFwiLFxuICBSRUpFQ1RFRCA9IFwicmVqZWN0ZWRcIjtcblxuZnVuY3Rpb24gU3luY2hyb25vdXNQcm9taXNlKGhhbmRsZXIpIHtcbiAgdGhpcy5zdGF0dXMgPSBQRU5ESU5HO1xuICB0aGlzLl9jb250aW51YXRpb25zID0gW107XG4gIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICBpZiAoaGFuZGxlcikge1xuICAgIGhhbmRsZXIuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICB0aGlzLl9jb250aW51ZVdpdGguYmluZCh0aGlzKSxcbiAgICAgIHRoaXMuX2ZhaWxXaXRoLmJpbmQodGhpcylcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxvb2tzTGlrZUFQcm9taXNlKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiAob2JqLnRoZW4pID09PSBcImZ1bmN0aW9uXCI7XG59XG5cblN5bmNocm9ub3VzUHJvbWlzZS5wcm90b3R5cGUgPSB7XG4gIHRoZW46IGZ1bmN0aW9uIChuZXh0Rm4sIGNhdGNoRm4pIHtcbiAgICB2YXIgbmV4dCA9IFN5bmNocm9ub3VzUHJvbWlzZS51bnJlc29sdmVkKCkuX3NldFBhcmVudCh0aGlzKTtcbiAgICBpZiAodGhpcy5faXNSZWplY3RlZCgpKSB7XG4gICAgICBpZiAodGhpcy5fcGF1c2VkKSB7XG4gICAgICAgIHRoaXMuX2NvbnRpbnVhdGlvbnMucHVzaCh7XG4gICAgICAgICAgcHJvbWlzZTogbmV4dCxcbiAgICAgICAgICBuZXh0Rm46IG5leHRGbixcbiAgICAgICAgICBjYXRjaEZuOiBjYXRjaEZuXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgIH1cbiAgICAgIGlmIChjYXRjaEZuKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGNhdGNoUmVzdWx0ID0gY2F0Y2hGbih0aGlzLl9lcnJvcik7XG4gICAgICAgICAgaWYgKGxvb2tzTGlrZUFQcm9taXNlKGNhdGNoUmVzdWx0KSkge1xuICAgICAgICAgICAgdGhpcy5fY2hhaW5Qcm9taXNlRGF0YShjYXRjaFJlc3VsdCwgbmV4dCk7XG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlKGNhdGNoUmVzdWx0KS5fc2V0UGFyZW50KHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBTeW5jaHJvbm91c1Byb21pc2UucmVqZWN0KGUpLl9zZXRQYXJlbnQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBTeW5jaHJvbm91c1Byb21pc2UucmVqZWN0KHRoaXMuX2Vycm9yKS5fc2V0UGFyZW50KHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLl9jb250aW51YXRpb25zLnB1c2goe1xuICAgICAgcHJvbWlzZTogbmV4dCxcbiAgICAgIG5leHRGbjogbmV4dEZuLFxuICAgICAgY2F0Y2hGbjogY2F0Y2hGblxuICAgIH0pO1xuICAgIHRoaXMuX3J1blJlc29sdXRpb25zKCk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH0sXG4gIGNhdGNoOiBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKCkpIHtcbiAgICAgIHJldHVybiBTeW5jaHJvbm91c1Byb21pc2UucmVzb2x2ZSh0aGlzLl9kYXRhKS5fc2V0UGFyZW50KHRoaXMpO1xuICAgIH1cbiAgICB2YXIgbmV4dCA9IFN5bmNocm9ub3VzUHJvbWlzZS51bnJlc29sdmVkKCkuX3NldFBhcmVudCh0aGlzKTtcbiAgICB0aGlzLl9jb250aW51YXRpb25zLnB1c2goe1xuICAgICAgcHJvbWlzZTogbmV4dCxcbiAgICAgIGNhdGNoRm46IGhhbmRsZXJcbiAgICB9KTtcbiAgICB0aGlzLl9ydW5SZWplY3Rpb25zKCk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH0sXG4gIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZpcnN0UGF1c2VkID0gdGhpcy5fZmluZEZpcnN0UGF1c2VkKCk7XG4gICAgaWYgKGZpcnN0UGF1c2VkKSB7XG4gICAgICBmaXJzdFBhdXNlZC5fcGF1c2VkID0gZmFsc2U7XG4gICAgICBmaXJzdFBhdXNlZC5fcnVuUmVzb2x1dGlvbnMoKTtcbiAgICAgIGZpcnN0UGF1c2VkLl9ydW5SZWplY3Rpb25zKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfZmluZEFuY2VzdHJ5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRpbnVhdGlvbnMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGN1cikge1xuICAgICAgaWYgKGN1ci5wcm9taXNlKSB7XG4gICAgICAgIHZhciBub2RlID0ge1xuICAgICAgICAgIHByb21pc2U6IGN1ci5wcm9taXNlLFxuICAgICAgICAgIGNoaWxkcmVuOiBjdXIucHJvbWlzZS5fZmluZEFuY2VzdHJ5KClcbiAgICAgICAgfTtcbiAgICAgICAgYWNjLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTtcbiAgfSxcbiAgX3NldFBhcmVudDogZnVuY3Rpb24gKHBhcmVudCkge1xuICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInBhcmVudCBhbHJlYWR5IHNldFwiKTtcbiAgICB9XG4gICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfY29udGludWVXaXRoOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBmaXJzdFBlbmRpbmcgPSB0aGlzLl9maW5kRmlyc3RQZW5kaW5nKCk7XG4gICAgaWYgKGZpcnN0UGVuZGluZykge1xuICAgICAgZmlyc3RQZW5kaW5nLl9kYXRhID0gZGF0YTtcbiAgICAgIGZpcnN0UGVuZGluZy5fc2V0UmVzb2x2ZWQoKTtcbiAgICB9XG4gIH0sXG4gIF9maW5kRmlyc3RQZW5kaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbmRGaXJzdEFuY2VzdG9yKGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgICByZXR1cm4gdGVzdC5faXNQZW5kaW5nICYmIHRlc3QuX2lzUGVuZGluZygpO1xuICAgIH0pO1xuICB9LFxuICBfZmluZEZpcnN0UGF1c2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbmRGaXJzdEFuY2VzdG9yKGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgICByZXR1cm4gdGVzdC5fcGF1c2VkO1xuICAgIH0pO1xuICB9LFxuICBfZmluZEZpcnN0QW5jZXN0b3I6IGZ1bmN0aW9uIChtYXRjaGluZykge1xuICAgIHZhciB0ZXN0ID0gdGhpcztcbiAgICB2YXIgcmVzdWx0O1xuICAgIHdoaWxlICh0ZXN0KSB7XG4gICAgICBpZiAobWF0Y2hpbmcodGVzdCkpIHtcbiAgICAgICAgcmVzdWx0ID0gdGVzdDtcbiAgICAgIH1cbiAgICAgIHRlc3QgPSB0ZXN0Ll9wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIF9mYWlsV2l0aDogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgdmFyIGZpcnN0UmVqZWN0ZWQgPSB0aGlzLl9maW5kRmlyc3RQZW5kaW5nKCk7XG4gICAgaWYgKGZpcnN0UmVqZWN0ZWQpIHtcbiAgICAgIGZpcnN0UmVqZWN0ZWQuX2Vycm9yID0gZXJyb3I7XG4gICAgICBmaXJzdFJlamVjdGVkLl9zZXRSZWplY3RlZCgpO1xuICAgIH1cbiAgfSxcbiAgX3Rha2VDb250aW51YXRpb25zOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRpbnVhdGlvbnMuc3BsaWNlKDAsIHRoaXMuX2NvbnRpbnVhdGlvbnMubGVuZ3RoKTtcbiAgfSxcbiAgX3J1blJlamVjdGlvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcGF1c2VkIHx8ICF0aGlzLl9pc1JlamVjdGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyXG4gICAgICBlcnJvciA9IHRoaXMuX2Vycm9yLFxuICAgICAgY29udGludWF0aW9ucyA9IHRoaXMuX3Rha2VDb250aW51YXRpb25zKCksXG4gICAgICBzZWxmID0gdGhpcztcbiAgICBjb250aW51YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGNvbnQpIHtcbiAgICAgIGlmIChjb250LmNhdGNoRm4pIHtcbiAgICAgICAgdmFyIGNhdGNoUmVzdWx0ID0gY29udC5jYXRjaEZuKGVycm9yKTtcbiAgICAgICAgc2VsZi5faGFuZGxlVXNlckZ1bmN0aW9uUmVzdWx0KGNhdGNoUmVzdWx0LCBjb250LnByb21pc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udC5wcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIF9ydW5SZXNvbHV0aW9uczogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9wYXVzZWQgfHwgIXRoaXMuX2lzUmVzb2x2ZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY29udGludWF0aW9ucyA9IHRoaXMuX3Rha2VDb250aW51YXRpb25zKCk7XG4gICAgaWYgKGxvb2tzTGlrZUFQcm9taXNlKHRoaXMuX2RhdGEpKSB7XG4gICAgICByZXR1cm4gdGhpcy5faGFuZGxlV2hlblJlc29sdmVkRGF0YUlzUHJvbWlzZSh0aGlzLl9kYXRhKTtcbiAgICB9XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBjb250aW51YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGNvbnQpIHtcbiAgICAgIGlmIChjb250Lm5leHRGbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBjb250Lm5leHRGbihkYXRhKTtcbiAgICAgICAgICBzZWxmLl9oYW5kbGVVc2VyRnVuY3Rpb25SZXN1bHQocmVzdWx0LCBjb250LnByb21pc2UpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgc2VsZi5faGFuZGxlUmVzb2x1dGlvbkVycm9yKGUsIGNvbnQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvbnQucHJvbWlzZSkge1xuICAgICAgICBjb250LnByb21pc2UucmVzb2x2ZShkYXRhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgX2hhbmRsZVJlc29sdXRpb25FcnJvcjogZnVuY3Rpb24gKGUsIGNvbnRpbnVhdGlvbikge1xuICAgIHRoaXMuX3NldFJlamVjdGVkKCk7XG4gICAgaWYgKGNvbnRpbnVhdGlvbi5jYXRjaEZuKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb250aW51YXRpb24uY2F0Y2hGbihlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgZSA9IGUyO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGludWF0aW9uLnByb21pc2UpIHtcbiAgICAgIGNvbnRpbnVhdGlvbi5wcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG4gIH0sXG4gIF9oYW5kbGVXaGVuUmVzb2x2ZWREYXRhSXNQcm9taXNlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gZGF0YS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgIHNlbGYuX2RhdGEgPSByZXN1bHQ7XG4gICAgICBzZWxmLl9ydW5SZXNvbHV0aW9ucygpO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgc2VsZi5fZXJyb3IgPSBlcnJvcjtcbiAgICAgIHNlbGYuX3NldFJlamVjdGVkKCk7XG4gICAgICBzZWxmLl9ydW5SZWplY3Rpb25zKCk7XG4gICAgfSk7XG4gIH0sXG4gIF9oYW5kbGVVc2VyRnVuY3Rpb25SZXN1bHQ6IGZ1bmN0aW9uIChkYXRhLCBuZXh0U3luY2hyb25vdXNQcm9taXNlKSB7XG4gICAgaWYgKGxvb2tzTGlrZUFQcm9taXNlKGRhdGEpKSB7XG4gICAgICB0aGlzLl9jaGFpblByb21pc2VEYXRhKGRhdGEsIG5leHRTeW5jaHJvbm91c1Byb21pc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0U3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUoZGF0YSk7XG4gICAgfVxuICB9LFxuICBfY2hhaW5Qcm9taXNlRGF0YTogZnVuY3Rpb24gKHByb21pc2VEYXRhLCBuZXh0U3luY2hyb25vdXNQcm9taXNlKSB7XG4gICAgcHJvbWlzZURhdGEudGhlbihmdW5jdGlvbiAobmV3RGF0YSkge1xuICAgICAgbmV4dFN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlKG5ld0RhdGEpO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChuZXdFcnJvcikge1xuICAgICAgbmV4dFN5bmNocm9ub3VzUHJvbWlzZS5yZWplY3QobmV3RXJyb3IpO1xuICAgIH0pO1xuICB9LFxuICBfc2V0UmVzb2x2ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnN0YXR1cyA9IFJFU09MVkVEO1xuICAgIGlmICghdGhpcy5fcGF1c2VkKSB7XG4gICAgICB0aGlzLl9ydW5SZXNvbHV0aW9ucygpO1xuICAgIH1cbiAgfSxcbiAgX3NldFJlamVjdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zdGF0dXMgPSBSRUpFQ1RFRDtcbiAgICBpZiAoIXRoaXMuX3BhdXNlZCkge1xuICAgICAgdGhpcy5fcnVuUmVqZWN0aW9ucygpO1xuICAgIH1cbiAgfSxcbiAgX2lzUGVuZGluZzogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gUEVORElORztcbiAgfSxcbiAgX2lzUmVzb2x2ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09IFJFU09MVkVEO1xuICB9LFxuICBfaXNSZWplY3RlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gUkVKRUNURUQ7XG4gIH1cbn07XG5cblN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICByZXR1cm4gbmV3IFN5bmNocm9ub3VzUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKGxvb2tzTGlrZUFQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgIHJlc3VsdC50aGVuKGZ1bmN0aW9uIChuZXdSZXN1bHQpIHtcbiAgICAgICAgcmVzb2x2ZShuZXdSZXN1bHQpO1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5TeW5jaHJvbm91c1Byb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICByZXR1cm4gbmV3IFN5bmNocm9ub3VzUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVqZWN0KHJlc3VsdCk7XG4gIH0pO1xufTtcblxuU3luY2hyb25vdXNQcm9taXNlLnVucmVzb2x2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgU3luY2hyb25vdXNQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuICB9KTtcbn07XG5cblN5bmNocm9ub3VzUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcmdzID0gbWFrZUFycmF5RnJvbShhcmd1bWVudHMpO1xuICBpZiAoQXJyYXkuaXNBcnJheShhcmdzWzBdKSkge1xuICAgIGFyZ3MgPSBhcmdzWzBdO1xuICB9XG4gIGlmICghYXJncy5sZW5ndGgpIHtcbiAgICByZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUoW10pO1xuICB9XG4gIHJldHVybiBuZXcgU3luY2hyb25vdXNQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXJcbiAgICAgIGFsbERhdGEgPSBbXSxcbiAgICAgIG51bVJlc29sdmVkID0gMCxcbiAgICAgIGRvUmVzb2x2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG51bVJlc29sdmVkID09PSBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIHJlc29sdmUoYWxsRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZWplY3RlZCA9IGZhbHNlLFxuICAgICAgZG9SZWplY3QgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZWplY3RlZCA9IHRydWU7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfTtcbiAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKGFyZywgaWR4KSB7XG4gICAgICBTeW5jaHJvbm91c1Byb21pc2UucmVzb2x2ZShhcmcpLnRoZW4oZnVuY3Rpb24gKHRoaXNSZXN1bHQpIHtcbiAgICAgICAgYWxsRGF0YVtpZHhdID0gdGhpc1Jlc3VsdDtcbiAgICAgICAgbnVtUmVzb2x2ZWQgKz0gMTtcbiAgICAgICAgZG9SZXNvbHZlKCk7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGRvUmVqZWN0KGVycik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG5pZiAoUHJvbWlzZSA9PT0gU3luY2hyb25vdXNQcm9taXNlKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSB1c2UgU3luY2hyb25vdXNQcm9taXNlLmluc3RhbGxHbG9iYWxseSgpIHRvIGluc3RhbGwgZ2xvYmFsbHlcIik7XG59XG52YXIgUmVhbFByb21pc2UgPSBQcm9taXNlO1xuU3luY2hyb25vdXNQcm9taXNlLmluc3RhbGxHbG9iYWxseSA9IGZ1bmN0aW9uKF9fYXdhaXRlcikge1xuICBpZiAoUHJvbWlzZSA9PT0gU3luY2hyb25vdXNQcm9taXNlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcjtcbiAgfSBcbiAgdmFyIHJlc3VsdCA9IHBhdGNoQXdhaXRlcklmUmVxdWlyZWQoX19hd2FpdGVyKTtcbiAgUHJvbWlzZSA9IFN5bmNocm9ub3VzUHJvbWlzZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblN5bmNocm9ub3VzUHJvbWlzZS51bmluc3RhbGxHbG9iYWxseSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoUHJvbWlzZSA9PT0gU3luY2hyb25vdXNQcm9taXNlKSB7XG4gICAgUHJvbWlzZSA9IFJlYWxQcm9taXNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBwYXRjaEF3YWl0ZXJJZlJlcXVpcmVkKF9fYXdhaXRlcikge1xuICBpZiAodHlwZW9mKF9fYXdhaXRlcikgPT09IFwidW5kZWZpbmVkXCIgfHwgX19hd2FpdGVyLl9fcGF0Y2hlZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXI7XG4gIH1cbiAgdmFyIG9yaWdpbmFsQXdhaXRlciA9IF9fYXdhaXRlcjtcbiAgX19hd2FpdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIFByb21pc2UgPSBSZWFsUHJvbWlzZTtcbiAgICBvcmlnaW5hbEF3YWl0ZXIuYXBwbHkodGhpcywgbWFrZUFycmF5RnJvbShhcmd1bWVudHMpKTtcbiAgfTtcbiAgX19hd2FpdGVyLl9fcGF0Y2hlZCA9IHRydWU7XG4gIHJldHVybiBfX2F3YWl0ZXI7XG59XG4vKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgU3luY2hyb25vdXNQcm9taXNlOiBTeW5jaHJvbm91c1Byb21pc2Vcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBnYW1lIHBpZWNlc1xyXG52YXIgcHJpc29uZXJEaWxlbW1hID0gcmVxdWlyZShcIi4vaXRlcmF0ZWQtcHJpc29uZXItZGlsZW1tYVwiKS5jcmVhdGVHZW5lcmF0b3I7XHJcbnZhciByb3VuZFJvYmluID0gcmVxdWlyZShcIi4vcm91bmQtcm9iaW5cIik7XHJcbnZhciB7IExvb3AgfSA9IHJlcXVpcmUoXCIuLi9saWIvZW5naW5lXCIpLlBsYXlhYmxlcztcclxuXHJcbi8vIGhlbHBlciBmdW5jdGlvbnNcclxudmFyIHsgZ2FtZVdyYXBwZXIgfSA9IHJlcXVpcmUoXCIuLi9saWIvaGVscGVyRnVuY3Rpb25zXCIpKFwic3RvY2stZ2FtZXNcIilcclxuXHJcbi8vIFBvcHVsYXRpb24gaW50ZXJmYWNlc1xyXG52YXIgeyBQb3B1bGF0aW9uIH0gPSByZXF1aXJlKFwiLi4vbGliL3BvcHVsYXRpb25cIik7XHJcbnZhciB7IGdlbmVyYXRlUG9wdWxhdGlvbiB9ID0gcmVxdWlyZShcIi4uL2xpYi9oZWxwZXJmdW5jdGlvbnNcIikoXCJ0b3VybmFtZW50XCIpO1xyXG5cclxudmFyIEF4ZWxyb2RUb3VybmFtZW50ID0gZ2FtZVdyYXBwZXIoZnVuY3Rpb24ocGxheWVycywgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0dmFyIHsgZ2VuZXJhdGVQbGF5ZXJzID0gdHJ1ZSwgcmVwZWF0cyA9IDUsIGdhbWVMZW5ndGggPSAyMDAgfSA9IHBhcmFtZXRlcnM7XHJcblxyXG5cdC8vIEVpdGhlciBjcmVhdGUgYW4gZW50aXJlIHBvcHVsYXRpb25cclxuXHRpZiAoZ2VuZXJhdGVQbGF5ZXJzKSB7XHJcblx0XHQvLyBHZXQgdHdvIHNldHMgb2YgcGxheWVycy4gVGhlIHNlY29uZCBpcyBzbyBwbGF5ZXJzIGNhbiBwbGF5IHRoZW1zZWx2ZXNcclxuXHRcdHBsYXllcnMgPSBnZW5lcmF0ZVBvcHVsYXRpb24oKTtcclxuXHRcdHZhciBjb3BpZXMgPSBnZW5lcmF0ZVBvcHVsYXRpb24oKTtcclxuXHRcdHBhcmFtZXRlcnMuY29waWVzID0gY29waWVzO1xyXG5cdH1cclxuXHJcblx0Ly8gb3IgdXNlIHRoZSBzdXBwbGllZCBwbGF5ZXJzXHJcblx0ZWxzZSBpZiAocGxheWVycykge1xyXG5cdFx0Ly8gZG8gbm90aGluZ1xyXG5cdH0gZWxzZSB7XHJcblx0XHQvLyBvciB1c2UgdGhlIHBsYXllcnMgYWxyZWFkeSBwcmVzZW50XHJcblx0XHRwbGF5ZXJzID0gUG9wdWxhdGlvbigpLm9ubHlBbGl2ZSgpLm9ubHlBdmFpbGFibGUoKTtcclxuXHR9XHJcblxyXG5cdC8vIGFzc2lnbiBwYXJhbWV0ZXJzIGFuZCBnZW5lcmF0ZSB0aGUgZ2FtZVxyXG5cdHBhcmFtZXRlcnMuaW5pdGlhbGl6ZVBsYXllcnMgPSBwbGF5ZXJzO1xyXG5cdHZhciBpdGVyYXRpb24gPSByb3VuZFJvYmluKHBsYXllcnMsIHByaXNvbmVyRGlsZW1tYShnYW1lTGVuZ3RoKSwgcGFyYW1ldGVycyk7XHJcblxyXG5cdHJldHVybiBMb29wKGl0ZXJhdGlvbiwgcmVwZWF0cywgeyBpZDogXCJBeGVscm9kLVRvdXJuYW1lbnRcIiB9KTtcclxufSk7XHJcblxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQXhlbHJvZFRvdXJuYW1lbnQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gbmFzaEpTIGVuZ2luZVxyXG52YXIge1BvcHVsYXRpb259ID0gcmVxdWlyZSgnLi4vbGliL2VuZ2luZScpO1xyXG52YXIge0xhbWJkYSwgU2ltdWx0YW5lb3VzLCBTZXF1ZW5jZSwgTG9vcH0gPSByZXF1aXJlKCcuLi9saWIvZW5naW5lJykuUGxheWFibGVzO1xyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIge2lzRnVuY3Rpb259ID0gcmVxdWlyZShcIi4uL2xpYi9oZWxwZXJmdW5jdGlvbnNcIikoXCJnZW5lcmFsXCIpO1xyXG5cclxuXHJcbi8vQ3VsdHVyYWwgZXZvbHV0aW9uXHJcbi8vXHJcbi8vIFRPRE86IGFkZCBpbnN0cnVjdGlvbnMgaGVyZVxyXG5mdW5jdGlvbiBDdWx0dXJhbEV2b2x1dGlvbihnYW1lR2VuZXJhdG9yLCBudW1Mb29wcz0xLCB7aWQgPSBcIkN1bHR1cmFsRXZvbHV0aW9uXCIsIGdhbWVQcm9iYWJpbGl0eT0uMjUsIHBhaXJQcm9iYWJpbGl0eT0uMjUsIGdlbmVyYXRlUG9wdWxhdGlvbj1udWxsLCBsb29wPXRydWV9PXt9KXtcclxuXHRcclxuXHRpZiAobG9vcCAmJiBpc05hTihudW1Mb29wcykpIHRocm93IG5ldyBFcnJvcihcIkN1bHR1cmFsRXZvbHV0aW9uIGFyZ3VtZW50ICdudW1Mb29wcyBtdXN0IGJlIGEgbnVtYmVyXCIpO1xyXG5cdGlmICghaXNGdW5jdGlvbihnYW1lR2VuZXJhdG9yKSkgdGhyb3cgbmV3IEVycm9yKFwiQ3VsdHVyYWxFdm9sdXRpb24gYXJndW1lbnQgJ2dhbWVHZW5lcmF0b3InIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcclxuXHRpZiAoaXNOYU4oZ2FtZVByb2JhYmlsaXR5KSB8fCBnYW1lUHJvYmFiaWxpdHkgPCAwIHx8IGdhbWVQcm9iYWJpbGl0eSA+IDEpIHRocm93IG5ldyBFcnJvcihcIkN1bHR1cmFsRXZvbHV0aW9uIGFyZ3VtZW50ICdnYW1lUHJvYmFiaWxpdHknIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxXCIpO1xyXG5cdGlmIChpc05hTihwYWlyUHJvYmFiaWxpdHkpIHx8IHBhaXJQcm9iYWJpbGl0eSA8IDAgfHwgcGFpclByb2JhYmlsaXR5ID4gMSkgdGhyb3cgbmV3IEVycm9yKFwiQ3VsdHVyYWxFdm9sdXRpb24gYXJndW1lbnQgJ3BhaXJQcm9iYWJpbGl0eScgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDFcIik7XHJcblx0XHJcblx0Ly8gR2VuZXJhdGUgcG9wdWxhdGlvbiBpZiB1c2VyIHdhbnRzIHVzIHRvLlxyXG5cdGlmIChpc0Z1bmN0aW9uKGdlbmVyYXRlUG9wdWxhdGlvbikpIGdlbmVyYXRlUG9wdWxhdGlvbigpO1xyXG5cdFxyXG5cdC8vUmVzZXQgdGhlIHNjb3JlcyBlYWNoIHJvdW5kLlxyXG5cdHZhciBSZXNldFNjb3JlcyA9IExhbWJkYShmdW5jdGlvbigpe1xyXG5cdFx0UG9wdWxhdGlvbigpLm9ubHlBbGl2ZSgpLnJlc2V0U2NvcmVzKCk7XHJcblx0fSk7XHJcblx0XHJcblx0Ly8gQ2FsY3VsYXRlIG51bWJlciBvZiBtYXRjaGVzXHJcblx0dmFyIG4gPSBNYXRoLmZsb29yKFBvcHVsYXRpb24oKS5vbmx5QWxpdmUoKS5sZW5ndGggKiBnYW1lUHJvYmFiaWxpdHkpO1xyXG5cdFxyXG5cdC8vIENyZWF0ZSBtYXRjaGVzLlxyXG5cdHZhciBtYXRjaGVzID0gWy4uLkFycmF5KG4pXVxyXG5cdGZvciAoaT0wOyBpPG47IGkrKyl7XHJcblx0XHRtYXRjaGVzW2ldID0gZ2FtZUdlbmVyYXRvcigpO1xyXG5cdFx0aWYgKCFtYXRjaGVzW2ldLnBsYXkpIHRocm93IG5ldyBFcnJvcihcIkN1bHR1cmFsRXZvbHV0aW9uIGFyZ3VtZW50ICdnYW1lR2VuZXJhdG9yJyBtdXN0IHJldHVybiBhIFBsYXlhYmxlXCIpO1xyXG5cdH1cclxuXHRcclxuXHQvL1J1biBhbGwgbWF0Y2hlcyBzaW11bHRhbmVvdXNseVxyXG5cdHZhciBSb3VuZCA9IFNpbXVsdGFuZW91cyhtYXRjaGVzKTtcclxuXHRcclxuXHQvL0NhbGN1bGF0ZSBudW1iZXIgb2YgcGFpcmluZ3NcclxuXHR2YXIgbiA9IE1hdGguZmxvb3IoUG9wdWxhdGlvbigpLm9ubHlBbGl2ZSgpLmxlbmd0aCAqIHBhaXJQcm9iYWJpbGl0eSlcclxuXHRcclxuXHQvL0NyZWF0ZSBwYWlyaW5nc1xyXG5cdHZhciBwYWlyaW5ncyA9IFsuLi5BcnJheShuKV07XHJcblx0Zm9yIChpPTA7IGk8bjsgaSsrKXtcclxuXHRcdFxyXG5cdFx0cGFpcmluZ3NbaV0gPUxhbWJkYShmdW5jdGlvbigpe1xyXG5cdFx0XHRcclxuXHRcdFx0Ly9GaW5kIHNvbWUgYXZhaWxhYmxlIHBsYXllcnNcclxuXHRcdFx0dmFyIHBvb2wgPSBQb3B1bGF0aW9uKCkub25seUFsaXZlKCkub25seUF2YWlsYWJsZSgpO1xyXG5cdFx0XHR2YXIgcDEgPSBwb29sW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSpwb29sLmxlbmd0aCldO1xyXG5cdFx0XHR2YXIgcDIgPSBwb29sW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSpwb29sLmxlbmd0aCldO1xyXG5cdFxyXG5cdFx0XHQvL01hcmsgdGhlbSBidXN5XHJcblx0XHRcdHAxLmJ1c3koKTtcclxuXHRcdFx0cDIuYnVzeSgpO1xyXG5cclxuXHRcdFx0Ly8gQXNzaWduIHN0cmF0ZWd5IG9mIHBsYXllciB3aXRoIGhpZ2hlciBzY29yZVxyXG5cdFx0XHRpZiAocDEuc2NvcmUoKSA+IHAyLnNjb3JlKCkpIHAyLmFzc2lnbihwMS5zdHJhdGVneSgpKTtcclxuXHRcdFx0ZWxzZSBpZiAocDEuc2NvcmUoKSA9PSBwMi5zY29yZSgpKSBudWxsO1xyXG5cdFx0XHRlbHNlIHAxLmFzc2lnbihwMi5zdHJhdGVneSgpKTtcclxuXHRcclxuXHRcdFx0Ly9SZXR1cm4gdmFsdWUgb2YgcGxheWVyIGlkcywgc28gdGhlIGxvZyBtYWtlcyBzb21lIHNlbnNlLlxyXG5cdFx0XHRyZXR1cm4gW3AxLmlkKCkscDIuaWQoKV07XHJcblx0XHR9KTtcclxuXHR9XHJcblx0XHRcclxuXHQvLyBSdW4gcGFpcmluZ3Mgc2ltdWx0YW5lb3VzbHlcclxuXHR2YXIgUGFpcmluZyA9IFNpbXVsdGFuZW91cyhwYWlyaW5ncyk7XHJcblx0XHRcclxuXHQvLyBBZnRlciBwYWlyaW5ncywgbWFyayBhbGwgcGxheWVycyBhcyBhdmFpbGFibGUuXHJcblx0dmFyIFJlbGVhc2VQbGF5ZXJzID0gTGFtYmRhKGZ1bmN0aW9uKCl7XHJcblx0XHRQb3B1bGF0aW9uKCkub25seUFsaXZlKCkucmVsZWFzZSgpO1xyXG5cdH0pO1xyXG5cdFxyXG5cdC8vIERlZmluZSB0aGUgZ2FtZS5cclxuXHRSb3VuZChSZXNldFNjb3Jlcyk7XHJcblx0UGFpcmluZyhSb3VuZCk7XHJcblx0UmVsZWFzZVBsYXllcnMoUGFpcmluZyk7XHJcblx0dmFyIEl0ZXJhdGlvbiA9IFNlcXVlbmNlKFJlc2V0U2NvcmVzLCBSZWxlYXNlUGxheWVycyk7XHJcblx0XHJcblx0Ly8gVXNlciBjYW4gc2V0IGxvb3AgcGFyYW1ldGVyIHRvIGZhbHNlLCB0byBhdm9pZCB3cmFwcGluZyB0aGlzIGluIGEgbG9vcC5cclxuXHRpZiAobG9vcCkgXHJcblx0XHR2YXIgQ0UgPSBMb29wKEl0ZXJhdGlvbiwgbnVtTG9vcHMsIHtwbGF5YWJsZVBhcmFtZXRlcnM6e2luaXRpYWxpemVQbGF5ZXJzOnRydWV9fSk7XHJcblx0ZWxzZSBcclxuXHRcdHZhciBDRSA9IEl0ZXJhdGlvbjtcclxuXHRcclxuXHRyZXR1cm4gQ0U7XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEN1bHR1cmFsRXZvbHV0aW9uOyIsInZhciBTdG9ja0dhbWVzID0ge1xyXG5cdC8vR2FtZSBza2VsZXRvbnNcclxuXHRcIlR3by1QbGF5ZXIgTm9ybWFsXCI6IHJlcXVpcmUoXCIuL3NpbXBsZS1ub3JtYWxcIikuVHdvUGxheWVyTm9ybWFsLFxyXG5cdFwiTm9ybWFsXCI6IHJlcXVpcmUoXCIuL3NpbXBsZS1ub3JtYWxcIikuTm9ybWFsLFxyXG5cdFwiU2ltcGxlIFplcm8tU3VtXCI6IHJlcXVpcmUoXCIuL3NpbXBsZS16ZXJvLXN1bVwiKSxcclxuXHJcblx0Ly8gQ2xhc3NpYyBnYW1lc1xyXG5cdFwiTWF0Y2hpbmcgUGVubmllc1wiOiByZXF1aXJlKFwiLi9tYXRjaGluZy1wZW5uaWVzXCIpLFxyXG5cdFwiUHJpc29uZXIncyBEaWxlbW1hXCI6IHJlcXVpcmUoXCIuL3ByaXNvbmVyLWRpbGVtbWFcIiksXHJcblx0XCJSb2NrLVBhcGVyLVNjaXNzb3JzXCI6IHJlcXVpcmUoXCIuL3JvY2stcGFwZXItc2Npc3NvcnNcIiksXHJcblxyXG5cdC8vIEl0ZXJhdGVkIGdhbWVzXHJcblx0XCJJdGVyYXRlZFwiOiByZXF1aXJlKFwiLi9pdGVyYXRlZFwiKSxcclxuXHRcIkl0ZXJhdGVkIFByaXNvbmVyJ3MgRGlsZW1tYVwiOiByZXF1aXJlKFwiLi9pdGVyYXRlZC1wcmlzb25lci1kaWxlbW1hXCIpLFxyXG5cclxuXHQvLyBFdm9sdXRpb25hcnkgZ2FtZXNcclxuXHRcIkN1bHR1cmFsIEV2b2x1dGlvblwiOiByZXF1aXJlKFwiLi9jdWx0dXJhbC1ldm9sdXRpb25cIiksXHJcblxyXG5cdC8vVG91cm5hbWVudHNcclxuXHRcIlJvdW5kIFJvYmluXCI6IHJlcXVpcmUoXCIuL3JvdW5kLXJvYmluXCIpLFxyXG5cdFwiQXhlbHJvZCBUb3VybmFtZW50XCI6IHJlcXVpcmUoXCIuL2F4ZWxyb2QtdG91cm5hbWVudFwiKVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTdG9ja0dhbWVzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vIEJhc2UgZ2FtZVxyXG52YXIgcHJpc29uZXJEaWxlbW1hID0gcmVxdWlyZShcIi4vcHJpc29uZXItZGlsZW1tYVwiKS5jcmVhdGVHZW5lcmF0b3IoKTtcclxuXHJcbi8vIGdhbWUgZW5naW5lXHJcbnZhciB7IExvb3AgfSA9IHJlcXVpcmUoXCIuLi9saWIvZW5naW5lXCIpLlBsYXlhYmxlcztcclxuXHJcbi8vIEdhbWUgdXRpbGl0eVxyXG52YXIgSXRlcmF0ZWQgPSByZXF1aXJlKFwiLi9pdGVyYXRlZFwiKVxyXG5cclxuLy8gaGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBnYW1lV3JhcHBlciB9ID0gcmVxdWlyZShcIi4uL2xpYi9oZWxwZXJGdW5jdGlvbnNcIikoXCJzdG9jay1nYW1lc1wiKVxyXG5cclxudmFyIEl0ZXJhdGVkUHJpc29uZXJEaWxlbW1hID0gZ2FtZVdyYXBwZXIoZnVuY3Rpb24ocGxheWVycywgbnVtYmVySXRlcmF0aW9ucyA9IDUwLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHRyZXR1cm4gSXRlcmF0ZWQocGxheWVycywgcHJpc29uZXJEaWxlbW1hLCBcIlByaXNvbmVyLURpbGVtbWFcIiwgbnVtYmVySXRlcmF0aW9ucywgcGFyYW1ldGVycylcclxufSk7XHJcbi8vIFRPRE8gdmFsaWRhdGUgYXJndW1lbnRzXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEl0ZXJhdGVkUHJpc29uZXJEaWxlbW1hXHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gZ2FtZSBlbmdpbmVcclxudmFyIHsgTG9vcCB9ID0gcmVxdWlyZShcIi4uL2xpYi9lbmdpbmVcIikuUGxheWFibGVzO1xyXG5cclxuLy8gaGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBnYW1lV3JhcHBlciB9ID0gcmVxdWlyZShcIi4uL2xpYi9oZWxwZXJGdW5jdGlvbnNcIikoXCJzdG9jay1nYW1lc1wiKVxyXG5cclxuXHJcbnZhciBJdGVyYXRlZCA9IGdhbWVXcmFwcGVyKGZ1bmN0aW9uKHBsYXllcnMsIGdhbWVHZW5lcmF0b3IsIGdhbWVOYW1lLCBudW1iZXJJdGVyYXRpb25zID0gNTAsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cclxuXHR2YXIgeyBwYXJhbWV0ZXJzOiBnYW1lUGFyYW1ldGVycyA9IHt9IH0gPSBwYXJhbWV0ZXJzXHJcblxyXG5cdGdhbWVQYXJhbWV0ZXJzLmlkID0gZ2FtZVBhcmFtZXRlcnMuaWQgfHwgZ2FtZU5hbWVcclxuXHRwYXJhbWV0ZXJzLmlkID0gcGFyYW1ldGVycy5pZCB8fCBcIkl0ZXJhdGVkLVwiICsgZ2FtZU5hbWU7XHJcblxyXG5cdHJldHVybiBMb29wKGdhbWVHZW5lcmF0b3IocGxheWVycywgZ2FtZVBhcmFtZXRlcnMpLCBudW1iZXJJdGVyYXRpb25zLCBwYXJhbWV0ZXJzKTtcclxufSlcclxuXHJcbi8vIFRPRE8gdmFsaWRhdGUgYXJndW1lbnRzXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEl0ZXJhdGVkO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vIGJhc2UgZ2FtZVxyXG52YXIgU2ltcGxlWmVyb1N1bSA9IHJlcXVpcmUoXCIuL3NpbXBsZS16ZXJvLXN1bVwiKTtcclxuXHJcbi8vIGhlbHBlciBmdW5jdGlvbnNcclxudmFyIHsgZ2FtZVdyYXBwZXIgfSA9IHJlcXVpcmUoXCIuLi9saWIvaGVscGVyRnVuY3Rpb25zXCIpKFwic3RvY2stZ2FtZXNcIilcclxuXHJcbi8vIFBsYXktdGltZSBsb2dpY1xyXG52YXIgeyBFeHByZXNzaW9uIH0gPSByZXF1aXJlKFwiLi4vbGliL2xvZ2ljXCIpO1xyXG5cclxuXHJcbnZhciBNYXRjaGluZ1Blbm5pZXMgPSBnYW1lV3JhcHBlcihmdW5jdGlvbihwbGF5ZXJzLCBwYXlvZmYgPSAxLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHRwYXJhbWV0ZXJzLmlkID0gcGFyYW1ldGVycy5pZCB8fCBcIk1hdGNoaW5nLVBlbm5pZXNcIjtcclxuXHJcblx0dmFyIHdpbiA9IHBheW9mZjtcclxuXHR2YXIgbG9zZSA9IEV4cHJlc3Npb24oZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gLXBheW9mZjtcclxuXHR9KTtcclxuXHJcblx0dmFyIGNob2ljZXMgPSBbXHJcblx0XHRbXCJIZWFkc1wiLCBcIlRhaWxzXCJdLFxyXG5cdFx0W1wiSGVhZHNcIiwgXCJUYWlsc1wiXVxyXG5cdF07XHJcblxyXG5cdHZhciBwYXlvZmZzID0gW1xyXG5cdFx0W3dpbiwgbG9zZV0sXHJcblx0XHRbbG9zZSwgd2luXVxyXG5cdF07XHJcblxyXG5cdHJldHVybiBTaW1wbGVaZXJvU3VtKHBsYXllcnMsIGNob2ljZXMsIHBheW9mZnMsIHBhcmFtZXRlcnMpO1xyXG59KTtcclxuXHJcbi8vIE1hdGNoaW5nIFBlbm5pZXNcclxubW9kdWxlLmV4cG9ydHMgPSBNYXRjaGluZ1Blbm5pZXM7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gYmFzZSBnYW1lXHJcbnZhciBUd29QbGF5ZXJOb3JtYWwgPSByZXF1aXJlKFwiLi9zaW1wbGUtbm9ybWFsXCIpLlR3b1BsYXllck5vcm1hbDtcclxuXHJcbi8vIGhlbHBlciBmdW5jdGlvbnNcclxudmFyIHsgZ2FtZVdyYXBwZXIgfSA9IHJlcXVpcmUoXCIuLi9saWIvaGVscGVyRnVuY3Rpb25zXCIpKFwic3RvY2stZ2FtZXNcIilcclxuXHJcbi8vIHBsYXktdGltZSBsb2dpY1xyXG52YXIgeyBWYXJpYWJsZSwgRXhwcmVzc2lvbiB9ID0gcmVxdWlyZShcIi4uL2xpYi9sb2dpY1wiKTtcclxuXHJcbnZhciBwcmlzb25lckRpbGVtbWEgPSBnYW1lV3JhcHBlcihmdW5jdGlvbihwbGF5ZXJzLCB7XHJcblx0aWQgPSBcIlByaXNvbmVyLURpbGVtbWFcIixcclxuXHRwYXlvZmZTY2FsZSA9IFZhcmlhYmxlKDEpLFxyXG5cdHBheW9mZlNwcmVhZCA9IFZhcmlhYmxlKDQpXHJcbn0gPSB7fSkge1xyXG5cdC8vVE9ETzogZml4IHRoZSBjYXNlIG9mIG5lZ2F0aXZlIHNjYWxlLlxyXG5cclxuXHR2YXIgbG93ZXJNaWRkbGUgPSBFeHByZXNzaW9uKGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHBheW9mZlNjYWxlICogKDEgKyAocGF5b2ZmU3ByZWFkIC0gMSkgKiAxIC8gMyk7XHJcblx0fSk7XHJcblx0dmFyIHVwcGVyTWlkZGxlID0gRXhwcmVzc2lvbihmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBwYXlvZmZTY2FsZSAqICgxICsgKHBheW9mZlNwcmVhZCAtIDEpICogMiAvIDMpO1xyXG5cdH0pO1xyXG5cdHZhciB1cHBlciA9IEV4cHJlc3Npb24oZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gcGF5b2ZmU2NhbGUgKiBwYXlvZmZTcHJlYWQ7XHJcblx0fSk7XHJcblxyXG5cdC8vIFBhc3MgYWxvbmcgcGFyYW1ldGVycywgYmUgc3VyZSB0byBpbmNsdWRlIGlkLlxyXG5cdHZhciBwYXJhbWV0ZXJzID0gYXJndW1lbnRzWzFdIHx8IHt9O1xyXG5cdHBhcmFtZXRlcnMuaWQgPSBwYXJhbWV0ZXJzLmlkIHx8IGlkO1xyXG5cclxuXHR2YXIgY2hvaWNlcyA9IFtcclxuXHRcdFtcIkNvb3BlcmF0ZVwiLCBcIkRlZmVjdFwiXSxcclxuXHRcdFtcIkNvb3BlcmF0ZVwiLCBcIkRlZmVjdFwiXVxyXG5cdF07XHJcblx0dmFyIHBheW9mZnMgPSBbXHJcblx0XHRbXHJcblx0XHRcdFt1cHBlck1pZGRsZSwgdXBwZXJNaWRkbGVdLFxyXG5cdFx0XHRbcGF5b2ZmU2NhbGUsIHVwcGVyXVxyXG5cdFx0XSxcclxuXHRcdFtcclxuXHRcdFx0W3VwcGVyLCBwYXlvZmZTY2FsZV0sXHJcblx0XHRcdFtsb3dlck1pZGRsZSwgbG93ZXJNaWRkbGVdXHJcblx0XHRdXHJcblx0XTtcclxuXHJcblx0cmV0dXJuIFR3b1BsYXllck5vcm1hbChwbGF5ZXJzLCBjaG9pY2VzLCBwYXlvZmZzLCBwYXJhbWV0ZXJzKTtcclxufSk7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBwcmlzb25lckRpbGVtbWE7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gYmFzZSBnYW1lXHJcbnZhciBTaW1wbGVaZXJvU3VtID0gcmVxdWlyZShcIi4vc2ltcGxlLXplcm8tc3VtXCIpO1xyXG5cclxuLy8gaGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBnYW1lV3JhcHBlciB9ID0gcmVxdWlyZShcIi4uL2xpYi9oZWxwZXJGdW5jdGlvbnNcIikoXCJzdG9jay1nYW1lc1wiKVxyXG5cclxuLy8gUGxheS10aW1lIGxvZ2ljXHJcbnZhciB7IEV4cHJlc3Npb24gfSA9IHJlcXVpcmUoXCIuLi9saWIvbG9naWNcIik7XHJcblxyXG4vLyBSb2NrLVBhcGVyLVNjaXNzb3JzXHJcbnZhciBSb2NrUGFwZXJTY2lzc29ycyA9IGdhbWVXcmFwcGVyKGZ1bmN0aW9uKHBsYXllcnMsIHBheW9mZiA9IDEsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdHBhcmFtZXRlcnMuaWQgPSBwYXJhbWV0ZXJzLmlkIHx8IFwiUm9jay1QYXBlci1TY2lzc29yc1wiO1xyXG5cclxuXHR2YXIgd2luID0gcGF5b2ZmO1xyXG5cdHZhciBsb3NlID0gRXhwcmVzc2lvbihmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiAtcGF5b2ZmO1xyXG5cdH0pO1xyXG5cclxuXHR2YXIgY2hvaWNlcyA9IFtcclxuXHRcdFtcIlJvY2tcIiwgXCJQYXBlclwiLCBcIlNjaXNzb3JzXCJdLFxyXG5cdFx0W1wiUm9ja1wiLCBcIlBhcGVyXCIsIFwiU2Npc3NvcnNcIl1cclxuXHRdO1xyXG5cdHZhciBwYXlvZmZzID0gW1xyXG5cdFx0WzAsIGxvc2UsIHdpbl0sXHJcblx0XHRbd2luLCAwLCBsb3NlXSxcclxuXHRcdFtsb3NlLCB3aW4sIDBdXHJcblx0XTtcclxuXHJcblx0cmV0dXJuIFNpbXBsZVplcm9TdW0ocGxheWVycywgY2hvaWNlcywgcGF5b2ZmcywgcGFyYW1ldGVycyk7XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSb2NrUGFwZXJTY2lzc29yc1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vIGhlbHBlciBmdW5jdGlvblxyXG52YXIgeyBzaHVmZmxlIH0gPSByZXF1aXJlKFwiLi4vbGliL2hlbHBlcmZ1bmN0aW9uc1wiKShcImdlbmVyYWxcIik7XHJcblxyXG4vLyBuYXNoSlMgZW5naW5lIGNvbXBvbmVudFxyXG52YXIgeyBTZXF1ZW5jZSwgU2ltdWx0YW5lb3VzIH0gPSByZXF1aXJlKFwiLi4vbGliL2VuZ2luZVwiKS5QbGF5YWJsZXM7XHJcblxyXG4vLyBoZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGdhbWVXcmFwcGVyIH0gPSByZXF1aXJlKFwiLi4vbGliL2hlbHBlckZ1bmN0aW9uc1wiKShcInN0b2NrLWdhbWVzXCIpXHJcblxyXG4vL2ZvciBpbmZvcm1hdGlvbiBtZWNoYW5pY3NcclxudmFyIHsgSW5mb3JtYXRpb24gfSA9IHJlcXVpcmUoXCIuLi9saWIvaW5mb3JtYXRpb25cIik7XHJcbnZhciB7IEhpc3RvcnkgfSA9IHJlcXVpcmUoXCIuLi9saWIvaGlzdG9yeVwiKTtcclxudmFyIHsgUGxheWVyTGlzdCB9ID0gcmVxdWlyZShcIi4uL2xpYi9wb3B1bGF0aW9uXCIpO1xyXG5cclxuLy8gZ2FtZUdlbmVyYXRvciBzaG91bGQgYmUgYSBmdW5jdGlvbiB3aG9zZSBmaXJzdCBhcmd1bWVudCBpcyBhbiBhcnJheSBvZiBwbGF5ZXJzXHJcbnZhciBSb3VuZFJvYmluID0gZ2FtZVdyYXBwZXIoZnVuY3Rpb24ocGxheWVycywgZ2FtZUdlbmVyYXRvciwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0cGFyYW1ldGVycy5pZCA9IHBhcmFtZXRlcnMuaWQgfHwgXCJSb3VuZC1Sb2JpblwiO1xyXG5cdHBhcmFtZXRlcnMuaW5pdGlhbGl6ZVBsYXllcnMgPSBwYXJhbWV0ZXJzLmluaXRpYWxpemVQbGF5ZXJzICYmIHRydWU7XHJcblxyXG5cdC8vIENyZWF0ZSBhcnJheSBvZiBlYWNoIGNvbWJpbmF0aW9uIG9mIHBsYXllcnNcclxuXHR2YXIgbWF0Y2hlcyA9IFtdO1xyXG5cclxuXHRwbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24ocGxheWVyMSwgaW5kZXgxKSB7XHJcblx0XHRmb3IgKHZhciBpbmRleDIgPSAwOyBpbmRleDIgPCBpbmRleDE7IGluZGV4MisrKSB7XHJcblx0XHRcdG1hdGNoZXMucHVzaChbcGxheWVyc1tpbmRleDJdLCBwbGF5ZXIxXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gb3B0aW9uYWwgcGFyYW1ldGVyICdjb3BpZXMuJyBQYXNzIGFuIGV4dHJhIGNvcHkgb2YgZWFjaCBwbGF5ZXIsIHRvIHBsYXkgdGhlbXNlbHZlc1xyXG5cdFx0aWYgKHBhcmFtZXRlcnMuY29waWVzKSBtYXRjaGVzLnB1c2goW3BhcmFtZXRlcnMuY29waWVzW2luZGV4MV0sIHBsYXllcjFdKTtcclxuXHR9KTtcclxuXHJcblx0Ly9yYW5kb21pemUgdGhlIG9yZGVyXHJcblx0c2h1ZmZsZShtYXRjaGVzKTtcclxuXHJcblx0Ly8gVHJhY2sgc2NvcmVzXHJcblx0dmFyIHNjb3Jlc1JlY29yZCA9IFtdO1xyXG5cclxuXHQvL1xyXG5cdHZhciBhZGRSb3VuZCA9IGZ1bmN0aW9uKHBsYXllcnMsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdFx0Ly8gaW5mb3JtYXRpb24gbWVjaGFuaWNzIGFuZCBvdGhlciBwYXJhbWV0ZXJzXHJcblx0XHR2YXIgcG9wdWxhdGlvbiA9IG5ldyBQbGF5ZXJMaXN0KHBsYXllcnMpLmdlbmVyYXRvclxyXG5cdFx0cGFyYW1ldGVycy5jb21wYXJ0bWVudGFsaXplID0geyBwb3B1bGF0aW9uIH1cclxuXHRcdHBhcmFtZXRlcnMuaW5pdGlhbGl6ZVBsYXllcnMgPSBwb3B1bGF0aW9uO1xyXG5cclxuXHRcdC8vIGdlbmVyYXRlIHJvdW5kXHJcblx0XHR2YXIgcm91bmQgPSBnYW1lR2VuZXJhdG9yKHBsYXllcnMsIHBhcmFtZXRlcnMpO1xyXG5cclxuXHRcdC8vIHRyYWNrIHRoZSBzY29yZXNcclxuXHRcdHZhciByZWNvcmRTY29yZXMgPSBMYW1iZGEoZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciBzY29yZSA9IHt9XHJcblx0XHRcdGZvciAobGV0IFtzdHJhdGVneSwgc2NvcmVzXSBvZiBPYmplY3QuZW50cmllcyhwb3B1bGF0aW9uKCkuc2NvcmVzQnlTdHJhdGVneSgpKSkge1xyXG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KHNjb3JlcykpIHtcclxuXHRcdFx0XHRcdGlmIChzY29yZXMubGVuZ3RoID09IDEpIHNjb3JlcyA9IHNjb3Jlc1swXVxyXG5cdFx0XHRcdFx0c2NvcmVbc3RyYXRlZ3ldID0gc2NvcmVzO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRzY29yZXNSZWNvcmQucHVzaChzY29yZSk7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwicmVjb3JkaW5nIHNjb3Jlc1wiKVxyXG5cdFx0XHQvL3JldHVybiBzY29yZSBmb3IgaGlzdG9yeVxyXG5cdFx0XHRyZXR1cm4gc2NvcmU7XHJcblx0XHR9LCB7IGlkOiBcIlJlY29yZC1TY29yZXNcIiB9KTtcclxuXHJcblx0XHQvL0NoYWluIHRvZ2V0aGVyXHJcblx0XHRyZWNvcmRTY29yZXMocm91bmQpO1xyXG5cclxuXHRcdC8vIHJldHVybiBib3RoXHJcblx0XHRyZXR1cm4gW3JvdW5kLCByZWNvcmRTY29yZXNcclxuXHRcdFx0Ly8gLFNlcXVlbmNlKHJvdW5kLCByZWNvcmRTY29yZXMpIC8vIFVuY29tbWVudCBmb3IgU2ltdWx0YW5lb3VzIGltcGxlbWVudGF0aW9uXHJcblx0XHRdO1xyXG5cdH07XHJcblxyXG5cclxuXHJcblx0Ly8gU2VxdWVudGlhbCBpbXBsZW1lbnRhdGlvblxyXG5cdC8vIGxvYWQgdGhlIGZpcnN0IG1hdGNoIG1hbnVhbGx5XHJcblx0dmFyIFtmaXJzdFJvdW5kLCBmaXJzdFJlY29yZF0gPSBhZGRSb3VuZChcclxuXHRcdG1hdGNoZXMuc2hpZnQoKSxcclxuXHRcdHBhcmFtZXRlcnMucGFyYW1ldGVyc1xyXG5cdCk7XHJcblxyXG5cdC8vdGhlbiBsb2FkIHN1YnNlcXVlbnQgbWF0Y2hlc1xyXG5cdHZhciByZWNvcmQgPSBmaXJzdFJlY29yZDtcclxuXHR2YXIgbGFzdFJlY29yZCwgbGFzdFJvdW5kO1xyXG5cclxuXHRtYXRjaGVzLmZvckVhY2goZnVuY3Rpb24obWF0Y2gpIHtcclxuXHRcdFtsYXN0Um91bmQsIGxhc3RSZWNvcmRdID0gYWRkUm91bmQobWF0Y2gsIHBhcmFtZXRlcnMucGFyYW1ldGVycyk7XHJcblxyXG5cdFx0bGFzdFJvdW5kKHJlY29yZCk7XHJcblx0XHRyZWNvcmQgPSBsYXN0UmVjb3JkO1xyXG5cdH0pO1xyXG5cclxuXHJcblx0cmV0dXJuIFNlcXVlbmNlKGZpcnN0Um91bmQsIGxhc3RSZWNvcmQsIHBhcmFtZXRlcnMpO1xyXG5cclxuXHQvKiAvLyBTaW11bHRhbmVvdXMgaW1wbGVtZW50YXRpb25cclxuXHR2YXIgcm91bmRzID0gW107XHJcblx0bWF0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uKG1hdGNoKSB7XHJcblx0ICByb3VuZHMucHVzaChhZGRSb3VuZChtYXRjaCwgcGFyYW1ldGVycy5nYW1lUGFyYW1ldGVycylbMl0pO1xyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gU2ltdWx0YW5lb3VzKHJvdW5kcywgcGFyYW1ldGVycyk7ICovXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSb3VuZFJvYmluO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpc0Z1bmN0aW9uIH0gPSByZXF1aXJlKFwiLi4vbGliL2hlbHBlckZ1bmN0aW9uc1wiKShcImdlbmVyYWxcIilcclxudmFyIHsgZ2FtZVdyYXBwZXIgfSA9IHJlcXVpcmUoXCIuLi9saWIvaGVscGVyRnVuY3Rpb25zXCIpKFwic3RvY2stZ2FtZXNcIilcclxuXHJcbi8vR2FtZSBlbmdpbmVcclxudmFyIHsgQ2hvaWNlLCBUdXJuIH0gPSByZXF1aXJlKFwiLi4vbGliL2VuZ2luZVwiKS5QbGF5YWJsZXM7XHJcblxyXG5cclxudmFyIE5vcm1hbCA9IGdhbWVXcmFwcGVyKGZ1bmN0aW9uKHBsYXllcnMsIGNob2ljZUxpc3RzLCBwYXlvZmZzID0gbnVsbCwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblxyXG5cdFx0Ly9wcm9wb2dhdGUgdGhlIGluZm9ybWF0aW9uIGZpbHRlclxyXG5cdFx0cGFyYW1ldGVycy5wYXJhbWV0ZXJzID8gcGFyYW1ldGVycy5wYXJhbWV0ZXJzLmluZm9ybWF0aW9uRmlsdGVyID0gcGFyYW1ldGVycy5pbmZvcm1hdGlvbkZpbHRlciA6XHJcblx0XHRcdHBhcmFtZXRlcnMucGFyYW1ldGVycyA9IHsgaW5mb3JtYXRpb25GaWx0ZXI6IHBhcmFtZXRlcnMuaW5mb3JtYXRpb25GaWx0ZXIgfVxyXG5cclxuXHRcdC8vIGNvbnN0cnVjdCB0aGUgY2hvaWNlc1xyXG5cdFx0dmFyIGNob2ljZXMgPSBjaG9pY2VMaXN0cy5tYXAoZnVuY3Rpb24obGlzdCwgaW5kZXgpIHtcclxuXHRcdFx0cmV0dXJuIENob2ljZShwbGF5ZXJzW2luZGV4XSwgbGlzdCwgcGFyYW1ldGVycy5wYXJhbWV0ZXJzKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHZhciBnYW1lID0gVHVybihjaG9pY2VzLCBwYXJhbWV0ZXJzKTtcclxuXHRcdGNvbnNvbGUubG9nKHBheW9mZnMpXHJcblx0XHRpZiAocGF5b2ZmcykgZ2FtZS5zZXRBbGxQYXlvZmZzKHBheW9mZnMpO1xyXG5cclxuXHRcdHJldHVybiBnYW1lO1xyXG5cdH0gLy8gXHRcdFx0XHRcdFx0XHRcdFx0XHRUT0RPOiB2YWxpZGF0ZSBhbGwgYXJndW1lbnRzXHJcbik7XHJcblxyXG5cclxudmFyIFR3b1BsYXllck5vcm1hbCA9IGdhbWVXcmFwcGVyKGZ1bmN0aW9uKHBsYXllcnMsIGNob2ljZXMsIHBheW9mZnMgPSBudWxsLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHJcblx0Ly8gSW5mb3JtYXRpb24gbWVjaGFuaWNzLi4gVGhlcmUgYXJlIG9ubHkgdHdvIHBsYXllcnMsIHNvIHdlIGNhbiBoYXZlIGEgJ21lJyBhbmQgJ29wcG9uZW50JyBlbnRyeS5cclxuXHQvLyBJZiB1c2VyIHN1cHBsaWVkIGFuIGluZm9ybWF0aW9uIGZpbHRlciwgd3JhcCB0aGF0IGZpbHRlciBpbiBvdXJzLlxyXG5cdHZhciB7IGluZm9ybWF0aW9uRmlsdGVyIH0gPSBwYXJhbWV0ZXJzO1xyXG5cdGlmICghaXNGdW5jdGlvbihpbmZvcm1hdGlvbkZpbHRlcikpIGluZm9ybWF0aW9uRmlsdGVyID0gbnVsbDtcclxuXHJcblx0Ly8gV3JhcCB0aGUgdXNlcidzIGZpbHRlclxyXG5cdHZhciB3cmFwcGVkRmlsdGVyID0gZnVuY3Rpb24oaW5mb3JtYXRpb24pIHtcclxuXHRcdC8vIEZpZ3VyZSBvdXQgd2hvIEkgYW0gYW5kIHdobyB0aGUgb3Bwb25lbnQgaXNcclxuXHRcdHZhciBtZSA9IGluZm9ybWF0aW9uLm1lLmlkXHJcblx0XHR2YXIgcGxheWVycyA9IFtpbmZvcm1hdGlvbi50dXJuLmNob2ljZXNbMF0uY2hvaWNlLnBsYXllciwgaW5mb3JtYXRpb24udHVybi5jaG9pY2VzWzFdLmNob2ljZS5wbGF5ZXJdXHJcblx0XHR2YXIgb3Bwb25lbnQgPSBwbGF5ZXJzLnNwbGljZShwbGF5ZXJzLmluZGV4T2YobWUpLCAxKSAmJiBwbGF5ZXJzWzBdO1xyXG5cclxuXHRcdC8vIGFkZCBlbnRyeSBmb3Igb3Bwb25lbnRcclxuXHRcdHZhciBvcHBvbmVudERldGFpbCA9IGluZm9ybWF0aW9uLnBvcHVsYXRpb24uZmlsdGVyKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRyZXR1cm4gKHBsYXllci5pZCA9PSBvcHBvbmVudClcclxuXHRcdH0pWzBdO1xyXG5cdFx0aW5mb3JtYXRpb24ub3Bwb25lbnQgPSBvcHBvbmVudERldGFpbDtcclxuXHJcblx0XHQvLyBydW4gdGhlIHVzZXIncyBpbmZvcm1hdGlvbiBmaWx0ZXJcclxuXHRcdGlmIChpbmZvcm1hdGlvbkZpbHRlcikgaW5mb3JtYXRpb24gPSBpbmZvcm1hdGlvbkZpbHRlcihpbmZvcm1hdGlvbik7XHJcblxyXG5cdFx0cmV0dXJuIGluZm9ybWF0aW9uO1xyXG5cdH1cclxuXHJcblx0Ly8gUGFzcyB0aGUgaW5mb3JtYXRpb24gZmlsdGVyXHJcblx0cGFyYW1ldGVycy5pbmZvcm1hdGlvbkZpbHRlciA9IHdyYXBwZWRGaWx0ZXJcclxuXHJcblx0cmV0dXJuIE5vcm1hbChwbGF5ZXJzLCBjaG9pY2VzLCBwYXlvZmZzLCBwYXJhbWV0ZXJzKVxyXG59KTsgLy9cdFx0XHRcdCBcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFRPRE86IG1heSB3YW50IHRvIHZhbGlkYXRlIGFyZ3VtZW50cyBoZXJlIHRvb1xyXG5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgVHdvUGxheWVyTm9ybWFsLCBOb3JtYWwgfTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBiYXNlIGdhbWVcclxudmFyIFR3b1BsYXllck5vcm1hbCA9IHJlcXVpcmUoXCIuL3NpbXBsZS1ub3JtYWxcIikuVHdvUGxheWVyTm9ybWFsO1xyXG5cclxuLy8gR2FtZSBzdGF0ZSBjb250cm9sbGVyXHJcbnZhciB7IHJlZ2lzdHJ5IH0gPSByZXF1aXJlKFwiLi4vbGliL3N0YXRlXCIpO1xyXG52YXIgeyBnYW1lV3JhcHBlciB9ID0gcmVxdWlyZShcIi4uL2xpYi9oZWxwZXJGdW5jdGlvbnNcIikoXCJzdG9jay1nYW1lc1wiKTtcclxuXHJcbi8vIFBsYXktdGltZSBsb2dpY1xyXG52YXIgeyBWYXJpYWJsZSwgRXhwcmVzc2lvbiB9ID0gcmVxdWlyZShcIi4uL2xpYi9sb2dpY1wiKTtcclxuXHJcbi8qIGJlYXV0aWZ5IHByZXNlcnZlOnN0YXJ0ICovXHJcbnZhciBTaW1wbGVaZXJvU3VtID0gZ2FtZVdyYXBwZXIoZnVuY3Rpb24ocGxheWVycywgY2hvaWNlcywgcGF5b2ZmcyA9IFtbMCwgMF0sXHRbMCwgMF1dLCBwYXJhbWV0ZXJzPXt9KSB7XHJcbi8qIGJlYXV0aWZ5IHByZXNlcnZlOmVuZCAqL1xyXG5cclxuXHR2YXIgZ2FtZSA9IFR3b1BsYXllck5vcm1hbChwbGF5ZXJzLCBjaG9pY2VzLCBudWxsLCBwYXJhbWV0ZXJzKVxyXG5cclxuXHR2YXIgZTtcclxuXHJcblx0Y2hvaWNlc1swXS5mb3JFYWNoKGZ1bmN0aW9uKGNob2ljZTAsIGluZGV4MCkge1xyXG5cdFx0Y2hvaWNlc1sxXS5mb3JFYWNoKGZ1bmN0aW9uKGNob2ljZTEsIGluZGV4MSkge1xyXG5cclxuXHRcdFx0Ly8gU2V0IGV4cHJlc3Npb25cclxuXHRcdFx0ZSA9IEV4cHJlc3Npb24oZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Ly9SZXR1cm4gdGhlIG5lZ2F0aXZlIHBheW9mZiwgb3IgemVyb1xyXG5cdFx0XHRcdHJldHVybiAoMCAtIHJlZ2lzdHJ5LnR1cm5zW2dhbWUuaWQoKV0ucGF5b2Zmc0ltcGxpY2l0W2Nob2ljZTBdW2Nob2ljZTFdWzBdIHx8IDApO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdC8vU2V0IHBheW9mZnNcclxuXHRcdFx0Z2FtZVtjaG9pY2UwXVtjaG9pY2UxXShbcGF5b2Zmc1tpbmRleDBdW2luZGV4MV0sIGVdKTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gZ2FtZTtcclxufSk7IC8vXHRcdFx0XHRcdFRPRE86IHZhbGlkYXRlIGFyZ3VtZW50c1xyXG5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNpbXBsZVplcm9TdW07XHJcbiJdfQ==
